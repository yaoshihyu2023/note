<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jason Notes</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html">Jason Notes</a></li><li class="chapter-item expanded "><a href="ubuntu/ubuntu_setup.html">Ubuntu</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ubuntu/command.html">Command</a></li><li class="chapter-item "><a href="ubuntu/gcp.html">GCP ssh</a></li></ol></li><li class="chapter-item expanded "><a href="android/android.html">Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/install_sdk.html">SDK install</a></li></ol></li><li class="chapter-item expanded "><a href="tools/tools.html">Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tools/asciinema.html">asciinema 把終端操作錄製成 gif 動畫</a></li><li class="chapter-item "><a href="tools/finmind.html">Finmind</a></li><li class="chapter-item "><a href="tools/add-enter-and-exit-trace-for-your-function.html">addr2line</a></li><li class="chapter-item "><a href="tools/cmake.html">cmake</a></li><li class="chapter-item "><a href="tools/network.html">Network</a></li><li class="chapter-item "><a href="tools/python-pycryptodome-aes-symmetric-encryption-tutorial-examples.html">實作 AES 對稱式加密</a></li></ol></li><li class="chapter-item expanded "><a href="html/html.html">HTML</a></li><li class="chapter-item expanded "><a href="vim/vim.html">Vim</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="vim/copilot.html">copilot</a></li><li class="chapter-item "><a href="vim/tabnine.html">tabnine</a></li></ol></li><li class="chapter-item expanded "><a href="gdb/gdb.html">Gdb</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="gdb/常用指令.html">常用指令</a></li><li class="chapter-item "><a href="gdb/jemalloc.html">jemalloc</a></li><li class="chapter-item "><a href="gdb/graphs.html">graphs</a></li><li class="chapter-item "><a href="gdb/rust-gdb.html">rust gdb</a></li></ol></li><li class="chapter-item expanded "><a href="c++/cpp.html">C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c++/benchmark.html">benchmark</a></li><li class="chapter-item "><a href="c++/smart_pointer.html">Smart pointer</a></li><li class="chapter-item "><a href="c++/l&rvalue.html">L&amp;R value</a></li><li class="chapter-item "><a href="c++/move.html">Move</a></li><li class="chapter-item "><a href="c++/CAS.html">CAS</a></li><li class="chapter-item "><a href="c++/HFT.html">HFT</a></li></ol></li><li class="chapter-item expanded "><a href="riscv/riscv.html">RISC-V</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="riscv/qemu_riscv_linux.html">QEMU上運行RISV-V Linux</a></li></ol></li><li class="chapter-item expanded "><a href="centos/centos.html">CentOS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="centos/tqdb_setup.html">TQDB 安裝紀錄</a></li></ol></li><li class="chapter-item expanded "><a href="ssh/ssh.html">SSH</a></li><li class="chapter-item expanded "><a href="network/socket.html">Network</a></li><li class="chapter-item expanded "><a href="docker/docker_helloworld.html">Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="docker/docker.html">Docker 基本教學</a></li><li class="chapter-item "><a href="docker/example.html">簡單範例</a></li><li class="chapter-item "><a href="docker/creating-the-perfect-python-dockerfile.html">Perfect python dockerfile</a></li><li class="chapter-item "><a href="docker/dockerfile-from-docker-image.html">由 Docker image 反推其 Dockerfile</a></li><li class="chapter-item "><a href="docker/python_connect_redis.html">Python連接Redis</a></li><li class="chapter-item "><a href="docker/command.html">Command</a></li><li class="chapter-item "><a href="docker/docker_compose.html">Docker compose</a></li><li class="chapter-item "><a href="docker/docker_compse_example.html">Docker compose example</a></li><li class="chapter-item "><a href="docker/python_redis.html">Python-Redis</a></li><li class="chapter-item "><a href="docker/redash.html">Redash</a></li><li class="chapter-item "><a href="docker/clickhouse.html">ClickHouse</a></li><li class="chapter-item "><a href="docker/clickhouse-setup.html">clickhouse-setup</a></li></ol></li><li class="chapter-item expanded "><a href="rust/rust.html">Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rust/note.html">Rust筆記</a></li><li class="chapter-item "><a href="rust/basic.html">Rust 基本教學</a></li><li class="chapter-item "><a href="rust/ownership.html">Rust 所有權系統</a></li><li class="chapter-item "><a href="rust/lifetime.html">Rust 生命週期 (Lifetime)</a></li><li class="chapter-item "><a href="rust/type.html">Rust 型別系統</a></li><li class="chapter-item "><a href="rust/polars.html">Polars</a></li><li class="chapter-item "><a href="rust/rust_call_c.html">Rust call C</a></li><li class="chapter-item "><a href="rust/10-rust-an-introduction.html">給 C++ 使用者的 Rust 簡介</a></li><li class="chapter-item "><a href="rust/可視化Rust各資料結構的記憶體佈局.html">可視化Rust各資料結構的記憶體佈局</a></li><li class="chapter-item "><a href="rust/rust_note.html">學習順序</a></li><li class="chapter-item "><a href="rust/overview.html">大局觀</a></li><li class="chapter-item "><a href="rust/String.html">理解字串</a></li><li class="chapter-item "><a href="rust/easy_rust.html">Easy Rust</a></li><li class="chapter-item "><a href="rust/rust_easy.html">Rust 新手</a></li><li class="chapter-item "><a href="rust/module.html">Rust 模組結構</a></li><li class="chapter-item "><a href="rust/rust_memory.html">Rust與記憶體</a></li><li class="chapter-item "><a href="rust/rust_vs_cpp.html">Rust vs C++語法</a></li><li class="chapter-item "><a href="rust/rust_file_format.html">Rust 檔案格式</a></li><li class="chapter-item "><a href="rust/binary_lib.html">Rust 函數庫/執行檔</a></li><li class="chapter-item "><a href="rust/print-function-name-dump-stack.html">印出函數名稱</a></li><li class="chapter-item "><a href="rust/note.html">30天深入淺出Rust系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rust/30天深入淺出Rust系列/rust_30_day.html">Rust 30 Day</a></li><li class="chapter-item "><a href="rust/30天深入淺出Rust系列/Move_Borrow_Ownership.html">變數的所有權與借出變數</a></li><li class="chapter-item "><a href="rust/30天深入淺出Rust系列/Lifetime.html">Lifetime： Borrow 的存活時間</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="go/go.html">Go</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="go/note.html">Golang  Note</a></li><li class="chapter-item "><a href="go/pytago.html">pytago</a></li><li class="chapter-item "><a href="go/Go編程實戰派基礎入門.html">Go編程實戰派基礎入門</a></li><li class="chapter-item "><a href="go/Go編程實戰派Web開發基礎.html">Go編程實戰派Web開發基礎</a></li><li class="chapter-item "><a href="go/golang_debugger.html">Golang Deubgger</a></li><li class="chapter-item "><a href="go/golang-go-module-tutorial.html">從一知半解到略懂 Go modules</a></li><li class="chapter-item "><a href="go/go_mod.html">Go modules</a></li><li class="chapter-item "><a href="go/trace.html">Golang大殺器之跟蹤剖析trace</a></li><li class="chapter-item "><a href="go/Coroutine.html">行程、執行緒、協程，傻傻分得清楚！</a></li><li class="chapter-item "><a href="go/goroutine-and-channel.html">Go併發</a></li><li class="chapter-item "><a href="go/websocket.html">Websocket</a></li><li class="chapter-item "><a href="go/returning-pointer-from-a-function-in-go.html">Returning Pointer from a Function in Go</a></li><li class="chapter-item "><a href="go/golang-memory-management.html">GC 全面解析</a></li><li class="chapter-item "><a href="go/golang-goroutine.html">Goroutine 與 GMP 原理全面分析</a></li><li class="chapter-item "><a href="go/oo.html">OO</a></li><li class="chapter-item "><a href="go/mutex-rwmutex.html">sync.Mutex 和 sync.RWMutex</a></li><li class="chapter-item "><a href="go/interface.html">interface</a></li><li class="chapter-item "><a href="go/example.html">Example</a></li></ol></li><li class="chapter-item expanded "><a href="ml/ml.html">ML</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/pytorch.html">Pytorch</a></li></ol></li><li class="chapter-item expanded "><a href="python/python.html">Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="python/Poetry完全入門指南.html">Poetry完全入門指南</a></li><li class="chapter-item "><a href="python/搭建gRPC服務.html">搭建gRPC服務</a></li><li class="chapter-item "><a href="python/python_debugger.html">Python Debugger</a></li><li class="chapter-item "><a href="python/decorator.html">Python decorator</a></li><li class="chapter-item "><a href="python/python-decorator.html">裝飾器看這一篇就夠了</a></li><li class="chapter-item "><a href="python/import-concept.html">import-concept</a></li><li class="chapter-item "><a href="python/process_thread.html">Process/Thread優缺點</a></li><li class="chapter-item "><a href="python/processing_communcation.html">Processing 通訊</a></li><li class="chapter-item "><a href="python/condition.html">Python中的wait和notify</a></li><li class="chapter-item "><a href="python/生產者消費者模式.html">生產者消費者模式</a></li><li class="chapter-item "><a href="python/Loguru.html">Loguru</a></li><li class="chapter-item "><a href="python/WebSocket_reconnect.html">Python WebSocket長連接心跳與短連接</a></li><li class="chapter-item "><a href="python/bloomrpc.html">bloomrpc</a></li><li class="chapter-item "><a href="python/concurrent.futures.html">Concurrent futures</a></li><li class="chapter-item "><a href="python/schedule.html">任務調度</a></li><li class="chapter-item "><a href="python/plot/plot.html">Plot</a></li><li class="chapter-item "><a href="python/plot/dash.html">Dash</a></li><li class="chapter-item "><a href="python/Rust_bindings_for_Python.html">Rust bindings for Python</a></li><li class="chapter-item "><a href="python/pandas.html">Pandas</a></li><li class="chapter-item "><a href="python/coroutine.html">Coroutine</a></li><li class="chapter-item "><a href="python/finmind.html">FinMind</a></li><li class="chapter-item "><a href="python/telegram_bot.html">Telegram Bot</a></li><li class="chapter-item "><a href="python/websocket_client_server.html">Websocket client/server</a></li><li class="chapter-item "><a href="python/poetry.html">從零開始使用 Poetry</a></li><li class="chapter-item "><a href="python/fil-memory-usage-profiler.html">Fil-memory-usage-profiler</a></li><li class="chapter-item "><a href="python/plot.html">繪圖</a></li><li class="chapter-item "><a href="python/shioaji.html">永豐shioaji</a></li><li class="chapter-item "><a href="python/other.html">Other</a></li></ol></li><li class="chapter-item expanded "><a href="mermaid/mermaid.html">Mermaid</a></li><li class="chapter-item expanded "><a href="linux_system/perf.html">Linux System</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="linux_system/1_day_socket.html">Socket</a></li><li class="chapter-item "><a href="linux_system/cgroup.html">Cgroup</a></li><li class="chapter-item "><a href="linux_system/perf.html">Perf</a></li></ol></li><li class="chapter-item expanded "><a href="strategy/bollmaker.html">Strategy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="strategy/造市/market_market.html">造市</a></li><li class="chapter-item "><a href="strategy/tw_futures.html">臺指</a></li><li class="chapter-item "><a href="strategy/arbitrage.html">套利</a></li><li class="chapter-item "><a href="strategy/海龜交易.html">海龜交易</a></li><li class="chapter-item "><a href="strategy/如何避免過擬合.html">如何避免過擬合</a></li><li class="chapter-item "><a href="strategy/Option/option.html">選擇權</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="strategy/Option/option_note.html">Option note</a></li></ol></li><li class="chapter-item "><a href="strategy/vectorbt.html">VectorBT</a></li><li class="chapter-item "><a href="strategy/orderbook.html">Orderbook</a></li><li class="chapter-item "><a href="strategy/選股條件.html">選股條件</a></li><li class="chapter-item "><a href="strategy/如何進場.html">如何進場</a></li><li class="chapter-item "><a href="strategy/如何出場.html">如何出場</a></li><li class="chapter-item "><a href="strategy/建倉加碼.html">建倉加碼</a></li><li class="chapter-item "><a href="strategy/奇正/奇正.html">奇正</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="strategy/奇正/資金控管與試單策略.html">資金控管與試單策略</a></li><li class="chapter-item "><a href="strategy/奇正/如何出場.html">如何出場</a></li></ol></li><li class="chapter-item "><a href="strategy/Book/JG.html">JG</a></li><li class="chapter-item "><a href="strategy/bnf.html">BNF</a></li><li class="chapter-item "><a href="strategy/cis.html">CIS</a></li><li class="chapter-item "><a href="strategy/stock.html">Stock</a></li><li class="chapter-item "><a href="strategy/note.html">Resource</a></li><li class="chapter-item "><a href="strategy/nansen.html">Nansen</a></li><li class="chapter-item "><a href="strategy/example.html">Example</a></li><li class="chapter-item "><a href="strategy/other.html">Other</a></li><li class="chapter-item "><a href="strategy/sample.html">Sample</a></li><li class="chapter-item "><a href="strategy/grid.html">Grid</a></li><li class="chapter-item "><a href="strategy/pine-script.html">pine-script</a></li><li class="chapter-item "><a href="strategy/拾人牙慧.html">拾人牙慧</a></li><li class="chapter-item "><a href="strategy/sharpe_ratio.html">夏普值</a></li><li class="chapter-item "><a href="strategy/display_mae_mfe_analysis.html">MAE&amp;MFE分析</a></li><li class="chapter-item "><a href="strategy/海龜投資法則.html">海龜投資法則</a></li><li class="chapter-item "><a href="strategy/edge-ratio-follow-application.html">彈性進出場的判斷</a></li><li class="chapter-item "><a href="strategy/finlab.html">Finlab</a></li><li class="chapter-item "><a href="strategy/backtrader/basis.html">Backtrader</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="strategy/backtrader/Python回測框架一Backtrader介紹.html">Python回測框架一Backtrader介紹</a></li><li class="chapter-item "><a href="strategy/backtrader/Python回測框架二定期定額投資.html">Python 回測框架（二）定期定額投資</a></li><li class="chapter-item "><a href="strategy/backtrader/Python回測框架三技術指標.html">Python 回測框架（三）技術指標</a></li><li class="chapter-item "><a href="strategy/backtrader/Python回測框架四CrossOver和Signal.html">Python 回測框架（四）CrossOver 和 Signal</a></li><li class="chapter-item "><a href="strategy/backtrader/Python回測框架五Sizer.html">Python 回測框架（五）Sizer</a></li><li class="chapter-item "><a href="strategy/backtrader/Python回測框架六Analyzers.html">Python 回測框架（六）Analyzers</a></li><li class="chapter-item "><a href="strategy/backtrader/多股組合操作策略.html">多股組合操作</a></li><li class="chapter-item "><a href="strategy/backtrader/均線交叉策略.html">均線交叉策略</a></li><li class="chapter-item "><a href="strategy/backtrader/唐奇安通道策略.html">唐奇安通道策略</a></li><li class="chapter-item "><a href="strategy/backtrader/Sizers模組.html">Sizers模組</a></li><li class="chapter-item "><a href="strategy/backtrader/Observers模組.html">Observers模組</a></li><li class="chapter-item "><a href="strategy/backtrader/Pyfolio.html">Pyfolio</a></li><li class="chapter-item "><a href="strategy/backtrader/Sample.html">Sample</a></li><li class="chapter-item "><a href="strategy/backtrader/performance.html">Performance</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="mq/kafka.html">MQ</a></li><li class="chapter-item expanded "><a href="mq/kafka-python.html">Kafka的通俗總結</a></li><li class="chapter-item expanded "><a href="database/redis.html">Database</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="database/redis.html">Redis</a></li><li class="chapter-item "><a href="database/hash.html">Redis Hash</a></li><li class="chapter-item "><a href="database/clickhouse.html">ClickHouse</a></li><li class="chapter-item "><a href="database/dolphin.html">Dolphin</a></li><li class="chapter-item "><a href="database/sqlite.html">Sqlite</a></li></ol></li><li class="chapter-item expanded "><a href="cryptotrade/cryptotrade.html">CryptoTrade</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cryptotrade/binance/binance.html">Binance</a></li><li class="chapter-item "><a href="cryptotrade/binance/oco.html">如何將OCO訂單發送到Binance</a></li></ol></li><li class="chapter-item expanded "><a href="git/git.html">Git</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="git/git-remove-commited-files.html">git-remove-commited-files</a></li><li class="chapter-item "><a href="git/cheat-sheet.html">Git 常用</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="jason-notes"><a class="header" href="#jason-notes">Jason Notes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h1>
<h3 id="開發環境安裝"><a class="header" href="#開發環境安裝">開發環境安裝</a></h3>
<pre><code class="language-sh">git clone https://github.com/clvv/fasd
git clone https://github.com/junegunn/fzf
git clone https://github.com/sharkdp/fd
git clone https://github.com/cgdb/cgdb
git clone https://github.com/neovim/neovim.git
git clone https://github.com/BurntSushi/ripgrep
git clone https://github.com/ggreer/the_silver_searcher
git clone https://github.com/universal-ctags/ctags
</code></pre>
<h3 id="選擇套件來源"><a class="header" href="#選擇套件來源">選擇套件來源</a></h3>
<pre><code class="language-sh">sudo /usr/bin/software-properties-gtk
</code></pre>
<h3 id="ubuntu-2204-package"><a class="header" href="#ubuntu-2204-package">ubuntu 22.04 package</a></h3>
<pre><code class="language-sh">sudo apt-get install autoconf automake linux-headers-`uname -r` \
 libclang-dev p7zip guake p7zip-full liblzma-dev \
 indicator-multiload filezilla pidgin pcmanx-gtk2 gparted meld \
 speedcrunch vim ssh id-utils cflow autogen \
 cutecom hexedit ccache clang pbzip2 smplayer plink putty-tools \
 ghex doxygen doxygen-doc libstdc++6 lib32stdc++6 build-essential \
 doxygen-gui graphviz git-core cconv alsa-oss wmctrl terminator \
 curl cgdb dos2unix libreadline-dev tmux \
 hexedit ccache ruby subversion htop astyle ubuntu-restricted-extras \
 libncurses5-dev xdot universal-ctags cscope \
 libsdl1.2-dev gitk libncurses5-dev binutils-dev gtkterm \
 libtool mpi-default-dev libbz2-dev libicu-dev scons csh \
 enca ttf-anonymous-pro libperl4-corelibs-perl cgvg catfish gawk \
 i2c-tools sshfs wavesurfer audacity fcitx fcitx-chewing libswitch-perl bin86 \
 inotify-tools u-boot-tools subversion crash tree mscgen krename umbrello \
 intel2gas kernelshark trace-cmd pppoe dcfldd flex bison help2man \
 texinfo texi2html ghp-import autossh samba sdcv xournal cloc geogebra \
 libluajit-5.1-dev libacl1-dev libgpmg1-dev libgtk-3-dev libgtk2.0-dev \
 liblua5.2-dev libperl-dev libselinux1-dev libtinfo-dev libxaw7-dev \
 libxpm-dev libxt-dev gnome-control-center gettext libtool libtool-bin cmake g++ pkg-config unzip xsel
</code></pre>
<h2 id="foliate-支持epubmobiazw和azw3文件-它不支持pdf文件"><a class="header" href="#foliate-支持epubmobiazw和azw3文件-它不支持pdf文件">foliate 支持.epub，.mobi，.azw和.azw3文件。 它不支持PDF文件。</a></h2>
<pre><code class="language-sh">sudo add-apt-repository ppa:apandada1/foliate
sudo apt update
sudo apt install foliate
</code></pre>
<h3 id="ubuntu-有線連線不見網路圖示不見解決方法"><a class="header" href="#ubuntu-有線連線不見網路圖示不見解決方法">ubuntu 有線連線不見（網路圖示不見）解決方法</a></h3>
<pre><code class="language-sh">sudo apt-get install gnome-control-center
sudo service network-manager stop
sudo rm /var/lib/NetworkManager/NetworkManager.state
sudo service network-manager start
sudo gedit /etc/NetworkManager/NetworkManager.conf
（把false改成true）
sudo service network-manager restart
</code></pre>
<h3 id="gnome-open"><a class="header" href="#gnome-open">gnome-open</a></h3>
<pre><code class="language-sh">sudo ln -s /usr/bin/xdg-open ~/.mybin/o
</code></pre>
<h3 id="將-tmp-設到-ramdisk-tmpfs-的方法"><a class="header" href="#將-tmp-設到-ramdisk-tmpfs-的方法">將 /tmp 設到 RamDisk (tmpfs) 的方法</a></h3>
<pre><code class="language-sh">基本上只要打以下指令，就能將 /tmp 綁定到 /dev/shm
mkdir /dev/shm/tmp
chmod 1777 /dev/shm/tmp
sudo mount --bind /dev/shm/tmp /tmp

※ 註：為何是用 mount --bind 綁定，而不是 ln -s 軟連結，原因是 /tmp 目錄，系統不給刪除。

不過每次開機都要打指令才能用，這樣是行不通的，必須讓它開機時自動執行，才會方便。

用文書編輯器，建立 /etc/init.d/ramtmp.sh 內容如下：

#!/bin/sh
# RamDisk tmp
PATH=/sbin:/bin:/usr/bin:/usr/sbin

mkdir -p /dev/shm/tmp
mkdir -p /dev/shm/cache
mount --bind /dev/shm/tmp /tmp
mount --bind /dev/shm/cache /home/shihyu/.cache
chmod 1777 /dev/shm/tmp
chmod 1777 /dev/shm/cache


將此檔改權限為 755，使其可執行

sudo chmod 755 /etc/init.d/ramtmp.sh

在 /etc/rcS.d 中，建立相關軟連結(捷徑)，使其一開機就執行 以下指令僅能終端機操作

cd /etc/rcS.d
sudo ln -s ../init.d/ramtmp.sh S50ramtmp.sh
</code></pre>
<h3 id="im-config--新酷音"><a class="header" href="#im-config--新酷音">im-config  新酷音</a></h3>
<pre><code class="language-sh">sudo apt-get install fcitx-table-boshiamy (嘸蝦米）
sudo apt-get install fcitx-table-cangjie-big （倉頡大字集）
sudo apt-get install fcitx-table-zhengma-large （鄭碼大字集）
sudo apt-get install fcitx-table-wubi-large （五筆大字集）
sudo apt-get install fcitx-chewing （新酷音）
sudo apt-get install fcitx-sunpinyin （雙拼）
sudo apt-get install fcitx-table-easy-big （輕鬆大詞庫）
sudo apt-get install fcitx-m17n
sudo apt-get remove ibus

im-config

選fcitx為預設
重開機或登入
在有可輸入中文的框中，按Ctrl+Space，然後用Ctrl+Shift選輸入法輸入，預設的簡繁轉換為Ctrl+Shift+F
</code></pre>
<h3 id="gitbook-安裝"><a class="header" href="#gitbook-安裝">Gitbook 安裝</a></h3>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install nodejs
sudo apt-get install npm

sudo npm install gitbook -g
</code></pre>
<h3 id="node-安裝"><a class="header" href="#node-安裝">node 安裝</a></h3>
<pre><code class="language-sh">https://nodejs.org/en/  

export N_PREFIX=$HOME/.mybin/node-v17.8.0-linux-x64/
export PATH=$N_PREFIX/bin:$PATH
</code></pre>
<h3 id="多個-ssh-key-對應多個-github-帳號"><a class="header" href="#多個-ssh-key-對應多個-github-帳號">多個 SSH Key 對應多個 Github 帳號</a></h3>
<pre><code class="language-sh">$ cd ~/.ssh
$ ssh-keygen -t rsa -C &quot;account1@email.com&quot; -f id_rsa_account1
$ ssh-keygen -t rsa -C &quot;account2@email.com&quot; -f id_rsa_account2

建立 config 檔
$ cd ~/.ssh
$ touch config
$ gedit config

#account1
Host github.com-account1
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_rsa_account1

#account2
Host github.com-account2
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_rsa_account2
    
修改相對應 repo 的 remote url。例如：
ssh://git@github.com-account1/github account/repo1.git
github account 是github帳號 ex : jasonblog , ccccjason , shihyu
</code></pre>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

更新 Rust 版本
rustup update
</code></pre>
<h2 id="cmake-setup"><a class="header" href="#cmake-setup">cmake Setup</a></h2>
<pre><code class="language-sh">wget https://cmake.org/files/v3.26/cmake-3.26.0.tar.gz
./bootstrap --prefix=$HOME/.mybin/cmake
make 
make install
export PATH=&quot;$HOME/.mybin/cmake/bin:$PATH&quot;
</code></pre>
<h2 id="新增虛擬記憶體swap"><a class="header" href="#新增虛擬記憶體swap">新增虛擬記憶體(swap)</a></h2>
<ol>
<li>
<p>切割4GB空間做為swap使用。</p>
<pre><code class="language-sh">sudo fallocate -l 4G /swapfile
</code></pre>
<p>4G：可視個人需求修改</p>
<p>/swapfile：做為swap使用的檔案存放路徑，可修改</p>
<p>這時你的硬碟空間就已被扣除4G保留為此檔案，做為虛擬記憶體使用。</p>
<p>不過這時只是新增了一個容量4G大的檔案而已，系統並不知道要用他來做swap。</p>
</li>
<li>
<p>告知系統使用此檔案，啟用swap功能。</p>
<pre><code class="language-sh">sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
</code></pre>
</li>
<li>
<p>將swap設定為開機自動掛載。</p>
<pre><code class="language-sh">sudo vim /etc/fstab
…

開啟檔案，到最後加入此行

/swapfile   none swap    sw 0 0
</code></pre>
<p>這樣以後每次重開機就會固定載入這個檔案做為虛擬記憶體使用了。</p>
<p>附註：其實在虛擬網站伺服器都是使用SSD的現在，舉個例，如Linode的Linode 2GB規格，記憶體2G硬碟30G，設定個6G~10G來做虛擬記憶體，就等於你擁有8~12G的記憶體可能還太多了，如果主機有特殊需求使用大量記憶體，可以參考看看這個做法。</p>
</li>
</ol>
<h2 id="改時區"><a class="header" href="#改時區">改時區</a></h2>
<blockquote>
<p>＃ <strong>tzselect</strong>
Please identify a location so that time zone rules can be set correctly.
Please select a continent, ocean, “coord&quot;, or “TZ&quot;.
\1) Africa
\2) Americas
\3) Antarctica
\4) Asia
\5) Atlantic Ocean
\6) Australia
\7) Europe
\8) Indian Ocean
\9) Pacific Ocean
\10) coord – I want to use geographical coordinates.
\11) TZ – I want to specify the time zone using the Posix TZ format.
＃? <strong>4</strong></p>
<p>Please select a country whose clocks agree with yours.
\1) Afghanistan 18) Israel 35) Palestine
\2) Armenia 19) Japan 36) Philippines
\3) Azerbaijan 20) Jordan 37) Qatar
\4) Bahrain 21) Kazakhstan 38) Russia
\5) Bangladesh 22) Korea (North) 39) Saudi Arabia
\6) Bhutan 23) Korea (South) 40) Singapore
\7) Brunei 24) Kuwait 41) Sri Lanka
\8) Cambodia 25) Kyrgyzstan 42) Syria
\9) China 26) Laos 43) Taiwan
\10) Cyprus 27) Lebanon 44) Tajikistan
\11) East Timor 28) Macau 45) Thailand
\12) Georgia 29) Malaysia 46) Turkmenistan
\13) Hong Kong 30) Mongolia 47) United Arab Emirates
\14) India 31) Myanmar (Burma) 48) Uzbekistan
\15) Indonesia 32) Nepal 49) Vietnam
\16) Iran 33) Oman 50) Yemen
\17) Iraq 34) Pakistan
＃? <strong>43</strong></p>
<p>The following information has been given:</p>
<p>Taiwan</p>
<p>Therefore TZ=’Asia/Taipei’ will be used.
Local time is now: Tue Apr 3 12:07:13 CST 2018.
Universal Time is now: Tue Apr 3 04:07:13 UTC 2018.
Is the above information OK?
\1) Yes
\2) No
＃? <strong>1</strong></p>
<p>＃ <strong>cp /usr/share/zoneinfo/Asia/Taipei /etc/localtime</strong></p>
</blockquote>
<h1 id="更新時間與測試"><a class="header" href="#更新時間與測試">更新時間與測試</a></h1>
<blockquote>
<p>＃ <strong>apt-get install ntpdate</strong></p>
<p>＃ <strong>ntpdate <a href="http://time.stdtime.gov.tw/">time.stdtime.gov.tw</a></strong></p>
<p>＃ <strong>hwclock -w</strong></p>
<p>(將時間寫入 BIOS)</p>
<p>＃ <strong>date</strong></p>
</blockquote>
<h1 id="加入排程"><a class="header" href="#加入排程">加入排程</a></h1>
<blockquote>
<p>＃ <strong>vim /etc/crontab</strong>…(略)</p>
<p>SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</p>
<p>＃ m h dom mon dow user command
<strong>10 5 * * * root ntpdate <a href="http://time.stdtime.gov.tw/">time.stdtime.gov.tw</a></strong></p>
</blockquote>
<p>或</p>
<blockquote>
<p>＃ <strong>crontab -e</strong>
<strong>@daily /usr/sbin/ntpdate <a href="http://time.stdtime.gov.tw/">time.stdtime.gov.tw</a> &gt; /dev/null</strong>
將對時寫進 crontab 每天做一次</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-sh">find . -type f -size +10M  ! -name '*.cpp' ! -name '*.c' ! -name '*.rs' ! -name '*.java'
</code></pre>
<pre><code class="language-sh">find . -not -path '*/\.git/*' -not -path '*readme*' -type f    ! -name '*.cpp' ! -name '*.c' ! -name '*.rs' ! -name '*.java' ! -name '*.go' ! -name '*.cc' ! -name '*.h' ! -name '*.kt' ! -name '*.py'  ! -name '*.sh'  ! -name '*.asm' ! -name '*.pl' ! -name '*.sed'  ! -name '*.hpp'  ! -name '*.cxx' ! -name '*makefile*'  ! -name '*.json' -exec rm {} \;
</code></pre>
<ul>
<li>https://github.com/dutchcoders/transfer.sh</li>
</ul>
<pre><code class="language-sh">transfer(){ if [ $# -eq 0 ];then echo &quot;No arguments specified.\nUsage:\n transfer &lt;file|directory&gt;\n ... | transfer &lt;file_name&gt;&quot;&gt;&amp;2;return 1;fi;if tty -s;then file=&quot;$1&quot;;file_name=$(basename &quot;$file&quot;);if [ ! -e &quot;$file&quot; ];then echo &quot;$file: No such file or directory&quot;&gt;&amp;2;return 1;fi;if [ -d &quot;$file&quot; ];then file_name=&quot;$file_name.zip&quot; ,;(cd &quot;$file&quot;&amp;&amp;zip -r -q - .)|curl --progress-bar --upload-file &quot;-&quot; &quot;https://transfer.sh/$file_name&quot;|tee /dev/null,;else cat &quot;$file&quot;|curl --progress-bar --upload-file &quot;-&quot; &quot;https://transfer.sh/$file_name&quot;|tee /dev/null;fi;else file_name=$1;curl --progress-bar --upload-file &quot;-&quot; &quot;https://transfer.sh/$file_name&quot;|tee /dev/null;fi;}
</code></pre>
<pre><code class="language-sh"># Upload using cURL
$ curl --upload-file ./hello.txt https://transfer.sh/hello.txt https://transfer.sh/wPbvjO/hello.txt

# Using the shell function
$ transfer hello.txt
##################################################### 100.0% https://transfer.sh/zmlFh3/hello.txt

# Upload from web
Drag your files here, or click to browse.
</code></pre>
<pre><code class="language-sh">find . -type f -not -path '*/\.git/*' -size +1M
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="從gcp-瀏覽器-ssh-登入"><a class="header" href="#從gcp-瀏覽器-ssh-登入">從gcp 瀏覽器 ssh 登入</a></h2>
<pre><code class="language-sh">sudo su
sudo adduser  shihyu
sudo su shihyu

mkdir ~/.ssh
copy 要登入gcp的主機公鑰到 gcp VM 的~/.ssh/authorized_keys
chmod 700 ~/.ssh
chmod 644 ~/.ssh/authorized_keys
</code></pre>
<p>之後就可以使用 shihyu 帳號登入囉～</p>
<pre><code class="language-sh"># sudo vim /etc/ssh/sshd_config
修改地方是
LoginGraceTime 指定時間
PermitRootLogin yes
StrictModes yes
PasswordAuthentication yes
修改完成後大概是這樣
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code>https://android.googlesource.com/

https:*//android.googlesource.com/platform/manifest/
</code></pre>
<pre><code class="language-sh">repo init -u https://android.googlesource.com/platform/manifest -b android-13.0.0_r18

repo sync -c -j8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安裝android-sdk"><a class="header" href="#安裝android-sdk">安裝Android Sdk</a></h1>
<h3 id="sdk安裝方式"><a class="header" href="#sdk安裝方式">sdk安裝方式</a></h3>
<p>常規思路，下載sdk，安裝之後修改環境。但是發現，網路上已經沒有了sdk的下載資源，有的也只是很老的版本。查看<a href="https://developer.android.google.cn/studio/command-line/sdkmanager">Android開發文件——sdkmanager的使用指南</a>，發現可以使用<code>sdkmanager</code>這個<a href="https://cloud.tencent.com/product/cli?from=10680">命令列工具</a>進行下載。</p>
<h3 id="下載sdkmanager工具包"><a class="header" href="#下載sdkmanager工具包">下載sdkmanager工具包</a></h3>
<p><a href="https://developer.android.google.cn/studio">官網下載頁最底部-命令列工具下載</a>，找到Linux平臺的工具包 </p>
<p><img src="android/images/1afcd5d6e4e6f9c9c671623cc62ab795.png" alt="" /></p>
<p>使用<code>wget</code>下載到<a href="https://cloud.tencent.com/product/cvm?from=10680">伺服器</a></p>
<pre><code class="language-javascript">wget -P /home/android-sdk/ https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip
</code></pre>
<h3 id="解壓工具包"><a class="header" href="#解壓工具包">解壓工具包</a></h3>
<pre><code class="language-javascript">unzip commandlinetools-linux-7583922_latest.zip
</code></pre>
<p><code>sdkmanager</code>在<code>/home/android-sdk/cmdline-tools/bin</code>下。</p>
<h3 id="選擇下載最新的sdk版本"><a class="header" href="#選擇下載最新的sdk版本">選擇下載最新的sdk版本</a></h3>
<p>使用命令查看最新的stable版本</p>
<pre><code class="language-javascript">[root@192 bin]# ./sdkmanager --list --channel=0
Error: Could not determine SDK root.
Error: Either specify it explicitly with --sdk_root= or move this package into its expected location: &lt;sdk&gt;/cmdline-tools/latest/
</code></pre>
<p>報錯了，無法找到sdk根目錄，提示說有兩種解決辦法：一是用–sdk_root指定路徑，二是把資料夾移動到指定路徑。</p>
<p>因為懶，選擇試一下第二個一勞永逸的方法。</p>
<pre><code class="language-javascript">[root@192 cmdline-tools]# mkdir latest
[root@192 cmdline-tools]# mv bin/ lib/ NOTICE.txt source.properties -t latest/
</code></pre>
<p>再次執行查詢命令，就會查出一長條的版本。</p>
<pre><code class="language-javascript">[root@192 cmdline-tools]# cd latest/bin/
[root@192 bin]# ./sdkmanager --list --channel=0
</code></pre>
<h3 id="安裝sdk"><a class="header" href="#安裝sdk">安裝sdk</a></h3>
<p>因為App項目使用了Android-30的版本，故安裝對應的platforms;android-30</p>
<pre><code class="language-javascript">./sdkmanager &quot;build-tools;30.0.3&quot; &quot;platforms;android-30&quot;
./sdkmanager &quot;platform-tools&quot; &quot;build-tools;31.0.0&quot; &quot;build-tools;32.0.0&quot; &quot;platforms;android-31&quot; &quot;platforms;android-32&quot;
</code></pre>
<p>在彈出協議許可時選擇<code>y</code>，就開始安裝了。</p>
<p>下載完成後，就可以在<code>cmdline-tools</code>的同級目錄，找到下載的sdk了。這也是為什麼上面要指定<code>sdk-root</code>的原因了。</p>
<pre><code class="language-javascript">[root@192 android-sdk]# ls
build-tools  cmdline-tools  commandlinetools-linux-7583922_latest.zip  emulator  licenses  patcher  platforms  platform-tools  tools
</code></pre>
<h3 id="組態android_home環境變數"><a class="header" href="#組態android_home環境變數">組態ANDROID_HOME環境變數</a></h3>
<pre><code class="language-javascript">[root@192 android-sdk]# export ANDROID_HOME=/home/android-sdk
[root@192 android-sdk]# export PATH=$ANDROID_HOME/platform-tools:$ANDROID_HOME/tools:$ANDROID_HOME/tools/bin:$PATH
[root@192 android-sdk]# source /etc/profile
</code></pre>
<p>至此，Linux安裝Android Sdk完成！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">tools</a></h1>
<p>https://itsfoss.com/rust-cli-tools/</p>
<pre><code class="language-sh">cargo install bottom procs zoxide du-dust exa tealdeer bat difftastic tokei hyperfine fd-find --locked
</code></pre>
<pre><code>curl -sS https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | bash

~/.bashrc
eval &quot;$(zoxide init bash)&quot;
</code></pre>
<ul>
<li>A very fast implementation of tldr in Rust: Simplified, example based and community-driven man pages.</li>
</ul>
<pre><code class="language-sh">tldr strace
</code></pre>
<ul>
<li>bat</li>
</ul>
<pre><code class="language-sh">alias cat=&quot;bat --theme=\$(defaults read -globalDomain AppleInterfaceStyle &amp;&gt; /dev/null &amp;&amp; echo default || echo GitHub)&quot;
</code></pre>
<ul>
<li>tig</li>
</ul>
<pre><code class="language-sh">https://github.com/jonas/tig
</code></pre>
<ul>
<li>pandoc </li>
</ul>
<pre><code class="language-sh">pandoc -f markdown -t epub3 -o xxx.epub 1.md 2.md 3.m

最直覺的做法是每章自成一個 HTML 檔，作者原來也是這麼做。但起初 Pandoc 將所有 HTML 併成一個 ch001.xhtml (解壓 ePub 觀察到的)，研究發現是因為作者把章標題放在 &lt;h2&gt;，&lt;h1&gt; 放書名，


而 Pandoc 的分檔是以 &lt;h1&gt; 區隔；故我寫了一段 PowerShell 將 h1 移除，h2 改 h1。h3 改 h2，h4 改 h3，修改後 ePub 也修正為一章一個 .html


。但有個已知問題，Pandoc 產生的目錄連結在 Google 電子書閱讀器套件或 Calibre 閱讀時功能正常，點各層章節都能跳到對映位置，但在我的 Kobo Forma 閱讀器上只能跳到章 (.html 層)，無法跳到節 (.html#section-id)。
</code></pre>
<pre><code class="language-sh">使用 ls -1 | cut -d &quot; &quot; -f 10- 命令來只列出檔案名稱，忽略 -rw-r--r-- 1 shihyu shihyu 8973 3月 13 20:06 這部分的檔案權限、所有者等詳細資訊，只顯示檔案名稱。 cut -d &quot; &quot; -f 10- 則是使用分割符號 &quot; &quot; （空格）分割每一行，選取第 10 個欄位到最後一個欄位，也就是檔案名稱。
</code></pre>
<ul>
<li>sed</li>
</ul>
<pre><code class="language-sh">find . -type f -name &quot;*&quot; -exec sed -i  &quot;s/hello/fuck/g&quot; {} \;
</code></pre>
<ul>
<li>更新 git</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

# Change to the directory containing the Git repositories
cd /path/to/directory

# Find all .git directories and run Git commands on each one
find . -name &quot;.git&quot; -type d -exec sh -c '
  cd &quot;{}&quot; &amp;&amp; cd .. &amp;&amp; 
  git stash &amp;&amp; git pull
' \;
</code></pre>
<ul>
<li>
<p>xelatex</p>
<ul>
<li>XeLaTeX 簡簡單單讓 LaTeX 說中文</li>
</ul>
<pre><code class="language-latex">%!TEX encoding = UTF-8 Unicode
\usepackage{xeCJK}
%\setCJKmainfont{標楷體}
%\setCJKmainfont{LiHei Pro}
\setCJKmainfont{PingFang TC}
</code></pre>
</li>
<li>
<p>每個月底執行 command</p>
</li>
</ul>
<pre><code class="language-sh">0 0 28-31 * * [ &quot;$(date +\%d -d tomorrow)&quot; = &quot;01&quot; ] &amp;&amp; command
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asciinema-把終端操作錄製成-gif-動畫"><a class="header" href="#asciinema-把終端操作錄製成-gif-動畫">asciinema 把終端操作錄製成 gif 動畫</a></h1>
<p><a href="https://asciinema.org/">asciinema</a> 是一個開源工具，可以把終端上的操作錄制下來轉換成 git 動畫，也可以進一步使用 ffmpeg 將動畫圖片轉換成 mp4 視頻。</p>
<h2 id="安裝"><a class="header" href="#安裝">安裝</a></h2>
<p>macOS</p>
<pre><code class="language-shell">brew install asciinema
</code></pre>
<p>Shell</p>
<p>Ubuntu/Debian</p>
<pre><code class="language-shell">sudo apt install asciinema
</code></pre>
<p>Shell</p>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<h3 id="錄制"><a class="header" href="#錄制">錄制</a></h3>
<pre><code class="language-shell">asciinema rec demo.cast
</code></pre>
<p>Shell</p>
<p>使用 ctrl + d 或 <code>exit</code> 停止錄制</p>
<h3 id="回放"><a class="header" href="#回放">回放</a></h3>
<pre><code class="language-shell">asciinema play demo.cast
</code></pre>
<p>Shell</p>
<h3 id="生成-gif-動畫"><a class="header" href="#生成-gif-動畫">生成 gif 動畫</a></h3>
<p>按照 asciinema 項目的使用建議，錄制好的配置文件可以上傳到官網，然後使用官方的腳本和連接嵌入到自己的網頁。如果需要離線使用，可以通過 asciinema2gif 生成動圖。</p>
<p><a href="https://github.com/asciinema/asciicast2gif">asciinema2gif</a> 基於 nodejs 開發，配合 Docker 更簡單。</p>
<h4 id="拉取鏡像"><a class="header" href="#拉取鏡像">拉取鏡像</a></h4>
<pre><code class="language-shell">docker pull asciinema/asciicast2gif
</code></pre>
<p>Shell</p>
<h4 id="製作-gif"><a class="header" href="#製作-gif">製作 gif</a></h4>
<pre><code class="language-shell">docker run --rm -v $PWD:/data asciinema/asciicast2gif demo.cast demo.gif
</code></pre>
<p>Shell</p>
<p>注意 <code>-v $PWD:/data</code> 即宿主機與容器映射存儲的設置，$PWD 代表當前目錄，要確保 <code>demo.cast</code> 文件在當前路徑中。</p>
<h4 id="轉換成-mp4"><a class="header" href="#轉換成-mp4">轉換成 mp4</a></h4>
<p>可以使用 ffmpeg 進一步將 gif 動圖轉換成 mp4 視頻：</p>
<pre><code class="language-shell">ffmpeg -i demo.gif demo.mp4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="製作個人專屬看盤軟體"><a class="header" href="#製作個人專屬看盤軟體">製作個人專屬看盤軟體</a></h1>
<p>https://medium.com/finmind/%E8%A3%BD%E4%BD%9C%E5%80%8B%E4%BA%BA%E5%B0%88%E5%B1%AC%E7%9C%8B%E7%9B%A4%E8%BB%9F%E9%AB%94-%E4%BA%8C-27081ce44689</p>
<p>首先，將以下專案 clone 下來</p>
<p>https://github.com/FinMind/finmind-visualization</p>
<p>（需要使用 docker 技術，請先確定你安裝了 docker）</p>
<h1 id="1-建立-docker-network"><a class="header" href="#1-建立-docker-network">1. 建立 docker network：</a></h1>
<pre><code>docker network create finmind_network
</code></pre>
<h1 id="2-建立相關的-services包含-mysql-資料庫rabbitmqredash"><a class="header" href="#2-建立相關的-services包含-mysql-資料庫rabbitmqredash">2. 建立相關的 services，包含 MySQL 資料庫、RabbitMQ、Redash：</a></h1>
<pre><code>docker-compose -f mysql.yml up -d
docker-compose -f rabbitmq.yml up -d
docker-compose -f redash.yml up -d
</code></pre>
<h1 id="3-建立-finmind-工具將使用-finmind-data-進行視覺化"><a class="header" href="#3-建立-finmind-工具將使用-finmind-data-進行視覺化">3. 建立 FinMind 工具，將使用 FinMind Data 進行視覺化：</a></h1>
<p>如果你有 FinMind Api Token，使用以下指令</p>
<pre><code>FINMIND_API_TOKEN=your_token docker-compose -f finmind.yml up -d
</code></pre>
<p>如果沒有 Token，使用以下指令（沒有 token，資料會更新比較慢）</p>
<pre><code>docker-compose -f finmind.yml up -d
</code></pre>
<p>邏輯上是，拉 FinMind Data，做視覺化，也就是說，如果是會員，更新資料速度會比較快，如果非會員，資料也是會更新，只是比較慢一點。</p>
<h1 id="4-建立完成後以下是相關-services-連線資訊"><a class="header" href="#4-建立完成後以下是相關-services-連線資訊">4. 建立完成後，以下是相關 services 連線資訊</a></h1>
<pre><code>mysql: http://localhost:8080/
    user : finmind
    password : test
flower: http://localhost:5555/
rabbitmq: http://localhost:15672/
    user : worker
    password : worker
visualization: http://localhost:5000/
finmind-visualization-api: http://localhost:8888/docs
</code></pre>
<h1 id="5-建立-mysql-table"><a class="header" href="#5-建立-mysql-table">5. 建立 MySQL Table</a></h1>
<p>進入以下連結，http://localhost:8888/docs，</p>
<p><img src="tools/images/1*IdCctc-HP_eu_BriaA6_jA.png" alt="img" /></p>
<p><img src="tools/images/1*dHxxo2g6B6t5frxnU3tGgw.png" alt="img" /></p>
<p>成功後，就會建立相關 Table 了，可以到以下連結查看，<a href="http://localhost:8080/">http://localhost:8080</a>，帳號密碼是，finmind／test。</p>
<p><img src="tools/images/1*gmZ67ffvLW4vzxRtyHrbuw.png" alt="img" /></p>
<h1 id="6-拉取歷史資料"><a class="header" href="#6-拉取歷史資料">6. 拉取歷史資料</a></h1>
<p>目前 MySQL 資料庫都是空的，因此需要拉取 FinMind 資料，方式如下。</p>
<p>一樣進入以下連結，http://localhost:8888/docs，並根據下圖，選擇 dataset，以 TaiwanStockPrice 為例</p>
<p><img src="tools/images/1*YWIsXPlwv7ux9FSPhPij1w.png" alt="img" /></p>
<h1 id="7-拉取資料方式"><a class="header" href="#7-拉取資料方式">7. 拉取資料方式</a></h1>
<p>是透過 RabbitMQ 進行，可以使用以下連結進入，http://localhost:15672/，帳號密碼，worker／worker。</p>
<p><img src="tools/images/1*nRh34sEuRIwcDrYrIfW9oQ.png" alt="img" /></p>
<p>等待 queues 消化完成歸 0 後，跳轉到 MySQL，可以看到都已經成功拉取 TaiwanStockPrice 歷史資料了，如下</p>
<p><img src="tools/images/1*yY6HR4f17qBUXbhpCuJwTg.png" alt="img" /></p>
<p>其他的 Data，也可以用一樣的方式更新歷史資料。</p>
<h1 id="8-如何定時更新資料"><a class="header" href="#8-如何定時更新資料">8. 如何定時更新資料？</a></h1>
<p>這時會有讀者想問，如何定時更新資料，首先，跳轉到 scheduler 的 table</p>
<p><img src="tools/images/1*ZFezkD6lQP_gTG2z8nLFYg.png" alt="img" /></p>
<p>預設都是不要定時更新，這部分留給使用者自行決定。</p>
<h1 id="9-開始建立視覺化"><a class="header" href="#9-開始建立視覺化">9. 開始建立視覺化</a></h1>
<p>前置工作都準備完成後，資料會定時更新了，開始進入主題，視覺化工具，進入以下連結，http://localhost:5000/，按照下圖步驟，帳號密碼讀者可自行設定</p>
<p><img src="tools/images/1*R9uOgFUuHM4RbRJEm47Ytw.png" alt="img" /></p>
<p>建立 Data Source，與 MySQL 做連結</p>
<p><img src="tools/images/1*A3Q-wso2In_LwaI7_18abg.png" alt="img" /></p>
<p>連線參數</p>
<p><img src="tools/images/1*NFwirsplQLFOnfM46_A-DQ.png" alt="img" /></p>
<p>以上成功後，開始建立，第一個 Query</p>
<h1 id="10-建立第一個-query"><a class="header" href="#10-建立第一個-query">10. 建立第一個 Query</a></h1>
<p>步驟如下圖</p>
<p><img src="tools/images/1*uZ3HQERzY90HXqVwWp0kHg.png" alt="img" /></p>
<p>輸入以下 SQL</p>
<pre><code>select
  *
from
  TaiwanStockPrice
where
  stock_id = '2330'
  and date &gt;= '2022-01-01'
</code></pre>
<p><img src="tools/images/1*Gy5keCCu4UTDcNx1L5PKhw.png" alt="img" /></p>
<p>到這就完成了基本設定，下一篇文章將介紹，如何進行視覺化做圖，如何做出第一篇文章中的圖表。</p>
<p><img src="tools/images/1*RGUXAgCMcMrAJBsy_hENBA.png" alt="img" /></p>
<h1 id=""><a class="header" href="#"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="為函數新增enter和exit級trace"><a class="header" href="#為函數新增enter和exit級trace">為函數新增enter和exit級trace</a></h1>
<p>日常開發中，我們為了輔助程序偵錯常常在每個函數的出入口(entry/exit)增加Trace，一般我們多用宏來實現這些Trace語句，例如：</p>
<pre><code class="language-c">#ifdef XX_DEBUG_
#define TRACE_ENTER() printf(&quot;Enter %s\n&quot;, __FUNCTION__)
#define TRACE_EXIT() printf(&quot;Exit %s\n&quot;, __FUNCTION__)
#else
#define TRACE_ENTER()
#define TRACE_EXIT()
#endif

// 有了TRACE_ENTER和TRACE_EXIT後，你就可以在你的函數中使用它們了。例如：
void foo(…)
{
    TRACE_ENTER();
    … …
    TRACE_EXIT();
}

</code></pre>
<p>這樣你就可以很容易看到函數的呼叫關係。不過這種手法用起來卻不輕鬆。首先你需要在每個函數中手工加入TRACE_ENTER和TRACE_EXIT，然後再利用XX_DEBUG_宏控制其是否生效。特別是對於初期未新增函數級Enter/Exit Trace的項目，後期加入工作量很大。</p>
<p>另外一種方便的手法：使用GCC的-finstrument-functions選項。-finstrument-functions使得GCC在生成程式碼時自動為每個函數在入口和出口生成__cyg_profile_func_enter和__cyg_profile_func_exit兩個函數呼叫。我們要做的就是給出一份兩個函數的實現即可。最簡單的實現莫過於列印出被呼叫函數的地址了：</p>
<pre><code class="language-c">/* func_trace.c */
__attribute__((no_instrument_function))
void __cyg_profile_func_enter(void* this_fn, void* call_site)
{
    printf(&quot;enter func =&gt; %p\n&quot;, this_fn);
}

__attribute__((no_instrument_function))
void __cyg_profile_func_exit(void* this_fn, void* call_site)
{
    printf(&quot;exit func &lt;= %p\n&quot;, this_fn);
}
</code></pre>
<p>我們將這兩個函數放入libfunc_trace.so：</p>
<pre><code class="language-sh">gcc -fPIC -shared -o libfunc_trace.so func_trace.c
</code></pre>
<p>我們為下面例子新增enter/exit級Trace：</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
/* example.c */
static void foo2()
{

}

void foo1()
{
    foo2();
}

void foo()
{
    chdir(&quot;/home/tonybai&quot;);
    foo1();
}

int main(int argc, const char* argv[])
{
    foo();
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ gcc -g example.c -o example -finstrument-functions -no-pie
$ LD_PRELOAD=libfunc_trace.so example
enter func =&gt; 0×8048524
enter func =&gt; 0x80484e5
enter func =&gt; 0x80484b2
enter func =&gt; 0×8048484
exit func &lt;= 0×8048484
exit func &lt;= 0x80484b2
exit func &lt;= 0x80484e5
exit func &lt;= 0×8048524
</code></pre>
<p>不過只輸出函數地址很難讓人滿意，根據這些地址我們無法得知到底對應的是哪個函數。那我們就嘗試一下將地址轉換為函數名後再輸出，這方面GNU依舊給我們提供了工具，它就是addr2line。addr2line是<a href="http://www.gnu.org/s/binutils">binutils</a>包中的一個工具，它可以根據提供的地址在可執行檔案中找出對應的函數名、對應的原始碼檔案名稱以及行數。我們改造一下func_trace.c中的兩個函數的實現：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/syscall.h&gt;

#define PATH_MAX 1024
#define gettid() syscall(SYS_gettid)
#define DUMP(func, call) printf(&quot;%s: func = %p, called by = %p/n&quot;, __FUNCTION__, func, call)

static char path[PATH_MAX];

__attribute__((constructor))
static void executable_path_init()
{
    char    buf[PATH_MAX];

    memset(buf, 0, sizeof(buf));
    memset(path, 0, sizeof(path));

#ifdef _SOLARIS_TRACE
    getcwd(buf, PATH_MAX);
    sprintf(path, &quot;%s/%s&quot;, buf, getexecname());
#elif _LINUX_TRACE
    readlink(&quot;/proc/self/exe&quot;, path, PATH_MAX);
#else
#endif
}

#ifdef __cplusplus
extern &quot;C&quot; {
#endif
__attribute__((no_instrument_function))
void __cyg_profile_func_enter(void* this_fn, void* call_site)
{
    char buf[PATH_MAX];
    char cmd[PATH_MAX];

    memset(buf, 0, sizeof(buf));
    memset(cmd, 0, sizeof(cmd));

    sprintf(cmd, &quot;addr2line %p -e %s -f|head -1&quot;, this_fn, path);
    printf(&quot;\n%s\n&quot;, cmd);

    FILE* ptr = NULL;
    memset(buf, 0, sizeof(buf));

    if ((ptr = popen(cmd, &quot;r&quot;)) != NULL) {
        fgets(buf, PATH_MAX, ptr);
        printf(&quot;enter func =&gt; %p:%s&quot;, this_fn, buf);
    }

    (void) pclose(ptr);
}

__attribute__((no_instrument_function))
void __cyg_profile_func_exit(void* this_fn, void* call_site)
{
    char buf[PATH_MAX];
    char cmd[PATH_MAX];

    memset(buf, 0, sizeof(buf));
    memset(cmd, 0, sizeof(cmd));

    sprintf(cmd, &quot;addr2line %p -e %s -f|head -1&quot;, this_fn, path);
    printf(&quot;\n%s\n&quot;, cmd);

    FILE* ptr = NULL;
    memset(buf, 0, sizeof(buf));

    if ((ptr = popen(cmd, &quot;r&quot;)) != NULL) {
        fgets(buf, PATH_MAX, ptr);
        printf(&quot;exit func &lt;= %p:%s&quot;, this_fn, buf);
    }

    (void) pclose(ptr);
}
#ifdef __cplusplus
}
#endif
</code></pre>
<pre><code class="language-sh">gcc -D_LINUX_TRACE -fPIC -shared -o libfunc_trace.so func_trace.c
$ gcc -g example.c -o example -finstrument-functions -no-pie 
$ LD_PRELOAD=./libfunc_trace.so ./example
enter func =&gt; 0×8048524:main
enter func =&gt; 0x80484e5:foo
enter func =&gt; 0x80484b2:foo1
enter func =&gt; 0×8048484:foo2
exit func &lt;= 0×8048484:foo2
exit func &lt;= 0x80484b2:foo1
exit func &lt;= 0x80484e5:foo
exit func &lt;= 0×8048524:main
</code></pre>
<p>關於這個實現，還有幾點要說道說道：
首先libfunc_trace.so是<a href="http://tonybai.com/2008/02/03/symbol-linkage-in-shared-library/">動態連結</a>到你的可執行程序中的，那麼如何獲取addr2line所需要的檔案名稱是一個問題；另外考慮到可執行程序中可能會呼叫chdir這樣的介面更換當前工作路徑，所以我們需要在初始化時就得到可執行檔案的絕對路徑供addr2line使用，否則會出現無法找到可執行檔案的錯誤。在這裡我們利用了GCC的__attribute__擴展：
<strong>attribute</strong>((constructor))</p>
<p>這樣我們就可以在main之前就將可執行檔案的絕對路徑獲取到，並在__cyg_profile_func_enter和__cyg_profile_func_exit中直接引用這個路徑。</p>
<p>在不同平臺下獲取可執行檔案的絕對路徑的方法有不同，像Linux下可以利用&quot;readlink /proc/self/exe&quot;獲得可執行檔案的絕對路徑，而Solaris下則用getcwd和getexecname拼接。</p>
<p>再總結一下，如果你想使用上面的libfunc_trace.so，你需要做的事情有：
1、將編譯好的libfunc_trace.so放在某路徑下，並export LD_PRELOAD=PATH_TO_libfunc_trace.so/libfunc_trace.so
2、你的環境下需要安裝binutils的addr2line
3、你的應用在編譯時增加-finstrument_functions選項。</p>
<p>我已經將這個小工具包放到了Google Code上，有興趣的朋友可以在<a href="http://code.google.com/p/bigwhite-code/">這裡</a>下載完整原始碼包（20110715更新：支援輸出函數所在原始檔路徑以及所在行號，前提編譯你的程序時務必加上-g選項）</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cmake"><a class="header" href="#cmake">Cmake</a></h2>
<p>常用的 CMake 參數：</p>
<ol>
<li><code>-DCMAKE_BUILD_TYPE</code>: 用於指定編譯模式，例如 <code>Debug</code>、<code>Release</code> 等。</li>
<li><code>-DCMAKE_INSTALL_PREFIX</code>: 用於指定安裝路徑，預設為 <code>/usr/local</code>。</li>
<li><code>-G</code>: 用於指定生成的專案文件類型，例如 <code>Unix Makefiles</code>、<code>Visual Studio</code> 等。</li>
<li><code>-DCMAKE_C_COMPILER</code> 和 <code>-DCMAKE_CXX_COMPILER</code>: 用於指定 C 和 C++ 編譯器的路徑。</li>
<li><code>-D</code>: 用於定義變數，例如 <code>-DENABLE_FEATURE_A=ON</code>。</li>
<li><code>-DBUILD_SHARED_LIBS</code>: 用於指定是否生成共享庫（動態連結庫），默認為 <code>OFF</code>。</li>
<li><code>-DCMAKE_VERBOSE_MAKEFILE</code>: 用於顯示詳細的編譯信息，包括編譯器命令和編譯時的選項。</li>
<li><code>-DCMAKE_C_FLAGS</code> 和 <code>-DCMAKE_CXX_FLAGS</code>: 用於指定編譯器的選項，例如 <code>-O2</code>、<code>-Wall</code> 等。</li>
<li><code>-DCMAKE_MODULE_PATH</code>: 用於指定 CMake 模組的路徑，例如 <code>/usr/local/share/cmake/Modules</code>。</li>
<li><code>-DCMAKE_PREFIX_PATH</code>: 用於指定查找庫文件和頭文件的路徑，例如 <code>/usr/local/lib</code> 和 <code>/usr/local/include</code>。</li>
</ol>
<p>以上是一些常用的 CMake 參數，你可以在需要的情況下使用它們來配置你的項目。</p>
<hr />
<p>在 CMakeLists.txt 中，你可以使用一些指令和變數來配置你的 CMake 項目。以下是一些常用的指令和變數及其解釋：</p>
<p>指令：</p>
<ol>
<li><code>cmake_minimum_required(VERSION x.y)</code>: 指定 CMake 的最低版本需求，例如 <code>cmake_minimum_required(VERSION 3.10)</code>。</li>
<li><code>project(name [LANGUAGES lang1 lang2 ...])</code>: 指定項目的名稱和支持的語言，例如 <code>project(MyProject CXX)</code>。</li>
<li><code>add_executable(name source1 [source2 ...])</code>: 指定生成執行文件的名稱和源文件，例如 <code>add_executable(MyProgram main.cpp)</code>。</li>
<li><code>add_library(name type source1 [source2 ...])</code>: 指定生成靜態庫或動態連結庫的名稱、類型和源文件，例如 <code>add_library(MyLibrary STATIC lib.cpp)</code>。</li>
<li><code>target_link_libraries(target library1 [library2 ...])</code>: 指定目標文件需要連結的庫文件，例如 <code>target_link_libraries(MyProgram MyLibrary)</code>。</li>
<li><code>include_directories(dir1 [dir2 ...])</code>: 指定頭文件搜索路徑，例如 <code>include_directories(include)</code>。</li>
</ol>
<p>變數：</p>
<ol>
<li><code>CMAKE_C_COMPILER</code> 和 <code>CMAKE_CXX_COMPILER</code>: 指定 C 和 C++ 編譯器的路徑，例如 <code>set(CMAKE_CXX_COMPILER /usr/bin/g++)</code>。</li>
<li><code>CMAKE_BUILD_TYPE</code>: 指定編譯模式，例如 <code>set(CMAKE_BUILD_TYPE Release)</code>。</li>
<li><code>CMAKE_INSTALL_PREFIX</code>: 指定安裝路徑，例如 <code>set(CMAKE_INSTALL_PREFIX /usr/local)</code>。</li>
<li><code>CMAKE_CXX_FLAGS</code> 和 <code>CMAKE_C_FLAGS</code>: 指定編譯器的選項，例如 <code>set(CMAKE_CXX_FLAGS &quot;-O2 -Wall&quot;)</code>。</li>
</ol>
<p>以上是一些常用的 CMake 指令和變數，你可以在 CMakeLists.txt 文件中使用它們來配置你的項目。</p>
<pre><code class="language-sh">set(CMAKE_BUILD_TYPE DEBUG)
set(CMAKE_C_FLAGS &quot;-O0 -ggdb&quot;)
set(CMAKE_C_FLAGS_DEBUG &quot;-O0 -ggdb&quot;)
set(CMAKE_C_FLAGS_RELEASE &quot;-O0 -ggdb&quot;)
set(CMAKE_CXX_FLAGS &quot;-O0 -ggdb&quot;)
set(CMAKE_CXX_FLAGS_DEBUG &quot;-O0 -ggdb&quot;)
set(CMAKE_CXX_FLAGS_RELEASE &quot;-O0 -ggdb&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ufw簡易防火牆設置"><a class="header" href="#ufw簡易防火牆設置">ufw：簡易防火牆設置</a></h1>
<p>出處:https://noob.tw/ufw/</p>
<p>Linux 上的 iptables 可能太難，我們不是專業的資安工程師，也不是什麼 Linux 老鳥。像我們這種菜鳥，還是用 ufw 就好了。這篇整理一些常用的 ufw 設定。</p>
<h2 id="安裝-ufw"><a class="header" href="#安裝-ufw">安裝 ufw</a></h2>
<p>ufw 的全名是 Uncomplicated Firewall，意思是不複雜的防火牆。它的指令不但好記，寫好的規則也淺顯易懂，不會像 iptables 的裹腳布又臭又長。</p>
<p>大部分的 Ubuntu 系統應該都已經裝好 ufw。如果你是 Debian，或是什麼特別瘦身版的 Ubuntu 的話，可以透過以下指令安裝：</p>
<pre><code class="language-bash">sudo apt-get install ufw
</code></pre>
<h2 id="設定防火牆預設規則"><a class="header" href="#設定防火牆預設規則">設定防火牆預設規則</a></h2>
<p>如果你想要規則嚴一點，可以預設封鎖所有通訊埠，再選擇性打開幾個 port；你也可以預設開放所有 port，然後再封鎖幾個 port。預設允許/封鎖的指令如下：</p>
<pre><code class="language-bash">sudo ufw default allow # 預設允許
sudo ufw default deny # 預設封鎖
</code></pre>
<h2 id="允許封鎖通訊埠port"><a class="header" href="#允許封鎖通訊埠port">允許/封鎖通訊埠（port）</a></h2>
<p>如果你要允許 SSH port 的話，可以這樣下：</p>
<pre><code class="language-bash">sudo ufw allow ssh
</code></pre>
<p>或是</p>
<pre><code class="language-bash">sudo ufw allow 22
</code></pre>
<p>也可以允許或封鎖其他的 port：</p>
<pre><code class="language-bash">sudo ufw allow 80 # 允許 80
sudo ufw allow 443 # 允許 443
sudo ufw deny 3389 # 封鎖 3389
sudo ufw deny 21 # 封鎖 21
</code></pre>
<p>甚至可以一次允許一個範圍的 port：</p>
<pre><code class="language-bash">sudo ufw allow 6000:6007/tcp # 允許 TCP 6000~6007
sudo ufw allow 6000:6007/udp # 允許 UDP 6000~6007
</code></pre>
<h2 id="來自特定-ip-的規則"><a class="header" href="#來自特定-ip-的規則">來自特定 IP 的規則</a></h2>
<p>上面的規則是針對所有 IP，如果你想要針對某些 IP 可以不受控管，你也可以這樣設定：</p>
<pre><code class="language-bash">sudo ufw allow from 192.168.11.10 # 允許 192.168.11.10 的所有連線
sudo ufw allow from 192.168.11.0/24 # 允許 192.168.11.1~192.168.11.255 的所有連線
sudo ufw deny from 192.168.11.4 # 封鎖 192.168.11.4 的所有連線
</code></pre>
<p>如果你只是不想讓某個小明偷偷連到你的 SSH Port，你也可以針對他封鎖：</p>
<pre><code class="language-bash">sudo ufw deny from 192.168.11.7 to any port 22
</code></pre>
<h2 id="查看目前設了什麼規則"><a class="header" href="#查看目前設了什麼規則">查看目前設了什麼規則</a></h2>
<p>推薦使用這個指令來看目前設了什麼規則：</p>
<pre><code class="language-bash">sudo ufw status numbered
</code></pre>
<p>這個指令會幫你把規則前面加上編號：</p>
<pre><code>Numbered Output:
Status: active

     To                         Action      From
     --                         ------      ----
[ 1] 22                         ALLOW IN    Anywhere
[ 2] 80                         ALLOW IN    Anywhere
[ 3] 443                        ALLOW IN    Anywhere
</code></pre>
<p>如果你突然不喜歡某個規則了，可以直接刪除它：</p>
<pre><code class="language-bash">sudo ufw delete 3
</code></pre>
<p>那個規則就不見囉！</p>
<h2 id="開啟關閉重設防火牆"><a class="header" href="#開啟關閉重設防火牆">開啟/關閉/重設防火牆</a></h2>
<p>設定完所有規則後，記得把防火牆打開。</p>
<blockquote>
<p>如果你是用 SSH 連線，別忘了要先 allow 自己的 SSH 連線。</p>
</blockquote>
<pre><code class="language-bash">sudo ufw enable # 啟用防火牆
sudo ufw disable # 停用防火牆
</code></pre>
<p>如果你把規則改爛了，想要重新來過的話，可以重設：</p>
<pre><code class="language-bash">sudo ufw reset
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-以-pycryptodome-實作-aes-對稱式加密方法教學與範例"><a class="header" href="#python-以-pycryptodome-實作-aes-對稱式加密方法教學與範例">Python 以 PyCryptodome 實作 AES 對稱式加密方法教學與範例</a></h1>
<p>出處：</p>
<p>https://officeguide.cc/python-pycryptodome-aes-symmetric-encryption-tutorial-examples/</p>
<p>以下將介紹如何在 Python 中安裝並使用 <code>PyCryptodome</code> 模組，以 AES 加密方法對資料進行加密與解密。</p>
<h2 id="安裝-pycryptodome-模組"><a class="header" href="#安裝-pycryptodome-模組">安裝 <code>PyCryptodome</code> 模組</a></h2>
<p>使用 pip 安裝 Python 的 <code>PyCryptodome</code> 模組：</p>
<pre><code># 安裝 PyCryptodome 模組
sudo pip3 install pycryptodome
</code></pre>
<p>這種安裝方式會讓 <code>PyCryptodome</code> 安裝在 <code>Crypto</code> 套件路徑之下，取代舊的 <code>PyCrypto</code> 模組，這兩個模組會互相干擾，所以不可以同時安裝。</p>
<p>測試 <code>PyCryptodome</code> 模組是否可以正常運作：</p>
<pre><code># 測試 PyCryptodome 模組
python3 -m Crypto.SelfTest
</code></pre>
<p>如果不希望影響到舊的 <code>PyCrypto</code> 模組，也可以選擇以獨立模組的方式安裝，將 <code>PyCryptodome</code> 模組安裝至 <code>Cryptodome</code> 套件路徑之下：</p>
<pre><code># 安裝 PyCryptodome 模組
sudo pip3 install pycryptodomex

# 測試 PyCryptodome 模組
python -m Cryptodome.SelfTest
</code></pre>
<h2 id="產生隨機金鑰"><a class="header" href="#產生隨機金鑰">產生隨機金鑰</a></h2>
<p>AES 加密方式的區塊長度固定為 128 位元，而金鑰長度則可以是 128、192 或 256 位元，在用 AES 進行資料加密之前，亦須先建立一組金鑰，最簡單的方式就是以隨機的方式產生金鑰。</p>
<pre><code>from Crypto.Random import get_random_bytes

# 產生 256 位元隨機金鑰（32 位元組 = 256 位元）
key = get_random_bytes(32)
print(key)
b'l\n\xe8\x7f#\xec{\xf9\x8a4\xb8hye\xe9V\\\xfb\x01\x08\x854\x89\xc9\xfc\x80\xa2S\x920@}'
</code></pre>
<h2 id="以密碼產生金鑰"><a class="header" href="#以密碼產生金鑰">以密碼產生金鑰</a></h2>
<p>如果希望使用一般的密碼來對資料進行加密與解密，可以根據密碼與一串固定的 salt 字串，產生對應的金鑰。</p>
<p>首先以亂數方式產生一串隨機的資料作為固定的 salt：</p>
<pre><code># 產生 salt
print(get_random_bytes(32))
b'\xd0\x18\xa7QM\xd6\x9b\xebxu\xe4\xed\xa8\x83\xf6\xa3/\x01\x9c\x9e\x86n\xda;\x10EdD\xf7\x932\xcc'
</code></pre>
<p>為了方便起見，可以將這串 salt 直接寫在程式當中，搭配自己的密碼即可產生金鑰：</p>
<pre><code>from Crypto.Protocol.KDF import PBKDF2

# 固定的 salt
salt = b'\xd0\x18\xa7QM\xd6\x9b\xebxu\xe4\xed\xa8\x83\xf6\xa3/\x01\x9c\x9e\x86n\xda;\x10EdD\xf7\x932\xcc'

# 密碼
password = 'my#password'

# 根據密碼與 salt 產生金鑰
key = PBKDF2(password, salt, dkLen=32)
</code></pre>
<h2 id="儲存金鑰"><a class="header" href="#儲存金鑰">儲存金鑰</a></h2>
<p>實務上我們通常會將產生的金鑰儲存在檔案中，方便後續的加密與解密使用：</p>
<pre><code># 金鑰儲存位置
keyPath = &quot;my_key.bin&quot;

# 儲存金鑰
with open(keyPath, &quot;wb&quot;) as f:
    f.write(key)

# 讀取金鑰
with open(keyPath, &quot;rb&quot;) as f:
    keyFromFile = f.read()

# 檢查金鑰儲存
assert key == keyFromFile, '金鑰不符'
</code></pre>
<h2 id="aes-cbc-加密模式"><a class="header" href="#aes-cbc-加密模式">AES CBC 加密模式</a></h2>
<p>以下是使用 AES 的 CBC 模式對資料進行加密的範例，以 CBC 模式加密時需要先對資料進行 padding 處理，再進行加密。</p>
<pre><code>from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

# 輸出的加密檔案名稱
outputFile = 'encrypted.bin'

# 要加密的資料（必須為 bytes）
data = b'My secret data.'

# 以金鑰搭配 CBC 模式建立 cipher 物件
cipher = AES.new(key, AES.MODE_CBC)

# 將輸入資料加上 padding 後進行加密
cipheredData = cipher.encrypt(pad(data, AES.block_size))

# 將初始向量與密文寫入檔案
with open(outputFile, &quot;wb&quot;) as f:
    f.write(cipher.iv)
    f.write(cipheredData)
</code></pre>
<p>以下則是 CBC 模式的解密方式：</p>
<pre><code>from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# 輸入的加密檔案名稱
inputFile = 'encrypted.bin'

# 從檔案讀取初始向量與密文
with open(inputFile, &quot;rb&quot;) as f:
    iv = f.read(16)         # 讀取 16 位元組的初始向量
    cipheredData = f.read() # 讀取其餘的密文

# 以金鑰搭配 CBC 模式與初始向量建立 cipher 物件
cipher = AES.new(key, AES.MODE_CBC, iv=iv)

# 解密後進行 unpadding
originalData = unpad(cipher.decrypt(cipheredData), AES.block_size)

# 輸出解密後的資料
print(originalData)
b'My secret data.'
</code></pre>
<h2 id="aes-cfb-加密模式"><a class="header" href="#aes-cfb-加密模式">AES CFB 加密模式</a></h2>
<p>AES 的 CFB 模式跟 CBC 模式很類似，不過資料在加密之前不需要經過 padding 處理。</p>
<pre><code>from Crypto.Cipher import AES

# 輸出的加密檔案名稱
outputFile = 'encrypted.bin'

# 要加密的資料（必須為 bytes）
data = b'My secret data.'

# 以金鑰搭配 CFB 模式建立 cipher 物件
cipher = AES.new(key, AES.MODE_CFB)

# 將輸入資料進行加密
cipheredData = cipher.encrypt(data)

# 將初始向量與密文寫入檔案
with open(outputFile, &quot;wb&quot;) as f:
    f.write(cipher.iv)
    f.write(cipheredData)
</code></pre>
<p>以下則是 CFB 模式的解密方式：</p>
<pre><code>from Crypto.Cipher import AES

# 輸入的加密檔案名稱
inputFile = 'encrypted.bin'

# 從檔案讀取初始向量與密文
with open(inputFile, &quot;rb&quot;) as f:
    iv = f.read(16)         # 讀取 16 位元組的初始向量
    cipheredData = f.read() # 讀取其餘的密文

# 以金鑰搭配 CFB 模式與初始向量建立 cipher 物件
cipher = AES.new(key, AES.MODE_CFB, iv=iv)

# 解密資料
originalData = cipher.decrypt(cipheredData)

# 輸出解密後的資料
print(originalData)
b'My secret data.'
</code></pre>
<h2 id="aes-eax-加密模式"><a class="header" href="#aes-eax-加密模式">AES EAX 加密模式</a></h2>
<p>AES 的 EAX 加密模式會產生 nonce 與 tag，這兩項必須連同密文一起儲存起來。</p>
<pre><code>from Crypto.Cipher import AES

# 輸出的加密檔案名稱
outputFile = 'encrypted.bin'

# 要加密的資料（必須為 bytes）
data = b'My secret data.'

# 以金鑰搭配 EAX 模式建立 cipher 物件
cipher = AES.new(key, AES.MODE_EAX)

# 將輸入資料進行加密
cipheredData, tag = cipher.encrypt_and_digest(data)

# 將 nonce、tag 與密文寫入檔案
with open(outputFile, &quot;wb&quot;) as f:
    f.write(cipher.nonce)
    f.write(tag)
    f.write(cipheredData)
</code></pre>
<p>以下則是 EAX 模式的解密方式：</p>
<pre><code>from Crypto.Cipher import AES

# 輸入的加密檔案名稱
inputFile = 'encrypted.bin'

# 從檔案讀取初始向量與密文
with open(inputFile, &quot;rb&quot;) as f:
    nonce = f.read(16)      # 讀取 16 位元組的 nonce
    tag = f.read(16)        # 讀取 16 位元組的 tag
    cipheredData = f.read() # 讀取其餘的密文

# 以金鑰搭配 EAX 模式與 nonce 建立 cipher 物件
cipher = AES.new(key, AES.MODE_EAX, nonce)

# 解密並驗證資料
originalData = cipher.decrypt_and_verify(cipheredData, tag)

# 輸出解密後的資料
print(originalData)
b'My secret data.'
</code></pre>
<h2 id="base64-編碼與-json-儲存格式"><a class="header" href="#base64-編碼與-json-儲存格式">Base64 編碼與 JSON 儲存格式</a></h2>
<p>如果要將密文等資料儲存至資料庫或是進行網路傳輸，可以考慮將資料經過 base64 編碼之後，放在一個 JSON 檔案中，以下是一個簡單的範例。</p>
<pre><code>import json
from base64 import b64encode, b64decode

# 要儲存的原始資料
ciphertext = b'...'
iv = b'...'

# 建立字典結構
outputJSON = {
    'ciphertext': b64encode(ciphertext).decode('utf-8'),
    'iv': b64encode(iv).decode('utf-8')
}

# 儲存為 JSON 檔案
with open('encrypted.json', 'w') as f:
    json.dump(outputJSON, f)

# 讀取 JSON 檔案
with open('encrypted.json') as f:
    inputJSON = json.load(f)

# 取用資料
ciphertext = b64decode(inputJSON['ciphertext'].encode('utf-8'))
iv = b64decode(inputJSON['iv'].encode('utf-8'))
</code></pre>
<p>參考資料：<a href="https://pycryptodome.readthedocs.io/en/latest/src/examples.html">PyCryptodome</a>、<a href="https://nitratine.net/blog/post/python-encryption-and-decryption-with-pycryptodome/">Nitratine</a>、<a href="https://nitratine.net/blog/post/python-gcm-encryption-tutorial/">Nitratine</a></p>
<hr />
<pre><code class="language-python">from base64 import b64encode, b64decode
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
import json


class AESCrypt:
    # 固定的 salt
    salt = b&quot;\xd0\x18\xa7QM\xd6\x9b\xebxu\xe4\xed\xa8\x83\xf6\xa3/\x01\x9c\x9e\x86n\xda;\x10EdD\xf7\x932\xcc&quot;

    def __init__(self, password):
        &quot;&quot;&quot;
        建立 AESCrypt 實例
        &quot;&quot;&quot;
        self.password = password
        # 根據密碼與 salt 產生金鑰
        self.key = self.generate_key()

    def generate_key(self):
        &quot;&quot;&quot;
        根據密碼與 salt 生成 PBKDF2 金鑰
        &quot;&quot;&quot;
        key = PBKDF2(self.password, AESCrypt.salt, 32)
        return key

    def encrypt(self, data):
        &quot;&quot;&quot;
        使用 AES 加密資料
        &quot;&quot;&quot;
        # 建立加密器
        cipher = AES.new(self.key, AES.MODE_CTR)

        # 將資料加密
        ciphertext = cipher.encrypt(data)

        # 回傳加密後的資料與 nonce
        return (b64encode(ciphertext), b64encode(cipher.nonce))

    def decrypt(self, data):
        &quot;&quot;&quot;
        使用 AES 解密資料
        &quot;&quot;&quot;
        # 將傳入的資料解析為密文與 nonce
        ciphertext, nonce = b64decode(data[0]), b64decode(data[1])

        # 建立解密器
        cipher = AES.new(self.key, AES.MODE_CTR, nonce=nonce)

        # 解密資料並回傳
        return cipher.decrypt(ciphertext)

if __name__ == &quot;__main__&quot;:
    # 創建 AESCrypt 實例
    aes = AESCrypt(&quot;my#password&quot;)

    # 需要加密的資料
    data = {&quot;id&quot;: 12345, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}

    # 編碼為 JSON 格式
    data_json = json.dumps(data)

    # 加密
    encrypted_data = aes.encrypt(data_json.encode(&quot;utf-8&quot;))

    # 將加密後的資料寫入文件
    with open(&quot;data.dat&quot;, &quot;wb&quot;) as f:
        f.write(encrypted_data[0])
        f.write(b&quot;\n&quot;)
        f.write(encrypted_data[1])

    # 從文件中讀取加密資料
    with open(&quot;data.dat&quot;, &quot;rb&quot;) as f:
        encrypted_data = (f.readline().strip(), f.readline().strip())

    # 解密
    decrypted_data = aes.decrypt(encrypted_data)

    # 將解密後的資料反序列化為 Python 對象
    data_decrypt = json.loads(decrypted_data.decode(&quot;utf-8&quot;))
    print(data_decrypt, type(data_decrypt))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lightweight-charts"><a class="header" href="#lightweight-charts">lightweight-charts</a></h2>
<pre><code class="language-sh">npm install lightweight-charts svelte-lightweight-charts
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;My Chart&lt;/title&gt;
    &lt;script src=&quot;https://unpkg.com/lightweight-charts@3.0.0/dist/lightweight-charts.standalone.production.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;chart&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
      const symbol = 'BTCUSDT';
      const interval = '1d';
      const limit = 1000;

      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&amp;interval=${interval}&amp;limit=${limit}`;

      fetch(url)
        .then(response =&gt; response.json())
        .then(data =&gt; {
          const chartData = data.map(item =&gt; ({
            time: item[0] / 1000,
            open: parseFloat(item[1]),
            high: parseFloat(item[2]),
            low: parseFloat(item[3]),
            close: parseFloat(item[4]),
          }));

          const chart = LightweightCharts.createChart(document.getElementById('chart'), {
            width: 600,
            height: 300,
          });

          const candlestickSeries = chart.addCandlestickSeries();

          candlestickSeries.setData(chartData);
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr />
<h2 id="trading-vue-js"><a class="header" href="#trading-vue-js">trading-vue-js</a></h2>
<p>https://github.com/tvjsx/trading-vue-js</p>
<pre><code class="language-sh">npm i trading-vue-js
</code></pre>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<ul>
<li>https://medium.com/marcius-studio/financial-charts-for-your-application-cfcceb147786</li>
<li>https://codesandbox.io/examples/package/trading-vue-js</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">VIM</a></h1>
<h2 id="nvim-編譯"><a class="header" href="#nvim-編譯">NVIM 編譯</a></h2>
<pre><code class="language-sh"># 關閉  anaconda 因為編譯環境會導向 anaconda lib
conda deactivate  

sudo apt-get install ninja-build \
     gettext libtool libtool-bin \
     autoconf automake cmake g++ \
     pkg-config unzip xsel

git clone https://github.com/neovim/neovim.git
cd neovim
git checkout stable
make CMAKE_EXTRA_FLAGS=&quot;-DCMAKE_INSTALL_PREFIX=$HOME/.mybin/nvim&quot; CMAKE_BUILD_TYPE=Release  -j8
make install

cd ~/.mybin/nvim/share/nvim/runtime/autoload
wget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

# copy vimrc to /home/shihyu/.config/nvim/init.vim   
 /home/shihyu/.config/nvim/init.vim
 
 
No &quot;python3&quot; provider found. Run :checkhealth provider
pip install --user --upgrade pynvim


# node 要新版的不然 coc 會報錯
sudo n 16 

// Enable Copy and Paste 
sudo apt-get install xclip xsel
</code></pre>
<pre><code class="language-sh">CocInstall coc-tabnine coc-clangd coc-cmake coc-css coc-html coc-json coc-r-lsp coc-go coc-pyright coc-tsserver coc-sh coc-rls
</code></pre>
<ul>
<li>~/.config/nvim/coc-settings.json</li>
</ul>
<pre><code class="language-sh">{
// 要空
}
</code></pre>
<pre><code class="language-sh">clangd.path 要空的
CocInstall coc-clangd
CocCommand clangd.install

CocInstall coc-go
CocCommand go.install.gopls

CocInstall coc-pyright
CocInstall coc-json coc-tsserver
</code></pre>
<pre><code class="language-sh"># neovim
## Config (`.config/nvim/init.vim`)
```
&quot; Neovim vimrc 

&quot;filetype plugin indent on    &quot; required

&quot; Use Vim settings rather than Vi settings
set nocompatible

&quot; Make backspace normal
set backspace=indent,eol,start

&quot; Syntax highlighting
syntax on
filetype plugin on

&quot; Show line numbers
set number

&quot; Allow hidden buffers, don't limit 1 file per window/split
set hidden

&quot; Set default Vim terminal window size to account for line number spacing
&quot; set lines=24 columns=82

&quot; Swaps, Undo, Backups
set undodir=~/.vim/undo/
set backupdir=~/.vim/backups/
set directory=~/.vim/swaps/
&quot; Added 12/14/2017
set backup
set undofile
set swapfile
&quot; Source .vimrc if present in working directory
set exrc

&quot; Restrict usage of write/execution shell commands
set secure

&quot; Search down into subfolders and provide tab-completion for file-tasks
set path+=**
set tabstop=4
set shiftwidth=4
set expandtab
&quot; Attempt to fix tmux/gnome-terminal color differences in Vim
set background=dark

&quot; Set default color 
colorscheme slate

&quot; Alter line numbers and background
hi Normal ctermbg=none
hi LineNr ctermfg=blue

&quot; Add a color column at max line len
hi ColorColumn ctermbg=darkgrey

&quot; Try and fix netrw:
&quot; Make smaller and rid banner
&quot; from here: https://shapeshed.com/vim-netrw/
let g:netrw_banner = 0
let g:netrw_winsize = 25

let g:vim_jsx_pretty_colorful_config = 1 &quot; default 0
&quot; python path
&quot;
let g:python3_host_prog=&quot;/usr/bin/python3&quot;
&quot; Set neovim's clipboard 
&quot; https://github.com/neovim/neovim/wiki/FAQ#how-to-use-the-windows-clipboard-from-wsl
set clipboard=unnamedplus

call plug#begin()
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'HerringtonDarkholme/yats.vim'
Plug 'yuezk/vim-js'
Plug 'maxmellon/vim-jsx-pretty'
if has('nvim')
  Plug 'Shougo/denite.nvim', { 'do': ':UpdateRemotePlugins' }
else
  Plug 'Shougo/denite.nvim'
  Plug 'roxma/nvim-yarp'
  Plug 'roxma/vim-hug-neovim-rpc'
endif
call plug#end()

&quot; === Denite setup ===&quot;
&quot; Use ripgrep for searching current directory for files
&quot; By default, ripgrep will respect rules in .gitignore
&quot;   --files: Print each file that would be searched (but don't search)
&quot;   --glob:  Include or exclues files for searching that match the given glob
&quot;            (aka ignore .git files)
&quot;
call denite#custom#var('file/rec', 'command', ['rg', '--files', '--glob', '!.git'])

&quot; Use ripgrep in place of &quot;grep&quot;
call denite#custom#var('grep', 'command', ['rg'])

&quot; Custom options for ripgrep
&quot;   --vimgrep:  Show results with every match on it's own line
&quot;   --hidden:   Search hidden directories and files
&quot;   --heading:  Show the file name above clusters of matches from each file
&quot;   --S:        Search case insensitively if the pattern is all lowercase
call denite#custom#var('grep', 'default_opts', ['--hidden', '--vimgrep', '--heading', '-S'])

&quot; Recommended defaults for ripgrep via Denite docs
call denite#custom#var('grep', 'recursive_opts', [])
call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
call denite#custom#var('grep', 'separator', ['--'])
call denite#custom#var('grep', 'final_opts', [])

&quot; Remove date from buffer list
call denite#custom#var('buffer', 'date_format', '')

&quot; Custom options for Denite
&quot;   auto_resize             - Auto resize the Denite window height automatically.
&quot;   prompt                  - Customize denite prompt
&quot;   direction               - Specify Denite window direction as directly below current pane
&quot;   winminheight            - Specify min height for Denite window
&quot;   highlight_mode_insert   - Specify h1-CursorLine in insert mode
&quot;   prompt_highlight        - Specify color of prompt
&quot;   highlight_matched_char  - Matched characters highlight
&quot;   highlight_matched_range - matched range highlight
let s:denite_options = {'default' : {
\ 'split': 'floating',
\ 'start_filter': 1,
\ 'auto_resize': 1,
\ 'source_names': 'short',
\ 'prompt': 'λ ',
\ 'highlight_matched_char': 'QuickFixLine',
\ 'highlight_matched_range': 'Visual',
\ 'highlight_window_background': 'Visual',
\ 'highlight_filter_background': 'DiffAdd',
\ 'winrow': 1,
\ 'vertical_preview': 1
\ }}

&quot; Loop through denite options and enable them
function! s:profile(opts) abort
  for l:fname in keys(a:opts)
    for l:dopt in keys(a:opts[l:fname])
      call denite#custom#option(l:fname, l:dopt, a:opts[l:fname][l:dopt])
    endfor
  endfor
endfunction

call s:profile(s:denite_options)

&quot; Special filetype settings
autocmd FileType html setlocal shiftwidth=2 tabstop=2
autocmd FileType javascript setlocal shiftwidth=2 tabstop=2
autocmd FileType css setlocal shiftwidth=2 tabstop=2
autocmd FileType jsx setlocal shiftwidth=2 tabstop=2
autocmd FileType tsx setlocal shiftwidth=2 tabstop=2
autocmd FileType ts setlocal shiftwidth=2 tabstop=2
autocmd FileType py setlocal shiftwidth=4 tabstop=4
```
## Setup
### Plugin system [`vim-plug`](https://github.com/junegunn/vim-plug)
```
sh -c 'curl -fLo &quot;${XDG_DATA_HOME:-$HOME/.local/share}&quot;/nvim/site/autoload/plug.vim --create-dirs \
       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
```
### Language servers
- `JavaScript`: https://github.com/neoclide/coc-tsserver `:CocInstall coc-tsserver`

- `Python`: https://github.com/neoclide/coc.nvim/wiki/Language-servers#python `:CocInstall coc-python`

- `bash`: https://github.com/josa42/coc-sh `:CocInstall coc-sh`

- `C/C++`: 
RHEL8: 
```
sudo dnf install clang
```

Ubuntu:
```
sudo apt install clangd-10 # as of fall 2020
```
In vim/neovim:
```
:CocInstall coc-clangd
```
- `cmake`: `:CocInstall coc-cmake`
- `css`: `:CocInstall coc-css`
- `html`: `:CocInstall coc-html`
- `json`: `:CocInstall coc-json`
- `R`: `:CocInstall coc-r-lsp`
- `go`: `:CocInstall coc-go`
- `python`: `:CocInstall coc-pyright`

Do a bunch, all in one go, e.g. `:CocInstall coc-tabnine coc-clangd coc-cmake coc-css coc-html coc-json coc-r-lsp coc-go coc-pyright coc-tsserver coc-sh coc-rls`!

### Tabnine Pro Key
If you're a user of [TabNine](https:://www.TabNine.com) within multiple editing environments, you probably have a pro key. As [coc-tabnine](https://github.com/neoclide/coc-tabnine) is community supported, you'll need to use the `TabNine::config` **Magic String** to configure your key in settings.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copilot"><a class="header" href="#copilot">copilot</a></h1>
<p>https://github.com/github/copilot.vim</p>
<ol>
<li>
<p>Install <a href="https://nodejs.org/en/download/">Node.js</a> 12 or newer.</p>
</li>
<li>
<p>Install <a href="https://github.com/neovim/neovim/releases/latest">Neovim</a> 0.6 or newer.</p>
</li>
<li>
<p>Install <code>github/copilot.vim</code> using vim-plug, packer.nvim, or any other plugin manager. Or to install directly:</p>
<ul>
<li>手動更新</li>
</ul>
<pre><code class="language-sh">git clone https://github.com/github/copilot.vim.git \
  ~/.config/nvim/pack/github/start/copilot.vim
</code></pre>
</li>
<li>
<p>Start Neovim and invoke <code>:Copilot setup</code>.</p>
</li>
</ol>
<p>https://github.com/github/copilot.vim/blob/release/doc/copilot.txt</p>
<pre><code class="language-sh">:Copilot disable        Globally disable GitHub Copilot inline suggestions.

                                                *:Copilot_enable*
:Copilot enable         Re-enable GitHub Copilot after :Copilot disable.

                                                *:Copilot_feedback*
:Copilot feedback       Open the website for providing GitHub Copilot
                        feedback.

                                                *:Copilot_setup*
:Copilot setup          Authenticate and enable GitHub Copilot.

                                                *:Copilot_signout*
:Copilot signout        Sign out of GitHub Copilot.

                                                *:Copilot_status*
:Copilot status         Check if GitHub Copilot is operational for the current
                        buffer and report on any issues.

                                                *:Copilot_panel*
:Copilot panel          Open a window with up to 10 completions for the
                        current buffer.  Use &lt;CR&gt; to accept a solution.  Maps
                        are also provided for [[ and ]] to jump from solution
                        to solution.  This is the default command if :Copilot
                        is called without an argument.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="coc-tabnine"><a class="header" href="#coc-tabnine">coc-tabnine</a></h2>
<p>vimを起動した狀態で以下のコマンドを実行します。</p>
<pre><code class="language-plain">:CocInstall coc-tabnine
</code></pre>
<p>依存しているTabnineをコマンドで追加インストールします。</p>
<pre><code class="language-plain">:CocCommand tabnine.updateTabNine
</code></pre>
<p>以下の表示が出たら完了です。Restartしておきましょう。</p>
<pre><code class="language-plain">:CocRestart
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb"><a class="header" href="#gdb">GDB</a></h1>
<pre><code class="language-sh">sudo apt-get install libgmp-dev libmpfr-dev

git clone https://github.com/bminor/binutils-gdb

../configure --enable-targets=all \
--prefix=/home/shihyu/.mybin/gdb

make -j8 &amp;&amp; make
</code></pre>
<hr />
<h2 id="編譯-gdb-79-build-gdbserver-and-gdb"><a class="header" href="#編譯-gdb-79-build-gdbserver-and-gdb">編譯 gdb-7.9 build gdbserver and gdb</a></h2>
<p>建議： 給特定用戶安裝 GDB 的 pretty-printer 打印出可讀性更好的 stdc++ 的 STL 容器 在編譯 GDB 之前，先安裝 ncurses 庫和 Python 庫（用於在 GDB 中 開啟 Python 支持，編譯 GDB 時必須添加 --with-python 選項）。</p>
<pre><code class="language-sh">sudo apt-get install texinfo libncurses-dev libreadline-dev python-dev
gdb 編譯新版修改  // 因為 gdb 會出現  'g' packet reply is too long:
修改gdb/remote.c文件，屏蔽process_g_packet函數中的下列兩行：
if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet)
error (_(“Remote ‘g’ packet reply is too long: %s”), rs-&gt;buf);
在其後添加：
if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet) {
    rsa-&gt;sizeof_g_packet = buf_len ;
    for (i = 0; i &lt; gdbarch_num_regs (gdbarch); i++)
    {
        if (rsa-&gt;regs[i].pnum == -1)
            continue;

        if (rsa-&gt;regs[i].offset &gt;= rsa-&gt;sizeof_g_packet)
            rsa-&gt;regs[i].in_g_packet = 0;
        else
            rsa-&gt;regs[i].in_g_packet = 1;
    }
}
</code></pre>
<h4 id="找到python可執行程序的位置"><a class="header" href="#找到python可執行程序的位置">找到python可執行程序的位置</a></h4>
<pre><code class="language-sh">which python

/home/shihyu/anaconda2/bin/python
</code></pre>
<h4 id="若為-anaconda則使用-anacondalib"><a class="header" href="#若為-anaconda則使用-anacondalib">若為 Anaconda，則使用 Anaconda/lib</a></h4>
<pre><code class="language-sh">設置環境變量

export LDFLAGS=&quot;-Wl,-rpath,/home/shihyu/anaconda3/lib -L/home/shihyu/anaconda3/lib&quot;

../configure --enable-targets=all \
             --enable-64-bit-bfd  \
             --with-python=python3.7 \
             --with-system-readline \
             --prefix=/home/shihyu/.mybin/gdb8.3_python3
設置環境變量

export LDFLAGS=&quot;-Wl,-rpath,/home/shihyu/anaconda2/lib -L/home/shihyu/anaconda2/lib&quot;

./configure --enable-targets=all \
            --enable-64-bit-bfd \
            --with-python=&quot;/home/shihyu/anaconda2/bin/&quot; \
            --with-system-readline \
            --prefix=/home/shihyu/.mybin/gdb_8.1
mkdir build ; cd build

export LDFLAGS=&quot;-Wl,-rpath,/home/shihyu/anaconda3/lib -L/home/shihyu/anaconda3/lib&quot;

../configure --enable-targets=all \
             --enable-64-bit-bfd  \
             --with-python=python3.6 \
             --with-system-readline \
             --prefix=/home/shihyu/.mybin/gdb_python3
../configure --enable-targets=all \
             --enable-64-bit-bfd  \
             --with-python=python3 \
             --with-system-readline \
             --prefix=/home/shihyu/.mybin/gdb_python3
./configure --enable-targets=all \
            --enable-64-bit-bfd \
            --with-python \
            --with-system-readline \
            --prefix=/home/shihyu/.mybin/gdb_8.1




# --target=arm-linux表示生成的gdb調試的目標是在arm核心Linux系統中運行的程序
# --enable-targets=all  gdb可以用同一個版本支持x86，ppc等多種體系結構。
# 比較新的bfd中，當設置的target是64位或者打開--enable-targets=all的時候，不需要設置會自動打開這個選項，不過保險起見還是打開。這樣編譯出的GDB就能支持GDB支持的全部體系結構了。
make
sudo make install
</code></pre>
<p>把[GCC源碼目錄]/libstdc++-v3/python 複製到任意一個目錄（比如 ~/.mybin/gdb_8.1 目錄下）， 如果源碼目錄下沒有上述 python 目錄，也可以用如下方式從遠程庫拉取之後再放到 ~/.mybin/gdb_8.1 目錄下：</p>
<pre><code class="language-sh">svn co svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python
</code></pre>
<p>然後，編輯 ~/.gdbinit，添加如下內容</p>
<pre><code class="language-sh">python
import sys
import os
p = os.path.expanduser('~/.gdb/python') 
print p
if os.path.exists(p):
    sys.path.insert(0, p)
    from libstdcxx.v6.printers import register_libstdcxx_printers
    register_libstdcxx_printers(None)
end
(gdb) set architecture
Display all 204 possibilities? (y or n)
alpha                          m68k:isa-c:nodiv:mac
alpha:ev4                      m88k:88100
alpha:ev5                      mep
alpha:ev6                      mips
am33                           mips:10000
am33-2                         mips:12000
arm                            mips:16
armv2                          mips:3000
armv2a                         mips:3900
armv3                          mips:4000
armv3m                         mips:4010
armv4                          mips:4100
armv4t                         mips:4111
armv5                          mips:4120
armv5t                         mips:4300
armv5te                        mips:4400
auto                           mips:4600
avr                            mips:4650
avr:1                          mips:5000
avr:2                          mips:5400
avr:3                          mips:5500
avr:4                          mips:6000
avr:5                          mips:7000
avr:6                          mips:8000
cris                           mips:9000
cris:common_v10_v32            mips:isa32
crisv32                        mips:isa32r2
ep9312                         mips:isa64
fr300                          mips:isa64r2
fr400                          mips:loongson_2e
fr450                          mips:loongson_2f
fr500                          mips:mips5
fr550                          mips:octeon
frv                            mips:sb1
h1                             mn10300
h8300                          ms1
h8300h                         ms1-003
h8300hn                        ms2
h8300s                         powerpc:403
h8300sn                        powerpc:601
h8300sx                        powerpc:603
h8300sxn                       powerpc:604
hppa1.0                        powerpc:620
i386                           powerpc:630
i386:intel                     powerpc:7400
i386:x86-64                    powerpc:750
i386:x86-64:intel              powerpc:EC603e
i8086                          powerpc:MPC8XX
ia64-elf32                     powerpc:a35
ia64-elf64                     powerpc:common
iq10                           powerpc:common64
iq2000                         powerpc:e500
iwmmxt                         powerpc:rs64ii
iwmmxt2                        powerpc:rs64iii
m16c                           rs6000:6000
m32c                           rs6000:rs1
m32r                           rs6000:rs2
m32r2                          rs6000:rsc
m32rx                          s390:31-bit
m68hc11                        s390:64-bit
m68hc12                        score
m68k                           sh
m68k:5200                      sh-dsp
m68k:5206e                     sh2
m68k:521x                      sh2a
m68k:5249                      sh2a-nofpu
m68k:528x                      sh2a-nofpu-or-sh3-nommu
m68k:5307                      sh2a-nofpu-or-sh4-nommu-nofpu
m68k:5407                      sh2a-or-sh3e
m68k:547x                      sh2a-or-sh4
m68k:548x                      sh2e
m68k:68000                     sh3
m68k:68008                     sh3-dsp
m68k:68010                     sh3-nommu
m68k:68020                     sh3e
m68k:68030                     sh4
m68k:68040                     sh4-nofpu
m68k:68060                     sh4-nommu-nofpu
m68k:cfv4e                     sh4a
m68k:cpu32                     sh4a-nofpu
m68k:fido                      sh4al-dsp
m68k:isa-a                     sh5
m68k:isa-a:emac                simple
m68k:isa-a:mac                 sparc
m68k:isa-a:nodiv               sparc:sparclet
m68k:isa-aplus                 sparc:sparclite
m68k:isa-aplus:emac            sparc:sparclite_le
m68k:isa-aplus:mac             sparc:v8plus
m68k:isa-b                     sparc:v8plusa
m68k:isa-b:emac                sparc:v8plusb
m68k:isa-b:float               sparc:v9
m68k:isa-b:float:emac          sparc:v9a
m68k:isa-b:float:mac           sparc:v9b
m68k:isa-b:mac                 spu:256K
m68k:isa-b:nousp               tomcat
m68k:isa-b:nousp:emac          v850
m68k:isa-b:nousp:mac           v850e
m68k:isa-c                     v850e1
m68k:isa-c:emac                vax
m68k:isa-c:mac                 xscale
m68k:isa-c:nodiv               xstormy16
m68k:isa-c:nodiv:emac          xtensa
set architecture arm:指定arm硬體
</code></pre>
<ul>
<li>Toolchain 無法使用 android 的 arm 編譯器目前原因不清楚</li>
</ul>
<pre><code>https://launchpad.net/linaro-toolchain-binaries/trunk/2013.10/+download/gcc-linaro-arm-linux-gnueabihf-4.8-2013.10_linux.tar.bz2
</code></pre>
<ul>
<li>build.env</li>
</ul>
<pre><code># -*- shell-script -*-
TOOLCHAIN=gcc-linaro-arm-linux-gnueabihf-4.8-2013.10_linux
DIR=$(pushd $(dirname $BASH_SOURCE) &gt; /dev/null; pwd; popd &gt; /dev/null)
echo $DIR
export PATH=${PATH}:${DIR}/${TOOLCHAIN}/bin
export CC=arm-linux-gnueabihf-gcc
</code></pre>
<h2 id="gdbserver--要注意gdb和gdbserver版本一致"><a class="header" href="#gdbserver--要注意gdb和gdbserver版本一致">gdbserver , 要注意gdb和gdbserver版本一致</a></h2>
<pre><code>source build.env
./configure --target=arm-linux --host=arm-linux LDFLAGS=&quot;-static&quot;
# 這裡的--host指定這個程序的目標平臺。這一步中會檢查系統中是否有交叉編譯器的。
# We must add the above LDFLAGS to let gdb statically linked, otherwise it cannot
run on Android.

time make -j8 2&gt;&amp;1 | tee build.log
file ./gdbserver

./gdbserver: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 3.1.1, BuildID[sha1]=4eec8a5a6893ed8ce65eea5d0741a55cc621236a, not stripped
</code></pre>
<hr />
<h2 id="cgdb"><a class="header" href="#cgdb">cgdb</a></h2>
<p>安裝 cgdb</p>
<p>cgdb 是一個開源的 gdb 前端，可以提供實時的代碼預覽，極大的方便了調試。</p>
<p>獲取源碼</p>
<pre><code class="language-sh">$ git clone git://github.com/cgdb/cgdb.git
</code></pre>
<p>依賴</p>
<pre><code class="language-sh">flex( gettext )，autoconf, aclocal, automake, help2man
</code></pre>
<p>安裝依賴 （1） flex</p>
<pre><code class="language-sh">$ sudo apt-get install flex
</code></pre>
<p>（2） aclocal, automake, autoconf, autoheader 這些 utilities 都在 automake 包中，因此安裝automake 就夠了。</p>
<pre><code class="language-sh">$ sudo apt-get install automake
$ sudo apt-get install autotools-dev
</code></pre>
<p>(3) makeinfo，這個 utility 在 texinfo 包中</p>
<pre><code class="language-sh">$ sudo apt-get install texinfo
</code></pre>
<p>（3）help2man</p>
<pre><code class="language-sh">$ sudo apt-get install help2man
</code></pre>
<h2 id="編譯和安裝"><a class="header" href="#編譯和安裝">編譯和安裝</a></h2>
<pre><code class="language-sh">$ cd cgdb
$ ./autogen.sh
$ ./configure --prefix=/usr/local
$ make
$ sudo make install
</code></pre>
<hr />
<ul>
<li>~/.gdbinit</li>
</ul>
<pre><code class="language-sh">#    ``                                                                                                    
#   STL GDB evaluators/views/utilities - 1.03
#
#   The new GDB commands:                                                         
#         are entirely non instrumental                                             
#         do not depend on any &quot;inline&quot;(s) - e.g. size(), [], etc
#       are extremely tolerant to debugger settings
#                                                                                 
#   This file should be &quot;included&quot; in .gdbinit as following:
#   source stl-views.gdb or just paste it into your .gdbinit file
#
#   The following STL containers are currently supported:
#
#       std::vector&lt;T&gt; -- via pvector command
#       std::list&lt;T&gt; -- via plist or plist_member command
#       std::map&lt;T,T&gt; -- via pmap or pmap_member command
#       std::multimap&lt;T,T&gt; -- via pmap or pmap_member command
#       std::set&lt;T&gt; -- via pset command
#       std::multiset&lt;T&gt; -- via pset command
#       std::deque&lt;T&gt; -- via pdequeue command
#       std::stack&lt;T&gt; -- via pstack command
#       std::queue&lt;T&gt; -- via pqueue command
#       std::priority_queue&lt;T&gt; -- via ppqueue command
#       std::bitset&lt;n&gt; -- via pbitset command
#       std::string -- via pstring command
#       std::widestring -- via pwstring command
#
#   The end of this file contains (optional) C++ beautifiers
#   Make sure your debugger supports $argc
#
#   Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL
#   Inspired by intial work of Tom Malnar, 
#     Tony Novac (PhD) / Cornell / Stanford,
#     Gilad Mishne (PhD) and Many Many Others.
#   Contact: dan_c_marinescu@yahoo.com (Subject: STL)
#
#   Modified to work with g++ 4.3 by Anders Elton
#   Also added _member functions, that instead of printing the entire class in map, prints a member.



#
# std::vector&lt;&gt;
#

define pvector
    if $argc == 0
        help pvector
    else
        set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start
        set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start
        set $size_max = $size - 1
    end
    if $argc == 1
        set $i = 0
        while $i &lt; $size
            printf &quot;elem[%u]: &quot;, $i
            p *($arg0._M_impl._M_start + $i)
            set $i++
        end
    end
    if $argc == 2
        set $idx = $arg1
        if $idx &lt; 0 || $idx &gt; $size_max
            printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max
        else
            printf &quot;elem[%u]: &quot;, $idx
            p *($arg0._M_impl._M_start + $idx)
        end
    end
    if $argc == 3
      set $start_idx = $arg1
      set $stop_idx = $arg2
      if $start_idx &gt; $stop_idx
        set $tmp_idx = $start_idx
        set $start_idx = $stop_idx
        set $stop_idx = $tmp_idx
      end
      if $start_idx &lt; 0 || $stop_idx &lt; 0 || $start_idx &gt; $size_max || $stop_idx &gt; $size_max
        printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max
      else
        set $i = $start_idx
        while $i &lt;= $stop_idx
            printf &quot;elem[%u]: &quot;, $i
            p *($arg0._M_impl._M_start + $i)
            set $i++
        end
      end
    end
    if $argc &gt; 0
        printf &quot;Vector size = %u\n&quot;, $size
        printf &quot;Vector capacity = %u\n&quot;, $capacity
        printf &quot;Element &quot;
        whatis $arg0._M_impl._M_start
    end
end

document pvector
    Prints std::vector&lt;T&gt; information.
    Syntax: pvector &lt;vector&gt; &lt;idx1&gt; &lt;idx2&gt;
    Note: idx, idx1 and idx2 must be in acceptable range [0..&lt;vector&gt;.size()-1].
    Examples:
    pvector v - Prints vector content, size, capacity and T typedef
    pvector v 0 - Prints element[idx] from vector
    pvector v 1 2 - Prints elements in range [idx1..idx2] from vector
end 

#
# std::list&lt;&gt;
#

define plist
    if $argc == 0
        help plist
    else
        set $head = &amp;$arg0._M_impl._M_node
        set $current = $arg0._M_impl._M_node._M_next
        set $size = 0
        while $current != $head
            if $argc == 2
                printf &quot;elem[%u]: &quot;, $size
                p *($arg1*)($current + 1)
            end
            if $argc == 3
                if $size == $arg2
                    printf &quot;elem[%u]: &quot;, $size
                    p *($arg1*)($current + 1)
                end
            end
            set $current = $current._M_next
            set $size++
        end
        printf &quot;List size = %u \n&quot;, $size
        if $argc == 1
            printf &quot;List &quot;
            whatis $arg0
            printf &quot;Use plist &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the list.\n&quot;
        end
    end
end

document plist
    Prints std::list&lt;T&gt; information.
    Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx
    Examples:
    plist l - prints list size and definition
    plist l int - prints all elements and list size
    plist l int 2 - prints the third element in the list (if exists) and list size
end

define plist_member
    if $argc == 0
        help plist_member
    else
        set $head = &amp;$arg0._M_impl._M_node
        set $current = $arg0._M_impl._M_node._M_next
        set $size = 0
        while $current != $head
            if $argc == 3
                printf &quot;elem[%u]: &quot;, $size
                p (*($arg1*)($current + 1)).$arg2
            end
            if $argc == 4
                if $size == $arg3
                    printf &quot;elem[%u]: &quot;, $size
                    p (*($arg1*)($current + 1)).$arg2
                end
            end
            set $current = $current._M_next
            set $size++
        end
        printf &quot;List size = %u \n&quot;, $size
        if $argc == 1
            printf &quot;List &quot;
            whatis $arg0
            printf &quot;Use plist_member &lt;variable_name&gt; &lt;element_type&gt; &lt;member&gt; to see the elements in the list.\n&quot;
        end
    end
end

document plist_member
    Prints std::list&lt;T&gt; information.
    Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx
    Examples:
    plist_member l int member - prints all elements and list size
    plist_member l int member 2 - prints the third element in the list (if exists) and list size
end


#
# std::map and std::multimap
#

define pmap
    if $argc == 0
        help pmap
    else
        set $tree = $arg0
        set $i = 0
        set $node = $tree._M_t._M_impl._M_header._M_left
        set $end = $tree._M_t._M_impl._M_header
        set $tree_size = $tree._M_t._M_impl._M_node_count
        if $argc == 1
            printf &quot;Map &quot;
            whatis $tree
            printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot;
        end
        if $argc == 3
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                printf &quot;elem[%u].left: &quot;, $i
                p *($arg1*)$value
                set $value = $value + sizeof($arg1)
                printf &quot;elem[%u].right: &quot;, $i
                p *($arg2*)$value
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
        end
        if $argc == 4
            set $idx = $arg3
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                if *($arg1*)$value == $idx
                    printf &quot;elem[%u].left: &quot;, $i
                    p *($arg1*)$value
                    set $value = $value + sizeof($arg1)
                    printf &quot;elem[%u].right: &quot;, $i
                    p *($arg2*)$value
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        if $argc == 5
            set $idx1 = $arg3
            set $idx2 = $arg4
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                set $valueLeft = *($arg1*)$value
                set $valueRight = *($arg2*)($value + sizeof($arg1))
                if $valueLeft == $idx1 &amp;&amp; $valueRight == $idx2
                    printf &quot;elem[%u].left: &quot;, $i
                    p $valueLeft
                    printf &quot;elem[%u].right: &quot;, $i
                    p $valueRight
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        printf &quot;Map size = %u\n&quot;, $tree_size
    end
end

document pmap
    Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well.
    Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s)
    Examples:
    pmap m - prints map size and definition
    pmap m int int - prints all elements and map size
    pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size
    pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map size
end


define pmap_member
    if $argc == 0
        help pmap_member
    else
        set $tree = $arg0
        set $i = 0
        set $node = $tree._M_t._M_impl._M_header._M_left
        set $end = $tree._M_t._M_impl._M_header
        set $tree_size = $tree._M_t._M_impl._M_node_count
        if $argc == 1
            printf &quot;Map &quot;
            whatis $tree
            printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot;
        end
        if $argc == 5
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                printf &quot;elem[%u].left: &quot;, $i
                p (*($arg1*)$value).$arg2
                set $value = $value + sizeof($arg1)
                printf &quot;elem[%u].right: &quot;, $i
                p (*($arg3*)$value).$arg4
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
        end
        if $argc == 6
            set $idx = $arg5
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                if *($arg1*)$value == $idx
                    printf &quot;elem[%u].left: &quot;, $i
                    p (*($arg1*)$value).$arg2
                    set $value = $value + sizeof($arg1)
                    printf &quot;elem[%u].right: &quot;, $i
                    p (*($arg3*)$value).$arg4
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        printf &quot;Map size = %u\n&quot;, $tree_size
    end
end

document pmap_member
    Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well.
    Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s)
    Examples:
    pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2
    pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalue
end


#
# std::set and std::multiset
#

define pset
    if $argc == 0
        help pset
    else
        set $tree = $arg0
        set $i = 0
        set $node = $tree._M_t._M_impl._M_header._M_left
        set $end = $tree._M_t._M_impl._M_header
        set $tree_size = $tree._M_t._M_impl._M_node_count
        if $argc == 1
            printf &quot;Set &quot;
            whatis $tree
            printf &quot;Use pset &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the set.\n&quot;
        end
        if $argc == 2
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                printf &quot;elem[%u]: &quot;, $i
                p *($arg1*)$value
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
        end
        if $argc == 3
            set $idx = $arg2
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                if *($arg1*)$value == $idx
                    printf &quot;elem[%u]: &quot;, $i
                    p *($arg1*)$value
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        printf &quot;Set size = %u\n&quot;, $tree_size
    end
end

document pset
    Prints std::set&lt;T&gt; or std::multiset&lt;T&gt; information. Works for std::multiset as well.
    Syntax: pset &lt;set&gt; &lt;T&gt; &lt;val&gt;: Prints set size, if T defined all elements or just element(s) having val
    Examples:
    pset s - prints set size and definition
    pset s int - prints all elements and the size of s
    pset s int 20 - prints the element(s) with value = 20 (if any) and the size of s
end



#
# std::dequeue
#

define pdequeue
    if $argc == 0
        help pdequeue
    else
        set $size = 0
        set $start_cur = $arg0._M_impl._M_start._M_cur
        set $start_last = $arg0._M_impl._M_start._M_last
        set $start_stop = $start_last
        while $start_cur != $start_stop
            p *$start_cur
            set $start_cur++
            set $size++
        end
        set $finish_first = $arg0._M_impl._M_finish._M_first
        set $finish_cur = $arg0._M_impl._M_finish._M_cur
        set $finish_last = $arg0._M_impl._M_finish._M_last
        if $finish_cur &lt; $finish_last
            set $finish_stop = $finish_cur
        else
            set $finish_stop = $finish_last
        end
        while $finish_first != $finish_stop
            p *$finish_first
            set $finish_first++
            set $size++
        end
        printf &quot;Dequeue size = %u\n&quot;, $size
    end
end

document pdequeue
    Prints std::dequeue&lt;T&gt; information.
    Syntax: pdequeue &lt;dequeue&gt;: Prints dequeue size, if T defined all elements
    Deque elements are listed &quot;left to right&quot; (left-most stands for front and right-most stands for back)
    Example:
    pdequeue d - prints all elements and size of d
end



#
# std::stack
#

define pstack
    if $argc == 0
        help pstack
    else
        set $start_cur = $arg0.c._M_impl._M_start._M_cur
        set $finish_cur = $arg0.c._M_impl._M_finish._M_cur
        set $size = $finish_cur - $start_cur
        set $i = $size - 1
        while $i &gt;= 0
            p *($start_cur + $i)
            set $i--
        end
        printf &quot;Stack size = %u\n&quot;, $size
    end
end

document pstack
    Prints std::stack&lt;T&gt; information.
    Syntax: pstack &lt;stack&gt;: Prints all elements and size of the stack
    Stack elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop)
    Example:
    pstack s - prints all elements and the size of s
end



#
# std::queue
#

define pqueue
    if $argc == 0
        help pqueue
    else
        set $start_cur = $arg0.c._M_impl._M_start._M_cur
        set $finish_cur = $arg0.c._M_impl._M_finish._M_cur
        set $size = $finish_cur - $start_cur
        set $i = 0
        while $i &lt; $size
            p *($start_cur + $i)
            set $i++
        end
        printf &quot;Queue size = %u\n&quot;, $size
    end
end

document pqueue
    Prints std::queue&lt;T&gt; information.
    Syntax: pqueue &lt;queue&gt;: Prints all elements and the size of the queue
    Queue elements are listed &quot;top to bottom&quot; (top-most element is the first to come on pop)
    Example:
    pqueue q - prints all elements and the size of q
end



#
# std::priority_queue
#

define ppqueue
    if $argc == 0
        help ppqueue
    else
        set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start
        set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start
        set $i = $size - 1
        while $i &gt;= 0
            p *($arg0.c._M_impl._M_start + $i)
            set $i--
        end
        printf &quot;Priority queue size = %u\n&quot;, $size
        printf &quot;Priority queue capacity = %u\n&quot;, $capacity
    end
end

document ppqueue
    Prints std::priority_queue&lt;T&gt; information.
    Syntax: ppqueue &lt;priority_queue&gt;: Prints all elements, size and capacity of the priority_queue
    Priority_queue elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop)
    Example:
    ppqueue pq - prints all elements, size and capacity of pq
end



#
# std::bitset
#

define pbitset
    if $argc == 0
        help pbitset
    else
        p /t $arg0._M_w
    end
end

document pbitset
    Prints std::bitset&lt;n&gt; information.
    Syntax: pbitset &lt;bitset&gt;: Prints all bits in bitset
    Example:
    pbitset b - prints all bits in b
end



#
# std::string
#

define pstring
    if $argc == 0
        help pstring
    else
        printf &quot;String \t\t\t= \&quot;%s\&quot;\n&quot;, $arg0._M_data()
        printf &quot;String size/length \t= %u\n&quot;, $arg0._M_rep()._M_length
        printf &quot;String capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity
        printf &quot;String ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount
    end
end

document pstring
    Prints std::string information.
    Syntax: pstring &lt;string&gt;
    Example:
    pstring s - Prints content, size/length, capacity and ref-count of string s
end 

#
# std::wstring
#

define pwstring
    if $argc == 0
        help pwstring
    else
        call printf(&quot;WString \t\t= \&quot;%ls\&quot;\n&quot;, $arg0._M_data())
        printf &quot;WString size/length \t= %u\n&quot;, $arg0._M_rep()._M_length
        printf &quot;WString capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity
        printf &quot;WString ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount
    end
end

document pwstring
    Prints std::wstring information.
    Syntax: pwstring &lt;wstring&gt;
    Example:
    pwstring s - Prints content, size/length, capacity and ref-count of wstring s
end 

#
# C++ related beautifiers (optional)
#

set height 0
set history size 10000
set history filename ~/.gdb_history
set history save on

#退出時不顯示提示信息
set confirm off

#按照派生類型打印對象
set print object on

#打印數組的索引下標
set print array-indexes on

#每行打印一個結構體成員
set print pretty on

set print union on

set print address on 

set print static-members on
set print vtbl on
set print demangle on
set demangle-style gnu-v3
set print sevenbit-strings off
set step-mode on

shell rm -f ./gdb.log
set logging off
set logging file ./gdb.log
set logging on

python
import sys
import os
p = os.path.expanduser('/home/shihyu/.mybin/gdb_8.1/python') 
print(p)
if os.path.exists(p):
    sys.path.insert(0, p)
    from libstdcxx.v6.printers import register_libstdcxx_printers
    register_libstdcxx_printers(None)
end
</code></pre>
<h2 id="100個gdb小技巧"><a class="header" href="#100個gdb小技巧">100個gdb小技巧</a></h2>
<ul>
<li>https://github.com/hellogcc/100-gdb-tips</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb常用指令"><a class="header" href="#gdb常用指令">GDB常用指令</a></h1>
<ul>
<li>GDB dashboard</li>
</ul>
<pre><code class="language-sh">https://github.com/cyrus-and/gdb-dashboard
</code></pre>
<ul>
<li>Gdbinit for OS X, iOS and others - x86, x86_64 and ARM</li>
</ul>
<pre><code class="language-sh">https://github.com/gdbinit/Gdbinit
</code></pre>
<ul>
<li>dotgdb：關於底層調試和反向工程的gdb腳本集</li>
</ul>
<pre><code class="language-sh">https://github.com/dholm/dotgdb
</code></pre>
<h2 id="打印記憶體內容"><a class="header" href="#打印記憶體內容">打印記憶體內容</a></h2>
<p>用gdb查看內存 格式: <code>x /nfu</code> 說明</p>
<pre><code>x 是 examine 的縮寫
n表示要顯示的內存單元的個數
f表示顯示方式, 可取如下值
x 按十六進制格式顯示變量。
d 按十進制格式顯示變量。
u 按十進制格式顯示無符號整型。
o 按八進制格式顯示變量。
t 按二進制格式顯示變量。
a 按十六進制格式顯示變量。
i 指令地址格式
c 按字符格式顯示變量。
f 按浮點數格式顯示變量。
u表示一個地址單元的長度
b表示單字節，
h表示雙字節，
w表示四字節，
g表示八字節

Format letters are 
o(octal), 
x(hex), 
d(decimal), 
u(unsigned decimal),
t(binary), 
f(float), 
a(address), 
i(instruction), 
c(char) and 
s(string).
Size letters are 
b(byte), 
h(halfword), 
w(word), 
g(giant, 8 bytes)
</code></pre>
<h2 id="舉例"><a class="header" href="#舉例">舉例</a></h2>
<pre><code class="language-sh">x/3uh buf 
表示從內存地址buf讀取內容，
h表示以雙字節為一個單位，
3表示三個單位，
u表示按十六進制顯示
例子：
n是個局部變量
Breakpoint 1, main (argc=1, argv=0xbffff3a4) at calc.c:7
7        int n = atoi(argv[1]);
(gdb) print &amp;n
$1 = (int *) 0xbffff2ec
(gdb) x 0xbffff2ec
0xbffff2ec:    0x00282ff4
(gdb) print * (int *) 0xbffff2ec
$2 = 2633716
(gdb) x /4xw 0xbffff2ec
0xbffff2ec:    0x00282ff4    0x080484e0    0x00000000    0xbffff378
(gdb) x /4dw 0xbffff2ec
0xbffff2ec:    2633716    134513888    0    -1073745032
(gdb)
</code></pre>
<h2 id="跳轉執行"><a class="header" href="#跳轉執行">跳轉執行</a></h2>
<p>一般來說，被調試程序會按照程序代碼的運行順序依次執行。 GDB提供了亂序執行的功能，也就是說，GDB可以修改程序的執行順序，可以讓程序執行隨意跳躍。 這個功能可以由GDB的jump命令來完：</p>
<pre><code class="language-sh">jump &lt;linespec&gt;
</code></pre>
<p>指定下一條語句的運行點。可以是文件的行號，可以是file:line格式，可以是+num這種偏移量格式。 表式著下一條運行語句從哪裡開始。</p>
<pre><code class="language-sh">jump &lt;address&gt;
這裡的 &lt;address&gt; 是代碼行的內存地址。
</code></pre>
<p>注意，jump命令不會改變當前的程序棧中的內容，所以，當你從一個函數跳到另一個函數時，當函數運行完返回時進行彈棧操作時必然會發生錯誤，可能結果還是非常奇怪的，甚至於產生程序Core Dump。 所以最好是同一個函數中進行跳轉。</p>
<p>熟悉彙編的人都知道，程序運行時，有一個寄存器用於保存當前<code>。 所以，jump命令也就是改變了這個寄存器中的值。 於是，你可以使用「set $pc」來更改跳轉執行的地址。如：</code>set $pc = 0x485`</p>
<ul>
<li>以便快速找出所有線程都在做。</li>
</ul>
<pre><code class="language-sh">thread apply all bt或 thread apply all print $pc
</code></pre>
<ul>
<li>不斷測試，之後會出現segmentation fault(core dump)</li>
</ul>
<pre><code class="language-sh">while ./bug_program ; do echo OK; done
</code></pre>
<hr />
<h2 id="高級技巧"><a class="header" href="#高級技巧">高級技巧</a></h2>
<p>一些不太廣為人知的技巧...</p>
<p>加載獨立的調試信息</p>
<p>gdb調試的時候可以從單獨的符號文件中加載調試信息。</p>
<pre><code class="language-sh">(gdb) exec-file test
(gdb) symbol-file test.debug
</code></pre>
<p>test是移除了調試信息的可執行文件, test.debug是被移除後單獨存儲的調試信息。參考stackoverflow上的一個問題，可以如下分離調試信息:</p>
<h3 id="編譯程序帶調試信息-g"><a class="header" href="#編譯程序帶調試信息-g">編譯程序，帶調試信息(-g)</a></h3>
<pre><code class="language-sh">gcc -g -o test main.c
```sh
### 拷貝調試信息到test.debug
</code></pre>
<p>objcopy --only-keep-debug test test.debug</p>
<pre><code>### 移除test中的調試信息
```sh
strip --strip-debug --strip-unneeded test
</code></pre>
<h3 id="然後啟動gdb"><a class="header" href="#然後啟動gdb">然後啟動gdb</a></h3>
<pre><code class="language-sh">gdb -s test.debug -e test
</code></pre>
<h3 id="或這樣啟動gdb"><a class="header" href="#或這樣啟動gdb">或這樣啟動gdb</a></h3>
<pre><code class="language-sh">gdb
(gdb) exec-file test
(gdb) symbol-file test.debug
</code></pre>
<p>分離出的調試信息test.debug還可以鏈接回可執行文件test中</p>
<pre><code class="language-sh">objcopy --add-gnu-debuglink test.debug test
</code></pre>
<p>然後就可以正常用addr2line等需要讀取調試信息的程序了</p>
<pre><code class="language-sh">addr2line -e test 0x401c23
</code></pre>
<p>更多內容可閱讀GDB: Debugging Information in Separate Files。</p>
<p>在內存和文件系統之間拷貝數據</p>
<ul>
<li>
<p>將內存數據拷貝到文件裡</p>
<pre><code class="language-sh">dump binary value file_name variable_name
dump binary memory file_name begin_addr end_addr
</code></pre>
</li>
<li>
<p>改變內存數據</p>
<pre><code>使用set命令
</code></pre>
</li>
</ul>
<h3 id="1-啟動"><a class="header" href="#1-啟動">1. 啟動</a></h3>
<pre><code class="language-sh">gdb 應用程序名
gdb 應用程序名 core文件名
gdb 應用程序名 pid
gdb --args 應用程序名 應用程序的運行參數
</code></pre>
<h3 id="幫助"><a class="header" href="#幫助">幫助:</a></h3>
<pre><code class="language-sh">help 顯示幫助
info 顯示程序狀態
set 修改
show 顯示gdb狀態
</code></pre>
<h3 id="運行及運行環境設置"><a class="header" href="#運行及運行環境設置">運行及運行環境設置:</a></h3>
<pre><code class="language-sh">set args # 設置運行參數
show args # 顯示運行參數

set env 變量名 = 值 # 設置環境變量
unset env [變量名] # 取消環境變量
show env [變量名] # 顯示環境變量

path 目錄名 # 把目錄添加到查找路徑中
show paths # 顯示當前查找路徑

cd 目錄 # 切換工作目錄
pwd # 顯示當前工作目錄

tty /dev/pts/1 # 修改程序的輸入輸出到指定的tty
set inferior-tty /dev/pts/1 # 修改程序的輸出到指定的tty
show inferior-tty
show tty

run 參數 # 運行
start 參數 # 開始運行，但是會在main函數停止
attach pid
detach

kill # 退出
Ctrl-C # 中斷(SIGINT)
Ctrl-]
</code></pre>
<h3 id="線程操作"><a class="header" href="#線程操作">線程操作:</a></h3>
<pre><code class="language-sh">info threads # 查看所有線程信息
thread 線程id # 切換到指定線程
thread apply [threadno | all ] 參數 # 對所有線程都應用某個命令
</code></pre>
<h3 id="子進程調試"><a class="header" href="#子進程調試">子進程調試:</a></h3>
<pre><code class="language-sh">set follow-fork-mode child|parent # fork後，需要跟蹤誰
show follow-fork-mode
set detach-on-flow on|off # fork後，需要兩個都跟蹤嗎

info forks # 顯示所有進程信息
fork 進程id # 切換到某個進程
detach-fork 進程id # 不再跟蹤某個進程
delete fork 進程id # kill某個進程並停止對它的跟蹤
</code></pre>
<h3 id="檢查點"><a class="header" href="#檢查點">檢查點:</a></h3>
<pre><code class="language-sh">checkpoint/restart
</code></pre>
<h3 id="查看停止原因"><a class="header" href="#查看停止原因">查看停止原因:</a></h3>
<pre><code class="language-c">info program
</code></pre>
<h3 id="斷點breakpoint-程序運行到某處就會中斷"><a class="header" href="#斷點breakpoint-程序運行到某處就會中斷">斷點(breakpoint): 程序運行到某處就會中斷</a></h3>
<pre><code class="language-sh">break(b) 行號|函數名|程序地址 | +/-offset | filenam:func [if 條件] # 在指定位置設置斷點
tbreak ... # 與break相似，只是設置一次斷點
hbreak ... # 與break相似，只是設置硬件斷點，需要硬件支持
thbreak ... # 與break相似，只是設置一次性硬件斷點，需要硬件支持
rbreak 正則表達式 # 給一批滿足條件的函數打上斷點
info break [斷點號] # 查看某個斷點或所有斷點信息

set breadpoint pending auto|on|off # 查看如果斷點位置沒有找到時行為
show breakpoint pending
</code></pre>
<h3 id="觀察點watchpoint-表達式的值修改時會被中斷"><a class="header" href="#觀察點watchpoint-表達式的值修改時會被中斷">觀察點(watchpoint): 表達式的值修改時會被中斷</a></h3>
<pre><code class="language-sh">watch 表達式 # 當表達式被寫入，並且值被改變時中斷
rwatch 表達式 # 當表達式被讀時中斷
awatch 表達式 # 當表達式被讀或寫時中斷
info watchpoints

set can-use-hw-watchpoints 值 # 設置使用的硬件觀察點的數
show can-use-hw-watchpoints

rwatch與awatch需要有硬件支持，另外如果是對局部變量使用watchpoint，那退出作用域時觀察點會自動被刪除
另外在多線程情況下，gdb的watchpoint只對一個線程有效
</code></pre>
<h3 id="捕獲點catchpoint-程序發生某個事件時停止如產生異常時"><a class="header" href="#捕獲點catchpoint-程序發生某個事件時停止如產生異常時">捕獲點(catchpoint): 程序發生某個事件時停止，如產生異常時</a></h3>
<pre><code class="language-sh">catch 事件名
事件包括:
throw # 產生c++異常
catch # 捕獲到c++異常
exec/fork/vfork # 一個exec/fork/vfork函數調用,只對HP-UX
load/unload [庫名] # 加載/卸載共享庫事件，對只HP-UX
tcatch 事件名 # 一次性catch
info break
</code></pre>
<h3 id="斷點操作"><a class="header" href="#斷點操作">斷點操作:</a></h3>
<pre><code class="language-sh">clear [函數名|行號] # 刪除斷點，無參數表示刪衛當前位置
delete [斷點號] # 刪除斷點，無參數表示刪所有斷點
disable [斷點號]
enable [斷點號]


condition 斷點號 條件 # 增加斷點條件
condition 斷點號 # 刪除斷點條件

ignore 斷點號 數目 # 忽略斷點n次

commands 斷點號 # 當某個斷點中斷時打印條件
條件
end
</code></pre>
<ul>
<li>下面是一個例子,可以一直打印當前的X值：</li>
</ul>
<pre><code class="language-sh">commands 3
printf &quot;X:%d\n&quot;,x
cont
end
</code></pre>
<h3 id="斷點後操作"><a class="header" href="#斷點後操作">斷點後操作:</a></h3>
<pre><code class="language-sh">continue(c) [忽略次數] # 繼續執行，[忽略前面n次中斷]
fg [忽略次數] # 繼續執行，[忽略前面n次中斷]

step(s) [n步] # 步進,重複n次
next(n) [n步] # 前進,重複n次

finish # 完成當前函數調用，一直執行到返回處，並打印返回值

until(u) [位置] # 一直執行到當前行或指定位置，或是當前函數返回
advance 位置 # 前面到指定位置，如果當前函數返回則停止,與until類似

stepi(si) [n步] # 精確的只執行一個彙編指令,重複n次
nexti(ni) [n步] # 精確的只執行一個彙編指令,碰到函數跳過,重複n次

set step-mode on|off # on時,如果函數沒有調試信息也跟進
show step-mode
</code></pre>
<h3 id="信號"><a class="header" href="#信號">信號:</a></h3>
<pre><code class="language-sh">info signals # 列出所有信號的處理方式
info handle # 同上

handle 信號 方式 # 改變當前處理某個信號的方式
方式包括:
nostop # 當信號發生時不停止，只打印信號曾經發生過
stop # 停止並打印信號
print # 信號發生時打印
noprint # 信號發生時不打印
pass/noignore # gdb充許應用程序看到這個信號
nopass/ignore # gdb不充許應用程序看到這個信號
</code></pre>
<h3 id="線程斷點"><a class="header" href="#線程斷點">線程斷點:</a></h3>
<pre><code class="language-sh">break 行號信息 thread 線程號 [if 條件] # 只在某個線程內加斷點
</code></pre>
<h3 id="線程調度鎖"><a class="header" href="#線程調度鎖">線程調度鎖:</a></h3>
<pre><code class="language-sh">set scheduler-locking on|off # off時所有線程都可以得到調度,on時只有當前
show scheduler-locking
</code></pre>
<h3 id="幀"><a class="header" href="#幀">幀:</a></h3>
<pre><code class="language-sh">frame(f) [幀號] # 不帶參數時顯示所有幀信息，帶參數時切換到指定幀
frame 地址 # 切換到指定地址的幀
up [n] # 向上n幀
down [n] # 向下n幀

select-frame 幀號 # 切換到指定幀並且不打印被轉換到的幀的信息
up-silently [n] # 向上n幀,不顯示幀信息
down-silently [n] # 向下n幀,不顯示幀信息
</code></pre>
<h3 id="調用鏈"><a class="header" href="#調用鏈">調用鏈:</a></h3>
<pre><code class="language-sh">backtrace(bt) [n|-n|full] # 顯示當前調用鏈,n限制顯示的數目,-n表示顯示後n個,n表示顯示前n個，full的話還會顯示變量信息
使用 thread apply all bt 就可以顯示所有線程的調用信息

set backtrace past-main on|off
show backtrace past-main

set backtrace past-entry on|off
show backtrace past-entry

set backtrace limit n # 限制調用信息的顯示層數
show backtrace limit
</code></pre>
<h3 id="顯示幀信息"><a class="header" href="#顯示幀信息">顯示幀信息:</a></h3>
<pre><code class="language-sh">info frame # 顯示當前幀信息
info frame addr # 顯示指定地址的幀信息
info args # 顯示幀的參數
info locals # 顯示局部變量信息
info catch # 顯示本幀異常信息
</code></pre>
<h3 id="顯示行號"><a class="header" href="#顯示行號">顯示行號:</a></h3>
<pre><code class="language-sh">list(l) [行號|函數|文件:行號] # 顯示指定位置的信息,無參數為當前位置
list - # 顯示當前行之前的信息

list first,last # 從frist顯示到last行
list ,last # 從當前行顯示到last行
list frist, # 從指定行顯示
list + # 顯示上次list後顯示的內容
list - # 顯示上次list前面的內容

在上面，first和last可以是下面類型:
行號
+偏移
-偏移
文件名:行號
函數名
函數名:行號

set listsize n # 修改每次顯示的行數
show listsize
</code></pre>
<h3 id="編輯"><a class="header" href="#編輯">編輯:</a></h3>
<pre><code class="language-sh">edit [行號|函數|函數名:行號|文件名:函數名] # 編輯指定位置
</code></pre>
<h3 id="查找"><a class="header" href="#查找">查找:</a></h3>
<pre><code class="language-sh">search 表示式 # 向前查找表達式
reverse-search 表示式 # 向後查找表達式
</code></pre>
<h3 id="指定源碼目錄"><a class="header" href="#指定源碼目錄">指定源碼目錄:</a></h3>
<pre><code class="language-sh">directory(dir) [目錄名] # 指定源文件查找目錄
show directories
</code></pre>
<h3 id="源碼與機器碼"><a class="header" href="#源碼與機器碼">源碼與機器碼：</a></h3>
<pre><code class="language-sh">info line [函數名|行號] # 顯示指定位置對應的機器碼地址範圍
disassemble [函數名 | 起始地址 結束地址] # 對指定範圍進行反彙編
set disassembly-flavor att|intel # 指定彙編代碼形式
show disassembly-flavor
</code></pre>
<h3 id="查看數據"><a class="header" href="#查看數據">查看數據:</a></h3>
<pre><code class="language-sh">ptype 表達式 # 查看某個表達式的類型

print [/f] [表達式] # 按格式查看錶達式內容,/f是格式化

set print address on|off # 打印時是不是顯示地址信息
show print address

set print symbol-filename on|off # 是不是顯示符號所在文件等信息
show print symbol-filename

set print array on | off # 是不是打印數組
show print array

set print array index on | off # 是不是打印下標
show print array index

...

表達式可以用下面的修飾符:
var@n # 表示把var當成長度為n的數組
filename::var # 表示打印某個函數內的變量,filename可以換成其它範圍符如文件名
{type} var # 表示把var當成type類型
</code></pre>
<h3 id="輸出格式"><a class="header" href="#輸出格式">輸出格式:</a></h3>
<pre><code class="language-sh">x # 16進制
d # 10進制
u # 無符號
o # 8進制
t # 2進制
a # 地址
c # 字符
f # 浮點
</code></pre>
<h3 id="查看內存"><a class="header" href="#查看內存">查看內存:</a></h3>
<pre><code class="language-sh">x /nfu 地址 # 查看內存
n 重複n次
f 顯示格式,為print使用的格式
u 每個單元的大小,為
b byte
h 2 byte
w 4 byte
g 8 byte
</code></pre>
<h3 id="自動顯示"><a class="header" href="#自動顯示">自動顯示:</a></h3>
<pre><code class="language-sh">display [/fmt] 表達式 # 每次停止時都會顯示錶達式,fmt與print的格式一樣,如果是內存地址，那fmt可像 x的參數一樣
undisplay 顯示編號
delete display 顯示編號 # 這兩個都是刪附某個顯示

disable display 顯示編號 # 禁止某個顯示
enable display 顯示編號 # 重顯示
display # 顯示當前顯示內容
info display # 查看所有display項
</code></pre>
<h3 id="查看變量歷史"><a class="header" href="#查看變量歷史">查看變量歷史：</a></h3>
<pre><code class="language-sh">show values 變量名 [n] # 顯示變量的上次顯示歷史,顯示n條
show values 變量名 + # 繼續上次顯示內容
</code></pre>
<h3 id="便利變量-聲明變量的別名以方便使用"><a class="header" href="#便利變量-聲明變量的別名以方便使用">便利變量: (聲明變量的別名以方便使用)</a></h3>
<pre><code class="language-sh">set $foo = *object_ptr # 聲明foo為object_ptr的便利變量
init-if-undefined $var = expression # 如果var還未定義則賦值
show convenience
</code></pre>
<h3 id="內部便利變量"><a class="header" href="#內部便利變量">內部便利變量：</a></h3>
<pre><code class="language-sh">$_ 上次x查看的地址
$__
$_exitcode 程序垢退出碼
</code></pre>
<h3 id="寄存器"><a class="header" href="#寄存器">寄存器:</a></h3>
<pre><code class="language-sh">into registers # 除了浮點寄存器外所有寄存器
info all-registers # 所有寄存器
into registers 寄存器名 # 指定寄存器內容
info float # 查看浮點寄存器狀態
info vector # 查看向量寄存器狀態

gdb為一些內部寄存器定義了名字，如$pc(指令),$sp(棧指針),$fp(棧幀),$ps(程序狀態)
p /x $pc # 查看pc寄存器當前值
x /i $pc # 查看要執行的下一條指令
set $sp += 4 # 移動棧指針
</code></pre>
<h3 id="內核中信息"><a class="header" href="#內核中信息">內核中信息:</a></h3>
<pre><code class="language-sh">info udot # 查看內核中user struct信息
info auxv # 顯示auxv內容(auxv是協助程序啟動的環境變量的)
</code></pre>
<h3 id="內存區域限制"><a class="header" href="#內存區域限制">內存區域限制:</a></h3>
<pre><code class="language-sh">mem 起始地址 結構地址 屬性 # 對[地始地址,結構地址)區域內存進行保護，如果結構地址為0表示地址最大值0xffffffff
delete mem 編號 # 刪除一個內存保護
disable mem 編號 # 禁止一個內存保護
enable mem 編號 # 打開一個內存保護
info mem # 顯示所有內存保護信息
</code></pre>
<h3 id="保護的屬性包括"><a class="header" href="#保護的屬性包括">保護的屬性包括：</a></h3>
<pre><code class="language-sh">1. 內存訪問模式: ro | wo |rw
2. 內存訪問大小: 8 | 16 | 32 | 64 如果不限制，表示可按任意大小訪問
3. 數據緩存: cache | nocache cache表示充許gdb緩存目標內存
</code></pre>
<h3 id="內存複製到從文件"><a class="header" href="#內存複製到從文件">內存複製到/從文件:</a></h3>
<pre><code class="language-sh">dump [格式] memory 文件名 起始地址 結構地址 # 把指定內存段寫到文件
dump [格式] value 文件名 表達式 # 把指定值寫到文件
格式包括:
binary 原始二進制格式
ihex intel 16進制格式
srec S-recored格式
tekhex tektronix 16進制格式

append [binary] memory 文件名 起始地址 結構地址 # 按2進制追加到文件
append [binary] value 文件名 表達式 # 按2進制追加到文件

restore 文件名 [binary] bias 起始地址 結構地址 # 恢復文件中內容到內存.如果文件內容是原始二進制，需要指定binary參數，不然會gdb自動識別文件格式
</code></pre>
<h3 id="產生core-dump文件"><a class="header" href="#產生core-dump文件">產生core dump文件</a></h3>
<pre><code class="language-sh">gcore [文件名] # 產生core dump文件
</code></pre>
<h3 id="字符集"><a class="header" href="#字符集">字符集:</a></h3>
<pre><code class="language-sh">set target-charset 字符集 # 聲明目標機器的locale,如gdbserver所在機器
set host-charset 字符集 # 聲明本機的locale
set charset 字符集 # 聲明目標機和本機的locale
show charset
show host-charset
show target-charset
</code></pre>
<h3 id="緩存遠程目標的數據為提高性能可以使用數據緩存不過gdb不知道volatile變量緩存可能會顯示不正確的結構"><a class="header" href="#緩存遠程目標的數據為提高性能可以使用數據緩存不過gdb不知道volatile變量緩存可能會顯示不正確的結構">緩存遠程目標的數據:為提高性能可以使用數據緩存，不過gdb不知道volatile變量，緩存可能會顯示不正確的結構</a></h3>
<pre><code class="language-sh">set remotecache on | off
show remotecache
info dcache # 顯示數據緩存的性能
</code></pre>
<h3 id="c預處理宏"><a class="header" href="#c預處理宏">C預處理宏:</a></h3>
<pre><code class="language-sh">macro expand(exp) 表達式 # 顯示宏展開結果
macro expand-once(expl) 表達式 # 顯示宏一次展開結果
macro info 宏名 # 查看宏定義
</code></pre>
<h3 id="追蹤tracepoint-就是在某個點設置採樣信息每次經過這個點時只執行已經定義的採樣動作但並不停止最後再根據採樣結果進行分析"><a class="header" href="#追蹤tracepoint-就是在某個點設置採樣信息每次經過這個點時只執行已經定義的採樣動作但並不停止最後再根據採樣結果進行分析">追蹤(tracepoint): 就是在某個點設置採樣信息，每次經過這個點時只執行已經定義的採樣動作但並不停止，最後再根據採樣結果進行分析。</a></h3>
<h3 id="採樣點定義"><a class="header" href="#採樣點定義">採樣點定義:</a></h3>
<pre><code class="language-sh">trace 位置 # 定義採樣點
info tracepoints # 查看採樣點列表
delete trace 採樣點編號 # 刪除採傑點
disable trace 採樣點編號 # 禁止採傑點
enable trace 採樣點編號 # 使用採傑點
passcount 採樣點編號 [n] # 當通過採樣點 n次後停止,不指定n則在下一個斷點停止
</code></pre>
<h3 id="預定義動作預定義動作以actions開始後面是一系列的動作"><a class="header" href="#預定義動作預定義動作以actions開始後面是一系列的動作">預定義動作：預定義動作以actions開始,後面是一系列的動作</a></h3>
<pre><code class="language-sh">actions [num] # 對採樣點num定義動作
行為:
collect 表達式 # 採樣表達式信息
一些表達式有特殊意義，如$regs(所有寄存器),$args(所有函數參數),$locals(所有局部變量)
while-steping n # 當執行第n次時的動作,下面跟自己的collect操作
</code></pre>
<h3 id="採樣控制"><a class="header" href="#採樣控制">採樣控制:</a></h3>
<pre><code class="language-sh">tstart # 開始採樣
tstop # 停止採樣
tstatus # 顯示當前採樣的數據
</code></pre>
<h3 id="使用收集到的數據"><a class="header" href="#使用收集到的數據">使用收集到的數據:</a></h3>
<pre><code class="language-sh">tfind start # 查找第一個記錄
tfind end | none # 停止查找
tfind # 查找下一個記錄
tfind - # 查找上一個記錄
tfind tracepoint N # 查找 追蹤編號為N 的下一個記錄
tfind pc 地址 # 查找代碼在指定地址的下一個記錄
tfind range 起始,結束
tfind outside 起始，結構
tfind line [文件名:]行號

tdump # 顯示當前記錄中追蹤信息
save-tracepoints 文件名 # 保存追蹤信息到指定文件,後面使用source命令讀
</code></pre>
<h3 id="追蹤中的便利變量"><a class="header" href="#追蹤中的便利變量">追蹤中的便利變量:</a></h3>
<pre><code class="language-sh">$trace_frame # 當前幀編號, -1表示沒有, INT
$tracepoint # 當前追蹤,INT
$trace_line # 位置 INT
$trace_file # 追蹤文件 string, 需要使用output輸出，不應用printf
$trace_func # 函數名 string
</code></pre>
<h3 id="覆蓋技術overray-用於調試過大的文件"><a class="header" href="#覆蓋技術overray-用於調試過大的文件">覆蓋技術(overray): 用於調試過大的文件</a></h3>
<h3 id="gdb文件"><a class="header" href="#gdb文件">gdb文件:</a></h3>
<pre><code class="language-sh">file 文件名 # 加載文件,此文件為可執行文件，並且從這裡讀取符號
core 文件名 # 加載core dump文件
exec-file 文件名 # 加載可執行文件
symbol-file 文件名 # 加載符號文件
add-symbol-file 文件名 地址 # 加載其它符號文件到指定地址
add-symbol-file-from-memory 地址 # 從指定地址中加載符號
add-share-symbol-files 庫文件 # 只適用於cygwin
session 段 地址 # 修改段信息
info files | target # 打開當前目標信息
maint info sections # 查看程序段信息
set truct-readonly-sections on | off # 加快速度
show truct-readonly-sections

set auto-solib-add on | off # 修改自動加載動態庫的模式
show auto-solib-add

info share # 打印當前加載的共享庫的地址信息
share [正則表達式] # 從符合的文件中加載共享庫的正則表達式

set stop-on-solib-events on | off # 設置當加載共享庫時是不是要停止
show stop-on-solib-events

set solib-absolute-prefix 路徑 # 設置共享庫的絕對路矩，當加載共享庫時會以此路徑下查找(類似chroot)
show solib-absolute-prefix

set solib-search-path 路徑 # 如果solib-absolute-prefix查找失敗，那將使用這個目錄查找共享庫
show solib-search-path
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="jemalloc源碼分析之分析工具"><a class="header" href="#jemalloc源碼分析之分析工具">jemalloc源碼分析之分析工具</a></h2>
<h3 id="簡介"><a class="header" href="#簡介">簡介</a></h3>
<p>jemalloc同malloc一樣, 是一種內存管理的實現.</p>
<p>如果使用gcc編譯軟件, 默認使用的是glic實現的ptmalloc算法. 而同樣的算法有google的C++實現tcmalloc算法, 而今天我們分析的是facebook使用C語言實現的jemalloc算法.</p>
<p>tcmalloc同jemalloc一樣都是對多線程多核友好的分配算法, 被各種語言借鑑來實現自身的內存管理.</p>
<h3 id="實現原理"><a class="header" href="#實現原理">實現原理</a></h3>
<p>如果使用C語言進行內存分配, 我們會調用malloc函數, 而jemalloc就是通過malloc的hook機制實現的.</p>
<p><a href="http://stackoverflow.com/questions/262439/create-a-wrapper-function-for-malloc-and-free-in-c">如何實現自定義的malloc函數</a> 這篇文章有介紹如何覆蓋或重寫默認的malloc函數.</p>
<p><a href="http://www.gnu.org/savannah-checkouts/gnu/libc/manual/html_node/Hooks-for-Malloc.html">GNU基於hook機制實現自定義的的malloc函數</a>, 具體就是通過覆蓋__malloc_hook 函數指標來實現的.</p>
<p>在jemalloc中我們能找到類似的代碼:</p>
<p>jemalloc.c:1830</p>
<pre><code class="language-c">/*
 * Begin non-standard override functions.
 */

#ifdef JEMALLOC_OVERRIDE_MEMALIGN
JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
void JEMALLOC_NOTHROW*
JEMALLOC_ATTR(malloc)
je_memalign(size_t alignment, size_t size)
{
    void* ret JEMALLOC_CC_SILENCE_INIT(NULL);

    if (unlikely(imemalign(&amp;ret, alignment, size, 1) != 0)) {
        ret = NULL;
    }

    return (ret);
}
#endif

#ifdef JEMALLOC_OVERRIDE_VALLOC
JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
void JEMALLOC_NOTHROW*
JEMALLOC_ATTR(malloc)
je_valloc(size_t size)
{
    void* ret JEMALLOC_CC_SILENCE_INIT(NULL);

    if (unlikely(imemalign(&amp;ret, PAGE, size, 1) != 0)) {
        ret = NULL;
    }

    return (ret);
}
#endif

/*
 * is_malloc(je_malloc) is some macro magic to detect if jemalloc_defs.h has
 * #define je_malloc malloc
 */
#define malloc_is_malloc 1
#define is_malloc_(a) malloc_is_ ## a
#define is_malloc(a) is_malloc_(a)

#if ((is_malloc(je_malloc) == 1) &amp;&amp; defined(JEMALLOC_GLIBC_MALLOC_HOOK))
/*
 * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible
 * to inconsistently reference libc's malloc(3)-compatible functions
 * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).
 *
 * These definitions interpose hooks in glibc.  The functions are actually
 * passed an extra argument for the caller return address, which will be
 * ignored.
 */
JEMALLOC_EXPORT void (*__free_hook)(void* ptr) = je_free;
JEMALLOC_EXPORT void* (*__malloc_hook)(size_t size) = je_malloc;
JEMALLOC_EXPORT void* (*__realloc_hook)(void* ptr, size_t size) = je_realloc;
# ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK
JEMALLOC_EXPORT void* (*__memalign_hook)(size_t alignment, size_t size) =
    je_memalign;
# endif
#endif

/*
 * End non-standard override functions.
 */
</code></pre>
<p>如果我們在自己的函數調用malloc就會被je_malloc攔截. 例如下面的例子:</p>
<pre><code class="language-c">int main()
{
    void* ptr = malloc(10);
    free(ptr);
    return 0;
}
</code></pre>
<p>整個過程是</p>
<pre><code>-&gt; main
-&gt; malloc -&gt; je_malloc(mmap等系統調用分配內存) -&gt; malloc結束
-&gt; free -&gt; jeje_free(munmap等系統調用釋放內存) -&gt; free結束
-&gt; main結束
</code></pre>
<p>上面是當我們程序調用malloc函數時執行的過程, 實際上在jemalloc載入的時候, 就已經進行了一些初始化操作.</p>
<p>具體是在jemalloc_constructor函數.</p>
<p>jemalloc.c:2576</p>
<pre><code class="language-c">#ifndef JEMALLOC_JET
JEMALLOC_ATTR(constructor)
static void
jemalloc_constructor(void)
{

    malloc_init();
}
#endif

jemalloc_macros.h.in:67
#  define JEMALLOC_ATTR(s) __attribute__((s))
</code></pre>
<p>通過這篇文章 <a href="http://stackoverflow.com/questions/1681145/how-to-initialize-a-shared-library-on-linux">如何在共享庫載入時進行初始化操作</a> 知道這是gcc的一個特性.</p>
<p>後面我們將結合&quot;call graph&quot;調用圖分別分析這兩個過程.</p>
<h3 id="開始調試"><a class="header" href="#開始調試">開始調試</a></h3>
<p>這節主要介紹下載編譯jemalloc, 編寫測試代碼, 使用callgrind生成調用圖, 使用gdb調試jemalloc.</p>
<p>jemalloc當前託管在github上</p>
<pre><code>git clone git@github.com:jemalloc/jemalloc.git
./autogen.sh
./configure --enable-debug
make dist
make
make install
</code></pre>
<p>然後使用ide添加jemalloc項目, 主要作用是方便查看源代碼, 在gdb中查看源代碼實在不太方便, 而且gdb-tui雖然提供了可視化界面, 但是偶爾會出現花屏的情況.</p>
<p>這中間可能因為doc文檔找不到的原因安裝失敗, 根據<a href="https://github.com/jemalloc/jemalloc/issues/231">issue231</a>, 將最後兩步換成</p>
<pre><code>make &amp;&amp; make install_bin install_include install_lib
</code></pre>
<p>即可.</p>
<p>然後編寫我們的調試代碼:</p>
<p>a.c文件:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

int func_long_name_a();
int func_long_name_b();
int func_long_name_c();

int func_long_name_a()
{
    printf(&quot;func_long_name_a called\n&quot;);
    func_long_name_b();
    return 0;
}

int func_long_name_b()
{
    printf(&quot;func_long_name_b called\n&quot;);
    func_long_name_c();
    return 0;
}

int func_long_name_c()
{
    printf(&quot;func_long_name_c called\n&quot;);
    int sizeArr[] = {1, 4095, 4096, 8192, 8193, 4 * 1024 * 1024, 10 * 1024 * 1024};
    int i;

    for (i = 0; i &lt; 7; ++i) {
        void* p = malloc(sizeArr[i]);
        free(p);
    }

    return 0;
}

int main(int argc, char** argv)
{
    printf(&quot;main called\n&quot;);
    func_long_name_a();
    func_long_name_c();
    printf(&quot;main exit\n&quot;);
    return 0;
}
</code></pre>
<p>然後編寫一個腳本來實現編譯及調用圖的生成</p>
<p>gen.sh文件</p>
<pre><code class="language-shell">#!/bin/bash

JEMALLOC_PATH=/home/shihyu/github/jemalloc
gcc -g -ljemalloc -o a -I${JEMALLOC_PATH}/include -L${JEMALLOC_PATH}/lib a.c
valgrind --tool=callgrind ./a
gprof2dot -f callgrind -n 0 callgrind.out.* | dot -Tsvg -o a.svg
date=`date '+%Y%m%d%H%i%s'`
mv a.svg &quot;$(date '+%Y-%m-%d_%H:%M:%S').svg&quot;
#rm -f callgrind.out.* .DS_Store a a.out
rm -f callgrind.out.* .DS_Store a.out
echo
ls -al .
</code></pre>
<p>中間需要安裝一些特別的軟件, 比如valgrind, gprof2dot, dot等, 這些都可以在網上找到相應的安裝方法.</p>
<p>最後生成我們的<a href="https://yaoguais.github.io/images/jemalloc_call_graph.svg">jemalloc_call_graph.svg</a>調用圖文件.</p>
<p>在gen.sh中我們並沒有刪除可執行文件&quot;a&quot;, 下面我就使用gdb來調試該文件.</p>
<pre><code class="language-gdb"># gdb a
# b jemalloc_constructor
# b src/jemalloc.c:1443
# b src/jemalloc.c:1811
# r
</code></pre>
<p>其中jemalloc_constructor是jemalloc共享庫載入時的入口.</p>
<p>src/jemalloc.c:1443是je_malloc函數實現的地方.</p>
<p>src/jemalloc.c:1811是je_free函數實現的地方.</p>
<p>可根據自己的jemalloc版本找到兩個函數的行數做出調整.</p>
<p>執行r後, gdb就停在了jemalloc_constructor函數處.</p>
<p>關於gdb的使用, 也很多, 這裡也有<a href="http://mingxinglai.com/cn/2013/07/gdbtui/">關於gdb可視化界面gdb-tui的使用</a>.</p>
<p>其中在tui模式和傳統模式切換的快捷鍵是ctrl+x接ctrl+a.</p>
<h3 id="總結"><a class="header" href="#總結">總結</a></h3>
<p>這篇文章主要介紹瞭如何調試jemalloc, 是分析jemalloc的準備工作, 也是分析其他開源c程序的普遍方法.</p>
<p>首先使用valgrind+dot打印函數調用圖, 找到函數執行的流程. 然後分析基礎的數據結構與其附屬的操作, 快速明白各種變量會有怎樣的轉換. 最後順著調用圖, 分析各個函數的實現, 以及各種結構體之間的關系. 至此, 所有的源代碼幾乎查看完畢, 一個軟件也分析完畢.</p>
<hr />
<h2 id="使用jemalloc來對cc程序進行內存管理"><a class="header" href="#使用jemalloc來對cc程序進行內存管理">使用jemalloc來對c，c++程序進行內存管理</a></h2>
<pre><code class="language-sh">git clone https://github.com/jemalloc/jemalloc

cd jemalloc

注意：這一步確定要把jemalloc的函數編譯成哪種形式，比如下面的配置就會把分配內存的函數編譯成je_malloc的形式，把calloc編譯成je_calloc等等。這樣就不會和系統的libc的分配函數malloc沖突，因為若不指定該選項默認編譯的分配函數是malloc。

 ./configure --enable-debug --with-jemalloc-prefix=je_

make -j8
</code></pre>
<h2 id="使用jemalloc"><a class="header" href="#使用jemalloc">使用jemalloc</a></h2>
<pre><code class="language-sh">mkdir jem_test
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;jemalloc/jemalloc.h&gt;
//define to jemalloc
#define malloc(size) je_malloc(size)
#define calloc(count,size) je_calloc(count,size)
#define realloc(ptr,size) je_realloc(ptr,size)
#define free(ptr) je_free(ptr)

int main(void)
{
    char* pcon;

    pcon = malloc(10 * sizeof(char));

    if (!pcon) {
        fprintf(stderr, &quot;malloc failed!\n&quot;);
    }

    if (pcon != NULL) {
        free(pcon);
        pcon = NULL;
    }

    fprintf(stderr, &quot;main end!\n&quot;);
    return 0;
}
</code></pre>
<pre><code class="language-makefile">CC=gcc
CFLAGS=-Wall -g
INCLUDES=-I /home/shihyu/github/jemalloc/include
ALLOC_DEP=/home/shihyu/github/jemalloc/lib/libjemalloc.a
ALLOC_LINK=$(ALLOC_DEP) -lpthread -ldl

dtest: dtest.o
	$(CC) $(INCLUDES) $(CFLAGS) -o dtest dtest.o $(ALLOC_LINK)

dtest.o: dtest.c $(ALLOC_DEP)
	$(CC) -c $(INCLUDES) $(CFLAGS) dtest.c

clean:
	rm -f dtest dtest.o
</code></pre>
<pre><code class="language-sh">cgdb dtest 
b je_malloc
r
</code></pre>
<p>http://www.web-lovers.com/c-jemalloc-address-problem.html</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gdb_graphs"><a class="header" href="#gdb_graphs">gdb_graphs</a></h2>
<p>https://github.com/tarun27sh/gdb_graphs</p>
<ul>
<li>~/.gdbinit</li>
</ul>
<pre><code class="language-sh">set pagination off
set print pretty
set logging file ./test.log
set logging enabled on
</code></pre>
<ul>
<li>test.c</li>
</ul>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;


static void func9(void) { printf(&quot;leaf\n&quot;); }

void func8(void) { func9(); }

void func7_1(bool is_true, int *p) { printf(&quot;leaf (is_true=%d, ptr=%p\n&quot;, is_true, p); }
void func7(void) { func8(); }

void func6(void) { func7(); }

void func5_1(const char* str) { printf(&quot;leaf (%s)\n&quot;, str); }
void func5(void) {
    func5_1(&quot;graph me\n&quot;);
    func6();
}

void func4(void) { func5(); }
void func3_1(int a, int b, int c) { printf(&quot;leaf\n&quot;); }
void func3(void) {
    func3_1(rand(), rand(), rand());
    func4();
}

void func2_1(int a, int b) { printf(&quot;leaf (%d, %d)\n&quot;, a, b);}
void func2(void) {
    func2_1(rand(),rand());
    func3();
}
void func1(void) { func2(); }
int main()
{
    srand(time(NULL));
    for(int i=0; i&lt;10; ++i) {
            func1();
    }
        return 0;
}
</code></pre>
<pre><code class="language-sh">gcc -g test.c -o test
gdb ./test

(gdb) rbreak test.c:.

Breakpoint 1 at 0x13a9: file test.c, line 37.
void func1(void);
Breakpoint 2 at 0x137a: file test.c, line 33.
void func2(void);
Breakpoint 3 at 0x134c: file test.c, line 32.
void func2_1(int, int);
Breakpoint 4 at 0x1316: file test.c, line 27.
void func3(void);
Breakpoint 5 at 0x12f2: file test.c, line 26.
void func3_1(int, int, int);
Breakpoint 6 at 0x12e2: file test.c, line 25.
void func4(void);
Breakpoint 7 at 0x12c6: file test.c, line 20.
void func5(void);
Breakpoint 8 at 0x129b: file test.c, line 19.
void func5_1(const char *);
Breakpoint 9 at 0x128b: file test.c, line 17.
void func6(void);
Breakpoint 10 at 0x1243: file test.c, line 11.
void func7(void);
Breakpoint 11 at 0x1210: file test.c, line 10.
void func7_1(_Bool, int *);
Breakpoint 12 at 0x1200: file test.c, line 8.
void func8(void);
Breakpoint 13 at 0x13b9: file test.c, line 39.
int main();
Breakpoint 14 at 0x11e9: file test.c, line 7.
static void func9(void);


(gdb) commands
Type commands for breakpoint(s) 1-14, one per line.
End with a line saying just &quot;end&quot;.
&gt;bt
&gt;c
&gt;end
(gdb) r


Breakpoint 1, func1 () at test.c:37
37	void func1(void) { func2(); }
#0  func1 () at test.c:37
#1  0x00005555555553e4 in main () at test.c:42

Breakpoint 2, func2 () at test.c:33
33	void func2(void) { 
#0  func2 () at test.c:33
#1  0x00005555555553b6 in func1 () at test.c:37
#2  0x00005555555553e4 in main () at test.c:42

Breakpoint 3, func2_1 (a=32767, b=-136364723) at test.c:32
32	void func2_1(int a, int b) { printf(&quot;leaf (%d, %d)\n&quot;, a, b);}
#0  func2_1 (a=32767, b=-136364723) at test.c:32
#1  0x000055555555539c in func2 () at test.c:34
#2  0x00005555555553b6 in func1 () at test.c:37
#3  0x00005555555553e4 in main () at test.c:42
leaf (1316343669, 1810645944)
...

[Inferior 1 (process 672172) exited normally]

Once the program finishes, it would have dumped the logs to the disk in `test.log` 
</code></pre>
<pre><code class="language-sh">sudo apt-get install graphviz
pip install -r requiments.txt
</code></pre>
<ul>
<li>
<h3 id="run-gen_graphpy"><a class="header" href="#run-gen_graphpy">Run gen_graph.py</a></h3>
</li>
</ul>
<pre><code class="language-sh">python gen_graph.py -i test/test.log 
</code></pre>
<pre><code class="language-sh">03/22/2023 08:33:26 PM [1] processing gdb bt data
03/22/2023 08:33:26 PM [2] adding nodes, edges, #ofnodes=14
03/22/2023 08:33:27 PM [3] Embedding JS
03/22/2023 08:33:27 PM [4] saving graph to:
03/22/2023 08:33:27 PM       /media/shihyu/ssd1/github/jason_note/src/gdb/src/gdb_graphs/test.svg

03/22/2023 08:33:27 PM Finished
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-1"><a class="header" href="#rust-1">Rust</a></h2>
<ul>
<li>test.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust">trait Printable {
    fn print(&amp;self);
}

struct Point {
    x: i32,
    y: i32,
}

impl Printable for Point {
    fn print(&amp;self) {
        println!(&quot;({}, {})&quot;, self.x, self.y);
    }
}

fn print_all&lt;T: Printable&gt;(list: Vec&lt;T&gt;) {
    for item in list {
        item.print();
    }
}

fn main() {
    let list = vec![Point { x: 1, y: 2 }, Point { x: 3, y: 4 }];
    print_all(list);
}
</code></pre></pre>
<pre><code class="language-sh">rustc -C debuginfo=2 test.rs
</code></pre>
<pre><code class="language-sh">https://github.com/zupzup/rust-gdb-example
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C++</a></h1>
<ul>
<li>
<p><a href="https://github.com/0voice/cpp_new_features">含C++ 11 / 14 / 17 / 20 / 23 新特性</a></p>
</li>
<li>
<p><a href="https://c-cpp.com/cpp">C/C++參考手冊</a></p>
</li>
<li>
<p><a href="https://github.com/parallel101">高性能並行編程與優化</a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/">C++ 官方文檔</a></p>
</li>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">C++ 核心開發規範</a></p>
</li>
<li>
<p><a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item22.md">Effective Mordern C++ 中文版</a></p>
</li>
<li>
<p><a href="https://github.com/jiayaozhang/OpenVDB_and_TBB">熱心觀眾整理的學習資料</a></p>
</li>
<li>
<p><a href="https://learncpp-cn.github.io/">LearnCpp 中文版</a></p>
</li>
<li>
<p><a href="http://faculty.cs.niu.edu/%7Ewinans/notes/patmc.pdf">Performance Analysis and Tuning on Modern CPUs</a></p>
</li>
<li>
<p><a href="https://www.bookstack.cn/read/Cpp_Concurrency_In_Action/README.md">C++ 併發編程實戰</a></p>
</li>
<li>
<p><a href="http://csapp.cs.cmu.edu/">深入理解計算機原理 (CSAPP)</a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/av48153629/">並行體系結構與編程 (CMU 15-418)</a></p>
</li>
<li>
<p><a href="https://www.inf.ed.ac.uk/teaching/courses/ppls/TBBtutorial.pdf">因特爾 TBB 編程指南</a></p>
</li>
<li>
<p><a href="https://www.bookstack.cn/read/CMake-Cookbook/README.md">CMake “菜譜”</a></p>
</li>
<li>
<p><a href="https://cmake.org/cmake/help/latest/">CMake 官方文檔</a></p>
</li>
<li>
<p><a href="https://git-scm.com/doc">Git 官方文檔</a></p>
</li>
<li>
<p><a href="https://docs.github.com/en">GitHub 官方文檔</a></p>
</li>
<li>
<p><a href="https://www.zhihu.com/people/AlbertRen/posts">助教老師知乎</a></p>
</li>
<li>
<p><a href="https://cppinsights.io/">實用網站 CppInsights 解構 C++ 語法糖</a></p>
</li>
<li>
<p><a href="http://godbolt.org/">實用網站 GodBolt 查看不同編譯器生成的彙編</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c性能測試工具google-benchmark入門"><a class="header" href="#c性能測試工具google-benchmark入門">c++性能測試工具：google benchmark入門</a></h2>
<p>出處：https://www.cnblogs.com/apocelipes/p/11067594.html</p>
<pre><code class="language-sh">sudo apt install g++ cmake
</code></pre>
<pre><code class="language-sh">git clone https://github.com/google/benchmark.git
git clone https://github.com/google/googletest.git benchmark/googletest
mkdir build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=RELEASE ../benchmark
make -j4
sudo make install
</code></pre>
<ul>
<li>benchmark_example.cpp</li>
</ul>
<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;
#include &lt;array&gt;

constexpr int len = 6;

// constexpr function具有inline屬性，你應該把它放在標頭檔中
constexpr auto my_pow(const int i)
{
    return i * i;
}

// 使用operator[]讀取元素，依次存入1-6的平方
static void bench_array_operator(benchmark::State&amp; state)
{
    std::array&lt;int, len&gt; arr;
    constexpr int i = 1;

    for (auto _ : state) {
        arr[0] = my_pow(i);
        arr[1] = my_pow(i + 1);
        arr[2] = my_pow(i + 2);
        arr[3] = my_pow(i + 3);
        arr[4] = my_pow(i + 4);
        arr[5] = my_pow(i + 5);
    }
}
BENCHMARK(bench_array_operator);

// 使用at()讀取元素，依次存入1-6的平方
static void bench_array_at(benchmark::State&amp; state)
{
    std::array&lt;int, len&gt; arr;
    constexpr int i = 1;

    for (auto _ : state) {
        arr.at(0) = my_pow(i);
        arr.at(1) = my_pow(i + 1);
        arr.at(2) = my_pow(i + 2);
        arr.at(3) = my_pow(i + 3);
        arr.at(4) = my_pow(i + 4);
        arr.at(5) = my_pow(i + 5);
    }
}
BENCHMARK(bench_array_at);

// std::get&lt;&gt;(array)是一個constexpr function，它會返回容器內元素的引用，並在編譯期檢查陣列的索引是否正確
static void bench_array_get(benchmark::State&amp; state)
{
    std::array&lt;int, len&gt; arr;
    constexpr int i = 1;

    for (auto _ : state) {
        std::get&lt;0&gt;(arr) = my_pow(i);
        std::get&lt;1&gt;(arr) = my_pow(i + 1);
        std::get&lt;2&gt;(arr) = my_pow(i + 2);
        std::get&lt;3&gt;(arr) = my_pow(i + 3);
        std::get&lt;4&gt;(arr) = my_pow(i + 4);
        std::get&lt;5&gt;(arr) = my_pow(i + 5);
    }
}
BENCHMARK(bench_array_get);

BENCHMARK_MAIN();
</code></pre>
<p>我們可以看到每一個benchmark測試用例都是一個類型為<code>std::function&lt;void(benchmark::State&amp;)&gt;</code>的函數，其中<code>benchmark::State&amp;</code>負責測試的運行及額外參數的傳遞。</p>
<p>隨後我們使用<code>for (auto _: state) {}</code>來運行需要測試的內容，state會選擇合適的次數來運行循環，時間的計算從循環內的語句開始，所以我們可以選擇像例子中一樣在for循環之外初始化測試環境，然後在循環體內編寫需要測試的程式碼。</p>
<p>測試用例編寫完成後我們需要使用<code>BENCHMARK(&lt;function_name&gt;);</code>將我們的測試用例註冊進benchmark，這樣程式執行時才會執行我們的測試。</p>
<p>最後是用<code>BENCHMARK_MAIN();</code>替代直接編寫的main函數，它會處理命令列參數並運行所有註冊過的測試用例生成測試結果。</p>
<p>示例中大量使用了constexpt，這是為了能在編譯期計算出需要的數值避免對測試產生太多噪音。</p>
<pre><code class="language-sh">g++ -Wall -std=c++14 benchmark_example.cpp -pthread -lbenchmark
</code></pre>
<p>benchmark需要連結<code>libbenchmark.so</code>，所以需要指定<code>-lbenchmark</code>，此外還需要thread的支援，因為libstdc++不提供thread的底層實現，我們需要pthread。另外不建議使用<code>-lpthread</code>，官方表示會出現相容問題，在我這測試也會出現連結錯誤。注意檔案名稱一定要在-lbenchmark前面，否則編譯會失敗</p>
<p>測試結果與預期基本相符，<code>std::get</code>最快，<code>at()</code>最慢。</p>
<h2 id="向測試用例傳遞參數"><a class="header" href="#向測試用例傳遞參數">向測試用例傳遞參數</a></h2>
<p>之前我們的測試用例都只接受一個<code>benchmark::State&amp;</code>類型的參數，如果我們需要給測試用例傳遞額外的參數呢？</p>
<p>舉個例子，假如我們需要實現一個佇列，現在有ring buffer和linked list兩種實現可選，現在我們要測試兩種方案在不同情況下的性能表現：</p>
<pre><code class="language-cpp">// 必要的資料結構
#include &quot;ring.h&quot;
#include &quot;linked_ring.h&quot;
 
// ring buffer的測試
static void bench_array_ring_insert_int_10(benchmark::State&amp; state)
{
    auto ring = ArrayRing&lt;int&gt;(10);
    for (auto _: state) {
        for (int i = 1; i &lt;= 10; ++i) {
            ring.insert(i);
        }
        state.PauseTiming(); // 暫停計時
        ring.clear();
        state.ResumeTiming(); // 恢復計時
    }
}
BENCHMARK(bench_array_ring_insert_int_10);
 
// linked list的測試
static void bench_linked_queue_insert_int_10(benchmark::State &amp;state)
{
    auto ring = LinkedRing&lt;int&gt;{};
    for (auto _:state) {
        for (int i = 0; i &lt; 10; ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
BENCHMARK(bench_linked_queue_insert_int_10);
 
// 還有針對刪除的測試，以及針對string的測試，都是高度重複的程式碼，這裡不再羅列
</code></pre>
<p>很顯然，上面的測試除了被測試類型和插入的資料量之外沒有任何區別，如果可以通過傳入參數進行控制的話就可以少寫大量重複的程式碼。</p>
<p>編寫重複的程式碼是浪費時間，而且往往意味著你在做一件蠢事，google的工程師們當然早就注意到了這一點。雖然測試用例只能接受一個<code>benchmark::State&amp;</code>類型的參數，但我們可以將參數傳遞給state對象，然後在測試用例中獲取：</p>
<pre><code class="language-cpp">static void bench_array_ring_insert_int(benchmark::State&amp; state)
{
    auto length = state.range(0);
    auto ring = ArrayRing&lt;int&gt;(length);
    for (auto _: state) {
        for (int i = 1; i &lt;= length; ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
BENCHMARK(bench_array_ring_insert_int)-&gt;Arg(10);
</code></pre>
<p>上面的例子展示瞭如何傳遞和獲取參數：</p>
<ol>
<li>傳遞參數使用<code>BENCHMARK</code>宏生成的對象的<code>Arg</code>方法</li>
<li>傳遞進來的參數會被放入state對象內部儲存，通過<code>range</code>方法獲取，呼叫時的參數0是傳入參數的需要，對應第一個參數</li>
</ol>
<p><code>Arg</code>方法一次只能傳遞一個參數，那如果一次想要傳遞多個參數呢？也很簡單：</p>
<pre><code class="language-cpp">static void bench_array_ring_insert_int(benchmark::State&amp; state)
{
    auto ring = ArrayRing&lt;int&gt;(state.range(0));
    for (auto _: state) {
        for (int i = 1; i &lt;= state.range(1); ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
BENCHMARK(bench_array_ring_insert_int)-&gt;Args({10, 10});
</code></pre>
<p>上面的例子沒什麼實際意義，只是為了展示如何傳遞多個參數，<code>Args</code>方法接受一個vector對象，所以我們可以使用c++11提供的大括號初始化器簡化程式碼，獲取參數依然通過<code>state.range</code>方法，1對應傳遞進來的第二個參數。</p>
<p>有一點值得注意，參數傳遞只能接受整數，如果你希望使用其他類型的附加參數，就需要另外想些辦法了。</p>
<h2 id="簡化多個類似測試用例的生成"><a class="header" href="#簡化多個類似測試用例的生成">簡化多個類似測試用例的生成</a></h2>
<p>測試用例傳遞參數的最終目的是為了在不編寫重複程式碼的情況下生成多個測試用例，在知道了如何傳遞參數後你可能會這麼寫：</p>
<pre><code class="language-cpp">static void bench_array_ring_insert_int(benchmark::State&amp; state)
{
    auto length = state.range(0);
    auto ring = ArrayRing&lt;int&gt;(length);
    for (auto _: state) {
        for (int i = 1; i &lt;= length; ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
// 下面我們生成測試插入10，100，1000次的測試用例
BENCHMARK(bench_array_ring_insert_int)-&gt;Arg(10);
BENCHMARK(bench_array_ring_insert_int)-&gt;Arg(100);
BENCHMARK(bench_array_ring_insert_int)-&gt;Arg(1000);
</code></pre>
<p>這裡我們生成了三個實例，會產生下面的結果：</p>
<p>看起來工作良好，是嗎？</p>
<p>沒錯，結果是正確的，但是記得我們前面說過的嗎——<em>不要編寫重複的程式碼</em>！是的，上面我們手動編寫了用例的生成，出現了可以避免的重複。</p>
<p>幸好<code>Arg</code>和<code>Args</code>會將我們的測試用例使用的參數進行註冊以便產生<code>用例名/參數</code>的新測試用例，並且返回一個指向<code>BENCHMARK</code>宏生成對象的指針，換句話說，如果我們想要生成僅僅是參數不同的多個測試的話，只需要鏈式呼叫<code>Arg</code>和<code>Args</code>即可：</p>
<pre><code class="language-c++">BENCHMARK(bench_array_ring_insert_int)-&gt;Arg(10)-&gt;Arg(100)-&gt;Arg(1000);
</code></pre>
<p>結果和上面一樣。</p>
<p>但這還不是最優解，我們仍然重複呼叫了Arg方法，如果我們需要更多用例時就不得不又要做重複勞動了。</p>
<p>對此google benchmark也有解決辦法：我們可以使用<code>Range</code>方法來自動生成一定範圍內的參數。</p>
<p>先看看Range的原型：</p>
<pre><code class="language-c++">BENCHMAEK(func)-&gt;Range(int64_t start, int64_t limit);
</code></pre>
<p>start表示參數範圍起始的值，limit表示範圍結束的值，Range所作用於的是一個_閉區間_。</p>
<p>但是如果我們這樣改寫程式碼，是會得到一個錯誤的測試結果：</p>
<pre><code class="language-c++">BENCHMARK(bench_array_ring_insert_int)-&gt;Range(10, 1000);
</code></pre>
<p><img src="c++/images/1434464-20190622023150158-2094667392.jpg" alt="error" /></p>
<p>為什麼會這樣呢？那是因為Range默認除了start和limit，中間的其餘參數都會是某一個基底（base）的冪，基地默認為8，所以我們會看到64和512，它們分別是8的平方和立方。</p>
<p>想要改變這一行為也很簡單，只要重新設定基底即可，通過使用<code>RangeMultiplier</code>方法：</p>
<pre><code class="language-c++">BENCHMARK(bench_array_ring_insert_int)-&gt;RangeMultiplier(10)-&gt;Range(10, 1000);
</code></pre>
<p>現在結果恢復如初了。</p>
<p>使用Ranges可以處理多個參數的情況：</p>
<pre><code class="language-c++">BENCHMARK(func)-&gt;RangeMultiplier(10)-&gt;Ranges({{10, 1000}, {128， 256}});
</code></pre>
<p>第一個範圍指定了測試用例的第一個傳入參數的範圍，而第二個範圍指定了第二個傳入參數可能的值（注意這裡不是範圍了）。</p>
<p>與下面的程式碼等價：</p>
<pre><code class="language-c++">BENCHMARK(func)-&gt;Args({10, 128})
               -&gt;Args({100, 128})
               -&gt;Args({1000, 128})
               -&gt;Args({10, 256})
               -&gt;Args({100, 256})
               -&gt;Args({1000, 256})
</code></pre>
<p>實際上就是用生成的第一個參數的範圍於後面指定內容的參數做了一個笛卡爾積。</p>
<h2 id="使用參數生成器"><a class="header" href="#使用參數生成器">使用參數生成器</a></h2>
<p>如果我想定製沒有規律的更複雜的參數呢？這時就需要實現自訂的參數生成器了。</p>
<p>一個參數生成器的簽名如下：</p>
<pre><code class="language-c++">void CustomArguments(benchmark::internal::Benchmark* b);
</code></pre>
<p>我們在生成器中計算處參數，然後呼叫<code>benchmark::internal::Benchmark</code>對象的Arg或Args方法像上兩節那樣傳入參數即可。</p>
<p>隨後我們使用<code>Apply</code>方法把生成器應用到測試用例上：</p>
<pre><code class="language-c++">BENCHMARK(func)-&gt;Apply(CustomArguments);
</code></pre>
<p>其實這一過程的原理並不複雜，我做個簡單的解釋：</p>
<ol>
<li><code>BENCHMARK</code>宏產生的就是一個<code>benchmark::internal::Benchmark</code>對象然後返回了它的指針</li>
<li>向<code>benchmark::internal::Benchmark</code>對象傳遞參數需要使用Arg和Args等方法</li>
<li><code>Apply</code>方法會將參數中的函數應用在自身</li>
<li>我們在生成器裡使用<code>benchmark::internal::Benchmark</code>對象的指針b的Args等方法傳遞參數，這時的b其實指向我們的測試用例</li>
</ol>
<p>到此為止生成器是如何工作的已經一目瞭然了，當然從上面得出的結論，我們還可以讓Apply做更多的事情。</p>
<p>下面看下Apply的具體使用：</p>
<pre><code class="language-c++">// 這次我們生成100，200，...，1000的測試用例，用range是無法生成這些參數的
static void custom_args(benchmark::internal::Benchmark* b)
{
    for (int i = 100; i &lt;= 1000; i += 100) {
        b-&gt;Arg(i);
    }
}
 
BENCHMARK(bench_array_ring_insert_int)-&gt;RangeMultiplier(10)-&gt;Apply(custom_args);
</code></pre>
<p>自訂參數的測試結果：</p>
<p><img src="c++/images/1434464-20190622023108640-364056091.jpg" alt="custom_args" /></p>
<p>至此向測試用例傳遞參數的方法就全部介紹完了。</p>
<h2 id="測量時間複雜度"><a class="header" href="#測量時間複雜度">測量時間複雜度</a></h2>
<p>google benchmark已經為我們提供了類似的功能，而且使用相當簡單。</p>
<p>具體的解釋在後面，我們先來看幾個例子，我們人為製造幾個時間複雜度分別為<code>O(n)</code>, <code>O(logn)</code>, <code>O(n^n)</code>的測試用例：</p>
<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;

// 這裡都是為了演示而寫成的程式碼，沒有什麼實際意義
static void bench_N(benchmark::State&amp; state)
{
    int n = 0;

    for ([[maybe_unused]] auto _ : state) {
        for (int i = 0; i &lt; state.range(0); ++i) {
            benchmark::DoNotOptimize(n +=
                                         2); // 這個函數防止編譯器將表示式最佳化，會略微降低一些性能
        }
    }

    state.SetComplexityN(state.range(0));
}
BENCHMARK(bench_N)-&gt;RangeMultiplier(10)-&gt;Range(10, 1000000)-&gt;Complexity();

static void bench_LogN(benchmark::State&amp; state)
{
    int n = 0;

    for ([[maybe_unused]] auto _ : state) {
        for (int i = 1; i &lt; state.range(0); i *= 2) {
            benchmark::DoNotOptimize(n += 2);
        }
    }

    state.SetComplexityN(state.range(0));
}
BENCHMARK(bench_LogN)-&gt;RangeMultiplier(10)-&gt;Range(10, 1000000)-&gt;Complexity();

static void bench_Square(benchmark::State&amp; state)
{
    int n = 0;
    auto len = state.range(0);

    for ([[maybe_unused]] auto _ : state) {
        for (int64_t i = 1; i &lt; len * len; ++i) {
            benchmark::DoNotOptimize(n += 2);
        }
    }

    state.SetComplexityN(len);
}
BENCHMARK(bench_Square)-&gt;RangeMultiplier(10)-&gt;Range(10, 100000)-&gt;Complexity();

BENCHMARK_MAIN();
</code></pre>
<p>如何傳遞參數和生成批次測試我們在上一篇已經介紹過了，這裡不再重複。</p>
<p>需要關注的是新出現的<code>state.SetComplexityN</code>和<code>Complexity</code>。</p>
<p>首先是<code>state.SetComplexityN</code>，參數是一個64位整數，用來表示演算法總體需要處理的資料總量。benchmark會根據這個數值，再加上運行耗時以及<code>state</code>的迭代次數計算出一個用於後面預估平均時間複雜度的值。</p>
<p><code>Complexity</code>會根據同一組的多個測試用例計算出一個較接近的平均時間複雜度和一個均方根值，需要和<code>state.SetComplexityN</code>配合使用。</p>
<p><code>Complexity</code>還有一個參數，可以接受一個函數或是<code>benchmark::BigO</code>列舉，它的作用是提示benchmark該測試用例的時間複雜度，預設值為<code>benchmark::oAuto</code>，測試中會自動幫我們計算出時間複雜度。對於較為複雜的演算法，而我們又有預期的時間按複雜度，這時我們就可以將其傳給這個方法，比如對於第二個測試用例，我們還可以這樣寫：</p>
<pre><code class="language-cpp">static void bench_LogN(benchmark::State&amp; state)
{
    // 中間部分與前面一樣，略過
}
BENCHMARK(bench_LogN)-&gt;RangeMultiplier(10)-&gt;Range(10, 1000000)-&gt;Complexity(benchmark::oLogN);
</code></pre>
<p>在選擇正確的提示後對測試結果幾乎沒有影響，除了偏差值可以降得更低，使結果更準確。</p>
<p><code>Complexity</code>在計算時間複雜度時會保留複雜度的係數，因此，如果我們發現給出的提示的時間複雜度前的係數過大的話，就意味著我們的預估發生了較大的偏差，同時它還會計算出RMS值，同樣反應了時間複雜度的偏差情況。</p>
<p>運行我們的測試：</p>
<p><img src="c++/images/1434464-20190630014036457-1448575692.jpg" alt="img" /></p>
<p>可以看到，自動的時間複雜度計算基本是精準的，可以在我們對演算法進行測試時提供一個有效的參考。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto_ptrunique_ptrshared_ptr"><a class="header" href="#auto_ptrunique_ptrshared_ptr">auto_ptr、unique_ptr、shared_ptr</a></h1>
<p>範本auto_ptr是C++98提供的解決方案，C++11已摒棄。</p>
<p>範本unique_ptr、shared_ptr是C++11提供的解決方案.</p>
<p>為什麼要摒棄auto_ptr呢？</p>
<p>先來看下面的賦值語句：</p>
<pre><code class="language-cpp">auto_ptr&lt;string&gt; ps(new string(&quot;I am a boy.&quot;));
auto_ptr&lt;stirng&gt; vocation;
vocation = ps;
</code></pre>
<p>上述賦值語句將完成什麼工作呢？如果ps和vocation是常規指針，則兩個指針將指向同一個string對象。這是不能接受的，因為程序將試圖刪除同一個對像兩次--一次是ps過期時，一次是vocation過期時。要避免這種問題，方法有多種。</p>
<ul>
<li>定義賦值運算子，使之執行深賦值。這樣兩個指針將指向不同的對象，其中的一個對像是另一個對象的副本。</li>
<li>建立所有權（ownership）概念，對於特定的對象，只能有一個智能指針可擁有它，這樣只能擁有對象的智能指針的建構函式會刪除該對象。然後，讓賦值操作轉讓所有權。這就是用於auto_ptr和unique_ptr的策略，但<strong>unique_ptr</strong>的策略更嚴格。</li>
<li>建立智能更高的指針，跟蹤引用特定對象的智能指針數。這稱為引用計數（reference counting）。例如，賦值時，計數將加1，而指針過期時，計數將減1。僅當最後一個指針過期時，才呼叫delete。這是<strong>shared_ptr</strong>採用的策略。</li>
</ul>
<p>每種方法都有其用途，</p>
<h3 id="1-下面是一個不適合使用auto_ptr的示例"><a class="header" href="#1-下面是一個不適合使用auto_ptr的示例">1 下面是一個不適合使用auto_ptr的示例：</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

using namespace std;

int main()
{
    auto_ptr&lt;string&gt; films[5] =
    {
        auto_ptr&lt;string&gt; (new string(&quot;one&quot;)),
        auto_ptr&lt;string&gt; (new string(&quot;two&quot;)),
        auto_ptr&lt;string&gt; (new string(&quot;three&quot;)),
        auto_ptr&lt;string&gt; (new string(&quot;four&quot;)),
        auto_ptr&lt;string&gt; (new string(&quot;five&quot;))
    };
    auto_ptr&lt;string&gt; pwin;
    pwin = films[2];  // films[2] lose ownership

    cout &lt;&lt; &quot;films data is: &quot; &lt;&lt; endl;
    for(auto_ptr&lt;string&gt; s : films)
        cout &lt;&lt; *s &lt;&lt; endl;
    cout &lt;&lt; &quot;pwin: &quot; &lt;&lt; *pwin &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>下面是該程序的輸出：</p>
<pre><code class="language-cpp">films data is:
one
two

Process returned -1073741819 (0xC0000005)   execution time : 1.659 s
Press any key to continue.
</code></pre>
<p>錯誤的使用auto_ptr可能導致問題（這種程式碼的行為是不確定的，其行為可能隨系統而異）。這裡的問題在於，下面的語句將所有權從films[2]轉讓給pwin：</p>
<pre><code class="language-text">pwin = films[2];  // films[2] lose ownership
</code></pre>
<p>這導致films[2]不再引用該字串。在auto_ptr放棄對象的所有權後，邊可能使用它來訪問該對象。當程序列印films[2]指向的字串時，卻發現這是一個空指針，因此發生錯誤。</p>
<h3 id="2-如果使用shared_ptr替換auto_ptr則程序將正常運行"><a class="header" href="#2-如果使用shared_ptr替換auto_ptr則程序將正常運行">2 如果使用shared_ptr替換auto_ptr，則程序將正常運行。</a></h3>
<p>示例程式碼：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

using namespace std;

int main()
{
    shared_ptr&lt;string&gt; films[5] =
    {
        shared_ptr&lt;string&gt; (new string(&quot;one&quot;)),
        shared_ptr&lt;string&gt; (new string(&quot;two&quot;)),
        shared_ptr&lt;string&gt; (new string(&quot;three&quot;)),
        shared_ptr&lt;string&gt; (new string(&quot;four&quot;)),
        shared_ptr&lt;string&gt; (new string(&quot;five&quot;))
    };
    shared_ptr&lt;string&gt; pwin;
    pwin = films[2];

    cout &lt;&lt; &quot;films data is: &quot; &lt;&lt; endl;
    for(shared_ptr&lt;string&gt; s : films)
        cout &lt;&lt; *s &lt;&lt; endl;
    cout &lt;&lt; &quot;pwin: &quot; &lt;&lt; *pwin &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>其輸出如下：</p>
<pre><code class="language-cpp">films data is:
one
two
three
four
five
pwin: three
</code></pre>
<p>這次pwin和films[2]指向同一個對象，而引用計數從1增加到2。在程序末尾，後聲明的pwin首先呼叫其解構函式，該解構函式將引用計數降低到1。然後，shared_ptr陣列的成員被釋放，對films[2]呼叫解構函式時，將引用計數降低到0，並釋放以前分配的空間。</p>
<h3 id="3-如果使用unique_ptr替換auto_ptr"><a class="header" href="#3-如果使用unique_ptr替換auto_ptr">3 如果使用unique_ptr替換auto_ptr</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

using namespace std;

int main()
{
    unique_ptr&lt;string&gt; films[5] =
    {
        unique_ptr&lt;string&gt; (new string(&quot;one&quot;)),
        unique_ptr&lt;string&gt; (new string(&quot;two&quot;)),
        unique_ptr&lt;string&gt; (new string(&quot;three&quot;)),
        unique_ptr&lt;string&gt; (new string(&quot;four&quot;)),
        unique_ptr&lt;string&gt; (new string(&quot;five&quot;))
    };
    unique_ptr&lt;string&gt; pwin;
    pwin = films[2];

    cout &lt;&lt; &quot;films data is: &quot; &lt;&lt; endl;
    for(unique_ptr&lt;string&gt; s : films)
        cout &lt;&lt; *s &lt;&lt; endl;
    cout &lt;&lt; &quot;pwin: &quot; &lt;&lt; *pwin &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>則程序將在下述程式碼行出現編譯錯誤。</p>
<pre><code class="language-cpp">pwin = films[2];  // films[2] lose ownership
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rvalue-參考"><a class="header" href="#rvalue-參考">rvalue 參考</a></h1>
<p>〈<a href="https://openhome.cc/Gossip/CppGossip/Reference.html">參考</a>〉中談到，參考是物件的別名，在 C++ 中，「物件」這個名詞，不單只是指類別的實例，而是指記憶體中的一塊資料，那麼可以參考字面常量嗎？常量無法使用 <code>&amp;</code> 取址，例如無法 <code>&amp;10</code>，因此以下會編譯錯誤：</p>
<pre><code class="language-cpp">int &amp;r = 10; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'
</code></pre>
<p>不過，加上 <code>const</code> 的話倒是可以：</p>
<pre><code class="language-cpp">const int &amp;r = 10; 
</code></pre>
<p>常量是記憶體中臨時的資料，無法對常量取址，因此編譯器會將以上轉換為像是：</p>
<pre><code class="language-cpp">const int _n = 10;
const int &amp;r = _n;
</code></pre>
<p>實際上，<code>r</code> 並不是真的參考至 10，而是 10 被複製給 <code>_n</code>，然後 <code>r</code> 參考至 <code>_n</code>，如果不加上 <code>const</code>，那麼你可能會以為變更了 <code>r</code>，就是變更了 10 位址處的值，因此就要求你一定得加上 <code>const</code>，不讓你改了。</p>
<p>為什麼會需要參考至常量？通常跟函式呼叫相關，這之後文件再來討論；類似地，以下會編譯失敗：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
int &amp;r = a + b; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'
</code></pre>
<p>這是因為 <code>a + b</code> 運算出的結果，會是在臨時的記憶體空間中，無法取址；類似地，若想通過編譯，必須加上 <code>const</code>：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
const int &amp;r = a + b; 
</code></pre>
<p>不過在 C++ 11 之後，像以上的運算式，可以直接參考了：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
int &amp;&amp;rr = a + b;
</code></pre>
<p>在以上的程式中，<code>int&amp;&amp;</code> 是 rvalue 參考（rvalue reference），<code>rr</code> 參考了 <code>a + b</code> 運算結果的空間，相對於以下的程式來說比較有效率：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
int c = a + b; // 將 a + b 的結果複製給 c
</code></pre>
<p>因為不必有將值複製、儲存至 <code>c</code> 的動作，效率上比較好，特別是當 rvalue 運算式會產生龐大物件的時候，複製就會是個成本考量，例如 <code>s1</code>、<code>s2</code> 若是個很長的 <code>string</code>，那麼 <code>s1 + s2</code> 的結果還會複製給目標 <code>string</code> 的話：</p>
<pre><code class="language-cpp">string result = s1 + s2;
</code></pre>
<p>改用以下會比較經濟：</p>
<pre><code class="language-cpp">string &amp;&amp;result = s1 + s2;
</code></pre>
<p>相對於 rvalue 參考，<code>int&amp;</code> 這類參考就被稱為 lvalue 參考；只不過，lvalue 或 rvalue 是什麼？方才編譯錯誤的訊息中，似乎也出現了 lvalue、rvalue 之類的字眼，這些是什麼？</p>
<p>lvalue、rvalue 是 C++ 對運算式（expression）的分類方式，一個粗略的判別方式，是看看 <code>&amp;</code> 可否對運算式取址，若可以的話，運算式是 lvalue，否則是個 rvalue。</p>
<p>若要精確的定義，可以參考〈<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>〉，該文件中 History 的區段，有談到運算式分類的歷史，最早是從 CPL 開始對運算式區分為左側模式（left-hand mode）與右側模式（right-hand mode），左、右是指運算式是在指定的左或右側，有些運算式只有在指定的左側才會有意義。</p>
<p>C 語言有類似的分類方式，分為 lvalue 與其他運算式，l 似乎暗示著 left 的首字母，不過實際上，並非以指定的左、右來分類，lvalue 是指可以識別物件的運算式，<strong>白話點的說法是，運算式的結果會是個有名稱的物件</strong>。</p>
<p>到了 C++ 98，非 lvalue 運算式被稱為 rvalue，一些 C 中非 lvalue 的運算式成了 lvalue，到了 C++ 11，運算式又被重新分類為〈<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>〉中的結果。</p>
<p>許多文件取 lvalue、rvalue 的 l、r，將它們分別譯為左值、右值，就運算式的分類歷史來說，不能說是錯，不過嚴格來說，C++ 中 lvalue、rvalue 的 l、r，並沒有左、右的意思，lvalue、rvalue 只是個分類名稱。</p>
<p>在〈<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>〉一開頭，可以看到目前的 C++ 標準，將運算式更細分為 glvalue、prvalue、xvalue、lvalue 與 rvalue，g 暗示為 generalized，pr 暗示為 pure，x 暗示為 eXpiring，就涵蓋關係而言，使用圖來表示會比較清楚：</p>
<p><img src="https://openhome.cc/Gossip/CppGossip/images/RvalueReference-1.JPG" alt="rvalue 參考" /></p>
<p>具體來說，哪個運算式屬於哪個分類，〈<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>〉都有舉例，當然，容易看到眼花花…</p>
<p><strong>方才談到，一個粗略的判別方式，是看看 <code>&amp;</code> 可否對運算式取址，若可以的話，運算式是 lvalue，否則是個 rvalue；另一個白話點的判別方式是，lvalue 運算式的結果會是個有名稱的物件，例如 <code>a</code>，rvalue 的結果是暫時性存在於記憶體，例如 <code>a + b</code>。</strong></p>
<p>那麼 <code>++i</code>、<code>i++</code> 呢？在〈<a href="https://openhome.cc/Gossip/CppGossip/IncrementDecrement.html">遞增、遞減、指定運算</a>〉中談過，<code>++i</code> 運算結果是遞增後的 <code>i</code>，也就是 <code>++i</code> 運算結果是個有名稱的物件，因此可以使用 lvalue 參考：</p>
<pre><code class="language-cpp">int i = 10;
int &amp;r = ++i; // OK
</code></pre>
<p>然而 <code>i++</code> 運算結果是遞增前的 <code>i</code>，暫時性存在於記憶體，若不指定給變數的話就不見了，因此 <code>i++</code> 是個 rvalue，因此以下會編譯失敗：</p>
<pre><code class="language-cpp">int i = 10;
int &amp;r = i++; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'
</code></pre>
<p>C++ 11 開始，若想參考 <code>i++</code> 運算時暫時存在於記憶體中遞增前的 <code>i</code>，可以使用 rvalue 參考：</p>
<pre><code class="language-cpp">int i = 10;
int &amp;&amp;rr = i++; // OK
</code></pre>
<p>哪些是 lvalue，而哪些又是 rvalue，基本上還是以〈<a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a>〉的定義為準，不清楚的話就查一下。</p>
<p>使用 rvalue 參考通常是為了效率上的考量，</p>
<p>還有個 <code>std::move</code>（定義於 <code>utility</code> 標頭檔）用來實現移動語義（move semantics），例如實現移動建構式（move constructor），這需要在認識類別定義、複製建構式等之後才能細談，就現階段而言，可以從 <code>string</code> 來稍微認識一下，例如，以下會將 <code>s1</code> 的資料複製給 <code>s2</code>：</p>
<pre><code class="language-cpp">string s2 = s1;    // s1 是個 string，而這邊會複製 s1 的內容給 s2
</code></pre>
<p>若 <code>s1</code> 指定給 <code>s2</code> 後，就不再會用到原本的內容，那麼複製就是不必要的成本，若能把 <code>s1</code> 的內容直接移給 <code>s2</code> 的話就好了，C++ 11 開始可以這麼做：</p>
<pre><code class="language-cpp">string s2 = std::move(s1);
</code></pre>
<p>這麼一來，<code>s1</code> 的資料就被移至 <code>s2</code> 了，在這之後不能立即使用 <code>s1</code> 來取值，因為資料轉移出去了，取值結果是不可預期的，只能銷毀 <code>s1</code>，或者是重新指定字串給 <code>s1</code>。</p>
<p>來看個簡單的示範：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; 
#include &lt;string&gt;
using namespace std; 

int main() { 
    string s1 = &quot;abc&quot;;
    string s2 = s1;     //  複製 s1 的資料

    cout &lt;&lt; s1 &lt;&lt; endl; // 顯示 &quot;abc&quot;
    cout &lt;&lt; s2 &lt;&lt; endl; // 顯示 &quot;abc&quot;
} 
</code></pre>
<p>跟移動版本比較一下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; 
#include &lt;string&gt;
#include &lt;utility&gt;

using namespace std; 

int main() { 
    string s1 = &quot;abc&quot;;
    string s2 = std::move(s1);    //  轉移 s1 的資料

    // cout &lt;&lt; s1 &lt;&lt; endl;        // 這時取值結果不可預期
    cout &lt;&lt; s2 &lt;&lt; endl;           // 顯示 &quot;abc&quot;

    s1 = &quot;xyz&quot;;                   // OK
    cout &lt;&lt; s1 &lt;&lt; endl;           // 這時可以取值
} 
</code></pre>
<p>移動版本之所以能夠運作，是因為 <code>string</code> 的建構式之一，使用了 rvalue 參考，而 <code>std::move</code> 的作用，其實是告訴編譯器，將指定的 lvalue 當成是 rvalue（某些程度就是一種 cast），以選擇定義了 rvalue 參考的建構式，而建構式中實現了移動來源資料的演算。</p>
<p>因為 move 這個名稱太平凡了，為了避免名稱衝突，建議包含 <code>std</code> 名稱空間，也就是使用 <code>std::move</code>。</p>
<hr />
<p>在Effective Modern C++中的一段對新C++特性的總結。其中rvalue references是一個比較核心的改進，對某些情況下對C++程式碼的效率很有幫助。最近在看相關的文件，筆者想寫篇關於rvalue references的介紹性文章；準備分兩部分：第一部分介紹下什麼是rvalue和rvalue references，第二部分介紹它的應用。</p>
<h2 id="lvalue-和-rvalue"><a class="header" href="#lvalue-和-rvalue">lvalue 和 rvalue</a></h2>
<p>lvalue和rvalue的概念最初來自C語言，後來C++對它們有所擴展。最初，在C裡lvalue和rvalue貌似分別指一個賦值表示式的左邊和右邊值。（“L” stands for “left” and “R” stands for “right“）C++引入後，這個名字裡左邊啊，右邊啊，就變得不那麼清晰了；也就是C++裡它們不再侷限於賦值表示式的左邊和右邊了。
首先，有一點是肯定的，C++裡一個表示式要麼是lvalue的，要麼是rvalue。這裡有一點要強調，lvalue和rvalue的是表示式的屬性，不是object的屬性。（C++03 3.10/1 says: “Every expression is either an lvalue or an rvalue.”）</p>
<p><strong>lvalue一般是有可以定址的儲存位置，它在表示式後還會存在（persist beyond a single expression）。rvalue一般是臨時性的，在表示式後就會消失；所以rvalue是無法得到地址的，原因是如果可以得到臨時東西的地址，那後續訪問這個地址將是災難性的。</strong>
還有一個判斷lvalue和rvalue的小竅門是試著對表示式取地址（&amp;）；能合法取地址的是lvalue，不能取的或者得到荒謬結果的是rvalue。比如，&amp;x，&amp;x[0]都是合理的，所以x和x[0]都是lvalue；而&amp;7，&amp;(x+1)，&amp;(x+y)都是非法的，所以7，(x+1)，(x+y)都是rvalue。</p>
<h2 id="lvalue-和-rvalue的例子"><a class="header" href="#lvalue-和-rvalue的例子">lvalue 和 rvalue的例子</a></h2>
<p>下面舉一些常見lvalue 和 rvalue的表示式。
以下是常見的lvalue：</p>
<pre><code class="language-cpp">int var = 0;
var = 1 + 2; // ok, var is an lvalue here
int* p1 = &amp;var; // ok, var is an lvalue
obj, *ptr, ptr[index], ++x;   // lvalue

// function returned is rvalue, except it returns a reference
int x;
int&amp; getRef ()
{
    return x;
}
getRef() = 4;     // lvalue, as getRef() returns a reference

</code></pre>
<p>常見的rvalue：</p>
<pre><code class="language-c++">1 + 2;
var + 1 = 2 + 3; // error, var + 1 is an rvalue
int* p2 = &amp;(var + 1); // error, var + 1 is an rvalue
x++；

// function returned is rvalue, except it returns a reference
int x;
int getVal ()
{
    return x;
}
getVal();    // rvalue
UserType().member_function(); // ok, calling a member function of the class rvalue
</code></pre>
<p>上面有兩點要注意的。第一是++x和x++。這兩哥們很像，平時幾乎沒區別（除了一個是先加再取x的值，一個是先取x的值後加）。<strong>但其實這倆是完全不同的表示式：前者是lvalue後者是rvalue!</strong>++x和x++都是增加x值，但是++x返回的是原來的x，++後x依然存在；而x++返回的只是一個x的臨時copy！
第二個要注意的是函數。只有返回引用時，函數才是lvalue；其他情況都是rvalue。</p>
<h2 id="運算子多載中的-lvalue-和-rvalue問題"><a class="header" href="#運算子多載中的-lvalue-和-rvalue問題">運算子多載中的 lvalue 和 rvalue問題</a></h2>
<p>上面的例子中沒有涉及到運算子多載；其實運算子多載和函數是一樣的規則——只有返回引用時，運算子多載才是lvalue；其他情況都是rvalue。</p>
<pre><code class="language-c++">reference operator[] (size_type n);

vector&lt;int&gt; v(10, 1729); 
v[0]；  // is an lvalue because operator[]() return reference int&amp; .

string operator+ (const string&amp; lhs, const string&amp; rhs);

string s(“foo”);
string t(“bar”);
s + t;   // is an rvalue because operator+() returns string (and &amp;(s + t) is invalid).

string&amp; operator= (const string&amp; str);

s=t=p; // makes sense; as operator= is lvalue
</code></pre>
<h2 id="lvalue-和-rvalue-const屬性"><a class="header" href="#lvalue-和-rvalue-const屬性">lvalue 和 rvalue const屬性</a></h2>
<p>lvalue 和 rvalue 都可以是const或non-const的。比如：</p>
<pre><code class="language-c++">string one(“cute”);
const string two(“fluffy”);
string three() { return “kittens”; }
const string four() { return “are an essential part of a healthy diet”; }

one;     // modifiable lvalue
two;     // const lvalue
three(); // modifiable rvalue
four();  // const rvalue
const string&amp;=three();
</code></pre>
<p>這裡最關鍵的是引用（Type &amp;）的變化。引用bind到 lvaue上，可以用來觀察和修改變數值；所以非const引用不能作用於const lvaue和rvalue。作用於rvalue意味著可以修改臨時變數值，這是絕對禁止的。
const引用（const Type &amp;）可以bind到任何value上，lvalues, const lvalues, rvalues, and const rvalues (and can be used to observe them).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-stdmove"><a class="header" href="#c-stdmove">C++ std::move</a></h1>
<p>https://medium.com/@berton1679/c-std-move-133d99d87fc1</p>
<p>一開始接觸c++11/14的人而言，絕大多數都會對 <code>std::move()</code> 這個神奇的function 所困惑。首先讓我們直接看一下<a href="https://en.cppreference.com/w/cpp/utility/move">cppreference</a> 中的介紹，</p>
<pre><code>std::move is used to indicate that an object t may be &quot;moved from&quot;, i.e. allowing the efficient transfer of resources from t to another object.In particular, std::move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.
</code></pre>
<p>而其實 <code>std::move()</code> 並沒有移動任何的物件，基本上只是轉型而已，程式碼基本上是如下</p>
<pre><code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)
</code></pre>
<p>所以他並不是什麼神奇的黑魔法，就只是轉型!</p>
<p>至於使用時機，我們用以下的class 作為例子方便說明</p>
<pre><code class="language-cpp">class BigObject
{
public:
    BigObject()
    {
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;std::endl;
    }
    BigObject(int g)
    {
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;std::endl;
        gg = g;
    }
    ~BigObject()
    {
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;std::endl;
    }
    BigObject (const BigObject &amp;b)
    {
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;std::endl;
    }
    BigObject (BigObject &amp;&amp;b)
    {
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;std::endl;
        this-&gt;gg = std::move(b.gg);
    }
    int gg = 0;
};
</code></pre>
<p>許多人一開始接觸 <code>std::move()</code> 誤以為可以增進效能，因為可以減少copy constructor 的次數，但這其實不一定正確的!!!!!</p>
<p>例如</p>
<pre><code class="language-cpp">BigObject test1(int i)
{
    auto dd = BigObject();
    if (i &lt;= 0){
        dd.gg = 5;
        return dd;
    }
    dd.gg = i;
    return std::move(dd);
}
BigObject test2(int i)
{
    auto dd = BigObject();
    if (i &lt;= 0){
        dd.gg = 5;
        return dd;
    }
    dd.gg = i;
    return dd;
}int main()
{
  auto tt1 = test1(5);
  auto tt2 = test2(5);  return 0;
}
</code></pre>
<p>output 則為</p>
<pre><code>BigObject::BigObject()
BigObject::BigObject(BigObject&amp;&amp;)
BigObject::~BigObject()BigObject::BigObject()
BigObject::~BigObject()
BigObject::~BigObject()
</code></pre>
<p>很多人以為function return object 會多一個copy constructor 而使用 <code>std::move()</code> ，因為很多人以為overload 較低，但是很明顯看到 <code>test2</code> 卻比 <code>test1</code> 更有效率，因為沒有多餘的copy/move constructor， 因為compiler 會自動做 RVO(Return Value Optimization)， 所以切記</p>
<p><strong>function 裡面能使用RVO 就使用RVO 不要自作聰明使用</strong> <code>**std::move**</code></p>
<p>那麼到底什麼時候可以使用 <code>std::move</code> 讓程式加快呢?</p>
<p>可以參考以下例子</p>
<p><code>std::array&lt;T&gt;</code> , <code>std::vector&lt;T&gt;</code> 基本上都可以支援random access 的container，但是 <code>std::move</code> 的實作卻差別很大</p>
<pre><code class="language-cpp">int main()
{
  std::vector&lt;BigObject&gt; test;
  test.resize(2);
  auto m_test = std::move(test);
  for(auto &amp;it : test)
    std::cout&lt;&lt;it.gg&lt;&lt;std::endl;
  for(auto &amp;it : m_test)
    std::cout&lt;&lt;it.gg&lt;&lt;std::endl;}
</code></pre>
<p>output</p>
<pre><code>BigObject::BigObject()
BigObject::BigObject()
0
0
BigObject::~BigObject()
BigObject::~BigObject()
</code></pre>
<p>可以看到 <code>std::vector</code> 對應的move constructor 可以不會做多餘的constructor ，且原本的element 都移到 <code>m_test</code> 之中。</p>
<p>output</p>
<pre><code>BigObject::BigObject()
BigObject::BigObject()
BigObject::BigObject(BigObject&amp;&amp;)
BigObject::BigObject(BigObject&amp;&amp;)
0
0
0
0
BigObject::~BigObject()
BigObject::~BigObject()
BigObject::~BigObject()
BigObject::~BigObject()
</code></pre>
<p>但是 <code>std::array&lt;T&gt;</code> 對應的 move constructor 卻有很大的分別，基本上是會對每個element 都 call move constructor 而不是對container</p>
<p>所以在使用 <code>std::move()</code> 語法的時候，最好要知道到底程式會怎麼跑，不然往往會自成程式碼的失控…..</p>
<p>最後分享一下，減少copy/move constructor 次數的確可以增進程式效能，但通常都是 演算法 &gt; 程式優化 ，所以往往演算法都是優化的第一步，但是如果在特定產業的話，對程式的速度非常在意，那優化 c++ 程式邏輯的確可以增進效能，因為現在產業的關係常常做這類似的優化，之前就有利用 universal reference 降低constructor 次數增進約10%的效能。</p>
<p>第一篇先以 <code>std::move()</code> 開頭，之後可能會多講一下 c++ optimization 的心得，順便紀錄工作用到的能力</p>
<hr />
<p>C++ 11引進了move semantic。在C++03時，”temporaries” or ”rvalues”都被視為non-modifiable，但C++11允許了右值的改動，因為這會有些時候相當有用。更精準來說：</p>
<blockquote>
<p>當右值被初始化之後，即可以被更改。其註記方式為 T&amp;&amp;, for a type of T</p>
</blockquote>
<p>而move semantics要解決的問題是：<strong>C++ 03中常常有不必要的copy，尤其在object pass by value的時候。</strong></p>
<p>而move semantics是為了提升這部分的效能。</p>
<p>舉個例子：</p>
<p>假設現在有個 std::vector<T> type（可以想像裡面有個 C-style array以及定義的size)。想像一個函數創造了這個vector並要將其回傳。按照C++03的方法則是宣告一個container來接收。如std::vector<T> ret = f()。此時函數內部創造的temporary內容會被完整複製一份放到ret，接著從記憶體中抹去所有temporary memory。這個過程很繁瑣，因為<strong>複製與刪去</strong>這兩個步驟是不必要的。</p>
<p>再仔細看move constructor的運作方式。今天一個std::vector<T>要透過rvalue形式的std::vector<T>來創建，則會發生以下步驟。</p>
<ol>
<li>rvalue的vector中，C-style array pointer會被複製到destination vector<T>中。</li>
<li>原本rvalue的C-array pointer會被指向null。</li>
<li>因為rvalue是temporaries，接下來的context也不會再使用到，所以其null pointer也不會被access（所以不用擔心out of scope之後，嘗試去delete一個null pointer的memory）。</li>
</ol>
<p>由此可見，這裡完全摒棄了deep copy的過程，但仍是safe的狀態。</p>
<p>除了move constructor的case，還有在function return 一個新的物件的時候（舉例: std::vector<T>），move semantics也可以避免多餘的deep copy。其原因是函數回傳一個新物件時，多了一步deep copy也是不必要的。在function return的這個case，temporary vector會自動被當作右值，move constructor會implicitly called。（在C++ 03中，如果沒有move constructor，則會自動呼叫copy constructor）</p>
<p>再來看一個stackoveflow的例子，幫助理解lvalue, rvalue以及move。</p>
<p>假設現在有個string class，同時也定義其copy constructor和destructor。</p>
<pre><code class="language-cpp">class string
{
char* datapublic:
    string(const char* p)
    {
        size_t size = std::strlen(p) + 1;
        data = new char[size];
        std::memcpy(data, p, size);
    }

    ~string()
    {
        delete[] data;
    }
}

</code></pre>
<p>接著我們執行三種string的操作：</p>
<pre><code class="language-cpp">string a(x);
string b(x + y);
string c(// a function returning string);
</code></pre>
<p>這裡只有第一行的操作會使用到deep copy。這裡x代表的就是string這個object。一個實際存在記憶體中，透過x去reference的物件。這我們稱為<strong>lvalue</strong>。</p>
<p>而第二與第三行都是在程式執行過程中產生的temporaries。我們沒辦法透過一個name去取得x + y或函數回傳的string object。這稱為<strong>rvalue</strong>。這些rvalues會在其存在的expression結束之後就被destroy。</p>
<p>而在接下來的部份我們要加入move constructor。我們可以透過rvalue reference &amp;&amp;偵測constructor的argument是否為rvalue。</p>
<p>因此我們定義：</p>
<pre><code class="language-cpp">string(string&amp;&amp; rhs)
{
    data = rhs.data;
    rhs.data = nullptr;
}
</code></pre>
<p>在move constructor中，我們可以對記憶體進行任何操作。只要最後右值是在一個valid state就可以。在這裡我們將rhs.data改成nullptr是為了避免rhs呼叫了destructor，刪除了被移動的string。</p>
<p>以上很容易看出來，move constructor做的事情是透過改變pointer，把source (rhs)的記憶體內容搬移到string中。</p>
<p>最後來看看assignment operator。當assignment接收的是lvalue時，呼叫的就會是copy constructor，<strong>若是rvalue，那就會是move constructor</strong>。如：</p>
<pre><code class="language-cpp">string c = a;
string c = a + b;
</code></pre>
<p>這裡move constructor做的事情只是更改了pointer指向的位置，而source object在之後也不可能被使用者操作，所以是個安全的操作。</p>
<hr />
<h1 id="一文讀懂c右值引用和stdmove"><a class="header" href="#一文讀懂c右值引用和stdmove">一文讀懂C++右值引用和std::move</a></h1>
<p>https://zhuanlan.zhihu.com/p/335994370?utm_id=0</p>
<p>C++11引入了右值引用，有一定的理解成本，工作中發現不少同事對右值引用理解不深，認為右值引用性能更高等等。本文從實用角度出發，用儘量通俗易懂的語言講清左右值引用的原理，性能分析及其應用場景，幫助大家在日常程式設計中用好右值引用和std::move。</p>
<h3 id="1-什麼是左值右值"><a class="header" href="#1-什麼是左值右值"><strong>1. 什麼是左值、右值</strong></a></h3>
<p>首先不考慮引用以減少幹擾，可以從2個角度判斷：左值<strong>可以取地址、位於等號左邊</strong>；而右值<strong>沒法取地址，位於等號右邊</strong>。</p>
<pre><code class="language-cpp">int a = 5;
</code></pre>
<ul>
<li>a可以通過 &amp; 取地址，位於等號左邊，所以a是左值。</li>
<li>5位於等號右邊，5沒法通過 &amp; 取地址，所以5是個右值。</li>
</ul>
<p>再舉個例子：</p>
<pre><code class="language-cpp">struct A {
    A(int a = 0) {
        a_ = a;
    }
 
    int a_;
};
 
A a = A();
</code></pre>
<ul>
<li>同樣的，a可以通過 &amp; 取地址，位於等號左邊，所以a是左值。</li>
<li>A()是個臨時值，沒法通過 &amp; 取地址，位於等號右邊，所以A()是個右值。</li>
</ul>
<p>可見左右值的概念很清晰，有地址的變數就是左值，沒有地址的字面值、臨時值就是右值。</p>
<h3 id="2-什麼是左值引用右值引用"><a class="header" href="#2-什麼是左值引用右值引用"><strong>2. 什麼是左值引用、右值引用</strong></a></h3>
<p>引用本質是別名，可以通過引用修改變數的值，傳參時傳引用可以避免複製，其實現原理和指針類似。 個人認為，引用出現的本意是為了降低C語言指針的使用難度，但現在指針+左右值引用共同存在，反而大大增加了學習和理解成本。</p>
<h3 id="21-左值引用"><a class="header" href="#21-左值引用"><strong>2.1 左值引用</strong></a></h3>
<p>左值引用大家都很熟悉，<strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<pre><code class="language-cpp">int a = 5;
int &amp;ref_a = a; // 左值引用指向左值，編譯通過
int &amp;ref_a = 5; // 左值引用指向了右值，會編譯失敗
</code></pre>
<p><strong>引用是變數的別名，由於右值沒有地址，沒法被修改，所以左值引用無法指向右值。</strong></p>
<p>但是，const左值引用是可以指向右值的：</p>
<pre><code class="language-cpp">const int &amp;ref_a = 5;  // 編譯通過
</code></pre>
<p>const左值引用不會修改指向值，因此可以指向右值，這也是為什麼要使用<code>const &amp;</code>作為函數參數的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<pre><code class="language-cpp">void push_back (const value_type&amp; val);
</code></pre>
<p>如果沒有<code>const</code>，<code>vec.push_back(5)</code>這樣的程式碼就無法編譯通過了。</p>
<h3 id="22-右值引用"><a class="header" href="#22-右值引用"><strong>2.2 右值引用</strong></a></h3>
<p>再看下右值引用，右值引用的標誌是<code>&amp;&amp;</code>，顧名思義，右值引用專門為右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<pre><code class="language-cpp">int &amp;&amp;ref_a_right = 5; // ok
 
int a = 5;
int &amp;&amp;ref_a_left = a; // 編譯不過，右值引用不可以指向左值
 
ref_a_right = 6; // 右值引用的用途：可以修改右值
</code></pre>
<h3 id="23-對左右值引用本質的討論"><a class="header" href="#23-對左右值引用本質的討論"><strong>2.3 對左右值引用本質的討論</strong></a></h3>
<p>下邊的論述比較複雜，也是本文的核心，對理解這些概念非常重要。</p>
<h3 id="231-右值引用有辦法指向左值嗎"><a class="header" href="#231-右值引用有辦法指向左值嗎"><strong>2.3.1 右值引用有辦法指向左值嗎？</strong></a></h3>
<p>有辦法，<code>std::move</code>：</p>
<pre><code class="language-cpp">int a = 5; // a是個左值
int &amp;ref_a_left = a; // 左值引用指向左值
int &amp;&amp;ref_a_right = std::move(a); // 通過std::move將左值轉化為右值，可以被右值引用指向
 
cout &lt;&lt; a; // 列印結果：5
</code></pre>
<p>在上邊的程式碼裡，看上去是左值a通過std::move移動到了右值ref_a_right中，那是不是a裡邊就沒有值了？並不是，列印出a的值仍然是5。</p>
<p><code>std::move</code>是一個非常有迷惑性的函數，不理解左右值概念的人們往往以為它能把一個變數裡的內容移動到另一個變數，<strong>但事實上std::move移動不了什麼，唯一的功能是把左值強制轉化為右值</strong>，讓右值引用可以指向左值。其實現等同於一個類型轉換：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>單純的std::move(xxx)不會有性能提升</strong>，std::move的使用場景在第三章會講。</p>
<p>同樣的，右值引用能指向右值，本質上也是把右值提升為一個左值，並定義一個右值引用通過std::move指向該左值：</p>
<pre><code class="language-cpp">int &amp;&amp;ref_a = 5;
ref_a = 6; 
 
等同於以下程式碼：
 
int temp = 5;
int &amp;&amp;ref_a = std::move(temp);
ref_a = 6;
</code></pre>
<h3 id="232-左值引用右值引用本身是左值還是右值"><a class="header" href="#232-左值引用右值引用本身是左值還是右值"><strong>2.3.2 左值引用、右值引用本身是左值還是右值？</strong></a></h3>
<p><strong>被聲明出來的左、右值引用都是左值</strong>。 因為被聲明出的左右值引用是有地址的，也位於等號左邊。仔細看下邊程式碼：</p>
<pre><code class="language-cpp">// 形參是個右值引用
void change(int&amp;&amp; right_value) {
    right_value = 8;
}
 
int main() {
    int a = 5; // a是個左值
    int &amp;ref_a_left = a; // ref_a_left是個左值引用
    int &amp;&amp;ref_a_right = std::move(a); // ref_a_right是個右值引用
 
    change(a); // 編譯不過，a是左值，change參數要求右值
    change(ref_a_left); // 編譯不過，左值引用ref_a_left本身也是個左值
    change(ref_a_right); // 編譯不過，右值引用ref_a_right本身也是個左值
     
    change(std::move(a)); // 編譯通過
    change(std::move(ref_a_right)); // 編譯通過
    change(std::move(ref_a_left)); // 編譯通過
 
    change(5); // 當然可以直接接右值，編譯通過
     
    cout &lt;&lt; &amp;a &lt;&lt; ' ';
    cout &lt;&lt; &amp;ref_a_left &lt;&lt; ' ';
    cout &lt;&lt; &amp;ref_a_right;
    // 列印這三個左值的地址，都是一樣的
}
</code></pre>
<p>看完後你可能有個問題，std::move會返回一個右值引用<code>int &amp;&amp;</code>，它是左值還是右值呢？ 從表示式<code>int &amp;&amp;ref = std::move(a)</code>來看，右值引用<code>ref</code>指向的必須是右值，所以move返回的<code>int &amp;&amp;</code>是個右值。所以右值引用既可能是左值，又可能是右值嗎？ 確實如此：<strong>右值引用既可以是左值也可以是右值，如果有名稱則為左值，否則是右值</strong>。</p>
<p>或者說：<strong>作為函數返回值的 &amp;&amp; 是右值，直接聲明出來的 &amp;&amp; 是左值</strong>。 這同樣也符闔第一章對左值，右值的判定方式：其實引用和普通變數是一樣的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>沒有什麼區別，等號左邊就是左值，右邊就是右值。</p>
<p>最後，從上述分析中我們得到如下結論：</p>
<ol>
<li><strong>從性能上講，左右值引用沒有區別，傳參使用左右值引用都可以避免複製。</strong></li>
<li><strong>右值引用可以直接指向右值，也可以通過std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li>
<li><strong>作為函數形參時，右值引用更靈活。雖然const左值引用也可以做到左右值都接受，但它無法修改，有一定侷限性。</strong></li>
</ol>
<pre><code class="language-cpp">void f(const int&amp; n) {
    n += 1; // 編譯失敗，const左值引用不能修改指向變數
}

void f2(int &amp;&amp; n) {
    n += 1; // ok
}

int main() {
    f(5);
    f2(5);
}
</code></pre>
<h3 id="3-右值引用和stdmove的應用場景"><a class="header" href="#3-右值引用和stdmove的應用場景"><strong>3. 右值引用和std::move的應用場景</strong></a></h3>
<p>按上文分析，<code>std::move</code>只是類型轉換工具，不會對性能有好處；右值引用在作為函數形參時更具靈活性，看上去還是挺雞肋的。他們有什麼實際應用場景嗎？</p>
<h3 id="31-實現移動語義"><a class="header" href="#31-實現移動語義"><strong>3.1 實現移動語義</strong></a></h3>
<p>在實際場景中，右值引用和std::move被廣泛用於在STL和自訂類中<strong>實現移動語義，避免複製，從而提升程序性能</strong>。 在沒有右值引用之前，一個簡單的陣列類通常實現如下，有<code>建構函式</code>、<code>複製建構函式</code>、<code>賦值運算子多載</code>、<code>解構函式</code>等。深複製/淺複製在此不做講解。</p>
<pre><code class="language-cpp">class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深複製構造
    Array(const Array&amp; temp_array) {
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i &lt; size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
     
    // 深複製賦值
    Array&amp; operator=(const Array&amp; temp_array) {
        delete[] data_;
 
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i &lt; size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
 
    ~Array() {
        delete[] data_;
    }
 
public:
    int *data_;
    int size_;
};
</code></pre>
<p>該類的複製建構函式、賦值運算子多載函數已經通過使用左值引用傳參來避免一次多餘複製了，但是內部實現要深複製，無法避免。 這時，有人提出一個想法：是不是可以提供一個<code>移動建構函式</code>，把被複製者的資料移動過來，被複製者後邊就不要了，這樣就可以避免深複製了，如：</p>
<pre><code class="language-cpp">class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深複製構造
    Array(const Array&amp; temp_array) {
        ...
    }
     
    // 深複製賦值
    Array&amp; operator=(const Array&amp; temp_array) {
        ...
    }
 
    // 移動建構函式，可以淺複製
    Array(const Array&amp; temp_array, bool move) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 為防止temp_array析構時delete data，提前置空其data_      
        temp_array.data_ = nullptr;
    }
     
 
    ~Array() {
        delete [] data_;
    }
 
public:
    int *data_;
    int size_;
};
</code></pre>
<p>這麼做有2個問題：</p>
<ul>
<li>不優雅，表示移動語義還需要一個額外的參數(或者其他方式)。</li>
<li>無法實現！<code>temp_array</code>是個const左值引用，無法被修改，所以<code>temp_array.data_ = nullptr;</code>這行會編譯不過。當然函數參數可以改成非const：<code>Array(Array&amp; temp_array, bool move){...}</code>，這樣也有問題，由於左值引用不能接右值，<code>Array a = Array(Array(), true);</code>這種呼叫方式就沒法用了。</li>
</ul>
<p>可以發現左值引用真是用的很不爽，<strong>右值引用的出現解決了這個問題</strong>，在STL的很多容器中，都實現了以<strong>右值引用為參數</strong>的<code>移動建構函式</code>和<code>移動賦值多載函數</code>，或者其他函數，最常見的如std::vector的<code>push_back</code>和<code>emplace_back</code>。參數為左值引用意味著複製，為右值引用意味著移動。</p>
<pre><code class="language-cpp">class Array {
public:
    ......
 
    // 優雅
    Array(Array&amp;&amp; temp_array) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 為防止temp_array析構時delete data，提前置空其data_      
        temp_array.data_ = nullptr;
    }
     
 
public:
    int *data_;
    int size_;
};
</code></pre>
<p>如何使用：</p>
<pre><code class="language-cpp">// 例1：Array用法
int main(){
    Array a;
 
    // 做一些操作
    .....
     
    // 左值a，用std::move轉化為右值
    Array b(std::move(a));
}
</code></pre>
<h3 id="32-實例vectorpush_back使用stdmove提高性能"><a class="header" href="#32-實例vectorpush_back使用stdmove提高性能"><strong>3.2 實例：vector::push_back使用std::move提高性能</strong></a></h3>
<pre><code class="language-cpp">// 例2：std::vector和std::string的實際例子
int main() {
    std::string str1 = &quot;aacasxs&quot;;
    std::vector&lt;std::string&gt; vec;
     
    vec.push_back(str1); // 傳統方法，copy
    vec.push_back(std::move(str1)); // 呼叫移動語義的push_back方法，避免複製，str1會失去原有值，變成空字串
    vec.emplace_back(std::move(str1)); // emplace_back效果相同，str1會失去原有值
    vec.emplace_back(&quot;axcsddcas&quot;); // 當然可以直接接右值
}
 
// std::vector方法定義
void push_back (const value_type&amp; val);
void push_back (value_type&amp;&amp; val);
 
void emplace_back (Args&amp;&amp;... args);
</code></pre>
<p>在vector和string這個場景，加個<code>std::move</code>會呼叫到移動語義函數，避免了深複製。</p>
<p>除非設計不允許移動，STL類大都支援移動語義函數，即<code>可移動的</code>。 另外，編譯器會<strong>默認</strong>在使用者自訂的<code>class</code>和<code>struct</code>中生成移動語義函數，但前提是使用者沒有主動定義該類的<code>複製構造</code>等函數(具體規則自行百度哈)。 <strong>因此，可移動對像在&lt;需要複製且被複製者之後不再被需要&gt;的場景，建議使用</strong><code>std::move</code><strong>觸發移動語義，提升性能。</strong></p>
<pre><code class="language-cpp">moveable_objecta = moveable_objectb; 
改為： 
moveable_objecta = std::move(moveable_objectb);
</code></pre>
<p>還有些STL類是<code>move-only</code>的，比如<code>unique_ptr</code>，這種類只有移動建構函式，因此只能移動(轉移內部對像所有權，或者叫淺複製)，不能複製(深複製):</p>
<pre><code class="language-cpp">std::unique_ptr&lt;A&gt; ptr_a = std::make_unique&lt;A&gt;();

std::unique_ptr&lt;A&gt; ptr_b = std::move(ptr_a); // unique_ptr只有‘移動賦值多載函數‘，參數是&amp;&amp; ，只能接右值，因此必須用std::move轉換類型

std::unique_ptr&lt;A&gt; ptr_b = ptr_a; // 編譯不通過
</code></pre>
<p><strong>std::move本身只做類型轉換，對性能無影響。</strong> <strong>我們可以在自己的類中實現移動語義，避免深複製，充分利用右值引用和std::move的語言特性。</strong></p>
<h3 id="4-完美轉發-stdforward"><a class="header" href="#4-完美轉發-stdforward"><strong>4. 完美轉發 std::forward</strong></a></h3>
<p>和<code>std::move</code>一樣，它的兄弟<code>std::forward</code>也充滿了迷惑性，雖然名字含義是轉發，但他並不會做轉發，同樣也是做類型轉換.</p>
<p>與move相比，forward更強大，move只能轉出來右值，forward都可以。</p>
<blockquote>
<p>std::forward<T>(u)有兩個參數：T與 u。 a. 當T為左值引用類型時，u將被轉換為T類型的左值； b. 否則u將被轉換為T類型右值。</p>
</blockquote>
<p>舉個例子，有main，A，B三個函數，呼叫關係為：<code>main-&gt;A-&gt;B</code>，建議先看懂<em>2.3節對左右值引用本身是左值還是右值的討論</em>再看這裡：</p>
<pre><code class="language-cpp">void B(int&amp;&amp; ref_r) {
    ref_r = 1;
}
 
// A、B的入參是右值引用
// 有名字的右值引用是左值，因此ref_r是左值
void A(int&amp;&amp; ref_r) {
    B(ref_r);  // 錯誤，B的入參是右值引用，需要接右值，ref_r是左值，編譯失敗
     
    B(std::move(ref_r)); // ok，std::move把左值轉為右值，編譯通過
    B(std::forward&lt;int&gt;(ref_r));  // ok，std::forward的T是int類型，屬於條件b，因此會把ref_r轉為右值
}
 
int main() {
    int a = 5;
    A(std::move(a));
}
</code></pre>
<p>例2：</p>
<pre><code class="language-cpp">void change2(int&amp;&amp; ref_r) {
    ref_r = 1;
}
 
void change3(int&amp; ref_l) {
    ref_l = 1;
}
 
// change的入參是右值引用
// 有名字的右值引用是 左值，因此ref_r是左值
void change(int&amp;&amp; ref_r) {
    change2(ref_r);  // 錯誤，change2的入參是右值引用，需要接右值，ref_r是左值，編譯失敗
     
    change2(std::move(ref_r)); // ok，std::move把左值轉為右值，編譯通過
    change2(std::forward&lt;int &amp;&amp;&gt;(ref_r));  // ok，std::forward的T是右值引用類型(int &amp;&amp;)，符合條件b，因此u(ref_r)會被轉換為右值，編譯通過
     
    change3(ref_r); // ok，change3的入參是左值引用，需要接左值，ref_r是左值，編譯通過
    change3(std::forward&lt;int &amp;&gt;(ref_r)); // ok，std::forward的T是左值引用類型(int &amp;)，符合條件a，因此u(ref_r)會被轉換為左值，編譯通過
    // 可見，forward可以把值轉換為左值或者右值
}
 
int main() {
    int a = 5;
    change(std::move(a));
}
</code></pre>
<p>上邊的示例在日常程式設計中基本不會用到，<code>std::forward</code>最主要運於範本程式設計的參數轉發中，想深入瞭解需要學習<code>萬能引用(T &amp;&amp;)</code>和<code>引用摺疊(eg:&amp; &amp;&amp; → ?)</code>等知識，本文就不詳細介紹這些了。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>私以為個人的技術水平應該是一個螺旋式上升的過程：先從書本去瞭解一個大概，然後在實踐中加深對相關知識的理解，遇到問題後再次回到書本，然後繼續實踐……接觸C++並行程式設計已經一年多，從慢慢啃《C++並行程式設計實戰》這本書開始，不停在期貨高頻交易軟體的開發實踐中去理解、運用、最佳化多執行緒相關技術。多執行緒知識的學習也是先從最基本的執行緒建立、互斥鎖、條件變數到更高級的執行緒安全資料結構、執行緒池等等技術，當然在項目中也用到了簡單的無鎖程式設計相關知識，今天把一些體會心得跟大家分享一下，如有錯誤，還望大家批評指正。</p>
<h2 id="多執行緒並行讀寫"><a class="header" href="#多執行緒並行讀寫">多執行緒並行讀寫</a></h2>
<p>在編寫多執行緒程序時，最重要的問題就是多執行緒間共享資料的保護。多個執行緒之間共享地址空間，所以多個執行緒共享處理程序中的全域變數和堆，都可以對全域變數和堆上的資料進行讀寫，但是如果兩個執行緒同時修改同一個資料，可能造成某執行緒的修改丟失；如果一個執行緒寫的同時，另一個執行緒去讀該資料時可能會讀到寫了一半的資料。這些行為都是執行緒不安全的行為，會造成程式執行邏輯出現錯誤。舉個最簡單的例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int  i = 0;
mutex mut;

void iplusplus() {
    int c = 10000000;  //循環次數
    while (c--) {
        i++;
    }
}
int main()
{
    thread thread1(iplusplus);  //建立並運行執行緒1
    thread thread2(iplusplus);  //建立並運行執行緒2
    thread1.join();  // 等待執行緒1運行完畢
    thread2.join();  // 等待執行緒2運行完畢
    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>上面程式碼main函數中建立了兩個執行緒thread1和thread2，兩個執行緒都是運行iplusplus函數，該函數功能就是運行i++語句10000000次，按照常識，兩個執行緒各對i自增10000000次，最後i的結果應該是20000000，但是運行後結果卻是如下：</p>
<p><img src="c++/images/v2-031d9901f4adb2325eac0efb9380812d_720w.webp" alt="img" /></p>
<p>i並不等於20000000，這是在多執行緒讀寫情況下沒有對執行緒間共享的變數i進行保護所導致的問題。</p>
<h2 id="有鎖程式設計"><a class="header" href="#有鎖程式設計">有鎖程式設計</a></h2>
<p>對於保護多執行緒共享資料，最常用也是最基本的方法就是使用C++11執行緒標準庫提供的互斥鎖mutex保護臨界區，保證同一時間只能有一個執行緒可以獲取鎖，持有鎖的執行緒可以對共享變數進行修改，修改完畢後釋放鎖，而不持有鎖的執行緒阻塞等待直到獲取到鎖，然後才能對共享變數進行修改，這種方法幾乎是並行程式設計中的標準做法。大體流程如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;

using namespace std;
int  i = 0;
mutex mut; //互斥鎖

void iplusplus() {
    int c = 10000000;  //循環次數
    while (c--) {
        mut.lock();  //互斥鎖加鎖
        i++;
        mut.unlock(); //互斥鎖解鎖
    }
}
int main()
{
    chrono::steady_clock::time_point start_time = chrono::steady_clock::now();//開始時間
    thread thread1(iplusplus);
    thread thread2(iplusplus);
    thread1.join();  // 等待執行緒1運行完畢
    thread2.join();  // 等待執行緒2運行完畢
    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;
    chrono::steady_clock::time_point stop_time = chrono::steady_clock::now();//結束時間
    chrono::duration&lt;double&gt; time_span = chrono::duration_cast&lt;chrono::microseconds&gt;(stop_time - start_time);
    std::cout &lt;&lt; &quot;共耗時：&quot; &lt;&lt; time_span.count() &lt;&lt; &quot; ms&quot; &lt;&lt; endl; // 耗時
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>程式碼14行和16行分別為互斥鎖加鎖和解鎖程式碼，29行我們列印程式執行耗時，程式碼運行結果如下：</p>
<p><img src="c++/images/v2-2ecdc6816641dec702b50b329d925d13_720w.webp" alt="img" /></p>
<p>可以看到，通過加互斥鎖，i的運行結果是正確的，由此解決了多執行緒同時寫一個資料產生的執行緒安全問題，程式碼總耗時3.37328ms。</p>
<h2 id="無鎖程式設計"><a class="header" href="#無鎖程式設計">無鎖程式設計</a></h2>
<p>原子操作是無鎖程式設計的基石，原子操作是不可分隔的操作，一般通過CAS(Compare and
Swap)操作實現，CAS操作需要輸入兩個數值，一個舊值（期望操作前的值）和一個新值，在操作期間先比較下舊值有沒有發生變化，如果沒有發生變化，才交換成新值，發生了變化則不交換。C++11的執行緒庫為我們提供了一系列原子類型，同時提供了相對應的原子操作，我們通過使用這些原子類型即可擺脫每次對共享變數進行操作都進行的加鎖解鎖動作，節省了系統開銷，同時避免了執行緒因阻塞而頻繁的切換。原子類型的基本使用方法如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;

using namespace std;
atomic&lt;int&gt; i = 0;

void iplusplus() {
    int c = 10000000;  //循環次數
    while (c--) {
        i++;
    }
}
int main()
{
    chrono::steady_clock::time_point start_time = chrono::steady_clock::now();//開始時間
    thread thread1(iplusplus);
    thread thread2(iplusplus);
    thread1.join();  // 等待執行緒1運行完畢
    thread2.join();  // 等待執行緒2運行完畢
    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;
    chrono::steady_clock::time_point stop_time = chrono::steady_clock::now();//結束時間
    chrono::duration&lt;double&gt; time_span = chrono::duration_cast&lt;chrono::microseconds&gt;(stop_time - start_time);
    std::cout &lt;&lt; &quot;共耗時：&quot; &lt;&lt; time_span.count() &lt;&lt; &quot; ms&quot; &lt;&lt; endl; // 耗時
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>程式碼的第8行定義了一個原子類型（int）變數i，在第13行多執行緒修改i的時候即可免去加鎖和解鎖的步驟，同時又能保證變數i的執行緒安全性。程式碼運行結果如下：</p>
<p><img src="c++/images/v2-3b9ca8e34703c8daa7493486f01cbcbe_720w.webp" alt="img" /></p>
<p>可以看到i的值是符合預期的，程式碼運行總耗時1.12731ms，僅為有鎖程式設計的耗時3.37328ms的1/3，由此可以看出無鎖程式設計由於避免了加鎖而相對於有鎖程式設計提高了一定的性能。</p>
<h2 id="總結-1"><a class="header" href="#總結-1">總結</a></h2>
<p>無鎖程式設計最大的優勢是什麼？是性能提高嗎？其實並不是，我們的測試程式碼中臨界區非常短，只有一個語句，所以顯得加鎖解鎖操作對程序性能影響很大，但在實際應用中，我們的臨界區一般不會這麼短，臨界區越長，加鎖和解鎖操作的性能損耗越微小，無鎖程式設計和有鎖程式設計之間的性能差距也就越微小。</p>
<p>我認為無鎖程式設計最大的優勢在於兩點：</p>
<ol>
<li>避免了死鎖的產生。由於無鎖程式設計避免了使用鎖，所以也就不會出現並行程式設計中最讓人頭疼的死鎖問題，對於提高程序健壯性有很大積極意義</li>
<li>程式碼更加清晰與簡潔。對於一個多執行緒共享的變數，保證其安全性我們只需在聲明時將其聲明為原子類型即可，在程式碼中使用的時候和使用一個普通變數一樣，而不用每次使用都要在前面寫個加鎖操作，在後面寫一個解鎖操作。我寫的C++期貨高頻交易軟體中，有一個全域變數fund，儲存的是當前資金量，程序採用執行緒池運行交易策略，交易策略中頻繁使用到fund變數，如果採用加鎖的方式，使用起來極其繁瑣，為了保護一個fund變數需要非常頻繁的加鎖解鎖，後來將fund變數改為原子類型，後面使用就不用再考慮加鎖問題，整個程序閱讀起來清晰很多。</li>
</ol>
<p>如果是為了提高性能將程序大幅改寫成無鎖程式設計，一般來說結果可能會讓我們失望，而且無鎖程式設計裡面需要注意的地方也非常多，比如ABA問題，記憶體順序問題，正確實現無鎖程式設計比實現有鎖程式設計要困難很多，除非有必要（確定了性能瓶頸）才去考慮使用無鎖程式設計，否則還是使用互斥鎖更好，畢竟程序的高性能是建立在程序正確性的基礎上，如果程序不正確，一切性能提升都是徒勞無功。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-為核心語言的高頻交易系統是如何做到低延遲"><a class="header" href="#c-為核心語言的高頻交易系統是如何做到低延遲">C++ 為核心語言的高頻交易系統是如何做到低延遲？</a></h1>
<p>出處：https://kknews.cc/tech/bozorm9.amp</p>
<p>問題中限定語言是C++，可討論的範圍就比較精簡了。現有的答案都在談系統架構層次上的東西，略顯跑題。我對C++瞭解不多，但我嘗試以一名C++程式設計師的視角，從基本思路出發做一個分析，拋磚引玉。</p>
<p>首先我們要明確係統的需求。所謂交易系統，從一個應用程式的角度來說，有以下幾個特點：</p>
<ol>
<li>一定是一個網絡相關的應用，假如機器沒聯網，肯定什麼交易也幹不了。所以系統需要通過TCP/IP連接來收發數據。數據要分兩種，一種從交易所發過來的市場數據，流量很大，另一種是系統向交易所發出的交易指令，相比前者流量很小，這兩種數據需要在不同的TCP/IP連接裡傳輸。</li>
<li>因為是自動化交易系統，人工幹預的部分肯定比較小，所以圖形界面不是重點。而為了性能考慮，圖形界面需要和後臺分開部署在不同的機器上，通過網絡交互，以免任何圖形界面上的問題導致後臺系統故障或者被搶佔資源。這樣又要在後臺增加新的TCP/IP連接。</li>
<li>高頻交易系統對延遲異常敏感，目前（2014）市面上的主流系統（可以直接買到的大眾系統）延遲至少在100微秒級別，頂尖的系統（HFT專有）可以做到10微秒以下。其他答案裡提到C++隨便寫寫延遲做到幾百微秒，是肯定不行的，這樣的性能對於高頻交易來說會是一場災難。</li>
<li>系統只需要專注於處理自己收到的數據，不需要和其他機器合作，不需要擔心流量過載。</li>
</ol>
<p>有了以上幾點基本的認識，我們可以看看用C++做為開發語言有哪些需要注意的。</p>
<p>首先前兩點需求就決定了，這種系統一定是一個多線程程序。雖然對於圖形界面來說，後臺系統相當於一個服務端，但這部分的性能不是重點，用常用的模式就能解決。而重要的面向交易所那端，系統其實是一個客戶端程序，只需要維護好固定數量的連接就可以了。為延遲考慮，一定要選擇異步I/O（阻塞的同步I/O會消耗時間在上下文切換），這裡有兩點需要注意：</p>
<ul>
<li>是否可以在單線程內完成所有處理？考慮市場數據的流量遠遠高於發出的交易指令，在單線程內處理顯然是不行的，否則可能收了一大堆數據還沒開始處理，錯過了發指令的最佳時機。</li>
<li>有答案提到要壓低平時的資源使用率，這是完全錯誤的設計思路。問題同樣出在上下文切換上，一旦系統進入IDLE狀態，再重新切換回處理模式是要付出時間代價的。正確的做法是保持對異步socket的瘋狂輪詢，一旦有消息就立刻處理，之後繼續輪詢，這樣是最快的處理方式。（順帶一提現在的CPU一般會帶有環保功能，使用率低了會導致CPU進入低功耗模式，同樣對性能有嚴重影響。真正的低延遲系統一定是永遠發燙的！）</li>
</ul>
<p>現在我們知道核心的模塊是一個多線程的，處理多個TCP/IP連接的模塊，接下來就可以針對C++進行討論。因為需要對接受到的每個TCP或UDP包進行處理，首先要考慮的是如何把包從接收線程傳遞給處理線程。我們知道C++是面向對象的語言，一般情況下最直觀的思路是創建一個對象，然後發給處理線程，這樣從邏輯上看是非常清晰的。但在追求低延遲的系統裡不能這樣做，因為對象是分配在堆上的，而堆的內存結構對我們來說是完全不透明的，沒辦法控制一個對象會具體分到內存的什麼位置上，這直接導致的問題是本來連續收到的網絡包，在內存裡的分佈是分散的，當處理線程需要讀取數據時就會發生大量的cache miss，產生不可控的延遲。所以對C++開發者來說，第一條需要謹記的應該是，不要隨便使用堆（用關鍵字new）。核心的數據要保證分配在連續內存裡。</p>
<p>另一個問題在於，市場數據和交易指令都是結構化的，包含了股票名稱，價格，時間等一系列信息。如果使用C++ class來對數據進行建模和封裝，同樣會產生不可知的內存結構。為了嚴格控制內存結構，應該使用struct來封裝。一方面在對接收到的數據解析時可以直接定義名稱，一方面在分配新對象（比如交易指令）時可以保證所有數據都分配在連續的內存區域。</p>
<p>以上兩點是關於延遲方面最重要的注意事項。除此之外，需要考慮的是業務邏輯的編寫。高頻交易系統裡註定了業務邏輯不會太複雜，但重要的是要保證正確性和避免指針錯誤。正確性應該可以藉助於C++的特性比如強類型，模板等來加強驗證，這方面我不熟悉就不多說了。高頻系統往往運行時要處理大量訂單，所以一定要保證系統運行時不能崩潰，一旦coredump後果很嚴重。這個問題也許可以多做編譯期靜態分析來加強，或者需要在系統外增加安全機制，這裡不展開討論了。</p>
<p>以下是幾點引申思考：</p>
<ul>
<li>如何存儲系統日誌？</li>
<li>如何對系統進行實時監控？</li>
<li>如果系統coredump，事後如何分析找出問題所在？</li>
<li>如何設計保證系統可用性，使得出現coredump之類的情況時可以及時切換到備用系統？</li>
</ul>
<p>這些問題相信在C++框架內都有合適的解決方案，我對此瞭解不多，所以只列在這裡供大家討論。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="risc-v-指令集分析"><a class="header" href="#risc-v-指令集分析">RISC-V 指令集分析</a></h2>
<p>出處：https://ithelp.ithome.com.tw/articles/10257457</p>
<p>有了基本檔案架構後，開始動工指令的部分。RISC-V將指令分成數個子集，其中包括RV32I、RV32E、RV64I、RV128I四套整數指令集，以及約14套擴充指令集，雖然號稱&quot;精簡&quot;，最基本的RV32I指令集也有47條指令，實作的effort也是不小。為了能有的放矢的進行實作，目前打算先以實際編譯出來最常用的指令開始處理。</p>
<p>為了觀察實際上compiler常用的指令，需要先取得RISC-V的<a href="https://github.com/riscv/riscv-gnu-toolchain/releases">GNU toolchain</a>，由於目前只打算支援riscv32架構，因此使用的是riscv32-elf-ubuntu-20.04-nightly-2021.06.26-nightly.tar.gz這個版本的toolchain。解壓縮後在riscv/bin資料夾下就可以找到gcc、objdump等常用工具。首先撰寫一個最基本的C程式：</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>使用gcc編譯，並使用odjbump得到完整的assembly：</p>
<pre><code class="language-bash">riscv/bin/riscv32-unknown-elf-gcc -o main.elf main.c
riscv/bin/riscv32-unknown-elf-objdump -D -M no-aliases main.elf &gt; main.asm
</code></pre>
<p>觀察入口點<code>_start</code>的assembly：</p>
<pre><code class="language-armasm">00010084 &lt;_start&gt;:
   10084:   00002197            auipc   gp,0x2
   10088:   b5c18193            addi    gp,gp,-1188 # 11be0 &lt;__global_pointer$&gt;
   1008c:   c3418513            addi    a0,gp,-972 # 11814 &lt;completed.1&gt;
   10090:   c5018613            addi    a2,gp,-944 # 11830 &lt;__BSS_END__&gt;
   10094:   8e09                    c.sub   a2,a0
   10096:   4581                    c.li    a1,0
   10098:   2209                    c.jal   1019a &lt;memset&gt;
   1009a:   00000517            auipc   a0,0x0
   1009e:   26650513            addi    a0,a0,614 # 10300 &lt;atexit&gt;
   100a2:   c511                    c.beqz  a0,100ae &lt;_start+0x2a&gt;
   100a4:   00000517            auipc   a0,0x0
   100a8:   26650513            addi    a0,a0,614 # 1030a &lt;__libc_fini_array&gt;
   100ac:   2c91                    c.jal   10300 &lt;atexit&gt;
   100ae:   2049                    c.jal   10130 &lt;__libc_init_array&gt;
   100b0:   4502                    c.lwsp  a0,0(sp)
   100b2:   004c                    c.addi4spn  a1,sp,4
   100b4:   4601                    c.li    a2,0
   100b6:   2881                    c.jal   10106 &lt;main&gt;
   100b8:   a8b9                    c.j 10116 &lt;exit&gt;
</code></pre>
<p>可以發現除了一般的RV32I外，其中為了降低code size大量使用了<code>c.</code>開頭的壓縮指令標準擴充(Standard Extension for Compressed Instructions)，因此也必須實作擴充指令集C。</p>
<p>至此已經有一個明顯的目標，就是將此ELF檔能順利跑完，並且能正確的更新所有的整數register以及PC。為達成此目標，指令實作的順序就以從<code>_start</code>開始執行的指令為準。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在qemu上執行64-bit-risc-v-linux"><a class="header" href="#在qemu上執行64-bit-risc-v-linux">在QEMU上執行64 bit RISC-V Linux</a></h1>
<p>出處: https://medium.com/swark/%E5%9C%A8qemu%E4%B8%8A%E5%9F%B7%E8%A1%8C64-bit-risc-v-linux-2a527a078819</p>
<p>本篇文章主要是用來記錄我的學習紀錄，嘗試在Virtual box上以Ubuntu 20.04 (kernel版本:5.4.0–54-generic) 來安裝QEMU並執行RISC-V Linux。</p>
<p>先列出本篇文章的重要參考對象
[1]https://ithelp.ithome.com.tw/articles/10192454
[2]https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html
[3]https://zhuanlan.zhihu.com/p/258394849</p>
<p>那麼就開始吧
首先我從設定路徑開始
一般的教學都會建議安裝設定如下
$ export RISCV=/opt/riscv
但像我自己是全部安裝在桌面上的資料夾之中
$export RISCV=/home/swark_riscv/Desktop/Riscv
*需要注意的是export的路徑，每次重開機後都會消失需要重設，不過也可以修改 &quot;/etc/profile&quot;，在其中加入export的環境變數，如此一來重開機之後都會存在。</p>
<h1 id="安裝-riscv-gnu-toolchain"><a class="header" href="#安裝-riscv-gnu-toolchain">安裝 riscv-gnu-toolchain</a></h1>
<p>建議先進入github riscv-gnu-toolchain中的README.md上閱讀一下，
可以看到Prerequisites中有提及有些需要先安裝的packages。</p>
<p>像我是使用ubuntu所以必須先用以下指令安裝所需packages</p>
<pre><code>sudo apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
</code></pre>
<p>接著我們開始安裝<a href="https://github.com/riscv/riscv-gnu-toolchain">riscv-gnu-toolchain</a></p>
<pre><code>git clone https://github.com/riscv/riscv-gnu-toolchain
cd riscv-gnu-toolchain
git submodule update — init — recursive  //update整包code
./configure --prefix=$RISCV
make linux &amp;&amp; make install //安裝Linux ABI(Application binary interface) 專用的toolchain
make &amp;&amp; make install //安裝 bare metal 專用的toolchain
</code></pre>
<p>*如果是用實體機器來建置環境的人，可以在make後用-j&lt;核心數&gt;，來決定要用幾核來build，比如make -j 4 (表示使用四核心)</p>
<p>安裝完畢後，導出toolcahin的安裝路徑
export PATH=$PATH:$RISCV/bin
順便測試以&quot;riscv64-unknown-linux-gnu-gcc -v&quot;是否安裝成功</p>
<p><img src="riscv/images/1*uQnlpQ0ElOrZyTAUL_r4kg.png" alt="img" /></p>
<h1 id="busybox的安裝"><a class="header" href="#busybox的安裝">Busybox的安裝</a></h1>
<p>先退回原工作目錄，比如我是Desktop下的Riscv</p>
<pre><code>git clone https://git.busybox.net/busybox
cd busybox
CROSS_COMPILE=riscv64-unknown-linux-gnu- make menuconfig
CROSS_COMPILE=riscv64-unknown-linux-gnu- make -j 4
CROSS_COMPILE=riscv64-unknown-linux-gnu- make install
</code></pre>
<p>make meunconfig中請做以下設定
選擇 Busybox Settings&gt;&gt;Build BusyBox as Static binary 為y</p>
<p><img src="riscv/images/1*vIDVfCc4W1RmNk9AXnvkgg.png" alt="img" /></p>
<p>*如果遇到以下問題</p>
<pre><code>make menuconfig HOSTCC scripts/kconfig/lxdialog/checklist.o &lt;command-line&gt;: fatal error: curses.h: No such file or directory compilation terminated. make[2]: *** [scripts/Makefile.host:120: scripts/kconfig/lxdialog/checklist.o] Error 1 make[1]: *** [/home/swark_riscv/Desktop/Riscv/busybox-1.27.2/scripts/kconfig/Makefile:14: menuconfig] Error 2 make: *** [Makefile:444: menuconfig] Error 2
</code></pre>
<p>我搜尋到的解法是去安裝ncurses，如下，則可解決</p>
<pre><code>sudo apt-get install libncurses5-dev
</code></pre>
<h1 id="編譯linux"><a class="header" href="#編譯linux">編譯Linux</a></h1>
<p>退回原工作目錄，
另外目前官方的Linux中已經包含了Risc-V的支援，
因此請直接
git clone https://github.com/torvalds/linux</p>
<p>接著步驟如下</p>
<pre><code>git checkout v5.4 make ARCH=riscv CROSS_COMPILE=$RISCV/bin/riscv64-unknown-linux-gnu- defconfig //配置config
make ARCH=riscv CROSS_COMPILE=$RISCV/bin/riscv64-unknown-linux-gnu- -j 4 //編譯
</code></pre>
<h1 id="編譯qemu"><a class="header" href="#編譯qemu">編譯QEMU</a></h1>
<pre><code>git clone https://github.com/qemu/qemu
cd qemu
git checkout v5.1.0
./configure --target-list=riscv64-softmmu --prefix=$RISCV/qemu
make -j $(nproc)
sudo make install
</code></pre>
<p>*可能遭遇問題</p>
<pre><code>ERROR: glib-2.48 gthread-2.0 is required to compile QEMU 
⇒sudo apt-get install libglib2.0-devERROR: pixman &gt;= 0.21.8 not present.
Please install the pixman devel package.
⇒sudo apt-get install libpixman-1-dev
</code></pre>
<p>導出Qemu的安裝目錄
export PATH=$PATH:$RISCV/qemu/bin
測試Qemu是否安裝成功</p>
<p><img src="riscv/images/1*94_Q2B83b4NA1RnKWaLPAA.png" alt="img" /></p>
<h1 id="製作開機用的rootfs"><a class="header" href="#製作開機用的rootfs">製作開機用的rootfs</a></h1>
<pre><code>qemu-img create rootfs.img 1g
mkfs.ext4 rootfs.img
mkdir rootfs
sudo mount -o loop rootfs.img  rootfs
cd rootfs
sudo cp -r ../busyboxsource/_install/* .
sudo mkdir proc sys dev etc etc/init.dcd etc/init.d/
sudo touch rcS
sudo vi rcS
</code></pre>
<p>rcS內容如下</p>
<pre><code>#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
</code></pre>
<p>並且修改rcS權限
<code>sudo chmod +x rcS</code></p>
<p>最後解除掛載即可
<code>sudo umount rootfs</code></p>
<p>另外如果是透過[1]的文章去製作rootfs的話，我建議在
cp -r $RISCV/sysroot $RISCV/rootfs中改成
cp -r $RISCV/sysroot $RISCV/rootfs_backup，
並且參考上述步驟，掛載rootfs後再將rootfs_backup內容copy進掛載的目錄中，我最後是透過這個方式才成功。</p>
<p>最後我們可以透過Qemu來執行64 bit RISC-V Linux，
請用以下指令</p>
<pre><code>qemu-system-riscv64 -M virt -m 256M -nographic -kernel linux/arch/riscv/boot/Image -drive file=rootfs.img,format=raw,id=hd0  -device virtio-blk-device,drive=hd0 -append &quot;root=/dev/vda rw console=ttyS0&quot;
</code></pre>
<p><img src="riscv/images/1*ty_AyiBT7I2yXN2e7tEadw.png" alt="img" /></p>
<p><img src="riscv/images/1*P3u4b9gW1tPmj1817Qlh1w.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-安裝-centos-7"><a class="header" href="#docker-安裝-centos-7">Docker 安裝 Centos 7</a></h1>
<pre><code class="language-sh">docker search centos
docker pull centos:7.5.1804
docker run -itd --privileged=true -p 20010:22 --name=&quot;centos&quot; centos:7.5.1804  /usr/sbin/init
docker exec -it centos bash
cat /etc/redhat-release
</code></pre>
<pre><code class="language-sh">yum install java-1.8.0-openjdk  vim
java -version
</code></pre>
<ul>
<li>vim /etc/yum.repos.d/cassandra.repo</li>
</ul>
<pre><code class="language-sh">[cassandra]
name=Apache Cassandra
baseurl=https://www.apache.org/dist/cassandra/redhat/311x/
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://www.apache.org/dist/cassandra/KEYS
</code></pre>
<pre><code class="language-sh">yum update
yum install cassandra
systemctl enable cassandra &amp;&amp;  systemctl restart cassandra

查看
systemctl status cassandra
nodetool status
</code></pre>
<ul>
<li>刪除 cassandra</li>
</ul>
<pre><code>sudo rm -r /var/lib/cassandra
sudo rm -r /var/log/cassandra
sudo yum remove &quot;cassandra-*&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tqdb"><a class="header" href="#tqdb">TQDB</a></h2>
<p>https://github.com/wldtw2008/tqdb/tree/prepareForCulster  &lt;==TQDB 在GitHub的最新版</p>
<p>https://github.com/wldtw2008/tqdb/blob/prepareForCulster/InitialTQDB.readme  &lt;==安裝說明</p>
<p>https://docs.datastax.com/en/cassandra-oss/3.x/cassandra/install/installRHEL.html &lt;== cassandra 安裝</p>
<p>若不需自己安裝，我有已經裝好的VirtualBox的VM 在這裡
https://drive.google.com/open?id=16ZawNAWJNDcGV2jGirviIWzd_EwXlNfe
id:tqdb, pw:tqdb@888, root pw:tqdb@888</p>
<h3 id="遇到問題"><a class="header" href="#遇到問題">遇到問題</a></h3>
<ol>
<li>
<p>MC  8899 沒設定好 ＆ 檢查設定</p>
</li>
<li>
<p>帳號路徑問題 需要依照帳號更改路徑 ex: trad 帳號 </p>
<pre><code class="language-sh">find . -type f -exec sed -i 's|/home/tqdb|/home/trad|g'  {} \;
</code></pre>
</li>
<li>
<p>如果使用python3  script 需要更改因為開發是使用 python2</p>
</li>
<li>
<p>檢查process   ps aux | grep 'tqdb'</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用不同-ssh-金鑰登入-github"><a class="header" href="#使用不同-ssh-金鑰登入-github">使用不同 ssh 金鑰登入 github</a></h2>
<p>在 github 抓取 Repository 時，我們常常用 git ssh 帳號去 clone 一個 Repository，像是：</p>
<pre><code class="language-sh">git clone git@github.com:laravel/laravel.git
</code></pre>
<p>而使用 ssh 去 clone Repository 時，則會需要 <code>ssh 金鑰</code> 才能夠順利的將專案複製下來，但只要有正確的金鑰，我們在每一次對 Repository 進行 clone / push / pull / fetch 的時候，則都不需要輸入帳號密碼即可完成操作（只要你的帳號有足夠的權限的話）</p>
<p>但當我們有個人的專案及公司的專案都在 github 時，且不同的專案所需要的 <code>ssh 金鑰</code> 皆不同時，則需要設定在不同的狀況需要使用不同的金鑰去存取我們的 Repository。</p>
<p>例如 <code>git@github.com:kj/kj.git</code> 需要 <code>id_rsa_kj_personal</code> 的金鑰，但 <code>git@github.com:kj-company/compony-project.git</code> 則需要 <code>id_rsa_kj_company</code> 的金鑰</p>
<p>此時可以使用的解法有下列 2 個</p>
<h2 id="設定-sshconfig-檔案"><a class="header" href="#設定-sshconfig-檔案">設定 .ssh/config 檔案</a></h2>
<p><code>.ssh/config</code> 的設定檔案格式像下方</p>
<pre><code class="language-sh">Host &lt;host_alias&gt;                       # 主機別名
    HostName &lt;hostname_or_ip&gt;           # 主機網址或 ip
    IdentityFile &lt;private_key_path&gt;     # 金鑰位置
</code></pre>
<pre><code class="language-sh">git clone ssh://git@github.com-CryptoTrade/shihyu/CryptoTrade.git
</code></pre>
<p>所以我們可以將 <code>.ssh/config</code> 檔案設定成這樣</p>
<pre><code class="language-sh"># GitHub KJ 個人專案
Host github-kj-personal
    HostName github.com
    IdentityFile ~/.ssh/id_rsa_kj_personal

# GitHub KJ 公司專案
Host github-kj-company
    HostName github.com
    IdentityFile ~/.ssh/id_rsa_kj_company
</code></pre>
<p>設定完 <code>.ssh/config</code> 之後</p>
<p>在存取個人專案的網址會從 <code>git@github.com:kj/kj.git</code> 改成 <code>git@github-kj-personal:kj/kj.git</code></p>
<p>在存取公司專案的網址會從 <code>git@github.com:kj-company/compony-project.git</code> 改成 <code>git@github-kj-company:kj-company/compony-project.git</code></p>
<p>所以複製專案指令會變成</p>
<pre><code class="language-sh">git clone git@github-kj-personal:kj/kj.git
git clone git@github-kj-company:kj-company/compony-project.git
</code></pre>
<p>下列是 git ssh 網址格式說明，所以可以看到我們用 <code>主機別名 Host &lt;host_alias&gt;</code> 將原本的主機名稱改掉</p>
<pre><code class="language-ssh"># 原始網址
git@github.com:&lt;accountname&gt;/&lt;reponame&gt;.git

# 網址格式
git@&lt;host_alias&gt;:&lt;accountname&gt;/&lt;reponame&gt;.git
</code></pre>
<p>當我們存取 <code>github-kj-personal</code> 主機時，根據 <code>.ssh/config</code> 設定，我們會存取到設定的 <code>HostName</code> 為 <code>github.com</code>，使用的金鑰為 <code>~/.ssh/id_rsa_kj_personal</code></p>
<p>當我們存取 <code>github-kj-company</code> 主機時，根據 <code>.ssh/config</code> 設定，我們會存取到設定的 <code>HostName</code> 為 <code>github.com</code>，使用的金鑰為 <code>~/.ssh/id_rsa_kj_company</code></p>
<p>所以這樣設定可以讓我們同時對 github 使用不同的金鑰進行存取</p>
<h2 id="加入臨時的-ssh-金鑰"><a class="header" href="#加入臨時的-ssh-金鑰">加入臨時的 ssh 金鑰</a></h2>
<p>在需要存取公司的 Repository 時，可以將公司的 ssh key 加入，這樣在一段時間內都可以使用此金耀進行存取</p>
<p>在 .bash_profile 可以設定指令的快捷</p>
<pre><code class="language-shell">alias ssh-set-company-key='export GIT_SSH_COMMAND=&quot;ssh -i ~/.ssh/COMPANY_KEY&quot;;
                           export PS1=&quot;${PS1}COMPANY ==&gt; &quot;'
</code></pre>
<p>設定完指令 alias 後，之後需要使用到公司的金鑰時，就可以輸入此指令，就可以存取公司專案了</p>
<h2 id="在-sourcetree-指定不同的金鑰"><a class="header" href="#在-sourcetree-指定不同的金鑰">在 SourceTree 指定不同的金鑰</a></h2>
<p><img src="ssh/./images/create_ssh_mac.gif" alt="" /></p>
<h1 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h1>
<ul>
<li>https://kejyuntw.gitbooks.io/ubuntu-learning-notes/content/network/network-multiple-ssh-key-to-same-github-site.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>語言中的 Socket 是在寫網路程式必會碰到的東西，而它牽涉較多參數與函式，不如 python 簡潔，本篇用於紀錄關於網路程式中 socket 相關的細節</p>
<hr />
<h2 id="0x01-berkeley-socket"><a class="header" href="#0x01-berkeley-socket">0x01 Berkeley Socket</a></h2>
<ul>
<li>Berkeley Socket 又稱 BSD Socket，是介於 Transport Layer 與 Application Layer 間的 API，用於行程間通訊 (UNIX Socket) 和網路通訊 (Network Socket)</li>
</ul>
<p><img src="network/images/course:program:c:c_3.png" alt="" /></p>
<ul>
<li>Connection-oriented socket (TCP)</li>
</ul>
<p><img src="network/images/course:program:c:c_1.png" alt="" />)</p>
<ul>
<li>Connectionless socket (UDP)</li>
</ul>
<p><img src="network/images/course:program:c:c_2.png" alt="" />)</p>
<hr />
<h2 id="0x02-通訊端-api-函式"><a class="header" href="#0x02-通訊端-api-函式">0x02 通訊端 API 函式</a></h2>
<ul>
<li><code>**socket()**</code> 根據指定的 socket type 建立一個新的 socket，為 socket 分配系統資源，並回傳一個 file descriptor</li>
<li><code>**bind()**</code> 一般用於 server 端，用來將一個 socket file descriptor 和一個 sockaddr structure 相關聯，sockaddr 結構中會指出這個 socket (sockfd) 所要監聽的 address, port number 等資訊</li>
<li><code>**listen()**</code> 用於 server 端，使一個 socket (sockfd) 進入監聽狀態</li>
<li><code>**connect()**</code> 用於 client 端，他會透過 sockfd 和 sockaddr structure 向指定的 server 進行直接通訊，如果是連線導向的協定，如 TCP，則 connect function 會先建立起連線</li>
<li><code>**accept()**</code> 用於 server 端，接受一個從 remote client 來的 TCP 連線請求，和 remote client 建立 TCP 連線並將建立的 socket 關連到 sockfd 與 sockaddr</li>
<li><code>**send()**</code>、<code>**recv()**</code>、<code>**write()**</code>、<code>**read()**</code>、<code>**recvfrom()**</code>、<code>**sendto()**</code> 用於傳送與接收資料</li>
<li><code>**close()**</code> 呼叫系統關閉分配的 sockfd，如果是 TCP 則連線會中斷</li>
<li><code>**gethostbyname()**</code>、<code>**gethostbyaddr()**</code> 用來解析 hostname 和 address，IPv4 only</li>
</ul>
<p><strong>socket()</strong></p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
 
int socket(int domain, int type, int protocol);
/* return a file descriptor for the new socket on success, or -1 if error */
</code></pre>
<p>建立一個 communication endpoint，並回傳一個 file descriptor</p>
<ul>
<li><em><strong>domain</strong></em> 為通訊端的協定集
<ul>
<li><strong>AF_INET</strong> 表示 IPv4 網路協定</li>
<li><strong>AF_INET6</strong> 表示 IPv6 網路協定</li>
<li><strong>AF_UNIX</strong> 表示本地端通訊協定</li>
</ul>
</li>
<li><em><strong>type</strong></em>
<ul>
<li><strong>SOCK_STREAM</strong> 提供雙向, 可靠的, 連線導向的串流連線 (TCP)</li>
<li><strong>SOCK_DGRAM</strong> 提供非連線導向的 datagrams 類型 (UDP)</li>
<li><strong>SOCK_SEQPACKET</strong> 提供雙向, 可靠的, 連線導向的 packet 類型</li>
<li><strong>SOCK_RAW</strong> 在 Network Layer 上的原始網路協議</li>
</ul>
</li>
<li><em><strong>protocol</strong></em> 指定實際使用的傳輸協定，在 &lt;netinet/in.h&gt; 有詳細說明。 最常見的就是
<ul>
<li><strong>IPPROTO_TCP</strong></li>
<li><strong>IPPROTO_SCTP</strong></li>
<li><strong>IPPROTO_UDP</strong></li>
<li><strong>IPPROTO_DCCP</strong></li>
<li>可以使用 0，即根據選定的domain和type選擇使用預設協定</li>
</ul>
</li>
</ul>
<p><strong>bind()</strong></p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
 
int bind(int sockfd, const struct sockaddr *address, socklen_t address_len);
/* return 0 for successful; otherwise, -1 if error */
include &lt;netinet/in.h&gt;  
 
struct sockaddr {  
    unsigned short    sa_family;       // 2 bytes address family, AF_xxx  
    char              sa_data[14];     // 14 bytes of protocol address  
};  
 
// IPv4 AF_INET sockets:  
 
struct sockaddr_in {  
    short            sin_family;       // 2 bytes e.g. AF_INET, AF_INET6  
    unsigned short   sin_port;         // 2 bytes e.g. htons(3490)  
    struct in_addr   sin_addr;         // 4 bytes see struct in_addr, below  
    char             sin_zero[8];      // 8 bytes zero this if you want to  
};  
 
struct in_addr {  
    unsigned long s_addr;              // 4 bytes load with inet_pton()  
};  
</code></pre>
<p>用於 server 端，用來將一個 socket file descriptor 和一個 sockaddr structure 相關聯，sockaddr 結構中會指出這個 socket (sockfd) 所要監聽的 address, port number 等資訊</p>
<ul>
<li><em><strong>sockfd</strong></em> 為上面 socket() 回傳的 file descriptor</li>
<li><em><strong>address</strong></em> 是一個 sockaddr 結構，包含了這個 socket 所要使用的一些資訊
<ul>
<li>sockaddr 和 sockaddr_in 結構類似，sockaddr_in 將 sockaddr 中的 char sa_data[14]; ，長度 14 bytes 轉為三個變數，一般寫成是我們使用 sockaddr_in 對其中的變數賦值，再將其轉型為 sockaddr</li>
<li>s_addr 是用 unsigned long int 所表示的 host address number
<ul>
<li>INADDR_LOOPBACK: 指本機的 address，也就是 127.0.0.1 (localhost)</li>
<li>INADDR_ANY: 指任何連上來的 address。如果要接受所有來自 internet 的 connection 可使用</li>
<li>INADDR_BROADCAST: 傳送 broadcast 訊息可使用</li>
<li>INADDR_NONE: 某些 function 錯誤時的回傳值</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>address_len</strong></em> 用來指出 sockaddr 結構長度</li>
</ul>
<p><strong>listen()</strong></p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
 
int listen(int sockfd, int backlog);
/* return 0 if success, otherwise, -1 for error */
</code></pre>
<ul>
<li><em><strong>sockfd</strong></em> 依然是上面的 socket file descriptor</li>
<li><em><strong>backlog</strong></em> 指定監聽佇列大小，當有連線請求到來會進入此監聽佇列，連線請求被 accept() 後會離開監聽佇列，當佇列滿時，新的連線請求會返回錯誤</li>
</ul>
<p><strong>accept()</strong></p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
 
int accept(int sockfd, struct sockaddr *restrict address, socklen_t *restrict address_len);
/* return the non-negative file descriptor of the accepted socket if success, Otherwise, -1 if error */
</code></pre>
<p>接受一個監聽佇列中的連線，回傳指向 client 的 file descriptor</p>
<ul>
<li><em><strong>sockfd</strong></em> 依然是上面的 socket file descriptor</li>
<li><em><strong>address</strong></em> 與上面 sockaddr 不同一個，自己宣告另一個指向 sockaddr structure 的變數用來記錄 client 的 socket 相關資訊，如不需要可以給 NULL</li>
<li><em><strong>address_len</strong></em> 用來指出 sockaddr 結構長度，如果前面第二參數給 NULL ，則這邊也給 NULL</li>
</ul>
<p><strong>connect()</strong></p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
 
int connect(int sockfd, const struct sockaddr *address, socklen_t address_len);
/* return 0 if success, otherwise, -1 for error */
</code></pre>
<p>用於 client 端，他會透過 sockfd 和 sockaddr structure 向指定的 server 連線</p>
<ul>
<li><em><strong>sockfd</strong></em> client 一樣要呼叫 socket() 從回傳值取得</li>
<li><em><strong>address</strong></em> 是一個 sockaddr 結構，包含了這個 socket 所要使用的一些資訊</li>
<li><em><strong>address_len</strong></em> 用來指出 sockaddr 結構長度</li>
</ul>
<hr />
<h2 id="0x03-example-code"><a class="header" href="#0x03-example-code">0x03 Example code</a></h2>
<pre><code class="language-c">/* Server code in C */
 
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
 
int main(void)
{
    struct sockaddr_in stSockAddr;
    int SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
 
    if(-1 == SocketFD)
    {
        perror(&quot;can not create socket&quot;);
        exit(EXIT_FAILURE);
    }
 
    memset(&amp;stSockAddr, 0, sizeof(struct sockaddr_in));
 
    stSockAddr.sin_family = AF_INET;
    stSockAddr.sin_port = htons(1100);
    stSockAddr.sin_addr.s_addr = INADDR_ANY;
 
    if(-1 == bind(SocketFD,(const struct sockaddr *)&amp;stSockAddr, sizeof(struct sockaddr_in)))
    {
        perror(&quot;error bind failed&quot;);
        close(SocketFD);
        exit(EXIT_FAILURE);
    }
 
    if(-1 == listen(SocketFD, 10))
    {
        perror(&quot;error listen failed&quot;);
        close(SocketFD);
        exit(EXIT_FAILURE);
    }
 
    for(;;)
    {
        int ConnectFD = accept(SocketFD, NULL, NULL);
 
        if(0 &gt; ConnectFD)
        {
            perror(&quot;error accept failed&quot;);
            close(SocketFD);
            exit(EXIT_FAILURE);
        }
 
        /* perform read write operations ... */
        shutdown(ConnectFD, SHUT_RDWR);
        close(ConnectFD);
    }
 
    close(SocketFD);
    return 0;
}
/* Client code in C */
 
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
 
int main(void)
{
    struct sockaddr_in stSockAddr;
    int Res;
    int SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
 
    if (-1 == SocketFD)
    {
        perror(&quot;cannot create socket&quot;);
        exit(EXIT_FAILURE);
    }
 
    memset(&amp;stSockAddr, 0, sizeof(struct sockaddr_in));
 
    stSockAddr.sin_family = AF_INET;
    stSockAddr.sin_port = htons(1100);
    Res = inet_pton(AF_INET, &quot;192.168.1.3&quot;, &amp;stSockAddr.sin_addr);
 
    if (0 &gt; Res)
    {
        perror(&quot;error: first parameter is not a valid address family&quot;);
        close(SocketFD);
        exit(EXIT_FAILURE);
    }
    else if (0 == Res)
    {
        perror(&quot;char string (second parameter does not contain valid ipaddress&quot;);
        close(SocketFD);
        exit(EXIT_FAILURE);
    }
 
    if (-1 == connect(SocketFD, (const struct sockaddr *)&amp;stSockAddr, sizeof(struct sockaddr_in)))
    {
        perror(&quot;connect failed&quot;);
        close(SocketFD);
        exit(EXIT_FAILURE);
    }
 
    /* perform read write operations ... */
 
    shutdown(SocketFD, SHUT_RDWR);
 
    close(SocketFD);
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-docker"><a class="header" href="#hello-docker">Hello Docker</a></h1>
<ul>
<li>Dockerfile</li>
</ul>
<pre><code class="language-sh">FROM python:3.7-slim

# Add requirements file in the container
COPY requirements.txt ./requirements.txt
RUN pip install -r requirements.txt

# Add source code in the container
COPY main.py ./main.py

# Define container entry point (could also work with CMD python main.py)
ENTRYPOINT [&quot;python&quot;, &quot;main.py&quot;]

</code></pre>
<ul>
<li>requirements.txt</li>
</ul>
<pre><code class="language-sh">requests==2.27.1
</code></pre>
<ul>
<li>main.py</li>
</ul>
<pre><code class="language-python">from pip import _internal

if __name__ == '__main__':
    print('Hello Docker world!')
    _internal.main(['list'])
</code></pre>
<pre><code class="language-sh">docker build -t docker-python-helloworld .
docker images 
# docker create -i -t --name 光碟機  iso
docker create -i -t --name  docker_test docker-python-helloworld
docker ps
docker start -i docker_test
docker stop docker_test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-教學"><a class="header" href="#docker-教學">Docker 教學</a></h1>
<p><strong><em>docker</em>實際上,就是一個系統聯合幾個元件一直在欺騙一個處理程序,主要依靠了三個幫兇namespace,<em>chroot,cgroup</em></strong> </p>
<p>Containers as a Service ( CaaS ) - 容器如同服務
Docker 是一個開源專案，出現於 2013 年初，最初是 Dotcloud 公司內部的 Side-Project。
它基於 Google 公司推出的 Go 語言實作。（ Dotcloud 公司後來改名為 Docker ）</p>
<h2 id="agenda"><a class="header" href="#agenda">Agenda</a></h2>
<ul>
<li>基本介紹 - 映像檔、容器、倉庫</li>
<li>指令說明 - 安裝、指令</li>
<li>Dockerfile 說明</li>
<li>進階應用 - docker compose</li>
<li>進階應用 - docker machine</li>
<li>實際案例</li>
</ul>
<h3 id="基本介紹"><a class="header" href="#基本介紹">基本介紹</a></h3>
<h4 id="什麼是容器技術container-應用程式為中心的虛擬化"><a class="header" href="#什麼是容器技術container-應用程式為中心的虛擬化">什麼是容器技術Container： <strong>應用程式為中心的虛擬化</strong></a></h4>
<h4 id="docker-歷史"><a class="header" href="#docker-歷史">Docker 歷史</a></h4>
<p>1982年Unix系統內建的chroot機制
LXC 利用controler groups 與namespaces的功能， 提供應用軟體一個獨立的作業系統環境
2013 Linux之父Linus Torvalds 發布Linux核心3.8版 支援Container技術
2013 dotCloud公司將內部專案Docker開源釋出程式碼</p>
<h4 id="containers容器-vs-virtual-machines虛擬主機"><a class="header" href="#containers容器-vs-virtual-machines虛擬主機">Containers(容器) vs Virtual Machines(虛擬主機)</a></h4>
<p><img src="docker/images/7db7ad1b-7830-4713-b96e-d3a103a4f7dc" alt="螢幕快照 2019-02-19 上午11.07.39.png" /></p>
<h4 id="docker-三個基本概念"><a class="header" href="#docker-三個基本概念">Docker 三個基本概念</a></h4>
<h5 id="映像檔image"><a class="header" href="#映像檔image">映像檔（Image）</a></h5>
<ul>
<li>Docker 映像檔就是一個唯讀的模板。</li>
<li>映像檔可以用來建立 Docker 容器。</li>
</ul>
<h5 id="容器container"><a class="header" href="#容器container">容器（Container）</a></h5>
<ul>
<li>容器是從映像檔建立的執行實例。</li>
<li>Docker 利用容器來執行應用。</li>
<li>可以被啟動、開始、停止、刪除。</li>
<li>每個容器都是相互隔離的、保證安全的平臺。</li>
</ul>
<h5 id="倉庫repository"><a class="header" href="#倉庫repository">倉庫（Repository）</a></h5>
<ul>
<li>倉庫是集中存放映像檔檔案的場所。</li>
<li>每個倉庫中又包含了多個映像檔。</li>
<li>每個映像檔有不同的標籤（tag）。</li>
<li>倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式。</li>
</ul>
<p><img src="docker/images/95ae632e-9016-416b-9c66-07b8c8e22ff9" alt="螢幕快照 2019-02-19 上午11.10.38.png" /></p>
<h3 id="指令說明---安裝指令"><a class="header" href="#指令說明---安裝指令">指令說明 - 安裝、指令</a></h3>
<pre><code>docker --help
</code></pre>
<h4 id="containers容器-vs-virtual-machines虛擬主機-1"><a class="header" href="#containers容器-vs-virtual-machines虛擬主機-1">Containers(容器) vs Virtual Machines(虛擬主機)</a></h4>
<p><img src="https://wt-box.worktile.com/public/7db7ad1b-7830-4713-b96e-d3a103a4f7dc" alt="螢幕快照 2019-02-19 上午11.07.39.png" /></p>
<h4 id="docker-三個基本概念-1"><a class="header" href="#docker-三個基本概念-1">Docker 三個基本概念</a></h4>
<h5 id="映像檔image-1"><a class="header" href="#映像檔image-1">映像檔（Image）</a></h5>
<ul>
<li>Docker 映像檔就是一個唯讀的模板。</li>
<li>映像檔可以用來建立 Docker 容器。</li>
</ul>
<h5 id="容器container-1"><a class="header" href="#容器container-1">容器（Container）</a></h5>
<ul>
<li>容器是從映像檔建立的執行實例。</li>
<li>Docker 利用容器來執行應用。</li>
<li>可以被啟動、開始、停止、刪除。</li>
<li>每個容器都是相互隔離的、保證安全的平臺。</li>
</ul>
<h5 id="倉庫repository-1"><a class="header" href="#倉庫repository-1">倉庫（Repository）</a></h5>
<ul>
<li>倉庫是集中存放映像檔檔案的場所。</li>
<li>每個倉庫中又包含了多個映像檔。</li>
<li>每個映像檔有不同的標籤（tag）。</li>
<li>倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式。</li>
</ul>
<p><img src="https://wt-box.worktile.com/public/95ae632e-9016-416b-9c66-07b8c8e22ff9" alt="螢幕快照 2019-02-19 上午11.10.38.png" /></p>
<h3 id="指令說明---安裝指令-1"><a class="header" href="#指令說明---安裝指令-1">指令說明 - 安裝、指令</a></h3>
<pre><code>docker --help
</code></pre>
<h4 id="安裝docker"><a class="header" href="#安裝docker">安裝Docker</a></h4>
<p><a href="https://docs.docker.com/docker-for-mac/">官方文件 Get started with Docker for Mac</a>
<a href="https://docs.docker.com/docker-for-windows/">官方官方 Get started with Docker for Windows</a>
<a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox overview</a></p>
<h4 id="image-映像檔-常用指令"><a class="header" href="#image-映像檔-常用指令">Image 映像檔 常用指令</a></h4>
<table><thead><tr><th style="text-align: center">指令</th><th style="text-align: center">說明</th><th style="text-align: center">範例</th></tr></thead><tbody>
<tr><td style="text-align: center">search</td><td style="text-align: center">搜尋</td><td style="text-align: center">docker search centos</td></tr>
<tr><td style="text-align: center">pull</td><td style="text-align: center">下載</td><td style="text-align: center">docker pull centos</td></tr>
<tr><td style="text-align: center">images</td><td style="text-align: center">列表</td><td style="text-align: center">docker images</td></tr>
<tr><td style="text-align: center">run</td><td style="text-align: center">執行</td><td style="text-align: center">docker run -ti centos /bin/bash</td></tr>
<tr><td style="text-align: center">rmi [Image ID]</td><td style="text-align: center">刪除</td><td style="text-align: center">docker rmi 615cb40d5d19</td></tr>
<tr><td style="text-align: center">build</td><td style="text-align: center">建立</td><td style="text-align: center">docker build -t member:1 .</td></tr>
<tr><td style="text-align: center">login</td><td style="text-align: center">登入</td><td style="text-align: center">docker login docker.okborn.com</td></tr>
<tr><td style="text-align: center">push</td><td style="text-align: center">上傳</td><td style="text-align: center">docker push</td></tr>
</tbody></table>
<h5 id="search-搜尋-centos-映像檔"><a class="header" href="#search-搜尋-centos-映像檔">Search 搜尋 Centos 映像檔</a></h5>
<pre><code>docker search contos
</code></pre>
<p><img src="docker/images/440a5d54-fbbe-495d-a6b9-e756aae5d6ec" alt="螢幕快照 2019-02-19 下午1.45.28.png" /></p>
<p>NAME：映像檔名稱
DESCRIPTION：映像檔描述
STARS：越多代表越多人使用
OFFICIAL：官方Image
AUTOMATED：自動化</p>
<h5 id="顯示目前本機的-images-列表"><a class="header" href="#顯示目前本機的-images-列表">顯示目前本機的 Images 列表</a></h5>
<pre><code>docker iamges
</code></pre>
<p>REPOSITORY：倉庫位置和映像檔名稱
TAG：映像檔標籤(通常是定義版本號)
IMAGE ID：映像檔ID(唯一碼)
CREATED：創建日期
SIZE：映像檔大小</p>
<h5 id="啟動容器"><a class="header" href="#啟動容器">啟動容器</a></h5>
<pre><code>docker run -ti centos /bin/bash
</code></pre>
<p>run : 參數說明 or docker run --help 常用：
-i ：則讓容器的標準輸入保持打開
-t：讓Docker分配一個虛擬終端（pseudo-tty）並綁定到容器的標準輸入上
-d：背景執行
-e：設定環境變數(AAA=BBB)
-p：Port 對應(host port:container port)
-v：資料對應(host folder:container folder)
--name：設定容器名稱</p>
<p>** 在執行RUN 映像檔時，如果沒有下載會先下載在執行 **
<img src="docker/images/9f869550-a1ed-4831-b150-c3e3ee2ccdb9" alt="螢幕快照 2019-02-19 下午2.00.23.png" /></p>
<p>rmi : 刪除映像檔前要先移除所有Container
build : 使用build 指令時要先切換到Dockerfile 目錄下面</p>
<h4 id="container-容器-常用指令"><a class="header" href="#container-容器-常用指令">Container 容器 常用指令</a></h4>
<table><thead><tr><th style="text-align: center">指令</th><th style="text-align: center">說明</th><th style="text-align: center">範例</th></tr></thead><tbody>
<tr><td style="text-align: center">run</td><td style="text-align: center">新建或啟動</td><td style="text-align: center">docker run -d centos</td></tr>
<tr><td style="text-align: center">start [Contain ID]</td><td style="text-align: center">啟動</td><td style="text-align: center">docker start a469b9226fc8</td></tr>
<tr><td style="text-align: center">stop [Contain ID]</td><td style="text-align: center">停止</td><td style="text-align: center">docker stop a469b9226fc8</td></tr>
<tr><td style="text-align: center">rm [Contain ID]</td><td style="text-align: center">刪除</td><td style="text-align: center">docker rm a4</td></tr>
<tr><td style="text-align: center">ps -a</td><td style="text-align: center">列表</td><td style="text-align: center">docker ps -a</td></tr>
<tr><td style="text-align: center">logs [Contain ID]</td><td style="text-align: center">查看容器內的資訊</td><td style="text-align: center">docker logs -f a4</td></tr>
<tr><td style="text-align: center">exec [Contain ID]</td><td style="text-align: center">進入容器(開新console)</td><td style="text-align: center">docker exec -ti a4 /bin/bash</td></tr>
<tr><td style="text-align: center">attach</td><td style="text-align: center">進入容器(退出停止容器)</td><td style="text-align: center">dockr attach a4</td></tr>
<tr><td style="text-align: center">inspect</td><td style="text-align: center">查看</td><td style="text-align: center">docker inspect a4</td></tr>
</tbody></table>
<h5 id="啟動一個-container-並且執行-ping-googlecom"><a class="header" href="#啟動一個-container-並且執行-ping-googlecom">啟動一個 Container 並且執行 ping google.com</a></h5>
<pre><code>docker run centos ping google.com
</code></pre>
<h5 id="請動一個-container-執行上面的動作並背景執行"><a class="header" href="#請動一個-container-執行上面的動作並背景執行">請動一個 Container 執行上面的動作，並背景執行</a></h5>
<p><img src="docker/images/aef96620-2681-441c-bb12-1ac5a046b9d4" alt="螢幕快照 2019-02-19 下午2.38.01.png" /></p>
<h5 id="使用-查看-container-指令"><a class="header" href="#使用-查看-container-指令">使用 查看 Container 指令</a></h5>
<pre><code>docker ps 
docker ps -a
</code></pre>
<p>ps : 參數說明 or docker ps --help 常用：
-a：顯示全部的容器</p>
<p>CONTAINER ID：容器ID
IMAGE：映像檔名稱
COMMAND：執行指令
CREATED：創建時間
STATUS：容器狀態
POSTS：開啟的Port號
NAMES：容器名稱</p>
<h5 id="顯示容器的-log"><a class="header" href="#顯示容器的-log">顯示容器的 log</a></h5>
<pre><code>docker logs -f 8a
</code></pre>
<p>logs : 參數說明 or docker logs --help 常用：
-f：不會跳出，會一直列印最新的log資訊
<img src="docker/images/a499b6d3-592d-4000-852a-ea2622d25e52" alt="螢幕快照 2019-02-19 下午2.48.58.png" /></p>
<h5 id="進入容器"><a class="header" href="#進入容器">進入容器</a></h5>
<pre><code>docker exec -ti 8a /bin/bash
</code></pre>
<p>exec : 參數說明 or docker exec --help 常用：
-i ：則讓容器的標準輸入保持打開
-t：讓Docker分配一個虛擬終端（pseudo-tty）並綁定到容器的標準輸入上
-e：設定環境變數(AAA=BBB)
<img src="docker/images/8b4736fe-aafa-4030-ad5e-dc3184d01d43" alt="螢幕快照 2019-02-19 下午2.51.57.png" /></p>
<h5 id="查看容器資訊"><a class="header" href="#查看容器資訊">查看容器資訊</a></h5>
<pre><code>docker inspect 8a
</code></pre>
<p><img src="docker/images/8ac45ac3-8cb3-4c97-9dcc-dd28d880250e" alt="螢幕快照 2019-02-19 下午2.56.52.png" /></p>
<h5 id="開啟容器到關閉容器"><a class="header" href="#開啟容器到關閉容器">開啟容器到關閉容器</a></h5>
<pre><code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
db0e9dbb150596a3a89db056d0ecb765c54c3c2fb5d428e3b35fc20b55813862
docker logs -f db
docker ps -a
docker stop db
docker ps -a
</code></pre>
<h4 id="registry-倉庫-常用指令"><a class="header" href="#registry-倉庫-常用指令">Registry 倉庫 常用指令</a></h4>
<table><thead><tr><th style="text-align: center">指令</th><th style="text-align: center">說明</th><th style="text-align: center">範例</th></tr></thead><tbody>
<tr><td style="text-align: center">commit</td><td style="text-align: center">容器存檔</td><td style="text-align: center">docker commit db aaa:v1</td></tr>
<tr><td style="text-align: center">pull</td><td style="text-align: center">下載</td><td style="text-align: center">docker pull docker.okborn.com/okborn:base</td></tr>
<tr><td style="text-align: center">tag</td><td style="text-align: center">標籤</td><td style="text-align: center">docker tag aaa docker.okborn.com/aaa</td></tr>
<tr><td style="text-align: center">push</td><td style="text-align: center">上傳</td><td style="text-align: center">docker push docker.okborn.com/member:1</td></tr>
<tr><td style="text-align: center">login</td><td style="text-align: center">登入</td><td style="text-align: center">docker login docker.okborn.com</td></tr>
<tr><td style="text-align: center">export</td><td style="text-align: center">匯出</td><td style="text-align: center">docker export 7691a814370e &gt; ubuntu.tar</td></tr>
<tr><td style="text-align: center">import</td><td style="text-align: center">匯入</td><td style="text-align: center">cat ubuntu.tar sudo docker import - test/ubuntu:v1.0</td></tr>
</tbody></table>
<h5 id="對容器存檔"><a class="header" href="#對容器存檔">對容器存檔</a></h5>
<pre><code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
96ea2a3f99e92ddd5fa0ec29f21d035703b6512f59c4f54fbaee551ee8fc044a
docker commit 96 aaa:v1
</code></pre>
<p><img src="docker/images/30bea8c2-2519-4b81-8fc1-682edd878bfe" alt="螢幕快照 2019-02-19 下午3.31.21.png" /></p>
<h5 id="對映像檔打標籤"><a class="header" href="#對映像檔打標籤">對映像檔打標籤</a></h5>
<pre><code>docker tag centos aaa asia.gcr.io/joyi-205504/aaa:v1
</code></pre>
<h5 id="上傳到-gcp-registry"><a class="header" href="#上傳到-gcp-registry">上傳到 GCP Registry</a></h5>
<pre><code>gcloud docker -- push  asia.gcr.io/joyi-205504/aaa:v1
</code></pre>
<h4 id="其他常用指令"><a class="header" href="#其他常用指令">其他常用指令</a></h4>
<p>刪除</p>
<pre><code>docker rmi `docker images|grep sele |awk '{print $3}'`
</code></pre>
<h4 id="dcoker-資料管理"><a class="header" href="#dcoker-資料管理">Dcoker 資料管理</a></h4>
<h5 id="資料卷data-volumes"><a class="header" href="#資料卷data-volumes">資料卷（Data volumes）</a></h5>
<ul>
<li>資料卷可以在容器之間共享和重用</li>
<li>對資料卷的修改會立馬生效</li>
<li>對資料卷的更新，不會影響映像檔</li>
<li>卷會一直存在，直到沒有容器使用</li>
</ul>
<h5 id="範例建立一個-web-容器並載入一個資料捲到容器的-webapp-目錄"><a class="header" href="#範例建立一個-web-容器並載入一個資料捲到容器的-webapp-目錄">範例：建立一個 web 容器，並載入一個資料捲到容器的 /webapp 目錄</a></h5>
<pre><code>docker run -d -P --name web -v /webapp training/webapp python app.py
</code></pre>
<h5 id="範例本機的-srcwebapp-目錄到容器的-optwebapp-目錄"><a class="header" href="#範例本機的-srcwebapp-目錄到容器的-optwebapp-目錄">範例：本機的 /src/webapp 目錄到容器的 /opt/webapp 目錄</a></h5>
<pre><code>docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
</code></pre>
<h5 id="範例docker-掛載資料卷的預設權限是讀寫使用者也可以透過-ro-指定為唯讀"><a class="header" href="#範例docker-掛載資料卷的預設權限是讀寫使用者也可以透過-ro-指定為唯讀">範例：Docker 掛載資料卷的預設權限是讀寫，使用者也可以透過 :ro 指定為唯讀</a></h5>
<pre><code>docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py
</code></pre>
<h5 id="資料卷容器data-volume-containers"><a class="header" href="#資料卷容器data-volume-containers">資料卷容器（Data volume containers）</a></h5>
<p>持續更新的資料需要在容器之間共享，最好建立資料卷容器。
一個正常的容器，專門用來提供資料卷供其它容器掛載的。</p>
<h5 id="範例建立一個命名的資料卷容器-dbdata"><a class="header" href="#範例建立一個命名的資料卷容器-dbdata">範例：建立一個命名的資料卷容器 dbdata</a></h5>
<pre><code>docker run -d -v /dbdata --name dbdata postgres echo Data-only container for postgres
</code></pre>
<h5 id="範例他容器中使用---volumes-from-來掛載-dbdata-容器中的資料卷"><a class="header" href="#範例他容器中使用---volumes-from-來掛載-dbdata-容器中的資料卷">範例：他容器中使用 --volumes-from 來掛載 dbdata 容器中的資料卷</a></h5>
<pre><code>docker run -d -P --volumes-from dbdata --name db1 postgres
docker run -d -P --volumes-from dbdata --name db2 postgres
</code></pre>
<h5 id="範例也可以從其他已經掛載了容器卷的容器來掛載資料卷"><a class="header" href="#範例也可以從其他已經掛載了容器卷的容器來掛載資料卷">範例：也可以從其他已經掛載了容器卷的容器來掛載資料卷。</a></h5>
<pre><code>docker run -d --name db3 --volumes-from db1 postgres
</code></pre>
<h5 id="範例備份"><a class="header" href="#範例備份">範例：備份</a></h5>
<p>首先使用 --volumes-from 標記來建立一個載入 dbdata 容器卷的容器，並從本地主機掛載當前到容器的 /backup 目錄。</p>
<pre><code>docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre>
<h5 id="範例恢復"><a class="header" href="#範例恢復">範例：恢復</a></h5>
<p>恢復資料到一個容器，首先建立一個帶有資料卷的容器 dbdata2</p>
<pre><code>docker run -v /dbdata --name dbdata2 ubuntu /bin/bash
</code></pre>
<p>然後建立另一個容器，掛載 dbdata2 的容器，並使用 untar 解壓備份檔案到掛載的容器卷中。</p>
<pre><code>docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar
</code></pre>
<h5 id="docker-中的網路功能介紹"><a class="header" href="#docker-中的網路功能介紹">Docker 中的網路功能介紹</a></h5>
<ul>
<li>要讓外部也可以存取這些應用</li>
<li>可以通過 -P 或 -p 參數來指定連接埠映射。</li>
</ul>
<h5 id="範例隨機本機port"><a class="header" href="#範例隨機本機port">範例：隨機本機Port</a></h5>
<pre><code>docker run -d -P training/webapp python app.py
</code></pre>
<h5 id="範例指定本機port"><a class="header" href="#範例指定本機port">範例：指定本機Port</a></h5>
<pre><code>docker run -d -p 5000:5000 training/webapp python app.py
</code></pre>
<h5 id="範例綁定-localhost-的任意連接埠到容器的-5000-連接埠本地主機會自動分配一個連接埠"><a class="header" href="#範例綁定-localhost-的任意連接埠到容器的-5000-連接埠本地主機會自動分配一個連接埠">範例：綁定 localhost 的任意連接埠到容器的 5000 連接埠，本地主機會自動分配一個連接埠</a></h5>
<pre><code>docker run -d -p 127.0.0.1::5000 training/webapp python app.py
</code></pre>
<h5 id="範例還可以使用-udp-標記來指定-udp-連接埠"><a class="header" href="#範例還可以使用-udp-標記來指定-udp-連接埠">範例：還可以使用 udp 標記來指定 udp 連接埠</a></h5>
<pre><code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</code></pre>
<h5 id="範例--p-標記可以多次使用來綁定多個連接埠"><a class="header" href="#範例--p-標記可以多次使用來綁定多個連接埠">範例： -p 標記可以多次使用來綁定多個連接埠</a></h5>
<pre><code>docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py
</code></pre>
<h3 id="dockerfile-說明"><a class="header" href="#dockerfile-說明">Dockerfile 說明</a></h3>
<ul>
<li>Dockerfile 由一行行命令語句組成，並且支援以 # 開頭的註解行。</li>
<li>Dockerfile 分為四部分：
<ul>
<li>基底映像檔資訊</li>
<li>維護者資訊</li>
<li>映像檔操作指令</li>
<li>容器啟動時執行指令。</li>
</ul>
</li>
</ul>
<pre><code class="language-shell"># This dockerfile uses the ubuntu image
# VERSION 2 - EDITION 1
# Author: docker_user
# Command format: Instruction [arguments / command] ..

# 基本映像檔，必須是第一個指令
FROM ubuntu

# 維護者： docker_user &lt;docker_user at email.com&gt; (@docker_user)
MAINTAINER docker_user docker_user@email.com

# 更新映像檔的指令
RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list
RUN apt-get update &amp;&amp; apt-get install -y nginx
RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf

# 建立新容器時要執行的指令
CMD /usr/sbin/nginx
</code></pre>
<p>####Dockerfile 基本語法</p>
<table><thead><tr><th style="text-align: center">指令</th><th style="text-align: center">說明</th><th style="text-align: center">範例</th></tr></thead><tbody>
<tr><td style="text-align: center">FROM :</td><td style="text-align: center">映像檔來源</td><td style="text-align: center">FROM python:3.5</td></tr>
<tr><td style="text-align: center">MAINTAINER</td><td style="text-align: center">維護者訊息</td><td style="text-align: center">MAINTAINER docker_user docker_user@email.com</td></tr>
<tr><td style="text-align: center">RUN</td><td style="text-align: center">創建映像檔時執行動作</td><td style="text-align: center">RUN apt-get -y update &amp;&amp; apt-get install -y supervisor</td></tr>
<tr><td style="text-align: center">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</td><td style="text-align: center">創建映像檔時執行動作</td><td style="text-align: center">RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</td></tr>
<tr><td style="text-align: center">CMD command param1 param2</td><td style="text-align: center">啟動容器時執行的命令</td><td style="text-align: center">CMD pserve development.ini</td></tr>
<tr><td style="text-align: center">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</td><td style="text-align: center">啟動容器時執行的命令</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">CMD [&quot;param1&quot;,&quot;param2&quot;]</td><td style="text-align: center">啟動容器時執行的命令</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">EXPOSE</td><td style="text-align: center">容器對外的埠號</td><td style="text-align: center">EXPOSE 8082</td></tr>
<tr><td style="text-align: center">ADD</td><td style="text-align: center">複製檔案(單檔)</td><td style="text-align: center">ADD requirements.txt /usr/src/app/</td></tr>
<tr><td style="text-align: center">COPY</td><td style="text-align: center">複製檔案(資料夾)</td><td style="text-align: center">COPY . /usr/src/app</td></tr>
<tr><td style="text-align: center">ENV</td><td style="text-align: center">環境變數</td><td style="text-align: center">ENV PG_VERSION 9.3.4</td></tr>
<tr><td style="text-align: center">ENTRYPOINT command param1 param2</td><td style="text-align: center">指定容器啟動後執行的命令</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</td><td style="text-align: center">指定容器啟動後執行的命令</td><td style="text-align: center">ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]</td></tr>
<tr><td style="text-align: center">VOLUME [&quot;/data&quot;]</td><td style="text-align: center">掛載資料卷</td><td style="text-align: center">VOLUME /var/lib/postgresql/data</td></tr>
<tr><td style="text-align: center">USER daemon</td><td style="text-align: center">指定運行使用者</td><td style="text-align: center">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</td></tr>
<tr><td style="text-align: center">WORKDIR /path/to/workdir</td><td style="text-align: center">指定工作目錄</td><td style="text-align: center">WORKDIR /usr/src/app</td></tr>
<tr><td style="text-align: center">ONBUILD [INSTRUCTION]</td><td style="text-align: center">基底映像檔建立時執行</td><td style="text-align: center">ONBUILD COPY . /usr/src/app</td></tr>
</tbody></table>
<p>RUN 當命令較長時可以使用 \ 來換行。
RUN : 在 shell 終端中運行命令，即 /bin/sh -c；
RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] : 使用 exec 執行。</p>
<p>CMD 指定啟動容器時執行的命令， <strong>每個 Dockerfile 只能有一條 CMD 命令</strong> 。
如果指定了多條命令，只有最後一條會被執行。
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 執行，推薦使用；
CMD command param1 param2 在 /bin/sh 中執行，使用在給需要互動的指令；
CMD [&quot;param1&quot;,&quot;param2&quot;] 提供給 ENTRYPOINT 的預設參數；</p>
<p>ENTRYPOINT：每個 Dockerfile 中只能有一個 ENTRYPOINT，當指定多個時，只有最後一個會生效。
USER：要臨時取得管理員權限可以使用 gosu，而不推薦 sudo。
WORKDIR：可以使用多個 WORKDIR 指令，後續命令如果參數是相對路徑，則會基於之前命令指定的路徑</p>
<h4 id="docker-file-base"><a class="header" href="#docker-file-base">Docker File Base</a></h4>
<pre><code class="language-dockerfile"># 映像檔Image
FROM python:3.5
# 維護者
MAINTAINER Pellok &quot;pellok@double-cash.com&quot;
# 更新
RUN apt-get -y update &amp;&amp; apt-get install -y supervisor
# 創建專案資料夾
RUN mkdir -p /usr/src/app
# 指定工作目錄在專案資料夾
WORKDIR /usr/src/app
# 預先要安裝的requirements複製到Docker裡面
ADD requirements.txt /usr/src/app/
# 安裝需要用的插件
RUN pip install --upgrade pip setuptools
RUN pip install --no-cache-dir -r requirements.txt
# 下次Build 的時候複製專案目錄到Docker 裡面
ONBUILD COPY . /usr/src/app
</code></pre>
<p>建置</p>
<pre><code>docker build -t sample:base .
</code></pre>
<h5 id="docker-file-for-project"><a class="header" href="#docker-file-for-project">Docker File for Project</a></h5>
<pre><code class="language-dockerfile">#  挑選Image
FROM sample:base
# 安裝cryptography
RUN pip install cryptography 
# 設定工作目錄
WORKDIR /usr/src/app/
# 執行Python Setup
RUN python setup.py develop
# 開啟Port號
EXPOSE 8082
# 執行專案
CMD pserve development.ini
</code></pre>
<p>建置</p>
<pre><code>docker build -t project:v1 .
</code></pre>
<h4 id="pyramid-專案-docker-化"><a class="header" href="#pyramid-專案-docker-化">Pyramid 專案 Docker 化</a></h4>
<pre><code class="language-shell">#創建一個新專案
pcreate -s alchemy pyramid_dockerlize
cd pyramid_dockerlize
# 創建dockerfile
touch Dockerfile
# 編輯 Dockerfile
# 建置映像檔
docker build -t pyramid_dockerlize .
# 執行容器
docker run -d -P pyramid_dockerlize
</code></pre>
<p>Dockerfile</p>
<pre><code class="language-dockerfile"># This dockerfile uses the python pyramid
# VERSION 1 - EDITION 1
# Author: pellok
# Command describe

# 使用的python映像檔版本
FROM python:3.5

MAINTAINER pellok pellok@okborn.com

# 創建存放專案的資料夾
RUN mkdir -p /usr/src/app

# 複製當前目錄的所有檔案到容器內的，資料放在/usr/src/app
COPY . /usr/src/app

# 指定工作目錄
WORKDIR /usr/src/app/

# 安裝環境變數和相依性套件
RUN python setup.py develop

# 初始化DB
RUN initialize_pyramid_dockerlize_db development.ini

# 專案監聽的Port號
EXPOSE 6543

# 啟動專案
CMD pserve production.ini
</code></pre>
<h3 id="參考"><a class="header" href="#參考">參考</a></h3>
<p><a href="http://school.soft-arch.net/courses/enrolled/vm-for-devops">VM-for-Devops</a>
<a href="https://www.virtualbox.org/wiki/Downloads">Virtual Box</a> [<a href="http://download.virtualbox.org/virtualbox/5.1.8/VirtualBox-5.1.8-111374-OSX.dmg">VirtualBox5.1.8</a>][<a href="http://download.virtualbox.org/virtualbox/5.1.8/Oracle_VM_VirtualBox_Extension_Pack-5.1.8-111374.vbox-extpack">Extension Pack</a>]
<a href="https://www.vagrantup.com/downloads.html">Vagrant</a>[<a href="https://releases.hashicorp.com/vagrant/1.8.7/vagrant_1.8.7.dmg">Vagrant1.8.7</a>]
<a href="http://kubernetes.io/docs/getting-started-guides/">kubernetes</a>
<a href="http://kubernetes.io/docs/getting-started-guides/minikube/#install-minikube">minikube</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="在dockerfile中設定時區"><a class="header" href="#在dockerfile中設定時區">在dockerfile中設定時區</a></h2>
<p>基於 Debian 鏡像</p>
<p>由於 Debian 鏡像中已經包含了tzdata，因此設定時區的方法比較簡單，只需新增環境變數TZ即可。</p>
<pre><code>FROM debian:stretch

ENV TZ=Asia/Taipei
</code></pre>
<p>基於 Alpine 鏡像</p>
<pre><code>FROM alpine:3.9

ENV TZ=Asia/Taipei

RUN apk update \
    &amp;&amp; apk add tzdata \
    &amp;&amp; echo &quot;${TZ}&quot; &gt; /etc/timezone \
    &amp;&amp; ln -sf /usr/share/zoneinfo/${TZ} /etc/localtime \
    &amp;&amp; rm /var/cache/apk/*
</code></pre>
<p>基於 Ubuntu 鏡像</p>
<pre><code>FROM ubuntu:bionic

ENV TZ=Asia/Taipei

RUN echo &quot;${TZ}&quot; &gt; /etc/timezone \
    &amp;&amp; ln -sf /usr/share/zoneinfo/${TZ} /etc/localtime \
    &amp;&amp; apt update \
    &amp;&amp; apt install -y tzdata \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
</code></pre>
<h2 id="簡單範例"><a class="header" href="#簡單範例">簡單範例</a></h2>
<pre><code class="language-py">from pip import _internal
import time

if __name__ == '__main__':
    _internal.main(['list'])
    while True:
        print('Hello Docker world!')
        time.sleep(1)
</code></pre>
<pre><code class="language-dockerfile">FROM python:3.10-slim

# Add requirements file in the container
COPY requirements.txt ./requirements.txt
RUN pip install -r requirements.txt

# Add source code in the container
COPY main.py ./main.py

# Define container entry point (could also work with CMD python main.py)
ENTRYPOINT [&quot;python&quot;, &quot;main.py&quot;]
</code></pre>
<ul>
<li>requirements.txt</li>
</ul>
<pre><code>requests
kafka-python
grpcio
protobuf
better-exceptions
loguru
pandas
python-binance
redis
aiohttp
flask
kubernetes
</code></pre>
<pre><code class="language-sh"># 編譯 image
docker build -t my-image-name .  

# Run docker
docker run -it my-image-name

#查看 container_name or id
docker ps
79c7e6661fa2   my-image-name                     &quot;python main.py&quot;         54 seconds ago   Up 54 seconds                                                                                                    beautiful_khayyam

docker exec -it 79c7e6661fa2 /bin/bash
docker exec -it beautiful_khayyam /bin/bash
</code></pre>
<hr />
<ol>
<li>
<p>使用命令行將上述 Dockerfile 文件保存在您的計算機上。</p>
</li>
<li>
<p>創建 Docker 映像，請在命令行中導航到 Dockerfile 文件所在的目錄，並運行以下命令：</p>
<pre><code class="language-sh">docker build -t image_name .
</code></pre>
<p>其中，<code>image_name</code> 是您要為映像命名的名稱，<code>.</code> 表示當前目錄是上下文。</p>
</li>
<li>
<p>運行 Docker 映像，請使用以下命令：</p>
<pre><code class="language-sh">docker run -it --rm image_name
</code></pre>
<p>其中，<code>-it</code> 表示要使用互動式終端來運行容器，<code>--rm</code> 表示當容器停止時，自動刪除容器。</p>
</li>
<li>
<p>如果需要，在運行容器的情況下登入 Docker，請使用以下命令：</p>
<pre><code class="language-sh">docker exec -it container_name /bin/bash
</code></pre>
<p>其中，<code>container_name</code> 是您要登入的容器的名稱，<code>/bin/bash</code> 是您要在容器中運行的命令。</p>
</li>
</ol>
<p>希望這些命令可以幫助您成功編譯、運行和登入您的 Docker 映像。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-perfect-python-dockerfile"><a class="header" href="#creating-the-perfect-python-dockerfile">Creating the Perfect Python Dockerfile</a></h1>
<pre><code class="language-dockerfile"># using ubuntu LTS version
FROM ubuntu:20.04 AS builder-image

# avoid stuck build due to user prompt
ARG DEBIAN_FRONTEND=noninteractive

RUN apt-get update &amp;&amp; apt-get install --no-install-recommends -y python3.9 python3.9-dev python3.9-venv python3-pip python3-wheel build-essential &amp;&amp; \
	apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# create and activate virtual environment
# using final folder name to avoid path issues with packages
RUN python3.9 -m venv /home/myuser/venv
ENV PATH=&quot;/home/myuser/venv/bin:$PATH&quot;

# install requirements
COPY requirements.txt .
RUN pip3 install --no-cache-dir wheel
RUN pip3 install --no-cache-dir -r requirements.txt

FROM ubuntu:20.04 AS runner-image
RUN apt-get update &amp;&amp; apt-get install --no-install-recommends -y python3.9 python3-venv &amp;&amp; \
	apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

RUN useradd --create-home myuser
COPY --from=builder-image /home/myuser/venv /home/myuser/venv

USER myuser
RUN mkdir /home/myuser/code
WORKDIR /home/myuser/code
COPY . .

EXPOSE 5000

# make sure all messages always reach console
ENV PYTHONUNBUFFERED=1

# activate virtual environment
ENV VIRTUAL_ENV=/home/myuser/venv
ENV PATH=&quot;/home/myuser/venv/bin:$PATH&quot;

# /dev/shm is mapped to shared memory and should be used for gunicorn heartbeat
# this will improve performance and avoid random freezes
CMD [&quot;gunicorn&quot;,&quot;-b&quot;, &quot;0.0.0.0:5000&quot;, &quot;-w&quot;, &quot;4&quot;, &quot;-k&quot;, &quot;gevent&quot;, &quot;--worker-tmp-dir&quot;, &quot;/dev/shm&quot;, &quot;app:app&quot;]

</code></pre>
<p>https://luis-sena.medium.com/creating-the-perfect-python-dockerfile-51bdec41f1c8</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="由-docker-image-反推其-dockerfile"><a class="header" href="#由-docker-image-反推其-dockerfile">由 Docker image 反推其 Dockerfile</a></h1>
<p>當我們使用現成的 Docker image 進行開發時，有時候會想知道這個 image 的內容是什麼，他提供的功能是如何達成的，這個時候如果能找到作者提供的 Dockerfile 是最好，但如果對方沒有公開的話，就有點麻煩了，這時候我們可以使用內建的 <code>docker history</code> 指令根據每層 image layer 的 metadata 看出做的事情，此外也有大大做了現成的工具讓我們可以直接產出接近原本 Dockerfile 該有的內容。</p>
<p>這邊我拿了兩個工具來做實驗:</p>
<pre><code class="language-shell">1. https://github.com/CenturyLinkLabs/dockerfile-from-image
2. https://github.com/lukapeschke/dockerfile-from-image
</code></pre>
<p>其中只有第二個是可行的，以下是實驗過程。</p>
<h2 id="centurylinkdockerfile-from-imagepermalink"><a class="header" href="#centurylinkdockerfile-from-imagepermalink">centurylink/dockerfile-from-image<a href="https://sdhuang32.github.io/zh-tw/dockerfile-from-docker-image/#centurylinkdockerfile-from-image">Permalink</a></a></h2>
<p>首先這個工具是參考<a href="https://philipzheng.gitbooks.io/docker_practice/content/dockerfile/file_from_image.html">這篇</a>而看到的。 我先拿 ruby 嘗試一下:</p>
<pre><code class="language-shell">$ docker pull centurylink/dockerfile-from-image
$ docker pull ruby
$ docker image | grep ruby
REPOSITORY                                    TAG                 IMAGE ID            CREATED              SIZE
docker.io/ruby                                latest              d529acb9f124        4 weeks ago          840 MB
$ docker run -v /var/run/docker.sock:/var/run/docker.sock centurylink/dockerfile-from-image d529acb9f124
/usr/lib/ruby/gems/2.2.0/gems/docker-api-1.24.1/lib/docker/connection.rb:42:in `rescue in request': 400 Bad Request: malformed Host header (Docker::Error::ClientError)
        from /usr/lib/ruby/gems/2.2.0/gems/docker-api-1.24.1/lib/docker/connection.rb:38:in `request'
        from /usr/lib/ruby/gems/2.2.0/gems/docker-api-1.24.1/lib/docker/connection.rb:65:in `block (2 levels) in &lt;class:Connection&gt;'
        from /usr/lib/ruby/gems/2.2.0/gems/docker-api-1.24.1/lib/docker/image.rb:172:in `all'
        from /usr/src/app/dockerfile-from-image.rb:32:in `&lt;main&gt;'
</code></pre>
<p>發現也有其他人碰到相同問題，參考<a href="https://github.com/CenturyLinkLabs/dockerfile-from-image/issues/14#issuecomment-272294267">這邊</a>的說明，利用他給的 Dockerfile 重新 build image 之後，反倒無法輸出任何東西。這個 repository 最近一次更新也是 2015 的事了，該工具似已不再適用新版的 Docker。</p>
<h2 id="lukapeschkedockerfile-from-imagepermalink"><a class="header" href="#lukapeschkedockerfile-from-imagepermalink">lukapeschke/dockerfile-from-image<a href="https://sdhuang32.github.io/zh-tw/dockerfile-from-docker-image/#lukapeschkedockerfile-from-image">Permalink</a></a></h2>
<p>參考上面同的討論串後續的內容找到第二個 repository，用他的 Dockerfile 來 build image:</p>
<pre><code class="language-shell">$ git clone https://github.com/lukapeschke/dockerfile-from-image.git
$ cd dockerfile-from-image/
$ docker build --rm -t lukapeschke/dockerfile-from-image .
</code></pre>
<p>他的使用方法 (只能用 image ID，不能用 image name!):</p>
<pre><code class="language-shell">$ docker run --rm -v '/var/run/docker.sock:/var/run/docker.sock' lukapeschke/dockerfile-from-image &lt;IMAGE_ID&gt;
</code></pre>
<p>以下拿 ruby 測試可以順利產生我們要的:</p>
<pre><code class="language-dockerfile">$ docker run --rm -v '/var/run/docker.sock:/var/run/docker.sock' lukapeschke/dockerfile-from-image d529acb9f124
FROM docker.io/ruby:latest
ADD file:2cddee716e84c40540a69c48051bd2dcf6cd3bd02a3e399334e97f20a77126ff in /
CMD [&quot;bash&quot;]
RUN /bin/sh -c apt-get update \
    &amp;&amp; apt-get install -y --no-install-recommends 		ca-certificates 		curl 		netbase 		wget 	\
    &amp;&amp; rm -rf /var/lib/apt/lists/*
RUN /bin/sh -c set -ex; 	if ! command -v gpg &gt; /dev/null; then 		apt-get update; 		apt-get install -y --no-install-recommends 			gnupg 			dirmngr 		; 		rm -rf /var/lib/apt/lists/*; 	fi
RUN /bin/sh -c apt-get update \
    &amp;&amp; apt-get install -y --no-install-recommends 		git 		mercurial 		openssh-client 		subversion 	procps 	\
    &amp;&amp; rm -rf /var/lib/apt/lists/*
RUN /bin/sh -c set -ex; 	apt-get update; 	apt-get install -y --no-install-recommends 		autoconf 		automake 		bzip2 		dpkg-dev 		file 		g++ 		gcc 		imagemagick 		libbz2-dev 	libc6-dev 		libcurl4-openssl-dev 		libdb-dev 		libevent-dev 		libffi-dev 		libgdbm-dev 	libgeoip-dev 		libglib2.0-dev 		libgmp-dev 		libjpeg-dev 		libkrb5-dev 		liblzma-dev 		libmagickcore-dev 		libmagickwand-dev 		libncurses5-dev 		libncursesw5-dev 		libpng-dev 	libpq-dev 		libreadline-dev 		libsqlite3-dev 		libssl-dev 		libtool 		libwebp-dev 	libxml2-dev 		libxslt-dev 		libyaml-dev 		make 		patch 		unzip 		xz-utils 		zlib1g-dev 				$( 			if apt-cache show 'default-libmysqlclient-dev' 2&gt;/dev/null | grep -q '^Version:'; then 				echo 'default-libmysqlclient-dev'; 			else 				echo 'libmysqlclient-dev'; 			fi 		) 	; 	rm -rf /var/lib/apt/lists/*
RUN /bin/sh -c set -eux; 	mkdir -p /usr/local/etc; 	{ 		echo 'install: --no-document'; 		echo 'update: --no-document'; 	} &gt;&gt; /usr/local/etc/gemrc
ENV RUBY_MAJOR=2.6
ENV RUBY_VERSION=2.6.3
ENV RUBY_DOWNLOAD_SHA256=11a83f85c03d3f0fc9b8a9b6cad1b2674f26c5aaa43ba858d4b0fcc2b54171e1
RUN /bin/sh -c set -eux; 		savedAptMark=&quot;$(apt-mark showmanual)&quot;; 	apt-get update; 	apt-get install -y --no-install-recommends 		bison 		dpkg-dev 		libgdbm-dev 		ruby 	; 	rm -rf /var/lib/apt/lists/*; 		wget -O ruby.tar.xz &quot;https://cache.ruby-lang.org/pub/ruby/${RUBY_MAJOR%-rc}/ruby-$RUBY_VERSION.tar.xz&quot;; 	echo &quot;$RUBY_DOWNLOAD_SHA256 *ruby.tar.xz&quot; | sha256sum --check --strict; 		mkdir -p /usr/src/ruby; 	tar -xJf ruby.tar.xz -C /usr/src/ruby --strip-components=1; 	rm ruby.tar.xz; 		cd /usr/src/ruby; 		{ 		echo '#define ENABLE_PATH_CHECK 0'; 		echo; 		cat file.c; 	} &gt; file.c.new; 	mv file.c.new file.c; 		autoconf; 	gnuArch=&quot;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)&quot;; 	./configure 		--build=&quot;$gnuArch&quot; 		--disable-install-doc 		--enable-shared 	; 	make -j &quot;$(nproc)&quot;; 	make install; 		apt-mark auto '.*' &gt; /dev/null; 	apt-mark manual $savedAptMark &gt; /dev/null; 	find /usr/local -type f -executable -not \( -name '*tkinter*' \) -exec ldd '{}' ';' 		| awk '/=&gt;/ { print $(NF-1) }' 		| sort -u 		| xargs -r dpkg-query --search 		| cut -d: -f1 		| sort -u 		| xargs -r apt-mark manual 	; 	apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; 		cd /; 	rm -r /usr/src/ruby; 	! dpkg -l | grep -i ruby; 	[ &quot;$(command -v ruby)&quot; = '/usr/local/bin/ruby' ]; 	ruby --version; 	gem --version; 	bundle --version
ENV GEM_HOME=/usr/local/bundle
ENV BUNDLE_PATH=/usr/local/bundle BUNDLE_SILENCE_ROOT_WARNING=1 BUNDLE_APP_CONFIG=/usr/local/bundle
ENV PATH=/usr/local/bundle/bin:/usr/local/bundle/gems/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
RUN /bin/sh -c mkdir -p &quot;$GEM_HOME&quot; \
    &amp;&amp; chmod 777 &quot;$GEM_HOME&quot;
CMD [&quot;irb&quot;]
</code></pre>
<p>不過可惜的是像這樣的工具終究無法還原出真實 Dockerfile 中 COPY 或 ADD 的時候加入到 image 中的檔案。 例如以下是用該工具還原他自己:</p>
<pre><code class="language-shell">$ docker images | grep &quot;lukapeschke/dockerfile-from-image&quot;
lukapeschke/dockerfile-from-image             latest              d719f8dcb798        37 minutes ago      59 MB

$ docker run -v /var/run/docker.sock:/var/run/docker.sock lukapeschke/dockerfile-from-image d719f8dcb798
FROM docker.io/alpine:latest
RUN /bin/sh -c apk add --update python3 wget      \
    &amp;&amp; wget -O - --no-check-certificate https://bootstrap.pypa.io/get-pip.py | python3      \
    &amp;&amp; apk del wget      \
    &amp;&amp; pip3 install -U docker-py      \
    &amp;&amp; yes | pip3 uninstall pip
COPY file:d7369c0379dc34ec79c308a782b14eab9c86ed1ebc41b5ce859e32760518fb21 in /root
ENTRYPOINT [&quot;/root/entrypoint.py&quot;]
</code></pre>
<p>可以看到 COPY 的部分只能知道有檔案被複製到指定目錄而已。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="python-連接-redis"><a class="header" href="#python-連接-redis">python 連接 redis</a></h2>
<p>出處:https://cloud.tencent.com/developer/article/1892663</p>
<h3 id="redis-安裝"><a class="header" href="#redis-安裝">redis 安裝</a></h3>
<p>先確保redis 已經安裝並且啟動</p>
<p>(host port):(docker port)</p>
<pre><code class="language-sh">docker pull redis:latest
docker run -itd --name redis-test -p 1234:6379 redis
</code></pre>
<pre><code class="language-sh">docker ps
</code></pre>
<pre><code class="language-sh">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                       NAMES
5ccd903da485   redis     &quot;docker-entrypoint.s…&quot;   6 minutes ago   Up 6 minutes   0.0.0.0:1234-&gt;6379/tcp, :::1234-&gt;6379/tcp   redis-test
</code></pre>
<p>進入docker容器</p>
<pre><code class="language-sh">docker exec -it redis-test /bin/bash
</code></pre>
<p>進入容器後，可以使用redis-cli 命令<code>redis-cli SET key value</code>的值,<code>redis-cli GET key</code>取出對應的值</p>
<pre><code class="language-sh">root@ec62efc510ce:/data# redis-cli SET yoyo &quot;hello world&quot;
OK
root@ec62efc510ce:/data# redis-cli GET yoyo              
&quot;hello world&quot;
</code></pre>
<p>經過簡單的測試，說明沒有問題</p>
<h3 id="python-連-reids"><a class="header" href="#python-連-reids">python 連 reids</a></h3>
<p>接著講下如何用 python 程式碼連上 redis <a href="https://cloud.tencent.com/product/dbexpert?from=10680">資料庫服務</a>器。 先使用pip 安裝redis 驅動包</p>
<pre><code class="language-sh">pip install redis
</code></pre>
<p>程式碼很簡單</p>
<pre><code class="language-python">import redis
r = redis.StrictRedis(host='127.0.0.1', port=1234)
print(r.get('yoyo'))
</code></pre>
<p>運行結果是byte類型：<code>b'hello world'</code>，可以加個參數<code>decode_responses=True</code>,設定得到str字串</p>
<pre><code class="language-python">import redis
r = redis.StrictRedis(host='127.0.0.1', port=1234, decode_responses=True)
print(r.get('yoyo'))
</code></pre>
<p>於是可以得到字串:<code>yoyo</code></p>
<p>測試下set新增鍵值對，get取值，中文也是沒問題的</p>
<pre><code class="language-python">import redis
r = redis.StrictRedis(host='127.0.0.1', port=1234, decode_responses=True)

# set 設定key-value
r.set(&quot;name&quot;, &quot;上海-悠悠&quot;)
print(r.get(&quot;name&quot;))
</code></pre>
<p>運行結果:上海-悠悠</p>
<p>當key不存在的時候，get()取值返回結果是None</p>
<h2 id="python-docker-容器與-redis-docker-容器-連動"><a class="header" href="#python-docker-容器與-redis-docker-容器-連動">Python Docker 容器與 Redis Docker 容器 連動</a></h2>
<p>docker redis 安裝 </p>
<pre><code class="language-sh">docker pull redis:latest
</code></pre>
<p>由於您的 Python Docker 容器與 Redis Docker 容器不在同一個 Docker 網路上，因此您需要將 Python Docker 容器加入相同的 Docker 網路。您可以使用以下命令創建一個名為 my-network 的 Docker 網路：</p>
<pre><code class="language-sh">docker network create my-network
</code></pre>
<p>然後，您可以使用以下命令運行 Python Docker 容器，並將其加入 <code>my-network</code> 網路：</p>
<pre><code class="language-sh">docker run -itd --name redis-test -p 1234:6379 --network my-network &lt;image_name&gt;  使用 docker images 查看

docker run -itd --name redis-test -p 1234:6379 --network my-network redis
</code></pre>
<h3 id="build-the-python-docker-image"><a class="header" href="#build-the-python-docker-image">Build the python docker image:</a></h3>
<ul>
<li>requirements.txt</li>
</ul>
<pre><code class="language-sh">requests
kafka-python
grpcio
protobuf
better-exceptions
loguru
pandas
python-binance
redis
aiohttp
flask
kubernetes
</code></pre>
<ul>
<li>Dockerfile</li>
</ul>
<pre><code class="language-sh">FROM python:3.11-slim

# Add requirements file in the container
COPY requirements.txt ./requirements.txt
RUN pip install -r requirements.txt

# Add source code in the container
COPY redis_test_script.py ./redis_test_script.py

# Define container entry point (could also work with CMD python main.py)
ENTRYPOINT [&quot;python&quot;, &quot;redis_test_script.py&quot;]
</code></pre>
<p>在 Python 應用程式中使用 Redis 容器的 IP 位置，而不是使用 <code>127.0.0.1</code>。由於 Redis 容器的名稱為 <code>redis-test</code>，因此您可以使用以下程式碼來連接 Redis 服務：</p>
<ul>
<li>redis_test_script.py</li>
</ul>
<pre><code class="language-python">import redis
r = redis.StrictRedis(host='redis-test', port=6379, decode_responses=True)

# set 設定key-value
r.set(&quot;name&quot;, &quot;上海-悠悠&quot;)
print(r.get(&quot;name&quot;))
</code></pre>
<p>在這個命令中，-t 參數指定映像檔的名稱</p>
<pre><code class="language-sh">docker build -t python-redis .
</code></pre>
<pre><code class="language-sh">docker run -d --network=my-network --name my-db redis ...
docker run    --network=my-network python-redis ...
</code></pre>
<p>第一個指令 <code>docker run -d --network=my-network --name my-db redis ...</code> 是用來運行 Redis Docker 容器。這個指令中的 <code>--network=my-network</code> 參數表示將容器連接到 Docker 網路 <code>my-network</code> 中，因此其他 Docker 容器可以通過這個網路訪問 Redis 容器。 <code>--name my-db</code> 參數為容器指定了一個名稱 <code>my-db</code>，方便後續使用。<code>redis</code> 表示我們要使用的 Docker 映像檔名稱和版本。最後的 <code>...</code> 表示可以在這個命令後面加上其他的參數來運行 Redis 容器。</p>
<p>第二個指令 <code>docker run --network=my-network python-redis ...</code> 是用來運行 Python Docker 容器。這個指令中的 <code>--network=my-network</code> 參數表示將容器連接到 Docker 網路 <code>my-network</code> 中，這樣 Python 容器就可以通過這個網路訪問 Redis 容器。 <code>python-redis</code> 表示我們要使用的 Docker 映像檔名稱和版本。最後的 <code>...</code> 表示可以在這個命令後面加上其他的參數來運行 Python 容器。</p>
<p>在這兩個指令中，<code>--network</code> 參數用於指定容器所使用的 Docker 網路，讓不同的容器可以在同一個網路中進行通信。 <code>--name</code> 參數用於指定容器的名稱，方便後續使用。而最後的 <code>...</code> 可以用於指定其他的參數，例如指定容器運行的命令等等。</p>
<h2 id="docker-connect-to-host"><a class="header" href="#docker-connect-to-host">Docker connect to host</a></h2>
<pre><code class="language-sh">docker build -t python-redis .

docker run --network=host -it  python-redis
</code></pre>
<p>Docker 容器內部的 Python 程式直接連接到宿主機器上運行的 Redis 服務。請注意，使用 <code>--network=host</code> 參數可能會降低容器的安全性，因為容器可以訪問宿主機器上的所有網路資源。因此，建議在必要時才使用這個參數。</p>
<pre><code class="language-python">import redis

r = redis.StrictRedis(host='127.0.0.1', port=6379, decode_responses=True)
# set 設定key-value
r.set(&quot;name&quot;, &quot;上海-悠悠 127.0.0.1&quot;)
print(r.get(&quot;name&quot;))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="docker-常用的指令"><a class="header" href="#docker-常用的指令">Docker 常用的指令</a></h2>
<p><img src="docker/images/dockercommand.png" alt="" /></p>
<p><img src="docker/images/docker-command-flow.png" alt="" /></p>
<p><img src="docker/images/images%2Fgwak2837%2Fpost%2F11ba0808-e871-4912-9ecc-234ed0f62587%2FIMG_0107.webp" alt="" /></p>
<h2 id="image"><a class="header" href="#image">image</a></h2>
<p>如果要搜索 image 可以上 dockerhub 找(裡面都有可以直接抓下來的指令)</p>
<pre><code>docker pull image_name
# 從 Dockerhub 拉回 image
docker images
docker image ls
# 列出本地 image
docker rmi (image_name or image_id)
#移除 image
</code></pre>
<h2 id="container"><a class="header" href="#container">Container</a></h2>
<pre><code># 查看本地 container
# -a：顯示所有執行中的 container。
docker ps (-a)
docker container ls (-a)
# 執行 container
docker start (container_id or container_name)
# 離開 container
exit  (退出並停止容器)
# 停止 container
docker stop (container_id or container_name)
# 移除 container
docker rm (container_id or container_name)
</code></pre>
<h2 id="volume"><a class="header" href="#volume">volume</a></h2>
<p>將本機的某個位置掛載至 Container 的某個位置。</p>
<pre><code># 列出本地 volume
docker volume ls
# 移除 volume
docker volume rm volume_name

# 移除所有未使用的 volume
docker volume prune
</code></pre>
<hr />
<h2 id="清理docker的containerimage與volume"><a class="header" href="#清理docker的containerimage與volume">清理Docker的container，image與volume</a></h2>
<p>出處: https://note.qidong.name/2017/06/26/docker-clean/</p>
<p>Docker的鏡像（image）、容器（container）、資料卷（volume）， 都是由daemon託管的。 因此，在需要清理時，也需要使用其自帶的手段。</p>
<h2 id="清理技巧-"><a class="header" href="#清理技巧-">清理技巧 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E6%8A%80%E5%B7%A7">¶</a></a></h2>
<p>清理所有停止運行的容器：</p>
<pre><code class="language-sh">docker container prune
# or
docker rm $(docker ps -aq)
</code></pre>
<p>清理所有懸掛（<code>&lt;none&gt;</code>）鏡像：</p>
<pre><code class="language-sh">docker image prune
# or
docker rmi $(docker images -qf &quot;dangling=true&quot;)
</code></pre>
<p>清理所有無用資料卷：</p>
<pre><code class="language-sh">docker volume prune
</code></pre>
<p>由於<code>prune</code>操作是批次刪除類的危險操作，所以會有一次確認。 如果不想輸入<code>y&lt;CR&gt;</code>來確認，可以新增<code>-f</code>操作。慎用！</p>
<h2 id="清理停止的容器-"><a class="header" href="#清理停止的容器-">清理停止的容器 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8">¶</a></a></h2>
<pre><code class="language-sh">docker rm -lv CONTAINER
</code></pre>
<p><code>-l</code>是清理link，<code>v</code>是清理volume。 這裡的CONTAINER是容器的name或ID，可以是一個或多個。</p>
<p>參數列表：</p>
<table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>–force, -f</td><td>false</td><td>Force the removal of a running container (uses SIGKILL)</td></tr>
<tr><td>–link, -l</td><td>false</td><td>Remove the specified link</td></tr>
<tr><td>–volumes, -v</td><td>false</td><td>Remove the volumes associated with the container</td></tr>
</tbody></table>
<h3 id="清理所有停止的容器-"><a class="header" href="#清理所有停止的容器-">清理所有停止的容器 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E6%89%80%E6%9C%89%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8">¶</a></a></h3>
<p>通過<code>docker ps</code>可以查詢當前運行的容器資訊。 而通過<code>docker ps -a</code>，可以查詢所有的容器資訊，包括已停止的。</p>
<p>在需要清理所有已停止的容器時，通常利用shell的特性，組合一下就好。</p>
<pre><code class="language-sh">docker rm $(docker ps -aq)
</code></pre>
<p>其中，<code>ps</code>的<code>-q</code>，是隻輸出容器ID，方便作為參數讓<code>rm</code>使用。 假如給<code>rm</code>指定<code>-f</code>，則可以清理所有容器，包括正在運行的。</p>
<p>這條組合命令，等價於另一條命令：</p>
<pre><code class="language-sh">docker container prune
</code></pre>
<p><code>container</code>子命令，下面包含了所有和容器相關的子命令。 包括<code>docker ps</code>，等價於<code>docker container ps</code>或<code>docker container ls</code>。 其餘還有<code>start</code>、<code>stop</code>、<code>kill</code>、<code>cp</code>等，一級子命令相當於二級子命令在外面的alias。 而<code>prune</code>則是特別提供的清理命令，這在其它的管理命令裡還可以看到，比如<code>image</code>、<code>volume</code>。</p>
<h3 id="按需批次清理容器-"><a class="header" href="#按需批次清理容器-">按需批次清理容器 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%8C%89%E9%9C%80%E6%89%B9%E9%87%8F%E6%B8%85%E7%90%86%E5%AE%B9%E5%99%A8">¶</a></a></h3>
<p>清除所有已停止的容器，是比較常用的清理。 但有時會需要做一些特殊過濾。</p>
<p>這時就需要使用<code>docker ps --filter</code>。</p>
<p>比如，顯示所有返回值為0，即正常退出的容器：</p>
<pre><code class="language-sh">docker ps -a --filter 'exited=0'
</code></pre>
<p>同理，可以得到其它非正常退出的容器。</p>
<p>目前支援的過濾器有：</p>
<blockquote>
<ul>
<li>id (container’s id)</li>
<li>label (<code>label=&lt;key&gt;</code> or <code>label=&lt;key&gt;=&lt;value&gt;</code>)</li>
<li>name (container’s name)</li>
<li>exited (int - the code of exited containers. Only useful with –all)</li>
<li>status (<code>created|restarting|running|removing|paused|exited|dead</code>)</li>
<li>ancestor (<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>, <code>&lt;image id&gt;</code> or <code>&lt;image@digest&gt;</code>) - filters containers that were created from the given image or a descendant.</li>
<li>before (container’s id or name) - filters containers created before given id or name</li>
<li>since (container’s id or name) - filters containers created since given id or name</li>
<li>isolation (<code>default|process|hyperv</code>) (Windows daemon only)</li>
<li>volume (volume name or mount point) - filters containers that mount volumes.</li>
<li>network (network id or name) - filters containers connected to the provided network</li>
<li>health (<code>starting|healthy|unhealthy|none</code>) - filters containers based on healthcheck status</li>
</ul>
</blockquote>
<h3 id="清理失敗-"><a class="header" href="#清理失敗-">清理失敗 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E5%A4%B1%E6%95%97">¶</a></a></h3>
<p>如果在清理容器時發生失敗，通過重啟Docker的Daemon，應該都能解決問題。</p>
<pre><code class="language-sh"># systemd
sudo systemctl restart docker.service

# initd
sudo service docker restart
</code></pre>
<h2 id="清理鏡像-"><a class="header" href="#清理鏡像-">清理鏡像 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E9%8F%A1%E5%83%8F">¶</a></a></h2>
<p>與清理容器的<code>ps</code>、<code>rm</code>類似，清理鏡像也有<code>images</code>、<code>rmi</code>兩個子命令。 <code>images</code>用來查看，<code>rmi</code>用來刪除。</p>
<p>清理鏡像前，應該確保該鏡像的容器，已經被清除。</p>
<pre><code class="language-sh">docker rmi IMAGE
</code></pre>
<p>其中，IMAGE可以是name或ID。 如果是name，不加TAG可以刪除所有TAG。</p>
<p>另外，這兩個命令也都屬於alias。 <code>docker images</code>等價於<code>docker image ls</code>，而<code>docker rmi</code>等價於<code>docker image rm</code>。</p>
<h3 id="按需批次清理鏡像-"><a class="header" href="#按需批次清理鏡像-">按需批次清理鏡像 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%8C%89%E9%9C%80%E6%89%B9%E9%87%8F%E6%B8%85%E7%90%86%E9%8F%A1%E5%83%8F">¶</a></a></h3>
<p>與<code>ps</code>類似，<code>images</code>也支援<code>--filter</code>參數。</p>
<p>與清理相關，最常用的，當屬<code>&lt;none&gt;</code>了。</p>
<pre><code class="language-sh">docker images --filter &quot;dangling=true&quot;
</code></pre>
<p>這條命令，可以列出所有懸掛（dangling）的鏡像，也就是顯示為<code>&lt;none&gt;</code>的那些。</p>
<pre><code class="language-sh">docker rmi $(docker images -qf &quot;dangling=true&quot;)
</code></pre>
<p>這條組合命令，如果不寫入Bash的alias，幾乎無法使用。 不過還有一條等價命令，非常容易使用。</p>
<pre><code class="language-sh">docker image prune
</code></pre>
<p><code>prune</code>和<code>images</code>類似，也同樣支援<code>--filter</code>參數。 其它的filter有：</p>
<blockquote>
<ul>
<li>dangling (boolean - true or false)</li>
<li>label (<code>label=&lt;key&gt;</code> or <code>label=&lt;key&gt;=&lt;value&gt;</code>)</li>
<li>before (<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>, <code>&lt;image id&gt;</code> or <code>&lt;image@digest&gt;</code>) - filter images created before given id or references</li>
<li>since (<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>, <code>&lt;image id&gt;</code> or <code>&lt;image@digest&gt;</code>) - filter images created since given id or references</li>
<li>reference (pattern of an image reference) - filter images whose reference matches the specified pattern</li>
</ul>
</blockquote>
<h3 id="清理所有無用鏡像-"><a class="header" href="#清理所有無用鏡像-">清理所有無用鏡像 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E6%89%80%E6%9C%89%E7%84%A1%E7%94%A8%E9%8F%A1%E5%83%8F">¶</a></a></h3>
<p>這招要慎用，否則需要重新下載。</p>
<pre><code class="language-sh">docker image prune -a
</code></pre>
<h2 id="清理資料卷-"><a class="header" href="#清理資料卷-">清理資料卷 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E6%B8%85%E7%90%86%E6%95%B8%E6%93%9A%E5%8D%B7">¶</a></a></h2>
<p>資料卷不如容器或鏡像那樣顯眼，但佔的硬碟卻可大可小。</p>
<p>資料卷的相關命令，都在<code>docker volume</code>中了。</p>
<p>一般用<code>docker volume ls</code>來查看，用<code>docker volume rm VOLUME</code>來刪除一個或多個。</p>
<p>不過，絕大多數情況下，不需要執行這兩個命令的組合。 直接執行<code>docker volume prune</code>就好，即可刪除所有無用卷。</p>
<p>注意：<strong>這是一個危險操作！甚至可以說，這是本文中最危險的操作！</strong> 一般真正有價值的運行資料，都在資料卷中。 （當然也可能掛載到了容器外的檔案系統裡，那就沒關係。） 如果在關鍵服務停止期間，執行這個操作，很可能會<strong>丟失所有資料</strong>！</p>
<h2 id="從檔案系統刪除-"><a class="header" href="#從檔案系統刪除-">從檔案系統刪除 <a href="https://note.qidong.name/2017/06/26/docker-clean/#%E5%BE%9E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%B5%B1%E5%88%AA%E9%99%A4">¶</a></a></h2>
<p>除組態檔案以為，Docker的內容相關檔案，基本都放在<code>/var/lib/docker/</code>目錄下。</p>
<p>該目錄下有下列子目錄，基本可以猜測出用途：</p>
<ul>
<li>aufs</li>
<li>containers</li>
<li>image</li>
<li>network</li>
<li>plugins</li>
<li>swarm</li>
<li>tmp</li>
<li>trust</li>
<li>volumes</li>
</ul>
<p>一般不推薦直接操作這些目錄，除非一些極特殊情況。 操作不當，後果難料，需要慎重。</p>
<h2 id="這兩個-docker-命令的差異在於它們的目的和執行方式"><a class="header" href="#這兩個-docker-命令的差異在於它們的目的和執行方式">這兩個 Docker 命令的差異在於它們的目的和執行方式。</a></h2>
<pre><code class="language-sh">docker run -it --rm redis bash 
docker exec -it redis sh
</code></pre>
<ul>
<li><code>docker run -it --rm redis bash</code> 命令的目的是啟動一個 Redis 容器，然後在容器中執行一個交互式 Bash shell。這個命令會建立一個新的容器，並且在容器內啟動一個新的 Bash shell。在這個 shell 中，您可以在容器內進行任何操作，就像在一個本地的 Bash shell 中一樣。這個容器會在退出 shell 後立即被刪除，因為我們使用了 <code>--rm</code> 選項。</li>
<li><code>docker exec -it redis sh</code> 命令的目的是在一個已經運行的 Redis 容器中執行一個新的交互式 shell。這個命令不會創建新的容器，而是在現有的 Redis 容器內運行一個新的 shell。因此，使用這個命令，您必須先啟動一個 Redis 容器。在 shell 中，您可以在容器內進行任何操作，並且這些操作將會對容器內的系統環境進行更改。該容器不會被刪除，因為我們沒有使用 <code>--rm</code> 選項。</li>
</ul>
<p>簡而言之，<code>docker run</code> 命令用於啟動新容器，而 <code>docker exec</code> 命令則用於在現有容器中運行命令。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-docker-compose-啟動多個-docker-container"><a class="header" href="#使用-docker-compose-啟動多個-docker-container">使用 Docker-Compose 啟動多個 Docker Container</a></h2>
<p>出處：https://ithelp.ithome.com.tw/articles/10194183</p>
<p>今天要介紹有關於 Docker-Compose 的部份，之前有介紹過使用 <code>docker run</code> 指令就可以把 Docker Container 啟動起來，但是如果我們要啟動很多個 Docker Container 時，就需要輸入很多次 <code>docker run</code> 指令，另外 container 和 container 之間要做關聯的話也要記得它們之間要如何的連結(link) Container，這樣在要啟動多個 Container 的情況下，就會顯得比較麻煩。</p>
<p>因此就出現了 Docker-Compose，只要寫一個 <code>docker-compose.yml</code>，把所有要使用 Docker Image 寫上去，另外也可以把 Container 之間的關係連結(link)起來，最後只要下 <code>docker-compose up</code> 指令，就可以把所有的 Docker Container 執行起來，這樣就可以很快速和方便的啟動多個 container。</p>
<p>實作的部份主要就是要把 Docker-Compose 安裝起來，然後撰寫一個 <code>docker-compose.yml</code>，並且使用 <code>docker-compose up</code>，指令把所有的 Docker Container 啟動起來，步驟如下：</p>
<p><strong>1. 安裝 Docker-Compose，指令如下</strong></p>
<pre><code>https://github.com/docker/compose/releases/

sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose

# cd /usr/bin
# wget https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64
# mv docker-compose-Linux-x86_64 docker-compose
# chmod 755 docker-compose
</code></pre>
<p><strong>2. 撰寫 <code>docker-compose.yml</code> 檔案如下</strong></p>
<pre><code>version: '2'
services:
  db:
     image: mysql
     environment:
        MYSQL_ROOT_PASSWORD: 123456
  admin:
     image: adminer
     ports:
       - 8080:8080
</code></pre>
<p>這個 <code>docker-compose.yml</code> 的檔案，是參考以下網站，改寫出來的
https://hub.docker.com/_/mysql/</p>
<p>主要的功能是要啟動 2 個 Docker Container，一個是 mysql 的 Container，另外一個是 admin 管理 mysql Web UI 的 container</p>
<p><code>MYSQL_ROOT_PASSWORD</code> 的環境變數用來設定登入 mysql 的密碼</p>
<p><strong>3. 啟動所有的 Docker Container 指令如下</strong></p>
<pre><code>$ docker-compose up -d
</code></pre>
<p>執行所有在 <code>docker-compose.yml</code> 檔案裡面設定的 Docker Image 啟動 Docker Container，另外 <code>-d</code> 參數代表要執行在背景的方式</p>
<p><strong>4. 使用 Docker-Compose 提供的指令查看 Docker Container 的執行狀態</strong></p>
<pre><code>$ docker-compose ps
</code></pre>
<p>要輸入此指令之前，要先把資料夾切到和 <code>docker-compose.yml</code> 同一層的資料夾路徑下面，執行結果如下
<img src="https://ithelp.ithome.com.tw/upload/images/20171227/20103456PGcFzKD8zW.png" alt="https://ithelp.ithome.com.tw/upload/images/20171227/20103456PGcFzKD8zW.png" /></p>
<p><strong>5. admin 執行的畫面如下</strong>
<img src="https://ithelp.ithome.com.tw/upload/images/20171227/20103456TxflRKpTN0.png" alt="https://ithelp.ithome.com.tw/upload/images/20171227/20103456TxflRKpTN0.png" /></p>
<p>帳號輸入 root 和密碼輸入 123456，之後就可以登入 mysql 的管理畫面，畫面如下：
<img src="https://ithelp.ithome.com.tw/upload/images/20171227/20103456lWgPQa4fXY.png" alt="https://ithelp.ithome.com.tw/upload/images/20171227/20103456lWgPQa4fXY.png" /></p>
<p><strong>6. 如果要看執行的 log 可以使用以下的指令</strong></p>
<pre><code>$ docker-compose logs
</code></pre>
<p>另外 <code>logs</code> 後面可以加上 Container Name
畫面如下
<img src="https://ithelp.ithome.com.tw/upload/images/20171227/201034564Ljx8jccEw.png" alt="https://ithelp.ithome.com.tw/upload/images/20171227/201034564Ljx8jccEw.png" /></p>
<p><strong>7. 如果要停止 docker-compose 執行的所有 Container 可以使用以下的指令</strong></p>
<pre><code>$ docker-compose stop
</code></pre>
<p><strong>8. 如果要刪除 docker-compose 的所有 Container 可以使用以下的指令</strong></p>
<pre><code>$ docker-compose rm
</code></pre>
<p>畫面如下
<img src="https://ithelp.ithome.com.tw/upload/images/20171227/20103456GIP06bKAUX.png" alt="https://ithelp.ithome.com.tw/upload/images/20171227/20103456GIP06bKAUX.png" /></p>
<p>今天介紹的 Docker-Compose 可以很方便的讓我們在執行啟動多個 Container，其實 <code>docker-compose.yml</code>，還有很多的寫法沒有介紹到，因此有興趣的話可以參考官方網站的說明，網址如下：
https://docs.docker.com/compose/compose-file/compose-file-v2/</p>
<hr />
<h2 id="docker-compse-安裝-redis"><a class="header" href="#docker-compse-安裝-redis">docker-compse 安裝 Redis</a></h2>
<ul>
<li>
<p>Run</p>
<pre><code class="language-sh">docker-compose -f docker-compose.yml up -d
</code></pre>
</li>
<li>
<p>test.py</p>
<pre><code class="language-python">import redis

r = redis.StrictRedis(host='127.0.0.1', port=1234, password='12345678')
print(r.get('yoyo'))
</code></pre>
</li>
<li></li>
<li>
<p>docker-compose.yml</p>
<pre><code class="language-python">version: '3.3'
services:
  redis:
    image: redis
    container_name: redis
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - &quot;1234:6379&quot;
    volumes:
      - ./data:/data
      - ./redis.conf:/usr/local/etc/redis/redis.conf
</code></pre>
<p>redis.conf</p>
<pre><code class="language-python"># Redis configuration file example.
#
# Note that in order to read the configuration file, Redis must be
# started with the file path as first argument:
#
# ./redis-server /path/to/redis.conf

# Note on units: when memory size is needed, it is possible to specify
# it in the usual form of 1k 5GB 4M and so forth:
#
# 1k =&gt; 1000 bytes
# 1kb =&gt; 1024 bytes
# 1m =&gt; 1000000 bytes
# 1mb =&gt; 1024*1024 bytes
# 1g =&gt; 1000000000 bytes
# 1gb =&gt; 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.

################################## INCLUDES ###################################

# Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis servers but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
#
# Notice option &quot;include&quot; won't be rewritten by command &quot;CONFIG REWRITE&quot;
# from admin or Redis Sentinel. Since Redis always uses the last processed
# line as value of a configuration directive, you'd better put includes
# at the beginning of this file to avoid overwriting config change at runtime.
#
# If instead you are interested in using includes to override configuration
# options, it is better to use include as the last line.
#
# include /path/to/local.conf
# include /path/to/other.conf

################################## MODULES #####################################

# Load modules at startup. If the server is not able to load modules
# it will abort. It is possible to use multiple loadmodule directives.
#
# loadmodule /path/to/my_module.so
# loadmodule /path/to/other_module.so

################################## NETWORK #####################################

# By default, if no &quot;bind&quot; configuration directive is specified, Redis listens
# for connections from all the network interfaces available on the server.
# It is possible to listen to just one or multiple selected interfaces using
# the &quot;bind&quot; configuration directive, followed by one or more IP addresses.
#
# Examples:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
#
# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
# internet, binding to all the interfaces is dangerous and will expose the
# instance to everybody on the internet. So by default we uncomment the
# following bind directive, that will force Redis to listen only into
# the IPv4 loopback interface address (this means Redis will be able to
# accept connections only from clients running into the same computer it
# is running).
#
# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
# JUST COMMENT THE FOLLOWING LINE.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# bind 127.0.0.1

# Protected mode is a layer of security protection, in order to avoid that
# Redis instances left open on the internet are accessed and exploited.
#
# When protected mode is on and if:
#
# 1) The server is not binding explicitly to a set of addresses using the
#    &quot;bind&quot; directive.
# 2) No password is configured.
#
# The server only accepts connections from clients connecting from the
# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
# sockets.
#
# By default protected mode is enabled. You should disable it only if
# you are sure you want clients from other hosts to connect to Redis
# even if no authentication is configured, nor a specific set of interfaces
# are explicitly listed using the &quot;bind&quot; directive.
protected-mode yes

# Accept connections on the specified port, default is 6379 (IANA #815344).
# If port 0 is specified Redis will not listen on a TCP socket.
port 6379

# TCP listen() backlog.
#
# In high requests-per-second environments you need an high backlog in order
# to avoid slow clients connections issues. Note that the Linux kernel
# will silently truncate it to the value of /proc/sys/net/core/somaxconn so
# make sure to raise both the value of somaxconn and tcp_max_syn_backlog
# in order to get the desired effect.
tcp-backlog 511

# Unix socket.
#
# Specify the path for the Unix socket that will be used to listen for
# incoming connections. There is no default, so Redis will not listen
# on a unix socket when not specified.
#
# unixsocket /tmp/redis.sock
# unixsocketperm 700

# Close the connection after a client is idle for N seconds (0 to disable)
timeout 0

# TCP keepalive.
#
# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
# of communication. This is useful for two reasons:
#
# 1) Detect dead peers.
# 2) Take the connection alive from the point of view of network
#    equipment in the middle.
#
# On Linux, the specified value (in seconds) is the period used to send ACKs.
# Note that to close the connection the double of the time is needed.
# On other kernels the period depends on the kernel configuration.
#
# A reasonable value for this option is 300 seconds, which is the new
# Redis default starting with Redis 3.2.1.
tcp-keepalive 300

################################# GENERAL #####################################

# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize no

# If you run Redis from upstart or systemd, Redis can interact with your
# supervision tree. Options:
#   supervised no      - no supervision interaction
#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
#   supervised auto    - detect upstart or systemd method based on
#                        UPSTART_JOB or NOTIFY_SOCKET environment variables
# Note: these supervision methods only signal &quot;process is ready.&quot;
#       They do not enable continuous liveness pings back to your supervisor.
supervised no

# If a pid file is specified, Redis writes it where specified at startup
# and removes it at exit.
#
# When the server runs non daemonized, no pid file is created if none is
# specified in the configuration. When the server is daemonized, the pid file
# is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.
#
# Creating a pid file is best effort: if Redis is not able to create it
# nothing bad happens, the server will start and run normally.
pidfile /var/run/redis_6379.pid

# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice

# Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile &quot;&quot;

# To enable logging to the system logger, just set 'syslog-enabled' to yes,
# and optionally update the other syslog parameters to suit your needs.
# syslog-enabled no

# Specify the syslog identity.
# syslog-ident redis

# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
# syslog-facility local0

# Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT &lt;dbid&gt; where
# dbid is a number between 0 and 'databases'-1
databases 16

# By default Redis shows an ASCII art logo only when started to log to the
# standard output and if the standard output is a TTY. Basically this means
# that normally a logo is displayed only in interactive sessions.
#
# However it is possible to force the pre-4.0 behavior and always show a
# ASCII art logo in startup logs by setting the following option to yes.
always-show-logo yes

################################ SNAPSHOTTING  ################################
#
# Save the DB on disk:
#
#   save &lt;seconds&gt; &lt;changes&gt;
#
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
#
#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.
#
#   It is also possible to remove all the previously configured save
#   points by adding a save directive with a single empty string argument
#   like in the following example:
#
#   save &quot;&quot;

save 900 1
save 300 10
save 60 10000

# By default Redis will stop accepting writes if RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases?
# For default that's set to 'yes' as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
rdbchecksum yes

# The filename where to dump the DB
dbfilename dump.rdb

# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir ./

################################# REPLICATION #################################

# Master-Replica replication. Use replicaof to make a Redis instance a copy of
# another Redis server. A few things to understand ASAP about Redis replication.
#
#   +------------------+      +---------------+
#   |      Master      | ---&gt; |    Replica    |
#   | (receive writes) |      |  (exact copy) |
#   +------------------+      +---------------+
#
# 1) Redis replication is asynchronous, but you can configure a master to
#    stop accepting writes if it appears to be not connected with at least
#    a given number of replicas.
# 2) Redis replicas are able to perform a partial resynchronization with the
#    master if the replication link is lost for a relatively small amount of
#    time. You may want to configure the replication backlog size (see the next
#    sections of this file) with a sensible value depending on your needs.
# 3) Replication is automatic and does not need user intervention. After a
#    network partition replicas automatically try to reconnect to masters
#    and resynchronize with them.
#
# replicaof &lt;masterip&gt; &lt;masterport&gt;

# If the master is password protected (using the &quot;requirepass&quot; configuration
# directive below) it is possible to tell the replica to authenticate before
# starting the replication synchronization process, otherwise the master will
# refuse the replica request.
#
# masterauth &lt;master-password&gt;

# When a replica loses its connection with the master, or when the replication
# is still in progress, the replica can act in two different ways:
#
# 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
#    still reply to client requests, possibly with out of date data, or the
#    data set may just be empty if this is the first synchronization.
#
# 2) if replica-serve-stale-data is set to 'no' the replica will reply with
#    an error &quot;SYNC with master in progress&quot; to all the kind of commands
#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
#    COMMAND, POST, HOST: and LATENCY.
#
replica-serve-stale-data yes

# You can configure a replica instance to accept writes or not. Writing against
# a replica instance may be useful to store some ephemeral data (because data
# written on a replica will be easily deleted after resync with the master) but
# may also cause problems if clients are writing to it because of a
# misconfiguration.
#
# Since Redis 2.6 by default replicas are read-only.
#
# Note: read only replicas are not designed to be exposed to untrusted clients
# on the internet. It's just a protection layer against misuse of the instance.
# Still a read only replica exports by default all the administrative commands
# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
# security of read only replicas using 'rename-command' to shadow all the
# administrative / dangerous commands.
replica-read-only yes

# Replication SYNC strategy: disk or socket.
#
# -------------------------------------------------------
# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY
# -------------------------------------------------------
#
# New replicas and reconnecting replicas that are not able to continue the replication
# process just receiving differences, need to do what is called a &quot;full
# synchronization&quot;. An RDB file is transmitted from the master to the replicas.
# The transmission can happen in two different ways:
#
# 1) Disk-backed: The Redis master creates a new process that writes the RDB
#                 file on disk. Later the file is transferred by the parent
#                 process to the replicas incrementally.
# 2) Diskless: The Redis master creates a new process that directly writes the
#              RDB file to replica sockets, without touching the disk at all.
#
# With disk-backed replication, while the RDB file is generated, more replicas
# can be queued and served with the RDB file as soon as the current child producing
# the RDB file finishes its work. With diskless replication instead once
# the transfer starts, new replicas arriving will be queued and a new transfer
# will start when the current one terminates.
#
# When diskless replication is used, the master waits a configurable amount of
# time (in seconds) before starting the transfer in the hope that multiple replicas
# will arrive and the transfer can be parallelized.
#
# With slow disks and fast (large bandwidth) networks, diskless replication
# works better.
repl-diskless-sync no

# When diskless replication is enabled, it is possible to configure the delay
# the server waits in order to spawn the child that transfers the RDB via socket
# to the replicas.
#
# This is important since once the transfer starts, it is not possible to serve
# new replicas arriving, that will be queued for the next RDB transfer, so the server
# waits a delay in order to let more replicas arrive.
#
# The delay is specified in seconds, and by default is 5 seconds. To disable
# it entirely just set it to 0 seconds and the transfer will start ASAP.
repl-diskless-sync-delay 5

# Replicas send PINGs to server in a predefined interval. It's possible to change
# this interval with the repl_ping_replica_period option. The default value is 10
# seconds.
#
# repl-ping-replica-period 10

# The following option sets the replication timeout for:
#
# 1) Bulk transfer I/O during SYNC, from the point of view of replica.
# 2) Master timeout from the point of view of replicas (data, pings).
# 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
#
# It is important to make sure that this value is greater than the value
# specified for repl-ping-replica-period otherwise a timeout will be detected
# every time there is low traffic between the master and the replica.
#
# repl-timeout 60

# Disable TCP_NODELAY on the replica socket after SYNC?
#
# If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and
# less bandwidth to send data to replicas. But this can add a delay for
# the data to appear on the replica side, up to 40 milliseconds with
# Linux kernels using a default configuration.
#
# If you select &quot;no&quot; the delay for data to appear on the replica side will
# be reduced but more bandwidth will be used for replication.
#
# By default we optimize for low latency, but in very high traffic conditions
# or when the master and replicas are many hops away, turning this to &quot;yes&quot; may
# be a good idea.
repl-disable-tcp-nodelay no

# Set the replication backlog size. The backlog is a buffer that accumulates
# replica data when replicas are disconnected for some time, so that when a replica
# wants to reconnect again, often a full resync is not needed, but a partial
# resync is enough, just passing the portion of data the replica missed while
# disconnected.
#
# The bigger the replication backlog, the longer the time the replica can be
# disconnected and later be able to perform a partial resynchronization.
#
# The backlog is only allocated once there is at least a replica connected.
#
# repl-backlog-size 1mb

# After a master has no longer connected replicas for some time, the backlog
# will be freed. The following option configures the amount of seconds that
# need to elapse, starting from the time the last replica disconnected, for
# the backlog buffer to be freed.
#
# Note that replicas never free the backlog for timeout, since they may be
# promoted to masters later, and should be able to correctly &quot;partially
# resynchronize&quot; with the replicas: hence they should always accumulate backlog.
#
# A value of 0 means to never release the backlog.
#
# repl-backlog-ttl 3600

# The replica priority is an integer number published by Redis in the INFO output.
# It is used by Redis Sentinel in order to select a replica to promote into a
# master if the master is no longer working correctly.
#
# A replica with a low priority number is considered better for promotion, so
# for instance if there are three replicas with priority 10, 100, 25 Sentinel will
# pick the one with priority 10, that is the lowest.
#
# However a special priority of 0 marks the replica as not able to perform the
# role of master, so a replica with priority of 0 will never be selected by
# Redis Sentinel for promotion.
#
# By default the priority is 100.
replica-priority 100

# It is possible for a master to stop accepting writes if there are less than
# N replicas connected, having a lag less or equal than M seconds.
#
# The N replicas need to be in &quot;online&quot; state.
#
# The lag in seconds, that must be &lt;= the specified value, is calculated from
# the last ping received from the replica, that is usually sent every second.
#
# This option does not GUARANTEE that N replicas will accept the write, but
# will limit the window of exposure for lost writes in case not enough replicas
# are available, to the specified number of seconds.
#
# For example to require at least 3 replicas with a lag &lt;= 10 seconds use:
#
# min-replicas-to-write 3
# min-replicas-max-lag 10
#
# Setting one or the other to 0 disables the feature.
#
# By default min-replicas-to-write is set to 0 (feature disabled) and
# min-replicas-max-lag is set to 10.

# A Redis master is able to list the address and port of the attached
# replicas in different ways. For example the &quot;INFO replication&quot; section
# offers this information, which is used, among other tools, by
# Redis Sentinel in order to discover replica instances.
# Another place where this info is available is in the output of the
# &quot;ROLE&quot; command of a master.
#
# The listed IP and address normally reported by a replica is obtained
# in the following way:
#
#   IP: The address is auto detected by checking the peer address
#   of the socket used by the replica to connect with the master.
#
#   Port: The port is communicated by the replica during the replication
#   handshake, and is normally the port that the replica is using to
#   listen for connections.
#
# However when port forwarding or Network Address Translation (NAT) is
# used, the replica may be actually reachable via different IP and port
# pairs. The following two options can be used by a replica in order to
# report to its master a specific set of IP and port, so that both INFO
# and ROLE will report those values.
#
# There is no need to use both the options if you need to override just
# the port or the IP address.
#
# replica-announce-ip 5.5.5.5
# replica-announce-port 1234

################################## SECURITY ###################################

# Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
#
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.

requirepass 12345678

# Command renaming.
#
# It is possible to change the name of dangerous commands in a shared
# environment. For instance the CONFIG command may be renamed into something
# hard to guess so that it will still be available for internal-use tools
# but not available for general clients.
#
# Example:
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# It is also possible to completely kill a command by renaming it into
# an empty string:
#
# rename-command CONFIG &quot;&quot;
#
# Please note that changing the name of commands that are logged into the
# AOF file or transmitted to replicas may cause problems.

################################### CLIENTS ####################################

# Set the max number of connected clients at the same time. By default
# this limit is set to 10000 clients, however if the Redis server is not
# able to configure the process file limit to allow for the specified limit
# the max number of allowed clients is set to the current file limit
# minus 32 (as Redis reserves a few file descriptors for internal uses).
#
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.
#
# maxclients 10000

############################## MEMORY MANAGEMENT ################################

# Set a memory usage limit to the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys
# according to the eviction policy selected (see maxmemory-policy).
#
# If Redis can't remove keys according to the policy, or if the policy is
# set to 'noeviction', Redis will start to reply with errors to commands
# that would use more memory, like SET, LPUSH, and so on, and will continue
# to reply to read-only commands like GET.
#
# This option is usually useful when using Redis as an LRU or LFU cache, or to
# set a hard memory limit for an instance (using the 'noeviction' policy).
#
# WARNING: If you have replicas attached to an instance with maxmemory on,
# the size of the output buffers needed to feed the replicas are subtracted
# from the used memory count, so that network problems / resyncs will
# not trigger a loop where keys are evicted, and in turn the output
# buffer of replicas is full with DELs of keys evicted triggering the deletion
# of more keys, and so forth until the database is completely emptied.
#
# In short... if you have replicas attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for replica
# output buffers (but this is not needed if the policy is 'noeviction').
#
# maxmemory &lt;bytes&gt;

# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
# is reached. You can select among five behaviors:
#
# volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.
# allkeys-lru -&gt; Evict any key using approximated LRU.
# volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.
# allkeys-lfu -&gt; Evict any key using approximated LFU.
# volatile-random -&gt; Remove a random key among the ones with an expire set.
# allkeys-random -&gt; Remove a random key, any key.
# volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)
# noeviction -&gt; Don't evict anything, just return an error on write operations.
#
# LRU means Least Recently Used
# LFU means Least Frequently Used
#
# Both LRU, LFU and volatile-ttl are implemented using approximated
# randomized algorithms.
#
# Note: with any of the above policies, Redis will return an error on write
#       operations, when there are no suitable keys for eviction.
#
#       At the date of writing these commands are: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#
# The default is:
#
# maxmemory-policy noeviction

# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
# algorithms (in order to save memory), so you can tune it for speed or
# accuracy. For default Redis will check five keys and pick the one that was
# used less recently, you can change the sample size using the following
# configuration directive.
#
# The default of 5 produces good enough results. 10 Approximates very closely
# true LRU but costs more CPU. 3 is faster but not very accurate.
#
# maxmemory-samples 5

# Starting from Redis 5, by default a replica will ignore its maxmemory setting
# (unless it is promoted to master after a failover or manually). It means
# that the eviction of keys will be just handled by the master, sending the
# DEL commands to the replica as keys evict in the master side.
#
# This behavior ensures that masters and replicas stay consistent, and is usually
# what you want, however if your replica is writable, or you want the replica to have
# a different memory setting, and you are sure all the writes performed to the
# replica are idempotent, then you may change this default (but be sure to understand
# what you are doing).
#
# Note that since the replica by default does not evict, it may end using more
# memory than the one set via maxmemory (there are certain buffers that may
# be larger on the replica, or data structures may sometimes take more memory and so
# forth). So make sure you monitor your replicas and make sure they have enough
# memory to never hit a real out-of-memory condition before the master hits
# the configured maxmemory setting.
#
# replica-ignore-maxmemory yes

############################# LAZY FREEING ####################################

# Redis has two primitives to delete keys. One is called DEL and is a blocking
# deletion of the object. It means that the server stops processing new commands
# in order to reclaim all the memory associated with an object in a synchronous
# way. If the key deleted is associated with a small object, the time needed
# in order to execute the DEL command is very small and comparable to most other
# O(1) or O(log_N) commands in Redis. However if the key is associated with an
# aggregated value containing millions of elements, the server can block for
# a long time (even seconds) in order to complete the operation.
#
# For the above reasons Redis also offers non blocking deletion primitives
# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
# FLUSHDB commands, in order to reclaim memory in background. Those commands
# are executed in constant time. Another thread will incrementally free the
# object in the background as fast as possible.
#
# DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.
# It's up to the design of the application to understand when it is a good
# idea to use one or the other. However the Redis server sometimes has to
# delete keys or flush the whole database as a side effect of other operations.
# Specifically Redis deletes objects independently of a user call in the
# following scenarios:
#
# 1) On eviction, because of the maxmemory and maxmemory policy configurations,
#    in order to make room for new data, without going over the specified
#    memory limit.
# 2) Because of expire: when a key with an associated time to live (see the
#    EXPIRE command) must be deleted from memory.
# 3) Because of a side effect of a command that stores data on a key that may
#    already exist. For example the RENAME command may delete the old key
#    content when it is replaced with another one. Similarly SUNIONSTORE
#    or SORT with STORE option may delete existing keys. The SET command
#    itself removes any old content of the specified key in order to replace
#    it with the specified string.
# 4) During replication, when a replica performs a full resynchronization with
#    its master, the content of the whole database is removed in order to
#    load the RDB file just transferred.
#
# In all the above cases the default is to delete objects in a blocking way,
# like if DEL was called. However you can configure each case specifically
# in order to instead release memory in a non-blocking way like if UNLINK
# was called, using the following configuration directives:

lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

############################## APPEND ONLY MODE ###############################

# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check http://redis.io/topics/persistence for more information.

appendonly yes

# The name of the append only file (default: &quot;appendonly.aof&quot;)

appendfilename &quot;appendonly.aof&quot;

# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
#
# The default is &quot;everysec&quot;, as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# &quot;no&quot; that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use &quot;always&quot; that's very slow but a bit safer than
# everysec.
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use &quot;everysec&quot;.

# appendfsync always
appendfsync everysec
# appendfsync no

# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I/O against the disk, in some Linux configurations
# Redis may block too long on the fsync() call. Note that there is no fix for
# this currently, as even performing fsync in a different thread will block
# our synchronous write(2) call.
#
# In order to mitigate this problem it's possible to use the following option
# that will prevent fsync() from being called in the main process while a
# BGSAVE or BGREWRITEAOF is in progress.
#
# This means that while another child is saving, the durability of Redis is
# the same as &quot;appendfsync none&quot;. In practical terms, this means that it is
# possible to lose up to 30 seconds of log in the worst scenario (with the
# default Linux settings).
#
# If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as
# &quot;no&quot; that is the safest pick from the point of view of durability.

no-appendfsync-on-rewrite no

# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
#
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite has happened since the restart, the size of
# the AOF at startup is used).
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage increase
# is reached but it is still pretty small.
#
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# An AOF file may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data=ordered option (however this can't happen when Redis itself
# crashes or aborts but the operating system still works correctly).
#
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default now) and start if the AOF file is found
# to be truncated at the end. The following option controls this behavior.
#
# If aof-load-truncated is set to yes, a truncated AOF file is loaded and
# the Redis server starts emitting a log to inform the user of the event.
# Otherwise if the option is set to no, the server aborts with an error
# and refuses to start. When the option is set to no, the user requires
# to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart
# the server.
#
# Note that if the AOF file will be found to be corrupted in the middle
# the server will still exit with an error. This option only applies when
# Redis will try to read more data from the AOF file but not enough bytes
# will be found.
aof-load-truncated yes

# When rewriting the AOF file, Redis is able to use an RDB preamble in the
# AOF file for faster rewrites and recoveries. When this option is turned
# on the rewritten AOF file is composed of two different stanzas:
#
#   [RDB file][AOF tail]
#
# When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;
# string and loads the prefixed RDB file, and continues loading the AOF
# tail.
aof-use-rdb-preamble yes

################################ LUA SCRIPTING  ###############################

# Max execution time of a Lua script in milliseconds.
#
# If the maximum execution time is reached Redis will log that a script is
# still in execution after the maximum allowed time and will start to
# reply to queries with an error.
#
# When a long running script exceeds the maximum execution time only the
# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
# used to stop a script that did not yet called write commands. The second
# is the only way to shut down the server in the case a write command was
# already issued by the script but the user doesn't want to wait for the natural
# termination of the script.
#
# Set it to 0 or a negative value for unlimited execution without warnings.
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################

# Normal Redis instances can't be part of a Redis Cluster; only nodes that are
# started as cluster nodes can. In order to start a Redis instance as a
# cluster node enable the cluster support uncommenting the following:
#
# cluster-enabled yes

# Every cluster node has a cluster configuration file. This file is not
# intended to be edited by hand. It is created and updated by Redis nodes.
# Every Redis Cluster node requires a different cluster configuration file.
# Make sure that instances running in the same system do not have
# overlapping cluster configuration file names.
#
# cluster-config-file nodes-6379.conf

# Cluster node timeout is the amount of milliseconds a node must be unreachable
# for it to be considered in failure state.
# Most other internal time limits are multiple of the node timeout.
#
# cluster-node-timeout 15000

# A replica of a failing master will avoid to start a failover if its data
# looks too old.
#
# There is no simple way for a replica to actually have an exact measure of
# its &quot;data age&quot;, so the following two checks are performed:
#
# 1) If there are multiple replicas able to failover, they exchange messages
#    in order to try to give an advantage to the replica with the best
#    replication offset (more data from the master processed).
#    Replicas will try to get their rank by offset, and apply to the start
#    of the failover a delay proportional to their rank.
#
# 2) Every single replica computes the time of the last interaction with
#    its master. This can be the last ping or command received (if the master
#    is still in the &quot;connected&quot; state), or the time that elapsed since the
#    disconnection with the master (if the replication link is currently down).
#    If the last interaction is too old, the replica will not try to failover
#    at all.
#
# The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform
# the failover if, since the last interaction with the master, the time
# elapsed is greater than:
#
#   (node-timeout * replica-validity-factor) + repl-ping-replica-period
#
# So for example if node-timeout is 30 seconds, and the replica-validity-factor
# is 10, and assuming a default repl-ping-replica-period of 10 seconds, the
# replica will not try to failover if it was not able to talk with the master
# for longer than 310 seconds.
#
# A large replica-validity-factor may allow replicas with too old data to failover
# a master, while a too small value may prevent the cluster from being able to
# elect a replica at all.
#
# For maximum availability, it is possible to set the replica-validity-factor
# to a value of 0, which means, that replicas will always try to failover the
# master regardless of the last time they interacted with the master.
# (However they'll always try to apply a delay proportional to their
# offset rank).
#
# Zero is the only value able to guarantee that when all the partitions heal
# the cluster will always be able to continue.
#
# cluster-replica-validity-factor 10

# Cluster replicas are able to migrate to orphaned masters, that are masters
# that are left without working replicas. This improves the cluster ability
# to resist to failures as otherwise an orphaned master can't be failed over
# in case of failure if it has no working replicas.
#
# Replicas migrate to orphaned masters only if there are still at least a
# given number of other working replicas for their old master. This number
# is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica
# will migrate only if there is at least 1 other working replica for its master
# and so forth. It usually reflects the number of replicas you want for every
# master in your cluster.
#
# Default is 1 (replicas migrate only if their masters remain with at least
# one replica). To disable migration just set it to a very large value.
# A value of 0 can be set but is useful only for debugging and dangerous
# in production.
#
# cluster-migration-barrier 1

# By default Redis Cluster nodes stop accepting queries if they detect there
# is at least an hash slot uncovered (no available node is serving it).
# This way if the cluster is partially down (for example a range of hash slots
# are no longer covered) all the cluster becomes, eventually, unavailable.
# It automatically returns available as soon as all the slots are covered again.
#
# However sometimes you want the subset of the cluster which is working,
# to continue to accept queries for the part of the key space that is still
# covered. In order to do so, just set the cluster-require-full-coverage
# option to no.
#
# cluster-require-full-coverage yes

# This option, when set to yes, prevents replicas from trying to failover its
# master during master failures. However the master can still perform a
# manual failover, if forced to do so.
#
# This is useful in different scenarios, especially in the case of multiple
# data center operations, where we want one side to never be promoted if not
# in the case of a total DC failure.
#
# cluster-replica-no-failover no

# In order to setup your cluster make sure to read the documentation
# available at http://redis.io web site.

########################## CLUSTER DOCKER/NAT support  ########################

# In certain deployments, Redis Cluster nodes address discovery fails, because
# addresses are NAT-ted or because ports are forwarded (the typical case is
# Docker and other containers).
#
# In order to make Redis Cluster working in such environments, a static
# configuration where each node knows its public address is needed. The
# following two options are used for this scope, and are:
#
# * cluster-announce-ip
# * cluster-announce-port
# * cluster-announce-bus-port
#
# Each instruct the node about its address, client port, and cluster message
# bus port. The information is then published in the header of the bus packets
# so that other nodes will be able to correctly map the address of the node
# publishing the information.
#
# If the above options are not used, the normal Redis Cluster auto-detection
# will be used instead.
#
# Note that when remapped, the bus port may not be at the fixed offset of
# clients port + 10000, so you can specify any port and bus-port depending
# on how they get remapped. If the bus-port is not set, a fixed offset of
# 10000 will be used as usually.
#
# Example:
#
# cluster-announce-ip 10.1.1.5
# cluster-announce-port 6379
# cluster-announce-bus-port 6380

################################## SLOW LOG ###################################

# The Redis Slow Log is a system to log queries that exceeded a specified
# execution time. The execution time does not include the I/O operations
# like talking with the client, sending the reply and so forth,
# but just the time needed to actually execute the command (this is the only
# stage of command execution where the thread is blocked and can not serve
# other requests in the meantime).
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.

# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128

################################ LATENCY MONITOR ##############################

# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
#
# Via the LATENCY command this information is available to the user that can
# print graphs and obtain reports.
#
# The system only logs operations that were performed in a time equal or
# greater than the amount of milliseconds specified via the
# latency-monitor-threshold configuration directive. When its value is set
# to zero, the latency monitor is turned off.
#
# By default latency monitoring is disabled since it is mostly not needed
# if you don't have latency issues, and collecting data has a performance
# impact, that while very small, can be measured under big load. Latency
# monitoring can easily be enabled at runtime using the command
# &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################

# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at http://redis.io/topics/notifications
#
# For instance if keyspace events notification is enabled, and a client
# performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two
# messages will be published via Pub/Sub:
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
#
#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.
#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events (events generated every time a key expires)
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.
#
#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed
#  of zero or multiple characters. The empty string means that notifications
#  are disabled.
#
#  Example: to enable list and generic events, from the point of view of the
#           event name, use:
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys subscribing to channel
#             name __keyevent@0__:expired use:
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. Note that if you don't
#  specify at least one of K or E, no events will be delivered.
notify-keyspace-events &quot;&quot;

############################### ADVANCED CONFIG ###############################

# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Lists are also encoded in a special way to save a lot of space.
# The number of entries allowed per internal list node can be specified
# as a fixed maximum size or a maximum number of elements.
# For a fixed maximum size, use -5 through -1, meaning:
# -5: max size: 64 Kb  &lt;-- not recommended for normal workloads
# -4: max size: 32 Kb  &lt;-- not recommended
# -3: max size: 16 Kb  &lt;-- probably not recommended
# -2: max size: 8 Kb   &lt;-- good
# -1: max size: 4 Kb   &lt;-- good
# Positive numbers mean store up to _exactly_ that number of elements
# per list node.
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
list-max-ziplist-size -2

# Lists may also be compressed.
# Compress depth is the number of quicklist ziplist nodes from *each* side of
# the list to *exclude* from compression.  The head and tail of the list
# are always uncompressed for fast push/pop operations.  Settings are:
# 0: disable all list compression
# 1: depth 1 means &quot;don't start compressing until after 1 node into the list,
#    going from either the head or tail&quot;
#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]
#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,
#    but compress all nodes between them.
# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]
# etc.
list-compress-depth 0

# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in radix 10 in the range
# of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000

# Streams macro node max size / items. The stream data structure is a radix
# tree of big nodes that encode multiple items inside. Using this configuration
# it is possible to configure how big a single node can be in bytes, and the
# maximum number of items it may contain before switching to a new node when
# appending new stream entries. If any of the following settings are set to
# zero, the limit is ignored, so for instance it is possible to set just a
# max entires limit by setting max-bytes to 0 and max-entries to the desired
# value.
stream-node-max-bytes 4096
stream-node-max-entries 100

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operation you run into a hash table
# that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
#
# The default is to use this millisecond 10 times every second in order to
# actively rehash the main dictionaries, freeing memory when possible.
#
# If unsure:
# use &quot;activerehashing no&quot; if you have hard latency requirements and it is
# not a good thing in your environment that Redis can reply from time to time
# to queries with 2 milliseconds delay.
#
# use &quot;activerehashing yes&quot; if you don't have such hard requirements but
# want to free memory asap when possible.
activerehashing yes

# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
#
# The limit can be set differently for the three different classes of clients:
#
# normal -&gt; normal clients including MONITOR clients
# replica  -&gt; replica clients
# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern
#
# The syntax of every client-output-buffer-limit directive is the following:
#
# client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;
#
# A client is immediately disconnected once the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (continuously).
# So for instance if the hard limit is 32 megabytes and the soft limit is
# 16 megabytes / 10 seconds, the client will get disconnected immediately
# if the size of the output buffers reach 32 megabytes, but will also get
# disconnected if the client reaches 16 megabytes and continuously overcomes
# the limit for 10 seconds.
#
# By default normal clients are not limited because they don't receive data
# without asking (in a push way), but just after a request, so only
# asynchronous clients may create a scenario where data is requested faster
# than it can read.
#
# Instead there is a default limit for pubsub and replica clients, since
# subscribers and replicas receive data in a push fashion.
#
# Both the hard or the soft limit can be disabled by setting them to zero.
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Client query buffers accumulate new commands. They are limited to a fixed
# amount by default in order to avoid that a protocol desynchronization (for
# instance due to a bug in the client) will lead to unbound memory usage in
# the query buffer. However you can configure it here if you have very special
# needs, such us huge multi/exec requests or alike.
#
# client-query-buffer-limit 1gb

# In the Redis protocol, bulk requests, that are, elements representing single
# strings, are normally limited ot 512 mb. However you can change this limit
# here.
#
# proto-max-bulk-len 512mb

# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys that are
# never requested, and so forth.
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified &quot;hz&quot; value.
#
# By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
hz 10

# Normally it is useful to have an HZ value which is proportional to the
# number of clients connected. This is useful in order, for instance, to
# avoid too many clients are processed for each background task invocation
# in order to avoid latency spikes.
#
# Since the default HZ value by default is conservatively set to 10, Redis
# offers, and enables by default, the ability to use an adaptive HZ value
# which will temporary raise when there are many connected clients.
#
# When dynamic HZ is enabled, the actual configured HZ will be used as
# as a baseline, but multiples of the configured HZ value will be actually
# used as needed once more clients are connected. In this way an idle
# instance will use very little CPU time while a busy instance will be
# more responsive.
dynamic-hz yes

# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
aof-rewrite-incremental-fsync yes

# When redis saves RDB file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
rdb-save-incremental-fsync yes

# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
# idea to start with the default settings and only change them after investigating
# how to improve the performances and how the keys LFU change over time, which
# is possible to inspect via the OBJECT FREQ command.
#
# There are two tunable parameters in the Redis LFU implementation: the
# counter logarithm factor and the counter decay time. It is important to
# understand what the two parameters mean before changing them.
#
# The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
# uses a probabilistic increment with logarithmic behavior. Given the value
# of the old counter, when a key is accessed, the counter is incremented in
# this way:
#
# 1. A random number R between 0 and 1 is extracted.
# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
# 3. The counter is incremented only if R &lt; P.
#
# The default lfu-log-factor is 10. This is a table of how the frequency
# counter changes with a different number of accesses with different
# logarithmic factors:
#
# +--------+------------+------------+------------+------------+------------+
# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
# +--------+------------+------------+------------+------------+------------+
# | 0      | 104        | 255        | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 1      | 18         | 49         | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 10     | 10         | 18         | 142        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 100    | 8          | 11         | 49         | 143        | 255        |
# +--------+------------+------------+------------+------------+------------+
#
# NOTE: The above table was obtained by running the following commands:
#
#   redis-benchmark -n 1000000 incr foo
#   redis-cli object freq foo
#
# NOTE 2: The counter initial value is 5 in order to give new objects a chance
# to accumulate hits.
#
# The counter decay time is the time, in minutes, that must elapse in order
# for the key counter to be divided by two (or decremented if it has a value
# less &lt;= 10).
#
# The default value for the lfu-decay-time is 1. A Special value of 0 means to
# decay the counter every time it happens to be scanned.
#
# lfu-log-factor 10
# lfu-decay-time 1

########################### ACTIVE DEFRAGMENTATION #######################
#
# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested
# even in production and manually tested by multiple engineers for some
# time.
#
# What is active defragmentation?
# -------------------------------
#
# Active (online) defragmentation allows a Redis server to compact the
# spaces left between small allocations and deallocations of data in memory,
# thus allowing to reclaim back memory.
#
# Fragmentation is a natural process that happens with every allocator (but
# less so with Jemalloc, fortunately) and certain workloads. Normally a server
# restart is needed in order to lower the fragmentation, or at least to flush
# away all the data and create it again. However thanks to this feature
# implemented by Oran Agra for Redis 4.0 this process can happen at runtime
# in an &quot;hot&quot; way, while the server is running.
#
# Basically when the fragmentation is over a certain level (see the
# configuration options below) Redis will start to create new copies of the
# values in contiguous memory regions by exploiting certain specific Jemalloc
# features (in order to understand if an allocation is causing fragmentation
# and to allocate it in a better place), and at the same time, will release the
# old copies of the data. This process, repeated incrementally for all the keys
# will cause the fragmentation to drop back to normal values.
#
# Important things to understand:
#
# 1. This feature is disabled by default, and only works if you compiled Redis
#    to use the copy of Jemalloc we ship with the source code of Redis.
#    This is the default with Linux builds.
#
# 2. You never need to enable this feature if you don't have fragmentation
#    issues.
#
# 3. Once you experience fragmentation, you can enable this feature when
#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.
#
# The configuration parameters are able to fine tune the behavior of the
# defragmentation process. If you are not sure about what they mean it is
# a good idea to leave the defaults untouched.

# Enabled active defragmentation
# activedefrag yes

# Minimum amount of fragmentation waste to start active defrag
# active-defrag-ignore-bytes 100mb

# Minimum percentage of fragmentation to start active defrag
# active-defrag-threshold-lower 10

# Maximum percentage of fragmentation at which we use maximum effort
# active-defrag-threshold-upper 100

# Minimal effort for defrag in CPU percentage
# active-defrag-cycle-min 5

# Maximal effort for defrag in CPU percentage
# active-defrag-cycle-max 75

# Maximum number of set/hash/zset/list fields that will be processed from
# the main dictionary scan
# active-defrag-max-scan-fields 1000
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="redis--python"><a class="header" href="#redis--python">Redis + Python</a></h2>
<pre><code class="language-yaml">version: '3.9'

services:
  redis:
    image: redis
    container_name: redis
    ports:
      - 1234:6379
    restart: always

  python:
    image: python:3.11
    container_name: python
    ports:
      - 8001:80
    command: sh -c 'pip install redis &amp;&amp; tail -f /dev/null'
    depends_on:
      - redis
    restart: always
</code></pre>
<h2 id="redis--python--appium--gitlab"><a class="header" href="#redis--python--appium--gitlab">Redis + Python + Appium + Gitlab</a></h2>
<pre><code class="language-yaml">version: '3.9'

services:
  redis:
    image: redis
    container_name: redis
    ports:
      - 1234:6379
    restart: always
    networks:
      - my-network

  python:
    image: python:3.11
    container_name: python
    ports:
      - 8001:80
    command: sh -c 'pip install redis &amp;&amp; tail -f /dev/null'
    depends_on:
      - redis
    restart: always
    networks:
      - my-network

  gitlab:
    image: gitlab/gitlab-ce
    container_name: gitlab
    ports:
      - 8081:80
    restart: always
    networks:
      - my-network

  appium:
    image: appium/appium
    container_name: appium
    ports:
      - 4723:4723
    restart: always
    networks:
      - my-network

networks:
  my-network:
    driver: bridge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-compose--dockerfile-綜合應用"><a class="header" href="#docker-compose--dockerfile-綜合應用">docker compose + Dockerfile 綜合應用</a></h1>
<p>出處:https://medium.com/%E7%A8%8B%E5%BC%8F%E4%B9%BE%E8%B2%A8/docker-docker-compose-dockerfile-%E7%B6%9C%E5%90%88%E6%87%89%E7%94%A8-7e71ff371ebc</p>
<h2 id="先來講講使用場景吧"><a class="header" href="#先來講講使用場景吧">先來講講使用場景吧</a></h2>
<p>舉個簡單的例子：假設我需要一個可以運行 python 的環境、還有一個 redis server 的環境，我要執行 python script 在 redis 上做一些資料儲存與運算。我一開始可能會這樣子啟動、<code>seperate-compose.yml</code>會這樣寫：</p>
<p><img src="docker/images/1*5Edx71z98-lSfElCpJJ3Bg.png" alt="img" /></p>
<p>兩個容器，彼此用網路連接</p>
<p>seperate-compose.yml</p>
<pre><code class="language-dockerfile">version: '3.5'
services:
  python:
    image: python:3.9-slim
    container_name: py-env
    restart: always
    ports:
      - 8001:80
    command: sh -c 'pip install redis &amp;&amp; tail -f /dev/null'
    links:
      - redis # 連結到 redis，讓兩個 container 可以互通網路
  redis:
    image: redis:6-alpine3.15
    restart: always
    container_name: redis
    ports:
      - 127.0.0.1:6379:6379
</code></pre>
<p>用指令 </p>
<pre><code>docker compose -f seperate-compose.yml up -d
</code></pre>
<p>來啟動之後，就可以啟動兩個 container(py-env, redis)</p>
<p><img src="docker/images/1*t7-hs0AgOpp0gAJs6A9XyA.png" alt="img" /></p>
<p>成功啟動 py-env, redis 兩個容器</p>
<p>接著進去剛啟動的 py-env 容器，bash 啟動 python環境連看看 redis，成功在redis這個container中塞入一筆資料(Key: “test”, Value: 1)。來敲指令吧～</p>
<pre><code class="language-sh">$ docker exec -it py-env sh #先進入 py-env 並啟動 shell
# python3 #在容器裡運行python
&gt;&gt;&gt; import redis #載入redis套件
&gt;&gt;&gt; r = redis.Redis(host='redis', port=6379) #連進容器的redis
&gt;&gt;&gt; r.set(&quot;test&quot;, 1) #塞一筆資料看看
True #代表塞入成功！
&gt;&gt;&gt; exit() #退出python
# exit #退出container
</code></pre>
<p>接著來 redis 這個容器看一下資料情形吧～一樣敲指令～</p>
<pre><code class="language-dockerfile">$ docker exec -it redis sh
# redis-cli #進入redis client端
127.0.0.1:6379&gt; get test #獲取剛剛的key值: test
&quot;1&quot; # 成功返回Value
127.0.0.1:6379&gt;
</code></pre>
<p><img src="docker/images/1*TiesJthGuGEKS4uhIfkYBg.png" alt="img" /></p>
<p>分別進入 py-env, redis 這兩個容器測試資料</p>
<h2 id="but我想要換個做法"><a class="header" href="#but我想要換個做法">BUT…我想要換個做法</a></h2>
<p>這樣我每次都要啟動 py-env, redis這兩個 container 互連才能夠把服務建立起來，我能不能一次到位？只啟動一個 container 就好呢？</p>
<blockquote>
<p>i.e 我想要一個 container 同時擁有 python 與 redis 的服務！</p>
</blockquote>
<p><img src="docker/images/1*gfNGHx3VwVUMHRWH7MZ70Q.png" alt="img" /></p>
<p>一個容器兩種享受，我全都要 🤤</p>
<p>眼尖的讀者可發現在前面的<code>seperate-compose.yml</code> ，其實兩個容器的基底image分別是 <code>python:3.9-slim</code> 與 <code>redis:6-alpine3.15</code> ，那要在哪裡找一個基底image、是在 build 的時候同時擁有 python+redis的環境呢？</p>
<p>答案就在一開始，我要自己寫一個 Dockerfile 定義好 image。接著再利用 docker compose 把這個強大的 image 啟動成 container💪</p>
<h1 id="先來看看-dockerfile吧"><a class="header" href="#先來看看-dockerfile吧">先來看看 Dockerfile吧</a></h1>
<p>首先，用下面這個 Dockerfile 建立起 image，簡單敘述一下裡頭做了些什麼事情：</p>
<pre><code class="language-dockerfile"># 1. 抓取基底image: redis
FROM redis:6-alpine3.15 

# 2. 基於redis image, 開始安裝 python 相關環境與套件
RUN apk add --update --no-cache python3 &amp;&amp; ln -sf python3 /usr/bin/python
RUN python3 -m ensurepip
RUN pip3 install --no-cache --upgrade pip setuptools
RUN pip install --no-cache-dir redis
</code></pre>
<h1 id="再來就是-docker-compose-的-yml-檔"><a class="header" href="#再來就是-docker-compose-的-yml-檔">再來就是 docker compose 的 yml 檔</a></h1>
<p>重頭戲來撰寫 combine-compose.yml</p>
<pre><code class="language-dockerfile"># docker compose -f redis-compose.yml up -d
version: &quot;3&quot;

services:
  redis:
    build:
      dockerfile: Dockerfile #基於Dockerfile建立image
    restart: always
    container_name: redis #容器名稱
    ports:
      - 6379:6379
    command: sh -c &quot;redis-server --daemonize yes &amp;&amp; tail -f /dev/null&quot; #啟動 redis-server
</code></pre>
<p>接著執行 <code>docker compose -f combine-compose.yml up -d</code> 來啟動 container</p>
<p><img src="docker/images/1*j-cem-fw4F9A9n_EkO4rHQ.png" alt="img" /></p>
<p>只剩下一個 redis 容器，還擁有 python 環境喔 🥳</p>
<h2 id="接下來進去-redis-這個-container-玩玩看吧"><a class="header" href="#接下來進去-redis-這個-container-玩玩看吧">接下來進去 redis 這個 container 玩玩看吧</a></h2>
<ol>
<li>
<p>進入容器並啟動shell</p>
<pre><code class="language-sh">$ docker exec -it redis sh
</code></pre>
</li>
<li>
<p>啟動python並嘗試在redis中塞入一筆資料，再退出python</p>
<pre><code class="language-sh"># python3
&gt;&gt;&gt; import redis
&gt;&gt;&gt; r = redis.Redis(host='redis', port=6379)
&gt;&gt;&gt; r.set(&quot;test_comb&quot;, 1)
True
&gt;&gt;&gt; exit()
</code></pre>
</li>
<li>
<p>去redis-server看看資料有沒有成功塞入</p>
<pre><code class="language-sh">/data# redis-cli
127.0.0.1:6379&gt; get test_comb
&quot;1&quot;
</code></pre>
</li>
</ol>
<p><img src="docker/images/1*WVWSEhnp56Ju0IflGj4A1A.png" alt="img" /></p>
<p>你有發現嗎？所有動作都在 redis 這個容器裡完成</p>
<p>如此一氣呵成～都在同一個容器內完成🥴</p>
<h2 id="總結-2"><a class="header" href="#總結-2">總結</a></h2>
<p>核心概念就是先建立 image，才能啟動 container。建立 image 的方式可以用現成的 docker pull、或是自己寫 Dockerfile 建立; 啟動 container 的方式可以用一般 docker run 指令、或是本文中 docker compose 的方式一次啟動多個。只要掌握住了，萬變不離其宗😎</p>
<p>以上程式碼都放在 <a href="https://github.com/pcchencode/docker-compose-demo">github</a> 上了，有興趣的讀者可以抓下來玩玩看</p>
<h1 id="延伸閱讀"><a class="header" href="#延伸閱讀">延伸閱讀</a></h1>
<p>以現今的趨勢，其實還是以啟動多容器來架構整個服務比較常見。我會有這種搞怪的做法，單純是因為我想要在 redis 啟動時可以 config 做一些特殊設定，例如：<em>在每天的半夜12點reset鍵值、或是每隔1小時新增一個鍵值。</em></p>
<p>這些需求沒有辦法用 redis 本身提供的指令做到，所以我只能另外啟動一個 python 環境運行 python script，來做 redis config 特殊設定。</p>
<p>當然可能還是有redis本身支援的方式，就有勞各位大神如果有更好的做法，還請不吝告知小弟，大家互相學習增長：）</p>
<hr />
<pre><code class="language-makefile">#up：啟動 Docker 組合。
#down：停止 Docker 組合。
#logs：顯示 Docker 組合的日誌。
#redis-cli：啟動 Redis 容器的 CLI。
#build：編譯映像。
REDIS_COMPOSE = combine-compose.yml
REDIS_CONTAINER = redis
IMAGE_NAME = redis-python

.PHONY: up down logs redis-cli exec build

up:
	@docker-compose -f $(REDIS_COMPOSE) up -d

down:
	@docker-compose -f $(REDIS_COMPOSE) down

logs:
	@docker-compose -f $(REDIS_COMPOSE) logs -f

redis-cli:
	@docker exec -it $(REDIS_CONTAINER) redis-cli

exec:
	@docker exec -it $(REDIS_CONTAINER) /bin/bash

build:
	docker build -t $(IMAGE_NAME) .
</code></pre>
<pre><code class="language-dockerfile">FROM redis

RUN apt-get update &amp;&amp; apt-get install -y vim redis-server wget build-essential &amp;&amp; \
    wget -q http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz &amp;&amp; \
    tar xzf ta-lib-0.4.0-src.tar.gz &amp;&amp; \
    cd ta-lib/ &amp;&amp; \
    ./configure --prefix=/usr &amp;&amp; \
    make &amp;&amp; \
    make install &amp;&amp; \
    cd .. &amp;&amp; \
    rm -rf ta-lib ta-lib-0.4.0-src.tar.gz

RUN wget https://repo.anaconda.com/miniconda/Miniconda3-py38_23.1.0-1-Linux-x86_64.sh -O /tmp/miniconda.sh &amp;&amp; \
    /bin/bash /tmp/miniconda.sh -b -p /opt/conda &amp;&amp; \
    rm /tmp/miniconda.sh

ENV PATH=/opt/conda/bin:$PATH

COPY requirements.txt /tmp/requirements.txt
RUN pip install -r /tmp/requirements.txt &amp;&amp; \
    rm /tmp/requirements.txt

RUN mkdir -p /usr/src/app

COPY *.py /usr/src/app

WORKDIR /usr/src/app/
</code></pre>
<pre><code class="language-docker"># docker compose -f redis-compose.yml up -d
version: &quot;3&quot;

services:
  redis:
    build:
      dockerfile: Dockerfile #基於Dockerfile建立image
    image: redis-python
    restart: always
    container_name: redis #容器名稱
    ports:
      - 6380:6379
    command: sh -c &quot;redis-server --daemonize yes &amp;&amp; tail -f /dev/null&quot; #啟動 redis-server
</code></pre>
<pre><code class="language-python">import redis 

r = redis.Redis(host=&quot;localhost&quot;, port=6379, db=1)
r.set('foo', 'bar')
print(r.get('foo'))


print (&quot;hello world!&quot;)
print (&quot;Welcome to python cron job&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="redash-入門"><a class="header" href="#redash-入門">Redash 入門</a></h2>
<p>出處:https://zhuanlan.zhihu.com/p/444590189</p>
<ul>
<li>下載程式碼</li>
</ul>
<pre><code class="language-bash">git clone https://github.com/getredash/redash.git
cd redash/
git checkout v10.1.0
</code></pre>
<ul>
<li>啟動docker服務</li>
</ul>
<p>在docker-compose.yml 的同級目錄，新建檔案 .env，內容如下：</p>
<pre><code class="language-python3">REDASH_SECRET_KEY=隨機字串1
REDASH_COOKIE_SECRET=隨機字串2
GOOGLE_CLIENT_ID=隨機字串3
</code></pre>
<p>不要把這個檔案提交到git中。然後在命令列輸入：</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<ul>
<li>安裝node packages</li>
</ul>
<pre><code class="language-text">npm install -g yarn
</code></pre>
<ul>
<li>建立資料庫</li>
</ul>
<pre><code class="language-text"># 建表
docker-compose -f docker-compose.yml run --rm redash create_db

# 建測試資料
docker-compose run --rm postgres psql -h postgres -U postgres -c &quot;create database tests&quot;
</code></pre>
<ul>
<li>然後訪問<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A5000/">http://127.0.0.1:5000/</a>就可以打開頁面了。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-c24bc51dc72343e6cab27df2a2bbeec2_720w.webp" alt="img" /></p>
<ul>
<li>
<p>常見問題</p>
</li>
<li>
<ul>
<li>使用<code>docker-compose up -d</code>啟動時遇到<code>Error response from daemon: OCI runtime create failed: container_linux.go:367: starting container process caused: exec: &quot;/app/bin/docker-entrypoint&quot;: permission denied: unknown</code>。</li>
</ul>
</li>
</ul>
<p>解決：修改宿主機上的檔案權限：</p>
<pre><code class="language-text"> sudo chmod 755 /bin/docker-entrypoint
 sudo chmod 755 manager.py
</code></pre>
<ul>
<li><code>yarn --frozen-lockfile</code> 時出現node版本不滿足。</li>
</ul>
<p>使用nvm 管理node版本。nvm 簡單使用方法如下：</p>
<pre><code class="language-text">nvm list
nvm install 12.0.0
nvm use 12.0.0
node -v 
nvm uninstall 12.0.0
</code></pre>
<ul>
<li>前端報錯：<code>Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory</code> 。</li>
</ul>
<p>在執行相關命令但shell中執行如下命令</p>
<pre><code>export NODE_OPTIONS=&quot;--max-old-space-size=8192&quot;
</code></pre>
<p>增加記憶體：如8192，16384這樣。</p>
<ul>
<li>個人感受</li>
</ul>
<p>程式碼比較清晰明瞭，但是每次生成可視化圖表都要徒手寫query，和<a href="https://link.zhihu.com/?target=https%3A//superset.apache.org/">superset</a>相比工作量太大。如果習慣於點點滑鼠就生成chart，我還是推薦superset，包括二次開發，儘管superset的code有些疊床架屋的感覺。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse-簡單部署使用測試"><a class="header" href="#clickhouse-簡單部署使用測試">ClickHouse 簡單部署&amp;使用測試</a></h1>
<p>出處:https://zhuanlan.zhihu.com/p/383817560</p>
<h3 id="介紹"><a class="header" href="#介紹">介紹</a></h3>
<p>ClickHouse 是一個真正的列式資料庫管理系統（DBMS)。在 ClickHouse 中，資料始終是按列儲存的，包括向量（向量或列塊）執行的過程。只要有可能，操作都是基於向量進行分派的，而不是單個的值，這被稱為«向量化查詢執行»，它有利於降低實際的資料處理開銷。</p>
<p>這個想法並不新鮮，其可以追溯到 APL 程式語言及其後代：A +、J、K 和 Q。向量程式設計被大量用於科學資料處理中。即使在關係型資料庫中，這個想法也不是什麼新的東西：比如，向量程式設計也被大量用於 Vectorwise 系統中。</p>
<p>通常有兩種不同的加速查詢處理的方法：向量化查詢執行和執行階段程式碼生成。在後者中，動態地為每一類查詢生成程式碼，消除了間接分派和動態分派。這兩種方法中，並沒有哪一種嚴格地比另一種好。執行階段程式碼生成可以更好地將多個操作融合在一起，從而充分利用 CPU 執行單元和流水線。向量化查詢執行不是特別實用，因為它涉及必須寫到快取並讀回的臨時向量。如果 L2 快取容納不下臨時資料，那麼這將成為一個問題。但向量化查詢執行更容易利用 CPU 的 SIMD 功能。朋友寫的一篇研究論文表明，將兩種方法結合起來是更好的選擇。ClickHouse 使用了向量化查詢執行，同時初步提供了有限的執行階段動態程式碼生成。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//clickhouse.tech/docs/zh/development/architecture/">瞭解更多詳情...</a></p>
<h2 id="1部署-clickhouse-服務"><a class="header" href="#1部署-clickhouse-服務">1.部署 Clickhouse 服務</a></h2>
<p>建立clickhouse 工作目錄</p>
<h3 id="11-pull-鏡像"><a class="header" href="#11-pull-鏡像">1.1, pull 鏡像</a></h3>
<pre><code class="language-text">按照官方推薦的鏡像拉取

docker pull yandex/clickhouse-server
</code></pre>
<h3 id="12docker-compose-啟動鏡像"><a class="header" href="#12docker-compose-啟動鏡像">1.2，docker-compose 啟動鏡像</a></h3>
<pre><code class="language-yaml">version: &quot;3&quot;

services:
  clickhouse-server:
    image: yandex/clickhouse-server:latest
    container_name: clickhouse-server
    hostname: clickhouse-server
    networks:
      - my-network
    ports:
      - 1111:8123
    restart: always


  python-client:
    image: python:3.11
    container_name: python-client
    hostname: python-client
    command: sh -c 'apt-get update &amp;&amp; apt-get install -y vim iputils-ping net-tools &amp;&amp; pip install lxml loguru line-notify clickhouse_driver rel numpy pandahouse websocket-client &amp;&amp; tail -f /dev/null'
    networks:
      - my-network
    restart: always
    volumes:
      - ./python-client:/app

networks:
  my-network:
    driver: bridge
</code></pre>
<p>查看運行狀態</p>
<p>http://127.0.0.1:1111/  會出現OK字樣代表成功</p>
<p>思考：如何修改clickhouse默認組態？資料如何持久化？如何查看日誌？</p>
<h3 id="13-更改默認組態資料持久化查看日誌"><a class="header" href="#13-更改默認組態資料持久化查看日誌">1.3 更改默認組態，資料持久化，查看日誌</a></h3>
<p>進入容器查看組態</p>
<pre><code class="language-sh">docker exec -it clickhouse-server /bin/bash
</code></pre>
<p>clickhouse 默認組態路徑是: /etc/clickhouse-server/</p>
<p>退出容器，複製組態檔案當前工作目錄</p>
<pre><code class="language-sh">docker cp 容器名:/etc/clickhouse-server/config.xml .
docker cp 容器名:/etc/clickhouse-server/uses.xml .
</code></pre>
<p>修改docker-compose 組態檔案</p>
<pre><code class="language-yaml">volumes: 
  # 默認組態 寫入config.d/users.d 目錄防止更新後檔案丟失
  - ./config.xml:/etc/clickhouse-server/config.d/config.xml:rw
  - ./users.xml:/etc/clickhouse-server/users.xml:rw
  # 運行日誌
  - ./logs:/var/log/clickhouse-server
  # 資料持久
  - ./data:/var/lib/clickhouse:rw
</code></pre>
<p>修改後的完整組態如下</p>
<pre><code class="language-sh">docker network ls  // 如果沒 my-network 要create
docker network create my-network
</code></pre>
<pre><code class="language-yaml">version: &quot;3&quot;

services:
  clickhouse-server:
    image: yandex/clickhouse-server:latest
    container_name: clickhouse-server
    hostname: clickhouse-server
    networks:
      - my-network
    ports:
      - 1111:8123
      - 8888:9000
    restart: always
    volumes: 
      # 默認組態 寫入config.d/users.d 目錄防止更新後檔案丟失
      - ./config.xml:/etc/clickhouse-server/config.d/config.xml:rw
      - ./users.xml:/etc/clickhouse-server/users.xml:rw
      # 運行日誌
      - ./logs:/var/log/clickhouse-server
      # 資料持久
      - ./data:/var/lib/clickhouse:rw


  python-client:
    image: python:3.11
    container_name: python-client
    hostname: python-client
    command: sh -c 'apt-get update &amp;&amp; apt-get install -y vim iputils-ping net-tools &amp;&amp; pip install lxml loguru line-notify clickhouse_driver rel numpy pandahouse websocket-client &amp;&amp; tail -f /dev/null'
    networks:
      - my-network
    volumes:
      - ./python-client:/app

networks:
  my-network:
    driver: bridge
</code></pre>
<p>重新啟動服務</p>
<pre><code class="language-text">docker-compose down &amp;&amp; docker-compose up -d
</code></pre>
<p>啟動後目錄結構</p>
<pre><code>├── config.xml
├── data
├── docker-compose-final.yml
├── docker-compose.yml
├── log
├── logs
└── users.xml
</code></pre>
<p>瀏覽器再次訪問  http://127.0.0.1:1111/  會出現OK字樣代表成功</p>
<p>查看容器日誌</p>
<pre><code class="language-sh">docker-compose logs -f
</code></pre>
<p>進入容器查看服務資料庫</p>
<pre><code class="language-sh">docker exec -it clickhouse-server /bin/bash

root@clickhouse-server:/# clickhouse-client 
ClickHouse client version 22.1.3.7 (official build).
Connecting to localhost:9000 as user default.
Connected to ClickHouse server version 22.1.3 revision 54455.


clickhouse-server :) show databases;

SHOW DATABASES

Query id: aef1df36-bc09-4c33-8821-c669c8a93c2c

┌─name───────────────┐
│ INFORMATION_SCHEMA │
│ default            │
│ information_schema │
│ system             │
└────────────────────┘

4 rows in set. Elapsed: 0.001 sec. 
</code></pre>
<p>服務運行正常！</p>
<h3 id="14建立使用者登錄-後期使用"><a class="header" href="#14建立使用者登錄-後期使用">1.4，建立使用者登錄 （後期使用）</a></h3>
<p>查看users.xml檔案</p>
<p>自訂使用者</p>
<pre><code class="language-xml">&lt;halobug&gt;
    &lt;password_sha256_hex&gt;4754fc7e290a9c280d9497b2d76dd854e77f7e1c92476577fdb52ed22afc13e7&lt;/password_sha256_hex&gt;
    &lt;networks incl=&quot;networks&quot; replace=&quot;replace&quot;&gt;
        &lt;ip&gt;::/0&lt;/ip&gt;
    &lt;/networks&gt;
    &lt;profile&gt;default&lt;/profile&gt;
    &lt;quota&gt;default&lt;/quota&gt;
    &lt;allow_databases&gt;
       &lt;database&gt;tutorial&lt;/database&gt;
       &lt;database&gt;CRYPTO&lt;/database&gt;
    &lt;/allow_databases&gt;
&lt;/halobug&gt;
</code></pre>
<p>生成密碼（進入容器運行）</p>
<pre><code class="language-sh">PASSWORD=$(base64 &lt; /dev/urandom | head -c8); echo &quot;$PASSWORD&quot;; echo -n &quot;$PASSWORD&quot; | sha256sum | tr -d '-'

FcP5O5HY
8aaa72053341d6fa19bdd150c8e1ff328e2d56444df1c977ac22f88710bac5ae 
</code></pre>
<p>黃色標註為自訂使用者，紅色為生成密碼</p>
<p><img src="docker/images/v2-44e731cf22b055dab4b64d81c58f82c6_r.jpg" alt="" /></p>
<p>驗證使用者密碼，重新啟動服務</p>
<pre><code class="language-text"># 重啟
docker-compose down &amp;&amp; docker-compose up -d
# 進入容器
docker exec -it clickhouse-server /bin/bash
# 驗證使用者名稱密碼
clickhouse-client -u halobug -h 127.0.0.1 --password FcP5O5HY  # FcP5O5HY 是出生成來的


# 建立資料庫 tutorial , tutorial 是 users.xml 建立
CREATE DATABASE tutorial;
CREATE DATABASE CRYPTO;
</code></pre>
<p>查看驗證結果</p>
<p><img src="docker/images/v2-c107aa8ec20553a1c4b4065863ca698f_r.jpg" alt="" /></p>
<p>成功！到此服務就搭建完成！</p>
<h2 id="登入-python-clinet-測試讀寫-clickhost"><a class="header" href="#登入-python-clinet-測試讀寫-clickhost">登入 python-clinet 測試讀寫 clickhost</a></h2>
<pre><code class="language-sh">docker exec -it python-client /bin/bash

# 測試是否連通
ping clickhouse-server 
</code></pre>
<pre><code class="language-python">import clickhouse_driver
import pandas as pd


connection_settings = {
    'host': 'clickhouse-server',
    'port': '9000',
    'user': 'halobug',
    'password': 'FcP5O5HY'
}

client = clickhouse_driver.Client(**connection_settings)

# 建立新資料庫
client.execute('CREATE DATABASE IF NOT EXISTS CRYPTO')

print(client.execute(&quot;SHOW DATABASES&quot;))
client.execute('USE CRYPTO')

# 創建一個簡單的表格
df = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie'], 'age': [25, 30, 35]})
client.execute('CREATE TABLE IF NOT EXISTS test_table (name String, age Int32) ENGINE = Memory')

# 將資料框寫入表格
client.execute('INSERT INTO test_table VALUES', df.to_dict('records'))

# 讀取表格中的資料
result = client.execute('SELECT * FROM test_table')
print(result)
</code></pre>
<pre><code class="language-python">from line_notify import LineNotify
from loguru import logger
from clickhouse_driver import Client
from multiprocessing import Process, Queue, Pipe
import signal
import multiprocessing
import rel
import numpy as np
import pandahouse as ph
import pandas as pd
import json
import websocket
import datetime as dt
import os
import sys
import traceback
import time


def monitor(monitor_queue, thread_name, ws_client_p, record_p):
    while True:
        try:
            data = monitor_queue.get(timeout=30)
            logger.info(f&quot;{thread_name}, {os.getpid()}, {data[0]}&quot;)
        except Exception as e:
            logger.warning(f&quot;{thread_name} monitor queue is empty, {e}&quot;)
            LineNotify(&quot;KXwzqEGtIp1JEkS5GjqXqRAT0D4BdQQvCNcqOa7ySfz&quot;).send(
                f&quot;{thread_name} monitor queue is empty&quot;
            )
            os.kill(ws_client_p.pid, signal.SIGUSR1)


def getErrMsg(e):
    error_class = e.__class__.__name__  # 取得錯誤類型
    detail = e.args[0]  # 取得詳細內容
    cl, exc, tb = sys.exc_info()  # 取得Call Stack
    lastCallStack = traceback.extract_tb(tb)[-1]  # 取得Call Stack的最後一筆資料
    fileName = lastCallStack[0]  # 取得發生的檔案名稱
    lineNum = lastCallStack[1]  # 取得發生的行號
    funcName = lastCallStack[2]  # 取得發生的函數名稱
    errMsg = 'File &quot;{}&quot;, line {}, in {}: [{}] {}'.format(
        fileName, lineNum, funcName, error_class, detail
    )
    return errMsg


logger.add(
    f&quot;{__file__}.log&quot;, encoding=&quot;utf-8&quot;, enqueue=True, retention=&quot;10 days&quot;,
)


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


class WebSocketClient(multiprocessing.Process):
    def __init__(
        self, thread_name, ws_url, symbol, params, queue, monitor_queue, line_notify
    ):
        multiprocessing.Process.__init__(self)
        self.__thread_name = thread_name
        self.__ws_url = ws_url
        self.__symbol = symbol
        self.__params = params
        self.__queue = queue
        self.__monitor_queue = monitor_queue
        self.__line_notify = line_notify
        self.__ws = websocket.WebSocketApp(
            self.__ws_url,
            on_open=self.on_open,
            on_message=self.on_message,
            on_close=self.on_close,
            on_error=self.on_error,
            # on_cont_message=self.on_cont_message,
            on_ping=self.on_ping,
            on_pong=self.on_pong,
        )
        self.msg_count = 0
        self.reconnecting_flag = False
        signal.signal(signal.SIGUSR1, self.receive_signal)

    def receive_signal(self, signum, stack):
        logger.warning(
            f&quot;Received:, {signum}, {os.getpid()}, reconnecting_flag:{self.reconnecting_flag}&quot;
        )
        # if not self.reconnecting_flag:
        #    self.reconnecting_flag = True
        #    self.reconnecting()
        # thread = threading.Thread(target=self.reconnecting, args=())
        # thread.start()

    def run(self):
        # self.__ws.run_forever()
        try:
            self.__ws.run_forever(ping_interval=0, dispatcher=rel, reconnect=3)
            rel.signal(2, rel.abort)  # Keyboard Interrupt
            rel.dispatch()
        except Exception as e:
            logger.exception(e)
            # os.kill(os.getpid(), signal.SIGUSR1)
            self.reconnecting()

    def on_open(self, ws):
        logger.info(f&quot;on_pong : {self.reconnecting_flag}&quot;)
        self.reconnecting_flag = False
        subscribe_message = {
            &quot;method&quot;: &quot;SUBSCRIBE&quot;,
            &quot;params&quot;: [self.__params],
            &quot;id&quot;: 1,
        }
        ws.send(json.dumps(subscribe_message))

    def on_message(self, ws, message):
        if self.__queue.full():
            logger.error(&quot;queue is full&quot;)
            self.__line_notify.send(&quot;queue is full&quot;)
        else:
            msg = json.loads(message)
            self.__queue.put(msg)
            self.msg_count = self.msg_count + 1

        if self.msg_count % 20 == 0:
            self.__monitor_queue.put([dt.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)])
            logger.info(
                f&quot;{self.__thread_name} msg_count:{self.msg_count} qsize:{self.__queue.qsize()}&quot;
            )
            self.msg_count = 0

        # print(json.dumps(msg, indent=4, ensure_ascii=False))

    def on_close(self, ws, status_code, message):
        logger.warning(f&quot;on_close {status_code} {message}&quot;)
        self.__line_notify.send(&quot;on_close &quot; + str(message))
        self.reconnecting()

    def on_error(self, ws, error):
        logger.error(str(error))
        self.__line_notify.send(&quot;on_error &quot; + str(error))
        # self.reconnecting()

    def on_cont_message(self, ws, message, flag):
        logger.warning(f&quot;on_cont_message: {message} {flag}&quot;)

    def on_ping(self, ws, message):
        logger.info(f&quot;{self.__thread_name} on_ping&quot;)
        ws.send(message, websocket.ABNF.OPCODE_PONG)

    def on_pong(self, ws, message):
        logger.info(f&quot;{self.__thread_name} on_pong&quot;)
        ws.send(message, websocket.ABNF.OPCODE_PONG)

    def reconnecting(self):
        logger.info(f&quot;{self.__thread_name} {os.uname()[1]} reconnecting&quot;)
        # self.__ws.close()
        # thread = threading.Thread(target=self.__ws.close, args=())
        # thread.start()
        # thread.join()

        # self.__ws.my_close()
        # rel.abort()
        # logger.info(f&quot;{self.__thread_name} websocket closed&quot;)

        rel.abort()
        self.__ws.run_forever(ping_interval=0, dispatcher=rel, reconnect=3)
        rel.signal(2, rel.abort)
        rel.dispatch()


class Record(multiprocessing.Process):
    def __init__(self, thread_name, ws_client_p, queue, line_notify):
        multiprocessing.Process.__init__(self)
        self.__thread_name = thread_name
        self.__ws_client_p = ws_client_p
        self.__queue = queue
        self.__line_notify = line_notify
        self.__data = []

    def clear_data(self):
        self.__data.clear()

    def create_db_table(self, df, str_database, str_table):
        dtypes_dict = dict(df.dtypes)
        ch_type_convert_dict = {
            np.dtype(&quot;datetime64[ns]&quot;): &quot;Datetime64&quot;,
            np.dtype(&quot;int64&quot;): &quot;Int64&quot;,
            np.dtype(&quot;float64&quot;): &quot;Float64&quot;,
            np.dtype(&quot;object&quot;): &quot;String&quot;,
            np.dtype(&quot;bool&quot;): &quot;Bool&quot;,
        }
        create_table_cmd_str = &quot;&quot;
        for x in dtypes_dict:
            type_str = ch_type_convert_dict.get(dtypes_dict[x], None)
            if type_str is None:
                print(f&quot;Undefined type {dtypes_dict[x]}&quot;)
            create_table_cmd_str = (
                create_table_cmd_str + f&quot;`{x}` {type_str} DEFAULT 0, &quot;
            )
        # create_table_cmd_str = f&quot;CREATE TABLE IF NOT EXISTS {str_database}.{str_table} ( {create_table_cmd_str[:-2]}) ENGINE = Log&quot;
        create_table_cmd_str = f&quot;CREATE TABLE IF NOT EXISTS {str_database}.{str_table} ({create_table_cmd_str[:-2]}) ENGINE = MergeTree PARTITION BY year_month_day ORDER BY year_month_day SETTINGS index_granularity = 16384&quot;
        client = Client(host=&quot;clickhouse-server&quot;, port=&quot;9000&quot;, user=&quot;halobug&quot;, password=&quot;FcP5O5HY&quot;)
        client.execute(f&quot;CREATE DATABASE IF NOT EXISTS {str_database};&quot;)
        client.execute(create_table_cmd_str)

    def write_orderbook_to_db(self):
        df = None
        try:
            if &quot;e&quot; in self.__data[0].keys() and self.__data[0][&quot;e&quot;] == &quot;depthUpdate&quot;:
                df = pd.DataFrame(self.__data)
                if not df.isnull().values.any():
                    df.rename(
                        columns={&quot;E&quot;: &quot;timestamp&quot;, &quot;a&quot;: &quot;asks&quot;, &quot;b&quot;: &quot;bids&quot;},
                        inplace=True,
                    )
                    df[&quot;date&quot;] = [
                        dt.datetime.fromtimestamp(x / 1000.0) for x in df[&quot;timestamp&quot;]
                    ]
                    df[&quot;year_month_day&quot;] = [
                        dt.datetime.fromtimestamp(x / 1000.0).strftime(&quot;%Y-%m-%d&quot;)
                        for x in df[&quot;timestamp&quot;]
                    ]
                    df.rename(columns={&quot;s&quot;: &quot;pair&quot;}, inplace=True)
                    # 僅保留需要的列
                    df = df[[&quot;pair&quot;, &quot;asks&quot;, &quot;bids&quot;, &quot;date&quot;, &quot;year_month_day&quot;]]

                    db_name = &quot;CRYPTO&quot;
                    table_name = &quot;BinanceOrderbookPartition_simplifiedFields&quot;
                    connection_info = dict(
                        database=db_name,
                        host=&quot;http://clickhouse-server:8123/&quot;,
                        user=&quot;halobug&quot;,
                        password=&quot;FcP5O5HY&quot;,
                    )

                    self.create_db_table(df, db_name, table_name)
                    ph.to_clickhouse(
                        df,
                        table_name,
                        index=False,
                        chunksize=100000,
                        connection=connection_info,
                    )
                print(df)

            if (
                &quot;event&quot; in self.__data[0].keys()
                and self.__data[0][&quot;event&quot;] == &quot;ORDER_BOOK&quot;
            ):
                df = pd.DataFrame(self.__data)
                if not df.isnull().values.any():
                    df[&quot;date&quot;] = [
                        dt.datetime.fromtimestamp(x / 1000.0).strftime(
                            &quot;%Y-%m-%d %H:%M:%S.%f&quot;
                        )
                        for x in df[&quot;timestamp&quot;]
                    ]
                    df[&quot;year_month_day&quot;] = [
                        dt.datetime.fromtimestamp(x / 1000.0).strftime(&quot;%Y-%m-%d&quot;)
                        for x in df[&quot;timestamp&quot;]
                    ]

                    df = df[[&quot;pair&quot;, &quot;asks&quot;, &quot;bids&quot;, &quot;date&quot;, &quot;year_month_day&quot;]]
                    db_name = &quot;CRYPTO&quot;
                    table_name = &quot;BitoProOrderbookPartition_simplifiedFields&quot;
                    connection_info = dict(
                        database=db_name,
                        host=&quot;http://clickhouse-server:8123/&quot;,
                        user=&quot;halobug&quot;,
                        password=&quot;FcP5O5HY&quot;,
                    )

                    self.create_db_table(df, db_name, table_name)
                    ph.to_clickhouse(
                        df,
                        table_name,
                        index=False,
                        chunksize=100000,
                        connection=connection_info,
                    )
                print(df)
            self.__data.clear()
        except Exception as e:
            logger.error(df)
            self.__data.clear()
            self.__line_notify.send(getErrMsg(e))
            logger.exception(e)
            os.kill(self.__ws_client_p.pid, signal.SIGUSR1)

    def run(self):
        while True:
            try:
                msg = self.__queue.get(block=True)
                self.__data.append(msg)
                if len(self.__data) &gt; 100:
                    self.write_orderbook_to_db()
            except Exception as e:
                self.__line_notify.send(getErrMsg(e))
                logger.exception(e)


class Manager(multiprocessing.Process):
    def __init__(self, thread_name, ws_url, symbol, params, queue, line_token):
        # threading.Thread.__init__(self)
        multiprocessing.Process.__init__(self)
        self.__thread_name = thread_name
        self.__ws_url = ws_url
        self.__symbol = symbol
        self.__params = params
        self.__queue = queue
        self.__line_notify = LineNotify(line_token)

    def run(self):
        self.__line_notify.send(f&quot;thread_name:{self.__thread_name}&quot;)
        monitor_queue = Queue(100)
        ws_client_p = WebSocketClient(
            thread_name=self.__thread_name,
            ws_url=self.__ws_url,
            symbol=self.__symbol,
            params=self.__params,
            queue=self.__queue,
            monitor_queue=monitor_queue,
            line_notify=self.__line_notify,
        )
        record_p = Record(
            thread_name=self.__thread_name,
            ws_client_p=ws_client_p,
            queue=self.__queue,
            line_notify=self.__line_notify,
        )
        tasks = [
            ws_client_p,
            record_p,
        ]
        for t in tasks:
            t.start()

        monitor_task = Process(
            target=monitor,
            args=(monitor_queue, self.__thread_name, ws_client_p, record_p),
        )
        monitor_task.start()

        for task in tasks:
            task.join()


if __name__ == &quot;__main__&quot;:
    Watcher()
    bitopro_orderbook_queue = Queue(1000)
    binance_orderbook_queue = Queue(1000)
    tasks = [
        Manager(
            thread_name=&quot;BitoPro Thread&quot;,
            ws_url=&quot;wss://stream.bitopro.com:9443/ws/v1/pub/order-books/BTC_USDT:20&quot;,
            symbol=&quot;&quot;,
            params=&quot;&quot;,
            queue=bitopro_orderbook_queue,
            line_token=&quot;KXwzqEGtIp1JEkS5GjqXqRAT0D4BdQQvCNcqOa7ySfz&quot;,
        ),
        Manager(
            thread_name=&quot;Binance Thread&quot;,
            ws_url=&quot;wss://stream.binance.com:9443/ws&quot;,
            symbol=&quot;&quot;,
            params=&quot;btcusdt@depth@100ms&quot;,
            queue=binance_orderbook_queue,
            line_token=&quot;KXwzqEGtIp1JEkS5GjqXqRAT0D4BdQQvCNcqOa7ySfz&quot;,
        ),
    ]
    for t in tasks:
        t.start()

    for task in tasks:
        task.join()

</code></pre>
<h2 id="dbeaver-登入-docker-clickhouse"><a class="header" href="#dbeaver-登入-docker-clickhouse">dbeaver 登入 docker clickhouse</a></h2>
<pre><code class="language-sh">port 1111
halobug
FcP5O5HY
</code></pre>
<p><img src="docker/images/dbeaver_clickhouse.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-for-set-up-clickhouse-server"><a class="header" href="#tutorial-for-set-up-clickhouse-server">Tutorial for set up clickhouse server</a></h1>
<p>https://github.com/jneo8/clickhouse-setup</p>
<ul>
<li>Makefile</li>
</ul>
<pre><code class="language-makefile">run-single-server:
	docker run -d --name clickhouse-server -p 9911:9000 -p 1121:8123 --ulimit nofile=262144:262144 yandex/clickhouse-server

run-single-client:
	docker run -it --rm --link clickhouse-server:clickhouse-server yandex/clickhouse-client  --host clickhouse-server

run-cluster-client-1:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-01:clickhouse-server yandex/clickhouse-client --host clickhouse-server
run-cluster-client-2:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-02:clickhouse-server yandex/clickhouse-client --host clickhouse-server
run-cluster-client-3:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-03:clickhouse-server yandex/clickhouse-client --host clickhouse-server
run-cluster-client-4:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-04:clickhouse-server yandex/clickhouse-client --host clickhouse-server
run-cluster-client-5:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-05:clickhouse-server yandex/clickhouse-client --host clickhouse-server
run-cluster-client-6:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-06:clickhouse-server yandex/clickhouse-client --host clickhouse-server

run-cluster-client-1-auth:
	docker run -it --rm --network=&quot;clickhouse-net&quot; --link clickhouse-01:clickhouse-server yandex/clickhouse-client --host clickhouse-server -u user1 --password 123456

exec:
	docker exec -it clickhouse-server /bin/bash
</code></pre>
<ul>
<li>docker-compose.yml</li>
</ul>
<pre><code class="language-dockerfile">version: '3'

services:
    clickhouse-zookeeper:
        image: zookeeper
        ports:
            - &quot;2181:2181&quot;
            - &quot;2182:2182&quot;
        container_name: clickhouse-zookeeper
        hostname: clickhouse-zookeeper

    clickhouse-01:
        image: yandex/clickhouse-server
        hostname: clickhouse-01
        container_name: clickhouse-01
        ports:
            - 9001:9000
        volumes:
                - ./config/clickhouse_config.xml:/etc/clickhouse-server/config.xml
                - ./config/clickhouse_metrika.xml:/etc/clickhouse-server/metrika.xml
                - ./config/macros/macros-01.xml:/etc/clickhouse-server/config.d/macros.xml
                - ./config/users.xml:/etc/clickhouse-server/users.xml
                # - ./data/server-01:/var/lib/clickhouse
        ulimits:
            nofile:
                soft: 262144
                hard: 262144
        depends_on:
            - &quot;clickhouse-zookeeper&quot;

    clickhouse-02:
        image: yandex/clickhouse-server
        hostname: clickhouse-02
        container_name: clickhouse-02
        ports:
            - 9002:9000
        volumes:
                - ./config/clickhouse_config.xml:/etc/clickhouse-server/config.xml
                - ./config/clickhouse_metrika.xml:/etc/clickhouse-server/metrika.xml
                - ./config/macros/macros-02.xml:/etc/clickhouse-server/config.d/macros.xml
                - ./config/users.xml:/etc/clickhouse-server/users.xml
                # - ./data/server-02:/var/lib/clickhouse
        ulimits:
            nofile:
                soft: 262144
                hard: 262144
        depends_on:
            - &quot;clickhouse-zookeeper&quot;

    clickhouse-03:
        image: yandex/clickhouse-server
        hostname: clickhouse-03
        container_name: clickhouse-03
        ports:
            - 9003:9000
        volumes:
                - ./config/clickhouse_config.xml:/etc/clickhouse-server/config.xml
                - ./config/clickhouse_metrika.xml:/etc/clickhouse-server/metrika.xml
                - ./config/macros/macros-03.xml:/etc/clickhouse-server/config.d/macros.xml
                - ./config/users.xml:/etc/clickhouse-server/users.xml
                # - ./data/server-03:/var/lib/clickhouse
        ulimits:
            nofile:
                soft: 262144
                hard: 262144
        depends_on:
            - &quot;clickhouse-zookeeper&quot;

    clickhouse-04:
        image: yandex/clickhouse-server
        hostname: clickhouse-04
        container_name: clickhouse-04
        ports:
            - 9004:9000
        volumes:
                - ./config/clickhouse_config.xml:/etc/clickhouse-server/config.xml
                - ./config/clickhouse_metrika.xml:/etc/clickhouse-server/metrika.xml
                - ./config/macros/macros-04.xml:/etc/clickhouse-server/config.d/macros.xml
                - ./config/users.xml:/etc/clickhouse-server/users.xml
                # - ./data/server-04:/var/lib/clickhouse
        ulimits:
            nofile:
                soft: 262144
                hard: 262144
        depends_on:
            - &quot;clickhouse-zookeeper&quot;

    clickhouse-05:
        image: yandex/clickhouse-server
        hostname: clickhouse-05
        container_name: clickhouse-05
        ports:
            - 9005:9000
        volumes:
                - ./config/clickhouse_config.xml:/etc/clickhouse-server/config.xml
                - ./config/clickhouse_metrika.xml:/etc/clickhouse-server/metrika.xml
                - ./config/macros/macros-05.xml:/etc/clickhouse-server/config.d/macros.xml
                - ./config/users.xml:/etc/clickhouse-server/users.xml
                # - ./data/server-05:/var/lib/clickhouse
        ulimits:
            nofile:
                soft: 262144
                hard: 262144
        depends_on:
            - &quot;clickhouse-zookeeper&quot;

    clickhouse-06:
        image: yandex/clickhouse-server
        hostname: clickhouse-06
        container_name: clickhouse-06
        ports:
            - 9006:9000
        volumes:
                - ./config/clickhouse_config.xml:/etc/clickhouse-server/config.xml
                - ./config/clickhouse_metrika.xml:/etc/clickhouse-server/metrika.xml
                - ./config/macros/macros-06.xml:/etc/clickhouse-server/config.d/macros.xml
                - ./config/users.xml:/etc/clickhouse-server/users.xml
                # - ./data/server-06:/var/lib/clickhouse
        ulimits:
            nofile:
                soft: 262144
                hard: 262144
        depends_on:
            - &quot;clickhouse-zookeeper&quot;
networks:
    default:
        external:
            name: clickhouse-net
</code></pre>
<h2 id="host-建立資料庫"><a class="header" href="#host-建立資料庫">Host 建立資料庫</a></h2>
<pre><code class="language-python">import clickhouse_driver
import pandas as pd


connection_settings = {
    'host': 'localhost',
    'port': '9911',
}

client = clickhouse_driver.Client(**connection_settings)

# 建立新資料庫
client.execute('CREATE DATABASE IF NOT EXISTS CRYPTO')

print(client.execute(&quot;SHOW DATABASES&quot;))
client.execute('USE CRYPTO')

# 創建一個簡單的表格
df = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie']*3333, 'age': [25, 30, 35]*3333})
#df = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie'], 'age': [25, 30, 35]})

client.execute('CREATE TABLE IF NOT EXISTS test_table (name String, age Int32) ENGINE = Memory')
#client.execute('CREATE TABLE IF NOT EXISTS test_table (name String, age Int32) ENGINE = MergeTree PARTITION BY name ORDER BY age')


# 將資料框寫入表格
client.execute('INSERT INTO test_table VALUES', df.to_dict('records'))

# 讀取表格中的資料
result = client.execute('SELECT * FROM test_table')
print(result)

# 刪除表格
# client.execute('DROP TABLE IF EXISTS test_table')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安裝-rust"><a class="header" href="#安裝-rust">安裝 Rust</a></h1>
<h2 id="linux-or-unix-or-macos"><a class="header" href="#linux-or-unix-or-macos">Linux or Unix or MacOS</a></h2>
<p>輸入下面的指令即可</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>若安裝完後發生問題，例如環境變數沒有自行設定好，可以輸入下面的指令</p>
<pre><code>source $HOME/.cargo/env
</code></pre>
<p>或在 <code>~/.bash_profile</code> 輸入</p>
<pre><code>export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>下載 <a href="https://win.rustup.rs/">rustup.exe</a></p>
<p>安裝需要用到 C++ build tools for VS2013 或更高的版本，可以在 Visual Studio 的官網下載軟體後，在其他的安裝選項中找到</p>
<h2 id="更新-rust-版本"><a class="header" href="#更新-rust-版本">更新 Rust 版本</a></h2>
<pre><code>rustup update
</code></pre>
<h2 id="安裝-rust-的其他版本"><a class="header" href="#安裝-rust-的其他版本">安裝 Rust 的其他版本</a></h2>
<p>EX: 安裝 nightly 的版本</p>
<pre><code>rustup install nightly
</code></pre>
<p>輸入下面指令檢查版本，如果有顯示就是代表安裝成功</p>
<pre><code class="language-bash">rustc --version
rustc 1.67.0-nightly (e0098a5cc 2022-11-29)
</code></pre>
<p>將 nightly 版本作為 default 版本</p>
<pre><code>rustup default nightly
</code></pre>
<h2 id="切換rust版本"><a class="header" href="#切換rust版本">切換rust版本</a></h2>
<p>查看目前所以安裝的版本</p>
<pre><code class="language-bash">ls ~/.rustup/toolchains/

nightly-x86_64-unknown-linux-gnu  
stable-x86_64-unknown-linux-gnu
</code></pre>
<p>切換預設版本</p>
<p><code>rustup default stable-x86_64-unknown-linux-gnu</code></p>
<h2 id="解除安裝-rust-與-rustup"><a class="header" href="#解除安裝-rust-與-rustup">解除安裝 Rust 與 rustup</a></h2>
<pre><code>rustup self uninstall
</code></pre>
<h2 id="rust-版本的差異"><a class="header" href="#rust-版本的差異">Rust 版本的差異</a></h2>
<ul>
<li>nightly: 每天的最新版本，但 bug 很多</li>
<li>beta: nightly 的新 bug feature 過一段時間穩定後，會在 beta 版出現</li>
<li>stable: 最穩定的版本，但相對的功能較舊</li>
</ul>
<h2 id="參考資料-1"><a class="header" href="#參考資料-1">參考資料</a></h2>
<ul>
<li>https://www.rust-lang.org/tools/install</li>
<li>https://doc.rust-lang.org/book/ch01-01-installation.html</li>
</ul>
<hr />
<h3 id="學習網站"><a class="header" href="#學習網站">學習網站</a></h3>
<ul>
<li><a href="https://github.com/rust-boom/rust-boom">Rust Room</a></li>
<li><a href="https://github.com/anonymousGiga/learn_rust/">令狐一沖</a></li>
<li><a href="https://shihyu.github.io/my_tour_of_rust/TOC_zh-tw.html">Rust 語言之旅</a></li>
<li><a href="https://rust-lang.tw/book-tw/#rust-%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E8%AA%9E%E8%A8%80">Rust 程式設計語言</a></li>
<li><a href="https://rustwiki.org/zh-CN/rust-by-example/">通過例子學 Rust 中文版</a></li>
<li><a href="https://shihyu.github.io/rust_by_example">通過例子學Rust繁體版</a></li>
<li><a href="https://rustcc.gitbooks.io/rustprimer/content/">RustPrimer</a></li>
<li><a href="https://shihyu.github.io/RustPrimerBook/">RustPrimer繁體</a></li>
<li><a href="https://skyao.io/learning-rust/">Rust學習筆記</a></li>
<li><a href="https://weathfold.gitbooks.io/rust-too-many-lists-zhcn/content/">通過大量的鏈表學習Rust</a></li>
<li><a href="https://shihyu.github.io/rust_hacks/">Rust入門秘籍</a></li>
<li><a href="https://ithelp.ithome.com.tw/users/20129675/ironman/4260?page=1">Rust 新手村 系列</a></li>
<li><a href="https://ithelp.ithome.com.tw/users/20111802/ironman/1742">30 天深入淺出 Rust 系列</a></li>
<li><a href="https://ithelp.ithome.com.tw/users/20120293/ironman/5180">30 天快快樂樂學 Rust 系列</a></li>
<li><a href="https://www.zhihu.com/column/c_1566579693834489856">30天讀完《深入淺出Rust》</a></li>
<li><a href="https://rust-lang.tw/book-tw/title-page.html#rust-%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E8%AA%9E%E8%A8%80">Rust 程式設計語言</a>
<ul>
<li>https://github.com/rust-tw/book-tw</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-筆記"><a class="header" href="#rust-筆記">Rust 筆記</a></h1>
<ul>
<li>as_ptr()</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn main() {
    let free_coloring_book = vec![
        &quot;mercury&quot;, &quot;venus&quot;, &quot;earth&quot;, &quot;mars&quot;, &quot;jupiter&quot;, &quot;saturn&quot;, &quot;uranus&quot;, &quot;neptune&quot;,
    ];
    // 1. free_coloring_book堆上數據的地址
    println!(&quot;address: {:p}&quot;, free_coloring_book.as_ptr());

    // 2. free_coloring_book棧上的地址
    let a = &amp;free_coloring_book;
    println!(&quot;address: {:p}&quot;, a);

    let mut friends_coloring_book = free_coloring_book;

    // 3. friends_coloring_book堆上數據的地址，和1一樣
    println!(&quot;address: {:p}&quot;, friends_coloring_book.as_ptr());

    // 4. friends_coloring_book棧上的地址
    let b = &amp;friends_coloring_book;
    println!(&quot;address: {:p}&quot;, b);
}
</code></pre></pre>
<ul>
<li>Rc / Box 用法</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

struct Aa {
    id: i32,
}

impl Drop for Aa {
    fn drop(&amp;mut self) {
        println!(&quot;Aa Drop, id: {}&quot;, self.id);
    }
}

fn print_type_of&lt;T&gt;(_: &amp;T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn test_1() {
    let a1 = Aa { id: 1 }; // 數據分配在棧中
    let a1 = Rc::new(a1); // 數據 move 到了堆中？
    print_type_of(&amp;a1);
    //drop(a1);
    println!(&quot;xxxxxxx&quot;);
}

fn test_2() {
    let a1 = Aa { id: 1 }; // 數據分配在棧中
    let a1 = Box::new(a1); // 數據 move 到了堆中？
    print_type_of(&amp;a1);
}

fn main() {
    test_1();
    test_2();
}
</code></pre></pre>
<ul>
<li>data  bss text heap stack</li>
</ul>
<pre><pre class="playground"><code class="language-rust">/// .Text段存放的是程序中的可執行代碼
/// .Data段保存的是已經初始化了的全局變量和靜態變量
/// .ROData（ReadOnlyData）段存放程序中的常量值，如字符串常量
/// .BSS段存放的是未初始化的全局變量和靜態變量，程序執行前會先進行一遍初始化
const G_ARRAY: [i32; 5] = [10; 5];
const G_X: i32 = 100;
static G_VAR: i32 = 1000;

fn test06_heap_or_stack() {
    let s: &amp;str = &quot;test list&quot;;
    //字符串字面量，位於ROData段
    println!(&quot;&amp;str: {:p}&quot;, s); //&amp;str: 0x7ff77e4c6b88
    println!(&quot;{:p}&quot;, &amp;G_ARRAY); //data段:0x7ff6c5fc6bb8
    println!(&quot;{:p}&quot;, &amp;G_X); //data段:0x7ff6c5fc64f0
    println!(&quot;{:p}&quot;, &amp;G_VAR); //data段:0x7ff77e4c6200
    println!(&quot;{}&quot;, &quot;-&quot;.repeat(10));

    // 位於堆
    let bi = Box::new(30);
    println!(&quot;{:p}&quot;, bi); //堆:0x19f6c6585e0
                          // 將字符串字面量從內存中的代碼區（ROData段）復制一份到堆
                          // 棧上分配的變量s1指向堆內存
    let mut s1: String = String::from(&quot;Hello&quot;);
    // 可以通過std::mem::transmute將
    // 從24字節的長度的3個uszie讀出來
    let pstr: [usize; 3] = unsafe { std::mem::transmute(s1) };
    // pstr[0]是一個堆內存地址
    println!(&quot;ptr: 0x{:x}&quot;, pstr[0]); //ptr: 0x19f6c658750

    println!(&quot;{}&quot;, &quot;-&quot;.repeat(10));
    // 位於棧
    let nums1 = [1, 2, 3, 4, 5, 6];
    let mut list: Vec&lt;i32&gt; = vec![20, 30, 40];
    let t = 100;
    println!(&quot;{:p}&quot;, &amp;t); //棧0x116aeff104
    println!(&quot;{:p}&quot;, &amp;nums1); //棧0x116aeff0d0
    println!(&quot;{:p}&quot;, &amp;list); //棧0x116aeff0e8
                             // 從ROData區復制了一份字符串字面量放到堆上，
                             // 然後用棧上分配的s指向堆
    let s: String = &quot;Hello&quot;.to_owned();
    println!(&quot;{:p}&quot;, &amp;s); //0x116aeff1f8
    let s: String = String::from(&quot;Hello&quot;);
    println!(&quot;{:p}&quot;, &amp;s); //0x116aeff260
    let s: String = &quot;Hello&quot;.into();
    println!(&quot;{:p}&quot;, &amp;s); //0x116aeff2c8
}

fn main() {
    test06_heap_or_stack();
}
</code></pre></pre>
<h2 id="ownership有個特性是個大坑"><a class="header" href="#ownership有個特性是個大坑">ownership有個特性是個大坑</a></h2>
<pre><pre class="playground"><code class="language-rust">// ownership有個特性，感覺是個大坑，把不可變資料的ownership move到可變資料，那麼就改值了。這個設定不安全。
fn main() {
    let immutable = Box::new(5u32);
    println!(&quot;{:}&quot;, immutable);

    let mut mutable_box = immutable;
    println!(&quot;{:}&quot;, mutable_box);
    *mutable_box = 4;
    println!(&quot;{:}&quot;, mutable_box);
} 
</code></pre></pre>
<h2 id="rust中mut--mut的區別"><a class="header" href="#rust中mut--mut的區別">Rust中mut, &amp;, &amp;mut的區別</a></h2>
<p>資源：記憶體區塊。不同的記憶體區塊位置和大小就是不同的資源。</p>
<h3 id="str"><a class="header" href="#str">str</a></h3>
<p>let a = &quot;xxx&quot;.to_string();　　
含義：a繫結到字串資源A上，擁有資源A的所有權</p>
<p>let mut a = &quot;xxx&quot;.to_string();　
含義：a繫結到字串資源A上，擁有資源A的所有權，同時a還可繫結到新的資源上面去（更新繫結的能力，但新舊資源類型要同）；</p>
<h3 id="value"><a class="header" href="#value">value</a></h3>
<p>let b = a;
含義：a繫結的資源A轉移給b，b擁有這個資源A</p>
<p>let b = &amp;a;　　
含義：a繫結的資源A借給b使用，b只有資源A的讀權限</p>
<p>let b = &amp;mut a;　　
含義：a繫結的資源A借給b使用，b有資源A的讀寫權限</p>
<p>let mut b = &amp;mut a;　　
含義：a繫結的資源A借給b使用，b有資源A的讀寫權限。同時，b可繫結到新的資源上面去（更新繫結的能力）</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>fn do(c: String) {}　　
含義：傳參的時候，實參d繫結的資源D的所有權轉移給c</p>
<p>fn do(c: &amp;String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D唯讀</p>
<p>fn do(c: &amp;mut String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D可讀寫</p>
<p>fn do(mut c: &amp;mut String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D可讀寫。同時，c可繫結到新的資源上面去（更新繫結的能力）</p>
<p>函數參數裡面，冒號左邊的部分，mut c，這個mut是對函數體內部有效；冒號右邊的部分，&amp;mut String，這個 &amp;mut 是針對外部實參傳入時的形式化（類型）說明。</p>
<p>下面的例子輸出是什麼：</p>
<pre><pre class="playground"><code class="language-rust">fn concat_literal(s: &amp;mut String) {     
    s.extend(&quot;world!&quot;.chars());         
}                                       
                                          
fn main() {                             
    let mut s = &quot;hello, &quot;.to_owned();   
    concat_literal(&amp;mut s);             
    println!(&quot;{}&quot;, s);                  
}  
</code></pre></pre>
<h2 id="打印-borrow-位址"><a class="header" href="#打印-borrow-位址">打印 borrow 位址</a></h2>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn test(a: &amp;mut i32) {
    println!(&quot;{:p}&quot;, *&amp;a); // 打印 reference address 
    println!(&quot;{:p}&quot;, a); // 打印 reference address 
    println!(&quot;{:}&quot;, a);
    *a = 100;
    println!(&quot;{:p}&quot;, &amp;a);
}

fn main() {
    let mut a = 10;
    print_type_of(a);
    let b = &amp;mut a;
    *b = 50;
    print_type_of(b);
    println!(&quot;{:p}&quot;, &amp;a);
    test(&amp;mut a);
    println!(&quot;{:}&quot;, a);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn main() {
    let a: i32 = 5;
    print_type_of(a);
    println!(&quot;addr：{:p}&quot;, &amp;a);
    let b = &amp;a;
    print_type_of(b);
    println!(&quot;addr：{:p}&quot;, b);
    println!(&quot;value ：{:}&quot;, b);
    //&amp;a先轉成raw指針，然後再把指針轉成usize，這個可以print的
    let addr = &amp;a as *const i32 as usize;
    println!(&quot;addr：0x{:X}&quot;, addr);

    //為了驗證剛才的地址是不是正確的，我們修改這個指針指向的數據
    //pa就是addr對應的raw指針
    let pa = addr as *mut i32;
    //解引用，*pa其實就是&amp;mut a了，給他賦值100
    unsafe { *pa = 100 };

    //打印a，可以看到a已經變成100了
    println!(&quot;value:{}&quot;, a);
}
</code></pre></pre>
<h2 id="self-和-self-的區別"><a class="header" href="#self-和-self-的區別">&amp;self 和 self 的區別</a></h2>
<p>在 Rust 的方法中，第一個參數為 &amp; self，那麼如果改成 self（不是大寫的 Self）行不行，兩者有什麼區別。
&amp;self，表示向函數傳遞的是一個引用，不會發生對像所有權的轉移；
self，表示向函數傳遞的是一個對象，會發生所有權的轉移，對象的所有權會傳遞到函數中。
原文作者：linghuyichong
轉自鏈接：https://learnku.com/articles/39050</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyType {
    name: String,
}

impl MyType {
    fn do_something(self, age: u32) {
        //等價於 fn do_something(self: Self, age: u32) {
        //等價於 fn do_something(self: MyType, age: u32) {
        println!(&quot;name = {}&quot;, self.name);
        println!(&quot;age = {}&quot;, age);
    }

    fn do_something2(&amp;self, age: u32) {
        println!(&quot;name = {}&quot;, self.name);
        println!(&quot;age = {}&quot;, age);
    }
}

fn main() {
    let my_type = MyType {
        name: &quot;linghuyichong&quot;.to_string(),
    };
    //使用self
    my_type.do_something(18); //等價於MyType::do_something(my_type, 18);
                              //println!(&quot;my_type: {:#?}&quot;, my_type);    //在do_something中，傳入的是對象，而不是引用，因此my_type的所有權就轉移到函數中了，因此不能再使用

    //使用&amp;self
    let my_type2 = MyType {
        name: &quot;linghuyichong&quot;.to_string(),
    };
    my_type2.do_something2(18);
    my_type2.do_something2(18);
    println!(&quot;my_type2: {:#?}&quot;, my_type2); //在do_something中，傳入是引用，函數並沒有獲取my_type2的所有權，因此此處可以使用
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li>
<p>模擬C++ 建構/解構</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::process;

struct MyStruct {
    value: i32,
}

impl MyStruct {
    fn new(value: i32) -&gt; MyStruct {
        println!(&quot;MyStruct with value {} created by pid {} tid {:?}&quot;, value, process::id(), thread::current().id());
        MyStruct { value: value }
    }
}

impl Drop for MyStruct {
    fn drop(&amp;mut self) {
        println!(&quot;MyStruct with value {} dropped by pid {} tid {:?}&quot;, self.value, process::id(), thread::current().id());
    }
}

fn main() {
    let my_struct = MyStruct::new(42);
}
</code></pre></pre>
</li>
<li>
<p>trait</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
/*
 * 這個程式碼定義了一個名叫 Movable 的 trait，這個 trait 定義了一個 movement 方法。
 * Human 和 Rabbit 是兩個結構體，分別實現了 Movable trait。在每個實現中，
 * 都定義了一個 movement 方法，實現了結構體如何移動的行為。
 * 在 main 函數中，我們創建了一個 Human 和一個 Rabbit 的實例，存儲在 human 和 rabbit 變數中。
 * 然後，我們依次對這兩個變數分別調用了 movement 方法，分別輸出了 &quot;Human walk&quot; 和 &quot;Rabbit jump&quot;。
 * 這個程式碼展示瞭如何使用 Rust 的 trait 和結構體來實現多態行為。
 * 使用 trait，可以將類似的操作組織成一個介面，並將其實現為多個不同的類型。這使得代碼更加模組化，可重用性更高。
 * */
trait Movable {
    fn movement(&amp;self);
}

struct Human;

impl Movable for Human {
    fn movement(&amp;self) {
        println!(&quot;Human walk&quot;);
    }
}

struct Rabbit;

impl Movable for Rabbit {
    fn movement(&amp;self) {
        println!(&quot;Rabbit jump&quot;);
    }
}

fn main() {
    let human = Human;
    let rabbit = Rabbit;

    human.movement();
    rabbit.movement();
}
</code></pre></pre>
<ul>
<li>Rust 中有三種方式來引用這個結構實例：<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>。下面舉例說明這三種實例引用方式的不同之處。</li>
</ul>
<p>self<code>和</code>&amp;mut self` 都用於引用結構體實例，但有著不同的含義。</p>
<p><code>self</code> 表示方法使用結構體實例的所有權；而 <code>&amp;mut self</code> 則表示方法使用結構體實例的可變引用。</p>
<p>具體來說，當使用 <code>self</code> 定義方法時，這個方法會接受結構體實例的所有權，即將結構體實例移動到方法中，可以在方法內部進行修改或銷毀。當方法執行完畢後，結構體實例的控制權會返回到調用方。</p>
<p>而使用 <code>&amp;mut self</code> 定義方法時，這個方法會接受結構體實例的可變引用。當方法被調用時，結構體實例依然保持存在，並且可以在方法內部進行修改。當方法執行完畢後，結構體實例保持存在並且可以繼續使用。</p>
<p>總體來說，使用 <code>self</code> 比使用 <code>&amp;mut self</code> 更加靈活，但也更加危險，因為它轉移了結構體實例的所有權。而使用 <code>&amp;mut self</code> 可以讓方法在調用時保留結構體實例，並可以在方法內部進行修改，但需要注意如果結構體同時被多個可讀寫的引用進行修改，就會產生賽博會同步錯誤。因此，方法的實現必須小心處理對結構體實例的存儲和修改依賴關係。</p>
<p>首先，讓我們定義一個結構 <code>Person</code>，其中包含了一個名稱屬性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>接下來，我們為這個結構定義三種方法，分別使用 <code>self</code>、<code>&amp;self</code> 和 <code>&amp;mut self</code> 來引用實例。</p>
<ol>
<li>使用 <code>self</code> 引用實例，並修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn set_name(self, new_name: String) -&gt; Person {
        Person { name: new_name }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在這個方法中，<code>self</code> 為結構體的值，透過使用 <code>set_name</code> 方法，我們可以將一個 <code>Person</code> 結構體的名稱屬性更改為一個新的名稱，然後返回一個新的 <code>Person</code> 結構體，原來的實例沒有被修改。這種方式可以原地修改實例，因為它轉移了所有權。</p>
<ol>
<li>使用 <code>&amp;self</code> 引用實例，但不修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn greet(&amp;self) {
        println!(&quot;Hi, my name is {}&quot;, self.name);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在這個方法中，<code>&amp;self</code> 為結構體的借用引用，它將 <code>Person</code> 結構體的所有權借用給了 <code>greet</code> 方法，但不允許 <code>greet</code> 方法修改該實例的任何屬性。因此，這種方式適用於只需要讀取結構屬性的方法。</p>
<ol>
<li>使用 <code>&amp;mut self</code> 引用實例，並修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn rename(&amp;mut self, new_name: String) {
        self.name = new_name;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在這個方法中，<code>&amp;mut self</code> 為結構體的可變引用，透過使用 <code>rename</code> 方法，我們可以將一個 <code>Person</code> 結構體的名稱屬性更改為一個新的名稱。這種方式允許修改結構屬性，因為它使用了結構體的可變引用。</p>
<p>總結來說，這三種方式分別提供了不同的實例引用方法。使用 <code>self</code> 從原始的實例移動所有權，這在歸還新創建的 <code>Person</code> 結構體時特別有用。使用 <code>&amp;self</code> 或 <code>&amp;mut self</code> 以引用的方式讀取和修改結構屬性。使用 <code>&amp;self</code>可以保證實例是不可變的，而使用 <code>&amp;mut self</code> 允許修改實例的內容。</p>
<ul>
<li>
<p>在 Rust 中，<code>self</code> 和 <code>Self</code> 都表示結構體或枚舉的類型，但有著不同的含義。</p>
<p>self<code>在方法定義中是用來引用實例自身，而</code>Self<code>則用來表示結構體或枚舉本身的類型。下面是一個示例，說明瞭</code>Self<code>和</code>self` 的使用：</p>
<p>在這個示例中，我們定義了一個名為 <code>Rectangle</code> 的結構體，並為其實現了三個方法：<code>new</code>、<code>area</code> 和 <code>same</code>。</p>
<p>在 <code>new</code> 方法中，我們使用了 <code>Self</code> 來表示結構體的類型，並使用了 <code>self</code> 變量，它是一個引用結構體實例的不可變引用。這個方法創建了一個新的 <code>Rectangle</code> 結構體實例，並將其返回。</p>
<p>在 <code>area</code> 方法中，我們使用了 <code>&amp;self</code> 引用，這個方法只是計算結構體實例的面積，但不修改它。</p>
<p>在 <code>same</code> 方法中，我們使用了 <code>&amp;Self</code> 引用，這個方法不需要引用結構體實例本身，而是可以直接使用 <code>Rectangle</code> 類型來比較兩個實例是否具有相同的寬度和高度。</p>
<p>在 <code>main</code> 函數中，我們創建了一個 <code>Rectangle</code> 結構體實例，調用了 <code>area</code> 方法來計算實例的面積，並調用了 <code>same</code> 方法來檢查實例是否是一個正方形。</p>
<p>總結來說，<code>self</code> 主要用於方法中引用結構體實例本身，而 <code>Self</code> 則用作表示結構體或枚舉的類型。</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn new(width: u32, height: u32) -&gt; Self {
        Self { width, height }
    }

    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn same(rect: &amp;Self) -&gt; bool {
        rect.width == rect.height
    }
}

fn main() {
    let rectangle = Rectangle::new(10, 5);
    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rectangle.area()
    );
    println!(&quot;Is the rectangle a square? {}&quot;, Rectangle::same(&amp;rectangle));
}

</code></pre></pre>
<h2 id="handle-trait-的方式不同"><a class="header" href="#handle-trait-的方式不同"><code>Handle</code> trait 的方式不同</a></h2>
<p>第一個代碼示例中，我們在 <code>Handle</code> trait 中定義了一個實例方法 <code>handle()</code>，它接受一個 <code>&amp;self</code> 參數，表示該方法是與 <code>Handler</code> 結構體實例相關聯的。在實現 <code>Handle</code> trait 時，我們對每個需要處理的類型都分別實現了 <code>handle()</code> 方法，通過 <code>impl Handle&lt;i32&gt; for Handler</code> 和 <code>impl Handle&lt;f64&gt; for Handler</code> 定義了對 <code>i32</code> 和 <code>f64</code> 類型的處理過程。在 <code>main()</code> 中，我們創建了 <code>Handler</code> 結構體對象 <code>handler</code>，然後調用 <code>handler.handle(10)</code> 和 <code>handler.handle(10.5)</code> 方法來處理輸入的不同類型數據。</p>
<pre><pre class="playground"><code class="language-rust">struct Handler;

trait Handle&lt;T&gt; {
    fn handle(&amp;self, input: T);
}

impl Handle&lt;i32&gt; for Handler {
    fn handle(&amp;self, input: i32) {
        println!(&quot;This is i32: {}&quot;, input);
    }
}

impl Handle&lt;f64&gt; for Handler {
    fn handle(&amp;self, input: f64) {
        println!(&quot;This is f64: {}&quot;, input);
    }
}

fn main() {
    let handler = Handler;

    // 使用 i32 類型的 Handler
    handler.handle(10);

    // 使用 f64 類型的 Handler
    handler.handle(10.5);
}
</code></pre></pre>
<p>第二個代碼示例中，我們在 <code>Handle</code> trait 中定義了一個關聯函數 <code>handle()</code>，它不需要 <code>&amp;self</code> 參數，表示該函數與 <code>Handler</code> 結構體實例無關。在實現 <code>Handle</code> trait 時，我們同樣對每個需要處理的類型都分別實現了 <code>handle()</code> 關聯函數，通過 <code>impl Handle&lt;i32&gt; for Handler</code> 和 <code>impl Handle&lt;f64&gt; for Handler</code> 定義了對 <code>i32</code> 和 <code>f64</code> 類型的處理過程。在 <code>main()</code> 中，我們不創建任何 <code>Handler</code> 的對象，而是直接對 <code>Handler</code> 結構體類型調用 <code>Handler::handle(10)</code> 和 <code>Handler::handle(10.5)</code>方法來處理輸入的不同類型數據。</p>
<p>因此，這兩段代碼的區別在於實現 <code>Handle</code> trait 的方式不同。第一個代碼示例中實現了一個實例方法 <code>handle()</code>，第二個代碼示例中實現了一個關聯函數 <code>handle()</code>。這兩個方法/函數的調用方式也不同。</p>
<pre><pre class="playground"><code class="language-rust">struct Handler;

trait Handle&lt;T&gt; {
    fn handle(&amp;self, input: T);
}

impl Handle&lt;i32&gt; for Handler {
    fn handle(&amp;self, input: i32) {
        println!(&quot;This is i32: {}&quot;, input);
    }
}

impl Handle&lt;f64&gt; for Handler {
    fn handle(&amp;self, input: f64) {
        println!(&quot;This is f64: {}&quot;, input);
    }
}

fn main() {
    let handler = Handler;

    // 使用 i32 類型的 Handler
    handler.handle(10);

    // 使用 f64 類型的 Handler
    handler.handle(10.5);
}
</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-基本教學"><a class="header" href="#rust-基本教學">Rust 基本教學</a></h1>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h2>
<h3 id="不使用管理工具編寫程式"><a class="header" href="#不使用管理工具編寫程式">不使用管理工具編寫程式</a></h3>
<ol>
<li>建立副檔名為 <code>.rs</code> 的檔案 ex: <code>main.rs</code></li>
<li>寫 main function，程式碼編譯過後，會以 main function 作為進入點</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main () {
    
}
</code></pre></pre>
<ol>
<li>印出 <code>Hello World!</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main () {
    println!(&quot;Hello World&quot;);
}
</code></pre></pre>
<ol>
<li>編譯程式碼</li>
</ol>
<pre><code>rustc main.rs
</code></pre>
<ol>
<li>編譯完後會產生 <code>main</code>/<code>main.exe</code> 檔，執行 <code>main</code>/<code>main.exe</code> 檔</li>
</ol>
<pre><code>./main
</code></pre>
<h3 id="使用-cargo-管理專案"><a class="header" href="#使用-cargo-管理專案">使用 Cargo 管理專案</a></h3>
<ol>
<li>建立專案</li>
</ol>
<pre><code>cargo new hello_world
</code></pre>
<ol>
<li>編輯 <code>src/main.rs</code> 的檔案</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ol>
<li>檢查專案是否可以編譯得過</li>
</ol>
<pre><code>cargo check
</code></pre>
<ol>
<li>編譯</li>
</ol>
<pre><code>cargo build
</code></pre>
<ol>
<li>執行</li>
</ol>
<pre><code>cargo run
</code></pre>
<ol>
<li>優化編譯</li>
</ol>
<pre><code>cargo build --release
</code></pre>
<h3 id="hello-world-的程式碼解析"><a class="header" href="#hello-world-的程式碼解析">Hello World 的程式碼解析</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main () {} // fn 是 function 的關鍵字
println!(&quot;Hello World!&quot;) // println 是印出資料的語法，! 是 macro 的寫法， println!  是官方的 macro ，會在編譯時期根據目標平臺轉換成相應的程式碼
</code></pre></pre>
<h2 id="宣告變數"><a class="header" href="#宣告變數">宣告變數</a></h2>
<ul>
<li>在 rust 中，可以不用宣告型別，也會由編譯器自行推定</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = 5; // 會被自行推定為 i32
    let y: i32 = 10; // 也可以宣告變數型別
}
</code></pre></pre>
<ul>
<li>預設所有變數都是不可變的</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = 5;
    x = 10; // 不可以改變 x 的值
}
</code></pre></pre>
<ul>
<li>若要改變變數，必須宣告 <code>mut</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let mut x = 5;
    x = 10; // OK
}
</code></pre></pre>
<ul>
<li>可以用 tuple 或 struct 的方式宣告多個變數並同時賦值</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let (a, b) = (1, 2);
    let (mut x, mut y) = (1, 2); // 或宣告可變的變數
}
</code></pre></pre>
<ul>
<li>可以事先宣告變數，但若變數被宣告後沒有初始化，同時在之後被使用到，會編譯不過</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x: i32;
    println!(&quot;{}&quot;, x); // use of possibly-uninitialized `x`
}
fn main () {
    let x: i32;
    let condition = true;
    if condition {
        x = 1; // 因為在這裡被初始化了
        println!(&quot;{}&quot;, x); // 所以可以使用
    }
    // 但在這裡沒有被初始化
    println!(&quot;{}&quot;, x); // 在這裡會出錯
}
</code></pre></pre>
<ul>
<li>有的時候會在接別人的 API 時，遇到用不到，但必須寫出來的變數，可以用<code>底線</code> 帶過，就可以讓編譯器閉嘴，讓編譯器忽略沒有使用到這個變數，但同時<code>底線</code>變數也被視為不能被使用的變數，所以不可以在後面的程式碼中使用到</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let _ = &quot;hello&quot;;
    println!(&quot;{}&quot;, _); // expected expression
}
</code></pre></pre>
<ul>
<li>如果在寫程式的途中，想要命名一個跟前面名稱一模一樣的變數是可以的</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = &quot;Hello&quot;;
    println!(&quot;{}&quot;, x);
    
    let x = 5; // 前面的變數會被 shadowing
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<ul>
<li>可以用 <code>type</code> 為一個型別取新的名字</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Age = u32;
fn grow (age: Age, year: u32) -&gt; Age {
    age + year
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>宣告靜態變數</li>
</ul>
<pre><code>static GLOBAL: i32 = 0;
</code></pre>
<ul>
<li>宣告常數</li>
</ul>
<pre><code>const GLOBAL: i32 = 0;
</code></pre>
<h2 id="型別種類"><a class="header" href="#型別種類">型別種類</a></h2>
<ul>
<li>bool</li>
<li>char</li>
<li>數字</li>
<li>array</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];
let first = a[0];
let second = a[1];
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>tuple</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = (&quot;hello&quot;, 1)
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>struct</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Person {
    age: u32,
    weight: u32,
}

fn main () {
    let ballfish = Person { age: 18, weight: 40 };
    println!(&quot;{}, {}&quot;, age, weight);
}
</code></pre></pre>
<ul>
<li>tuple struct</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color (i32, i32, i32);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>enum</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Food {
    Noodle,
    Rice
}

enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="ifelseloopfunction"><a class="header" href="#ifelseloopfunction">if/else、loop、function</a></h2>
<ul>
<li>用大括號括起來的區塊，可以放在等號後面，最後一行不寫分號，會被視為回傳直傳出去</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = { println!(&quot;喵喵喵喵&quot;); 5 };
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<ul>
<li>if/else</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let n = 4;
    if n &lt; 0 {
        println!(&quot;Wow&quot;);
    } else if n == 0 {
        println!(&quot;owo&quot;);
    } else {
        println!(&quot;Orz&quot;);
    }
    // Orz
}
</code></pre></pre>
<ul>
<li>Rust 並沒有三元運算子（ex: n &lt; 0 ? “owo” : “OAO”），但可以把 if/else 寫成下面這樣</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let n = 4;
    let x = if n &lt; 4 { &quot;owo&quot; } else { &quot;OAO&quot; };
    println!(&quot;{}&quot;, x);
    // OAO
}
</code></pre></pre>
<ul>
<li>Rust 中，若 else 沒有寫出來，視為回傳 <code>()</code>，以剛剛的例子而言，由於 <code>x</code> 必須在編譯時期就確定型態，所以 if/else 回傳的值必須一致。也因此，通常 if 會伴隨 else，除非 if 沒有回傳值</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let n = 4;
    let x = if n &lt; 4 { &quot;owo&quot; } else { 5 }; // expected `&amp;str`, found integer
    println!(&quot;{}&quot;, x);
}
fn main () {
    let n = 4;
    let x = if n &lt; 4 { &quot;owo&quot; }; // expected `()`, found `&amp;str`
}
fn main () {
    let n = 4;
    let x = if n &lt; 5 { println!(&quot;OAO&quot;) };
    // OAO
}
</code></pre></pre>
<ul>
<li>loop，是一個不帶條件的無限迴圈</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    loop {
        print!(&quot;喵喵喵喵&quot;);
    }
}
</code></pre></pre>
<ul>
<li>跟其他的程式語言一樣，Rust 有 <code>continue</code> 與 <code>break</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    loop {
        print!(&quot;汪汪&quot;);
        break;
    }
    
    loop {
        print!(&quot;喵喵喵喵&quot;);
        continue;
        print!(&quot;噗伊&quot;);
    }
}
</code></pre></pre>
<ul>
<li>你可以在 <code>break</code> 後面接值，這個值會被作為回傳值</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let a = loop {
        println!(&quot;噗伊&quot;);
        break 5;
    };
    println!(&quot;{}&quot;, a);
    // 噗伊
    // 5
}
</code></pre></pre>
<ul>
<li>while，帶有條件的迴圈</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let mut n = 0;
    while n &lt; 10 {
        println!(&quot;喵喵喵喵&quot;);
        n += 1;
    }
}
</code></pre></pre>
<ul>
<li>while 也可以接在等號後面，但因為 <code>break</code> 在 <code>while</code> 中不能接值，所以永遠會回傳 <code>()</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let mut n = 0;
    let x = while n &lt; 10 {
        n += 1;
        break 5; // can only break with a value inside `loop` or breakable block
    };
}
fn main () {
    let mut n = 0;
    // OK，但 x = ()
    let x = while n &lt; 10 {
        n += 1;
        break;
    };
}
</code></pre></pre>
<ul>
<li>loop 與 while 的差異
<ul>
<li>loop 是不帶條件一定會執行的迴圈</li>
<li>while 是帶有條件，不一定會被執行的迴圈</li>
<li>對於編義器來說，while block 裡的程式碼不一定會被執行到，無論 while 後面接的是不是 true</li>
<li>也是因為這個差異，<code>break</code> 在 <code>while</code> 裡面才會不能接值，因為 while 沒有被執行的情況下，回傳直永遠是 <code>()</code>，所以在 while block 裡的回傳值一定要是 <code>()</code></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x;
    loop { x = 1; break; }
    println!(&quot;{}&quot;, x); // x 一定會在 loop 中被初始化，所以編譯會過
}
fn main () {
    let x;
    while true { x = 1; break; }
    // 因為編譯器無法保證 while block 裡的程式碼一定會被執行到，所以無法保證 x 一定會被初始化，因此編譯不會過
    println!(&quot;{}&quot;, x); // use of possibly-uninitialized `x`
}
</code></pre></pre>
<ul>
<li>for loop，Rust 中沒有其他語言常有的 <code>for (i = 0;i &lt; 10;i++)</code>，Rust 中的 for loop形式跟其他語言的 for-each 視同義的</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let array = [1, 2, 3];
    for i in array.iter() {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<ul>
<li>for loop 跟 while 的特性一樣，block 中的 <code>break</code> 後不可以接值， for loop 可以接在等號後面</li>
<li>function</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add (t: (i32, i32)) -&gt; i32 {
    t.0 + t.1
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>function 的 parameter 還可以直接解構</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add ((x, y): (i32, i32)) -&gt; i32 {
    x + y
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>function 可以作為一個普通的變數</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn add ((x, y): (i32, i32)) -&gt; i32 {
    x + y
}
fn main () {
    let func = add;
    println!(&quot;{}&quot;, func((1, 2))); // 3
}
</code></pre></pre>
<ul>
<li>不會正常回傳的 function</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn amazing () -&gt; ! {
    panic!(&quot;crash the application~~&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>const fn，加上 const 關鍵字的 function 可以在編譯時期被執行，執行完的值也可以作為常數使用</li>
</ul>
<pre><pre class="playground"><code class="language-rust">const fn add ((x, y): (i32, i32)) -&gt; i32 {
    x + y
}

fn main () {
    const CONSTANT: i32 = add((1, 2));
    println!(&quot;{}&quot;, CONSTANT);
}
</code></pre></pre>
<ul>
<li>Rust 的 function 可以遞迴，但跟其他語言一樣過多層的遞迴會 stack overflow</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-所有權系統"><a class="header" href="#rust-所有權系統">Rust 所有權系統</a></h1>
<h2 id="所有權的機制-ownership"><a class="header" href="#所有權的機制-ownership">所有權的機制 (Ownership)</a></h2>
<ol>
<li>所有的 Value 與 記憶體位置 只會有一個 變數 管理他們，意思是不會有兩個變數同時紀錄同一個記憶體位置</li>
<li>所有的 Value 與 記憶體位置 都必須要有個一個 變數 管理他們，所以當變數因為生命週期結束時，代表Value會被銷毀、記憶體位置會被釋放</li>
</ol>
<h2 id="所有權轉移-move"><a class="header" href="#所有權轉移-move">所有權轉移 (Move)</a></h2>
<p><img src="rust/images/hNwvegt.jpg" alt="img" /></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
fn main () {
    let x = Person { age: 16 };
    let y = x;
    // borrow of moved value: `x`
    // 所有權被轉移了，所以你不能再使用 x
    println!(&quot;{:?}&quot;, x);
    println!(&quot;{:?}&quot;, y);
}
</code></pre></pre>
<h2 id="按位複製-copy"><a class="header" href="#按位複製-copy">按位複製 (Copy)</a></h2>
<p><img src="rust/images/TyvUGES.jpg" alt="img" /></p>
<ul>
<li>記憶體位置是不能被 Copy 的</li>
<li>struct 在沒有實現 Copy 前，是不會進行 Copy，而會進行 Move</li>
<li>但 array、tuple、Option 本身就有實現 Copy，所以在所有的值都可以實現 Copy 的情況，會進行 Copy，如果有一個值不能實現 Copy 則會進行 Move</li>
<li>實現 Copy、Clone trait (因為 Copy 繼承 Clone，所以必須同時實現 Copy 與 Clone trait) (關於 trait 會在之後的章節提到)</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
// Clone trait 用來實現 deep clone
// 任何類型都可以實作 Clone
impl Clone for Person {
    fn clone (&amp;self) -&gt; Person {
        Person { age: self.age }
    }
}
// Copy trait 像是一個標籤
// 他裡面沒有任何可以實現的 function
// 但實作 Copy 的 struct 可以進行 Copy
// 不過可以實作 Copy 的 struct，成員必須不包含指標類型
impl Copy for Person {}
fn main () {
    let x = Person { age: 16 };
    let y = x;
    println!(&quot;{:p}&quot;, &amp;x);
    println!(&quot;{:?}&quot;, x);
    println!(&quot;{:p}&quot;, &amp;y);
    println!(&quot;{:?}&quot;, y);
}
</code></pre></pre>
<ul>
<li>快速實現 Copy 與 Clone</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Copy, Clone)]
struct Person {
    age: i32
}
fn main () {
    let x = Person { age: 16 };
    let y = x;
    println!(&quot;{:p}&quot;, &amp;x);
    println!(&quot;{:?}&quot;, x);
    println!(&quot;{:p}&quot;, &amp;y);
    println!(&quot;{:?}&quot;, y);
}
</code></pre></pre>
<h2 id="所有權借用-borrow"><a class="header" href="#所有權借用-borrow">所有權借用 (Borrow)</a></h2>
<h3 id="介紹-1"><a class="header" href="#介紹-1">介紹</a></h3>
<ul>
<li>借用分成不可變借用(&amp;)跟可變借用(&amp;mut)</li>
<li>用 &amp; 來借用</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
fn birthday (y: &amp;mut Person) {
    y.age = y.age + 1;
}
fn main () {
    let mut x = Person { age: 16 };
    birthday(&amp;mut x);
    println!(&quot;{:?}&quot;, x);
}
</code></pre></pre>
<ul>
<li>沒有借用的情況，所有權會被轉移</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
fn birthday (mut y: Person) {
    y.age = y.age + 1;
}
fn main () {
    let x = Person { age: 16 };
    birthday(x);
    println!(&quot;{:?}&quot;, x);
}
</code></pre></pre>
<p>output</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
9  |     let x = Person { age: 16 };
   |         - move occurs because `x` has type `Person`, which does not implement the `Copy` trait
10 |     birthday(x);
   |              - value moved here
11 |     println!(&quot;{:?}&quot;, x);
   |                      ^ value borrowed here after move
<span class="boring">}
</span></code></pre></pre>
<h3 id="借用的規則-rust-核心原則之一共享不可變可變不共享"><a class="header" href="#借用的規則-rust-核心原則之一共享不可變可變不共享">借用的規則 (Rust 核心原則之一：共享不可變，可變不共享)</a></h3>
<ul>
<li>在不可變借用期間 (共享)，擁有者不能修改 Value，也不能進行可變借用 (不可變)，但可以再進行不可變借用</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
#[allow(dead_code)]
fn birthday (y: &amp;mut Person) {
    y.age = y.age + 1;
}
#[allow(unused_mut)]
fn main () {
    let mut x = Person { age: 16 };
    let y = &amp;x; // 不可變借用，擁有者是 x，借用者是 y
    println!(&quot;{:p}&quot;, &amp;x); // x 可以再進行不可變借用
    // cannot borrow `x` as mutable because it is also borrowed as immutable
    // 但不可以再進行可變借用
    birthday(&amp;mut x);
    println!(&quot;{:?}&quot;, y); // 借用者 y 可以使用 x，印出值
}
</code></pre></pre>
<ul>
<li>在可變借用期間 (可變)，擁有者不能存取 Value，也不能進行不可變借用 (不共享)</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
#[allow(dead_code)]
fn birthday (y: &amp;mut Person) {
    y.age = y.age + 1;
}
#[allow(unused_mut)]
fn main () {
    let mut x = Person { age: 16 };
    let y = &amp;mut x; // 可變借用，擁有者是 x，借用者是 y
    y.age = 1;
    // cannot borrow `x` as immutable because it is also borrowed as mutable
    // x 不可以再進行不可變借用
    println!(&quot;{:p}&quot;, &amp;x);
    // cannot borrow `x` as mutable more than once at a time
    // 當然也不可以再進行可變借用
    birthday(&amp;mut x);
    // cannot use `x.age` because it was mutably borrowed
    // 同時你也不可以存取 x
    y.age = x.age + 1;
    println!(&quot;{:?}&quot;, y); // 借用者 y 可以使用 x，印出值
}
</code></pre></pre>
<ul>
<li>
<p>借用者的</p>
<p>生命週期</p>
<p>不能夠長於擁有者</p>
<ul>
<li>範例在生命週期的章節再寫</li>
</ul>
</li>
</ul>
<h2 id="also-see"><a class="header" href="#also-see">Also see</a></h2>
<ul>
<li>https://shihyu.github.io/rust_hacks/ch6/02_move_copy.html</li>
<li>https://rust-lang.tw/book-tw/ch04-01-what-is-ownership.html</li>
</ul>
<hr />
<h2 id="rust-所有權"><a class="header" href="#rust-所有權">Rust-所有權</a></h2>
<p>https://ithelp.ithome.com.tw/articles/10272643</p>
<p>所有權可以說是Rust核心概念，這讓Rust不需要垃圾回收(garbage collector)就可以保障記憶體安全。Rust的安全性和所有權的概念息息相，因此理解Rust中的所有權如何運作是非常重要的</p>
<h3 id="所有權的規則"><a class="header" href="#所有權的規則">所有權的規則</a></h3>
<ul>
<li>Rust 中每個數值都會有一個變數作為它的<strong>擁有者（owner）</strong>。</li>
<li>同時間只能有一個擁有者。</li>
<li>當擁有者離開作用域時，數值就會被丟棄。</li>
</ul>
<h3 id="變數作用域"><a class="header" href="#變數作用域"><strong>變數作用域</strong></a></h3>
<p>用下面這段程序描述變數範圍的概念</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 在宣告以前，變數s無效
    let s = &quot;hello&quot;;
    // 這裡是變數s的可用範圍
}
// 變數範圍已經結束，變數s無效
<span class="boring">}
</span></code></pre></pre>
<p>變數作用域是變數的一個屬性，其代表變數的可使用範圍，默認從宣告變數開始有效直到變數所在作用域結束。</p>
<h3 id="記憶體與分配"><a class="header" href="#記憶體與分配">記憶體與分配</a></h3>
<p>定義一個變數並賦予值，這個變數的值存在記憶體中，例如需要用戶輸入的一串字串由於長度的不確定只能存放在<code>堆(heap)上</code>，這需要記憶體分配器在執行時請求記憶體並在不需要時還給分配器</p>
<p>在擁有垃圾回收機制(garbage collector, GC)的語言中，GC會追蹤並清除不再使用的記憶體，如果沒有GC的話則需要在不使用時顯式的呼叫釋放記憶體</p>
<p>例如C語言</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{    
    char *s = strdup(&quot;hello&quot;);    
    free(s); *// 釋放s資源*
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust選擇了一個不同的道路，當變數在離開作用域時會自動釋放例如下面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s 在此開始視為有效
    // 使用 s
} // 此作用域結束，釋放s變數     
<span class="boring">}
</span></code></pre></pre>
<p>當變數離開作用域(大括號結束)時會自動呼叫特殊函示drop來釋放記憶體</p>
<h3 id="變數與資料互動的方式"><a class="header" href="#變數與資料互動的方式">變數與資料互動的方式</a></h3>
<p><strong>移動(Move)</strong></p>
<p>變數可以在Rust中以不同的方式與相同的資料進行互動</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 100;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p>這個代碼將值100綁定到變數x，然後將x的值復制並賦值給變數y現在棧(stack)中將有兩個值100。此情況中的數據是&quot;純量型別&quot;的資料，不需要存儲到堆中，<code>僅在棧(stack)中的資料的&quot;移動&quot;方式是直接複製</code>，這不會花費更長的時間或更多的存儲空間。&quot;純量型別&quot;有這些：</p>
<ul>
<li>所有整數類型，例如 i32 、 u32 、 i64 等</li>
<li>布爾類型 bool，值為true或false</li>
<li>所有浮點類型，f32和f64</li>
<li>字符類型 char</li>
<li>僅包含以上類型數據的元組(Tuples)</li>
</ul>
<p>現在來看一下非純量型別的移動</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>String物件的值&quot;hello&quot;為不固定長度長度型別所以被分配到堆(heap)</p>
<p>當s1賦值給s2，String的資料會被拷貝，不過我們拷貝是指標、長度和容量。我們不會拷貝指標指向的資料</p>
<p>前面説當變數超出作用域時，Rust自動調用釋放資源函數並清理該變數的記憶體。但是s1和s2都被釋放的話堆(heap)區中的&quot;hello&quot;被釋放兩次，這是不被系統允許的。為了確保安全，在給s2賦值時 s1已經無效了</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1; 
println!(&quot;{}, world!&quot;, s1); // 會發生錯誤 s1已經失效了
<span class="boring">}
</span></code></pre></pre>
<p><strong>克隆(clone)</strong></p>
<p>正常情況下Rust在較大資料上都會以淺拷貝的方式，當然也有提供深拷貝的method</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
println!(&quot;{} {}&quot;, s1, s2);

輸出
hello hello
<span class="boring">}
</span></code></pre></pre>
<h3 id="所有權與函式"><a class="header" href="#所有權與函式">所有權與函式</a></h3>
<p>將一個變數當作函式的參數傳給其他函式，怎樣安全的處理所有權</p>
<p>傳遞數值給函式這樣的語義和賦值給變數是類似的。傳遞變數給函式會是移動或拷貝就像賦值一樣</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // s被宣告
    let s = String::from(&quot;hello&quot;); // s進入作用域

    takes_ownership(s); // s的值被當作參數傳入函式 所以可以當作s已經被移動，從這開始已經無效

    // x被宣告
    let x = 5; // x進入作用域

    makes_copy(x); // x的值被當作參數傳入函式，但x是純量型別 i32被copy，依然有效
} // 函式結束，x無效，接著是s的值已經被移動了它不會有任何動作

fn takes_ownership(some_string: String) {
    // 一個String參數some_string傳入，有效
    println!(&quot;{}&quot;, some_string);
} // 函式結束，參數some_string佔用的記憶體被釋放

fn makes_copy(some_integer: i32) {
    // 一個i32參數some_integer傳入，有效
    println!(&quot;{}&quot;, some_integer);
} // 函式結束，參數some_integer是純量型別，沒有任何動作發生
</code></pre></pre>
<p>如果在呼叫takes_ownership之後在使用s變數在編譯時會出錯</p>
<h3 id="回傳值與作用域"><a class="header" href="#回傳值與作用域">回傳值與作用域</a></h3>
<p>回傳值轉移所有權</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership(); // gives_ownership移動它的回傳值給s1
    let s2 = String::from(&quot;哈囉&quot;); // s2進入作用域
    let s3 = takes_and_gives_back(s2); // s2移入takes_and_gives_back，該函式又將其回傳值移到s3
} // s3 在此離開作用域並釋放
  // s2 已被移走，所以沒有任何動作發生
  // s1 離開作用域並釋放

// 此函式回傳一個String
fn gives_ownership() -&gt; String {
    let some_string = String::from(&quot;hello&quot;); // some_string進入作用域

    return some_string; // 回傳some_string並移動給呼叫它的函式
}

// 此函式會取得一個String然後回傳它
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string進入作用域
    return a_string; // 回傳a_string並移動給呼叫的函式
}
</code></pre></pre>
<p>引用與借用在前面介紹<a href="https://ithelp.ithome.com.tw/articles/10269251">定義函式</a>時有介紹過了，這邊就不多講了</p>
<p>講一下迷途指標(dangling pointer)，這個在很多指標語言常發生的錯誤</p>
<p>簡單講就是用到空指標，Rust會在編譯時檢查這類型的錯誤</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangle() -&gt; &amp;String { // 回傳String的迷途引用
    let s = String::from(&quot;hello&quot;); // 宣告一個新的String
    return &amp;s // 回傳String的引用
} // s在此會離開作用域並釋放
<span class="boring">}
</span></code></pre></pre>
<p>編譯時會產生錯誤 missing lifetime specifier</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-生命週期-lifetime"><a class="header" href="#rust-生命週期-lifetime">Rust 生命週期 (Lifetime)</a></h1>
<h2 id="介紹幹話"><a class="header" href="#介紹幹話">介紹(幹話)</a></h2>
<ul>
<li>變數 從出生到死亡的時間段</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = Box::new(5); // x 出生
    println!(&quot;{:?}&quot;, x);
    {
        let y = Box::new(1); // y 出生
        println!(&quot;{:?}&quot;, y);
    } // y 死亡
    // cannot find value `y` in this scope
    // y 死掉了，所以你存取不到他
    println!(&quot;{:?}&quot;, y);
} // x 死亡
</code></pre></pre>
<h2 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow checker</a></h2>
<ul>
<li>編譯器的機制</li>
<li>會檢查借用者的生命週期會不會活的比擁有者久</li>
<li>為了避免 null pointer 發生，就是擁有者已經死了，Value 已經被銷毀了，但借用者還活著，就會存取到不存在的東西</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[allow(unused_variables, unused_assignments)]
fn main () {
    let x; // x 出生
    {
        let y = Box::new(1); // y 出生
        x = &amp;y; // x 借用 y 的所有權
        println!(&quot;{:?}&quot;, y);
    } // y 死亡
    // `y` does not live long enough
    // y 死掉了，所以 x 存取不到他 (1編譯器：可憐的 y 他活的不夠久 owo)
    println!(&quot;{:?}&quot;, x);
} // x 死亡
</code></pre></pre>
<h2 id="生命週期標示"><a class="header" href="#生命週期標示">生命週期標示</a></h2>
<ul>
<li>在名字前面加個 <code>'</code> ，就是生命週期的標示</li>
<li>以剛剛的例子來說</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    test();
}

// 生命週期標示，必須像泛型一樣，在 function 簽名中先被宣告
fn test&lt;'a, 'b&gt; () {
    let x: &amp;'a i32 = &amp;5; // 'a 開始
    println!(&quot;{:?}&quot;, x);
    {
        let y: &amp;'b i32 = &amp;2; // 'b 開始
        println!(&quot;{:?}&quot;, y);
    } // 'b 結束
} // 'a 結束
</code></pre></pre>
<ul>
<li>不必要標生命週期的情況</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
// 因為 傳入值 與 回傳值 只有一個
// 不會造成編譯器需要檢查生命週期的問題
// 所以沒有必要標示生命週期
fn life_again_gun (y: &amp;mut Person) -&gt; &amp;mut Person {
    y.age = 0;
    y
}
fn main () {
    let mut x = Person { age: 16 };
    let y = life_again_gun(&amp;mut x);
    println!(&quot;{:?}&quot;, y);
}
</code></pre></pre>
<ul>
<li>必須要標生命週期的情況</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
// missing lifetime specifier
// 因為編譯器看不出回傳的 借用者 是不是會超過 擁有者 的 lifetime
// 所以要求你編上 lifetime
fn the_older (x: &amp;Person, y: &amp;Person) -&gt; &amp;Person {
    if x.age &gt; y.age { x } else { y }
}
fn main () {
    
}
#[derive(Debug)]
struct Person {
    age: i32
}
// 我們預期這裡只會有一種生命週期
fn the_older&lt;'a&gt; (x: &amp;'a Person, y: &amp;'a Person) -&gt; &amp;'a Person {
    if x.age &gt; y.age { x } else { y }
}
fn main () {
    let x = Person { age: 16 };
    let y = Person { age: 17 };
    let res = the_older(&amp;x, &amp;y);
    println!(&quot;{:?}&quot;, res)
}
</code></pre></pre>
<ul>
<li>指定多個生命週期，並標示哪個生命週期比較長</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
// 我們有兩個生命週期 'a 與 'b，其中 'b 活的比 'a 久
fn the_older&lt;'a, 'b: 'a&gt; (x: &amp;'a Person, y: &amp;'b Person) -&gt; &amp;'a Person {
    if x.age &gt; y.age { x } else { y }
}
fn main () {
    let x = Person { age: 16 };
    let res;
    {
        let y = Person { age: 17 };
        res = the_older(&amp;x, &amp;y);
        println!(&quot;{:?}&quot;, res);
    }
}
</code></pre></pre>
<h2 id="nll-non-lexical-lifetime"><a class="header" href="#nll-non-lexical-lifetime">NLL (Non-Lexical-Lifetime)</a></h2>
<h3 id="lexical-lifetime"><a class="header" href="#lexical-lifetime">Lexical-Lifetime</a></h3>
<ul>
<li>是指說生命週期與變數的作用域是綁定在一起的</li>
<li>舉個例子</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
fn birthday (y: &amp;mut Person) {
    y.age = y.age + 1;
}
fn life_again_gun (y: &amp;mut Person) -&gt; &amp;mut Person {
    y.age = 0;
    y
}
fn main () {
    let mut x = Person { age: 16 };
    let y = life_again_gun(&amp;mut x);
    // 在 Lexical-Lifetime 的情況，y 的生命週期沒有結束
    // 所以 y 還在進行可變借用
    // 那理論上 x 就不可以再度可變出借
    // (NLL 好像已經是標準了，所以我無法實現 LL 的編譯錯誤)
    birthday(&amp;mut x);
    println!(&quot;{:?}&quot;, x);
}
</code></pre></pre>
<h3 id="non-lexical-lifetime"><a class="header" href="#non-lexical-lifetime">Non-Lexical-Lifetime</a></h3>
<ul>
<li>borrow checker 的分析結構方式從 AST 轉向 MIR
<ul>
<li>AST 是抽象語法樹，它會以樹狀的形式表現程式語言的語法結構，因為舊的 borrow checker 用 AST 做分析，所以會造成生命週期與作用域掛鉤</li>
<li>MIR 是中間表達式，他在編譯器內部會有像是流程圖的資料結構，用流程控制的方式去分析生命週期</li>
<li>只要變數在後面的程式碼中，沒有機會被使用到，就會提早被結束生命週期</li>
</ul>
</li>
<li>NLL 將作用域與生命週期拆開來看了</li>
<li>NLL 縮短了過長的生命週期 (縮減了變數的生命)，讓程式不會充滿一堆 block 去迴避 LL 造成的問題</li>
<li>舉例來說</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
fn birthday (y: &amp;mut Person) {
    y.age = y.age + 1;
}
fn life_again_gun (y: &amp;mut Person) -&gt; &amp;mut Person {
    y.age = 0;
    y
}
fn main () {
    let mut x = Person { age: 16 };
    let y = life_again_gun(&amp;mut x);
    // 在 Non-Lexical-Lifetime 的情況
    // y 在這段程式碼的後面都沒有被使用到
    // y 的生命週期就結束了
    // 那這裡就不會有問題
    birthday(&amp;mut x);
    println!(&quot;{:?}&quot;, x);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    age: i32
}
fn birthday (y: &amp;mut Person) {
    y.age = y.age + 1;
}
fn life_again_gun (y: &amp;mut Person) -&gt; &amp;mut Person {
    y.age = 0;
    y
}
fn main () {
    let mut x = Person { age: 16 };
    let y = life_again_gun(&amp;mut x);
    // cannot borrow `x` as mutable more than once at a time
    // 但如果 y 在後面有機會被使用到
    // 就代表 y 的生命週期還沒有結束
    // 所以 x 不可以再度進行可變出借
    birthday(&amp;mut x);
    y.age = 16;
    println!(&quot;{:?}&quot;, x);
}
</code></pre></pre>
<hr />
<h2 id="borrow-的存活時間"><a class="header" href="#borrow-的存活時間">Borrow 的存活時間</a></h2>
<p>出處: https://ithelp.ithome.com.tw/articles/10200106</p>
<p>Rust 有個重要的功能叫 borrow checker ，它除了檢查在上一篇提到的規則外，還檢查使用者會不會使用到懸空參照 (dangling reference) ，懸空參照是在電腦世界中一種現象： 如果你今天把一個變數借給別人，實際上借走的人只是知道我可以去哪裡找到這個別人借我的東西而已，那個東西的擁有者還是你本人，以現實世界做比喻的話，這像是借別人東西只是把放那個東西的儲物櫃位置，以及鑰匙暫時的交給別人而已，送別人東西則是直接把儲物櫃的擁有者變成他。</p>
<p>所以如果今天發生了一種情況，你把東西借給別人後，管理每個儲物櫃擁有者的系統馬上把你的使用權收回去呢？會發生什麼事，這沒人說的準，可能儲物櫃還沒被清空，你還是可以拿到借來的東西，或是馬上又換了主人，你已經不是拿到原本的東西了，就像以下的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt;&amp;i32 {
  // 這個變數在離開這個範圍後就消失了
  let a = 42;
  // 但是這邊卻回傳了 borrow
  &amp;a
}
<span class="boring">}
</span></code></pre></pre>
<p>上面這段 code 是無法編譯的。</p>
<p>為瞭解決這樣的一個問題， Rust 提出來的就是 lifetime 的觀念，只要函式的參數或回傳值有 borrow 出現，使用者就要幫 borrow 標上 lifetime ，標記後讓編譯器可以去追蹤每個變數借出去與釋放掉的情況，確保不會有釋放掉已經出借的變數的可能性。</p>
<p>Rust 使用 <code>'a</code> 一個單引號加上一個識別字當作 lifetime 的標記，所以這些都是可以的 <code>'b</code>, <code>'foo</code>, <code>'_bar</code> ，此外有兩個保留用作特殊用途的 lifetime: <code>'static</code> 和 <code>'_</code>：</p>
<ul>
<li><code>'static</code>： 這代表這是個整個程式都有效的 borrow 比如字串常數 <code>&quot;foo&quot;</code> 它的 lifetime 就是 <code>'static</code></li>
<li><code>'_</code>：這是保留給 Rust 2018 使用的，這裡先不提它的功能</li>
</ul>
<p>這邊是個加上 lifetime 標記後的範例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(a: &amp;'a i32) -&gt; &amp;'a i32 {
  a
}
<span class="boring">}
</span></code></pre></pre>
<p>其中我們必須在函式名稱後加上 <code>&lt;&gt;</code> 並在其中宣告我們的 lifetime ，接著把 borrow 的 <code>&amp;</code> 後都加上我們的 lifetime 標記，但事實上在上一篇文章中，我們完全沒用使用到 lifetime ， Rust 可以在某些情況下自動推導出正確的 lifetime ，使得實際上需要手動標註的情況並不多，最有可能遇到的情況是一個函式同時使用了兩個 borrow ：</p>
<pre><pre class="playground"><code class="language-rust">fn max&lt;'a&gt;(a: &amp;'a i32, b: &amp;'a i32) -&gt; &amp;'a i32 {
  if a &gt; b {
    a
  } else {
    b
  }
}

fn main() {
  let a = 3;
  let m = &amp;a;
  {
    let b = 2;
    let n = &amp;b;
    // 對於 max 來說， m 與 n 同時存活的這個範圍就是 'a ，
    // 而回傳值也可以在這個範圍內使用
    println!(&quot;{}&quot;, max(m, n));
  } // b 與 n 會在這邊消失
} // a 與 m 會在這邊消失
</code></pre></pre>
<p>這種情況編譯器因為看到了兩個 borrow ，於是沒辦法猜出來回傳的值應該要跟哪個 lifetime 一樣，這邊的作法就是全部都標記一樣的 lifetime ，讓 Rust 知道說我們的變數都會存活在同一個範圍內，同時回傳值也可以在同樣的範圍存活。</p>
<p>大部份的情況下編譯器都能自動的推導，所以需要手動標註的情況其實不多，通常是先嘗試讓編譯器做推導，如果編譯器報錯了才來想辦法標註。</p>
<p>lifetime 還有個用途是用來限制使用者傳入的參數必須是常數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_message(message: &amp;'static str) {
  println!(&quot;{}&quot;, message);
}
<span class="boring">}
</span></code></pre></pre>
<p>這個函式就只能接受如 <code>&quot;Hello&quot;</code> 這樣的常數了，雖說只是偶爾會有這樣的需求。</p>
<h2 id="lifetime-elision-lifetime-省略規則-進階"><a class="header" href="#lifetime-elision-lifetime-省略規則-進階">Lifetime Elision (Lifetime 省略規則) (進階)</a></h2>
<p>這部份大概的瞭解一下就好了</p>
<ol>
<li>所有的 borrow 都會自動的分配一個 lifetime</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: &amp;i32, b: &amp;i32);
fn foo&lt;'a, 'b&gt;(a: &amp;'a i32, b: &amp;'b i32); // 推導結果
<span class="boring">}
</span></code></pre></pre>
<ol>
<li><strong>如果函式只有一個 borrow 的參數，則它的 lifetime 會自動被應用到回傳值上</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: &amp;i32);
fn foo&lt;'a&gt;(a: &amp;'a i32) -&gt; &amp;'a i32; // 推導結果
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>如果有多個 borrow ，但其中一個是 <code>self</code> ，則 <code>self</code> 的 lifetime 會被應用在回傳值</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
  fn method(&amp;self, a: &amp;i32) -&gt; &amp;Self {
  }
}

// 推導結果
impl Foo {
  fn method&lt;'a, 'b&gt;(&amp;'a self, b: &amp;'b i32) -&gt; &amp;'a Self {
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>若不符合上面任一條規則，則必須要標註型態。</p>
<p>如果我們把以上的規則套用在上面的範例 <code>max</code> 上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: &amp;i32, b: &amp;i32) -&gt; &amp;i32 {
  if a &gt; b {
    a
  } else {
    b
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>套用規則 1 ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;'a, 'b&gt;(a: &amp;'a, i32, b: &amp;'b i32) -&gt; &amp;i32 {
  if a &gt; b {
    a
  } else {
    b
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>到這邊結束，編譯器已經沒有可用的規則了，但是回傳值的 lifetime 依然是未知，於是就編譯失敗。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-型別系統"><a class="header" href="#rust-型別系統">Rust 型別系統</a></h1>
<ul>
<li>Rust 型別系統
<ul>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E5%9E%8B%E5%88%A5%E5%A4%A7%E5%B0%8F">型別大小</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E6%B3%9B%E5%9E%8B">泛型</a></li>
<li>trait 用法
<ul>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E5%AE%A3%E5%91%8A-interface">宣告 interface</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E7%94%A8-trait-%E5%B0%8D%E6%B3%9B%E5%9E%8B%E5%81%9A%E9%99%90%E5%AE%9A-trait-Bound">用 trait 對泛型做限定 (trait Bound)</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E5%AE%A3%E5%91%8A%E6%8A%BD%E8%B1%A1%E5%9E%8B%E5%88%A5-Abstract-Type">宣告抽象型別 (Abstract Type)</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E5%8B%95%E6%85%8B%E5%88%86%E9%85%8D%E8%88%87%E9%9D%9C%E6%85%8B%E5%88%86%E9%85%8D%E7%9A%84%E6%AF%94%E8%BC%83">動態分配與靜態分配的比較</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#impl-Trait">impl Trait</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E6%A8%99%E7%B1%96">標籖</a></li>
</ul>
</li>
</ul>
</li>
<li>類型轉換
<ul>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#Deref">Deref</a></li>
<li>as 運算符號
<ul>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E9%A1%9E%E5%9E%8B%E8%BD%89%E6%8F%9B%EF%BC%88%E5%90%AB%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%EF%BC%89">類型轉換（含生命週期）</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E9%99%90%E5%AE%9A%E7%94%A8%E6%B3%95">限定用法</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#From%E8%88%87Into">From與Into</a></li>
</ul>
</li>
</ul>
</li>
<li>Trait系統的不足
<ul>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E5%AD%A4%E5%85%92%E5%8E%9F%E5%89%87">孤兒原則</a></li>
<li><a href="https://hackmd.io/@ballfish/H14LFb6hU#%E7%A8%8B%E5%BC%8F%E8%A4%87%E7%94%A8%E7%8E%87%E4%B8%8D%E9%AB%98">程式複用率不高</a></li>
</ul>
</li>
</ul>
<h2 id="型別大小"><a class="header" href="#型別大小">型別大小</a></h2>
<ul>
<li>Sized Tyep
<ul>
<li>大部分的類型都是 Sized Type，就是可以在編譯時期就知道大小的</li>
<li>例如：u32, i64</li>
</ul>
</li>
<li>Dynamic Sized Type
<ul>
<li>無法在編譯時期知道大小的型別則叫作「DST (Dynamic Sized Type)」</li>
<li>例如：[T], Box</li>
<li><img src="rust/images/w9TQhgu.jpg" alt="img" /></li>
</ul>
</li>
<li>Zero Sized Type
<ul>
<li>另外還有一種類型叫「ZST (Zero Sized Type)」，在執行時期，不佔用空間大小的型別</li>
<li>你可以用 ZST 來做一些反覆運算，Rust 編譯器有對 ZST 做最佳化</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v: Vec&lt;()&gt; = vec![(); 10];
    // 像是你可以這樣寫
    for _i in v {
        println!(&quot;{:?}&quot;, 1);
    }
    
    // 雖然你有更簡單的寫法
    for _i in 1..10 {
        println!(&quot;{:?}&quot;, 1);
    }
}
</code></pre></pre>
<ul>
<li>Bottom Type
<ul>
<li>只的是 never 類型</li>
<li>程式碼中用 <code>!</code> 表示</li>
<li>特點
<ul>
<li>沒有值</li>
<li>是任意類型的子類型</li>
</ul>
</li>
<li>Bottom Type 的用處
<ul>
<li>Diverging Function (發散函數)</li>
<li>loop 迴圈</li>
<li>空列舉 <code>enum Void{}</code></li>
</ul>
</li>
<li>ex:</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn print_meow_forever () -&gt; ! {
    loop { println!(&quot;meow&quot;); }
}

fn main () {
    let i = if false {
        print_meow_forever();
    } else {
        100
    };
    println!(&quot;{}&quot;, i);
}
</code></pre></pre>
<ul>
<li>
<pre><code>turbofish
</code></pre>
<p>運算子</p>
<ul>
<li>用來做顯示的型別宣告
ex:</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = &quot;1&quot;;
    println!(&quot;{}&quot;, x.parse::&lt;i32&gt;().unwrap());
}
</code></pre></pre>
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<ul>
<li>用這樣的語法<code>&lt;T&gt;</code>宣告泛型
ex:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; { x: T, y: T } 
<span class="boring">}
</span></code></pre></pre>
<h2 id="trait-用法"><a class="header" href="#trait-用法">trait 用法</a></h2>
<h3 id="宣告-interface"><a class="header" href="#宣告-interface">宣告 interface</a></h3>
<ul>
<li>interface 裡可以定義 function 或 type</li>
<li>interface 裡不能實作另一個 interface，但 interface 之間可以繼承</li>
<li>使用 <code>impl</code> 實作 interface</li>
<li>使用 <code>trait</code> 宣告 interface</li>
<li>孤兒原則 (Orphan Rule)
<ul>
<li>要實現某個 trait，這個 trait 必須要在當前的 crate 中被定義</li>
<li>用來避免標準函式庫，或在其他地方被定義好的 trait 被修改到，而難以追查</li>
</ul>
</li>
</ul>
<p>實作自己的 Add:</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;RHS, Output&gt; {
    fn my_add (self, rhs: RHS) -&gt; Output;
}

impl Add&lt;i32, i32&gt; for i32 {
    fn my_add (self, rhs: i32) -&gt; i32 {
        self + rhs
    }
}

impl Add&lt;u32, i32&gt; for u32 {
    fn my_add (self, rhs: u32) -&gt; i32 {
        (self + rhs) as i32
    }
}

fn main () {
    let (a, b, c, d) = (1i32, 2i32, 3u32, 4u32);
    let x: i32 = a.my_add(b);
    let y: i32 = c.my_add(d);
    println!(&quot;{}&quot;, x);
    println!(&quot;{}&quot;, y);
}
</code></pre></pre>
<p>標準函式庫裡的 Add trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;RHS = Self&gt; {
    type Output;
    fn add (self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>標準函式庫 u32 的加法實作</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add for u32 {
    type Output = u32;
    fn add (self, rhs: u32) -&gt; u32 { self + rhs }
}
<span class="boring">}
</span></code></pre></pre>
<p>標準函式庫 String 的加法實作</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add for String {
    type Output = String;
    fn add (mut self, rhs: &amp;str) -&gt; String {
        self.push_str(rhs);
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>trait 裡的 function 可以有一個 default 的實作</p>
<pre><pre class="playground"><code class="language-rust">trait Top {
    fn wear_top (&amp;mut self, _clothes: String) {
        println!(&quot;Default: coat&quot;);
    }
}

trait Bottom {
    fn wear_bottom (&amp;mut self, _clothes: String) {
        println!(&quot;Default: pants&quot;);
    } 
}

struct PersonLikeCoat {
    top: String,
    bottom: String,
}

impl Top for PersonLikeCoat {}

impl Bottom for PersonLikeCoat {
    fn wear_bottom (&amp;mut self, clothes: String) {
        self.bottom = clothes;
        println!(&quot;Changed: {}&quot;, self.bottom);
    }
}

fn main () {
    let mut ballfish = PersonLikeCoat { top: String::from(&quot;coat&quot;), bottom: String::from(&quot;pants&quot;) };
    ballfish.wear_top(String::from(&quot;sweater&quot;));
    ballfish.wear_bottom(String::from(&quot;skirt&quot;));
}
</code></pre></pre>
<p>trait 的繼承</p>
<pre><pre class="playground"><code class="language-rust">trait Top {
    fn wear_top (&amp;mut self, _clothes: String) {
        println!(&quot;Default: coat&quot;);
    }
}

trait Bottom {
    fn wear_bottom (&amp;mut self, _clothes: String) {
        println!(&quot;Default: pants&quot;);
    } 
}

struct Person {
    top: String,
    bottom: String,
}

impl Top for Person {}

impl Bottom for Person {
    fn wear_bottom (&amp;mut self, clothes: String) {
        self.bottom = clothes;
        println!(&quot;Changed: {}&quot;, self.bottom);
    }
}

trait WholeBody: Top + Bottom {
    fn wear_whole_body (&amp;mut self, top: String, bottom: String) {
        self.wear_top(top);
        self.wear_bottom(bottom);
    }
}

impl WholeBody for Person {}

fn main () {
    let mut ballfish = Person { top: String::from(&quot;coat&quot;), bottom: String::from(&quot;pants&quot;) };
    ballfish.wear_whole_body(String::from(&quot;sweater&quot;), String::from(&quot;skirt&quot;));
}
</code></pre></pre>
<h3 id="用-trait-對泛型做限定-trait-bound"><a class="header" href="#用-trait-對泛型做限定-trait-bound">用 trait 對泛型做限定 (trait Bound)</a></h3>
<ul>
<li><img src="rust/images/aAD2Hsm.jpg" alt="img" /></li>
</ul>
<p>語法 <code>fn generic&lt;T: FirstTrait + SecondTrait&gt;(t: T) {}</code>
或 <code>fn generice&lt;T&gt; (t: T) where T: FirstTrait + SecondTrait {}</code></p>
<p>ex:</p>
<pre><pre class="playground"><code class="language-rust">trait Top {
    fn wear_top (&amp;mut self, _clothes: String) {
        println!(&quot;Default: coat&quot;);
    }
}

trait Bottom {
    fn wear_bottom (&amp;mut self, _clothes: String) {
        println!(&quot;Default: pants&quot;);
    } 
}

struct Person {
    top: String,
    bottom: String,
}

impl Top for Person {}

impl Bottom for Person {
    fn wear_bottom (&amp;mut self, clothes: String) {
        self.bottom = clothes;
        println!(&quot;Changed: {}&quot;, self.bottom);
    }
}

fn go_routin1&lt;P: Top + Bottom&gt; (p: &amp;mut P) {
    p.wear_top(String::from(&quot;sweater&quot;));
    p.wear_bottom(String::from(&quot;skirt&quot;));
}

fn go_routin2&lt;P&gt; (p: &amp;mut P) where P: Top + Bottom {
    p.wear_top(String::from(&quot;sweater&quot;));
    p.wear_bottom(String::from(&quot;skirt&quot;));
}

fn main () {
    let mut ballfish = Person { top: String::from(&quot;coat&quot;), bottom: String::from(&quot;pants&quot;) };
    go_routin1::&lt;Person&gt;(&amp;mut ballfish); // ::&lt;Person&gt; 可省
    go_routin2::&lt;Person&gt;(&amp;mut ballfish); // ::&lt;Person&gt; 可省
}
</code></pre></pre>
<h3 id="宣告抽象型別-abstract-type"><a class="header" href="#宣告抽象型別-abstract-type">宣告抽象型別 (Abstract Type)</a></h3>
<ul>
<li>Abstract Type 是無法產生實體的型別</li>
<li>rust 有兩種方式處理抽象型別：trait Object、impl Trait</li>
<li>trait Object
<ul>
<li>將 trait 當作一種型別使用</li>
<li>與 trait bound 有點像，但 trait bound 是靜態分配，而 trait Object 是動態分配</li>
<li>trait Object 在編譯時期無法知道其記憶體大小，所以他本身是一種指標</li>
</ul>
</li>
</ul>
<p><img src="rust/images/w9TQhgu.jpg" alt="img" /></p>
<pre><code>pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
</code></pre>
<ul>
<li>
<p>上面的 struct 來自標準函式庫，但不是真的 trait 物件</p>
</li>
<li>
<p>data指標指向trait物件儲存的類型資料T</p>
</li>
<li>
<p>vtable指標指向包含為T實作的virtual table (虛表）</p>
</li>
<li>
<p>虛表本身是一種struct，包含解構函數、大小、方法等</p>
</li>
<li>
<p>編譯器只知道trait object的指標，但不知道要呼叫哪個方法</p>
</li>
<li>
<p>運行期， 會從虛表中查出正確的指標• 再進行動態呼叫</p>
</li>
<li>
<p>Trait物件的限制</p>
<ul>
<li>Trait的Self有一個隱式的trait bound <code>?Sized</code>如<code>&lt;Self: ?Sized&gt;</code>，包含所有可確定大小的類型，也就是<code>&lt;T: Sized&gt;</code></li>
<li>但trait物件的Self不能被限定是Sized，因為trait物件一定是動態分配，所以不可能滿足Sized的條件</li>
<li>但Trait物件在運行期進行動態分發時必須確定大小，否則無法為其正確分配記憶體空間</li>
<li>因此trait中的方法必定是物件安全，物件安全即為必受到<code>Self: Sized</code>的約束，且為沒有額外Self類型參數的非泛型方法</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 物件不安全的 trait
trait Foo {
    fn bad&lt;T&gt; (&amp;self, x: T);
    fn new() -&gt; Self;
}

// 方法一：將不安全的部份拆出去
trait Bar {
    fn bad&lt;T&gt; (&amp;self, x: T);
}
trait Foo: Bar {
    fn new() -&gt; Self;
}

// 方法二：使用 where
trait Foo {
    fn bad&lt;T&gt;(&amp;self, x: T);
    fn new() -&gt; Self where self: Sized; // 但這個 trait 作為物件時， new 會無法被呼叫
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="動態分配與靜態分配的比較"><a class="header" href="#動態分配與靜態分配的比較">動態分配與靜態分配的比較</a></h3>
<pre><pre class="playground"><code class="language-rust">trait Top {
    fn wear_top (&amp;mut self, _clothes: String) {
        println!(&quot;Default: coat&quot;);
    }
}

trait Bottom {
    fn wear_bottom (&amp;mut self, _clothes: String) {
        println!(&quot;Default: pants&quot;);
    } 
}

struct Person {
    top: String,
    bottom: String,
}

impl Top for Person {}

impl Bottom for Person {
    fn wear_bottom (&amp;mut self, clothes: String) {
        self.bottom = clothes;
        println!(&quot;Changed: {}&quot;, self.bottom);
    }
}

trait WholeBody: Top + Bottom {
    fn wear_whole_body (&amp;mut self, top: String, bottom: String) {
        self.wear_top(top);
        self.wear_bottom(bottom);
    }
}

impl WholeBody for Person {}

fn static_dispatch&lt;P: WholeBody&gt; (p: &amp;mut P) {
    p.wear_top(String::from(&quot;sweater&quot;));
    p.wear_bottom(String::from(&quot;skirt&quot;));
}

fn dynamic_dispatch (p: &amp;mut WholeBody) {
    p.wear_top(String::from(&quot;sweater&quot;));
    p.wear_bottom(String::from(&quot;skirt&quot;));
}

fn main () {
    let mut ballfish = Person { top: String::from(&quot;coat&quot;), bottom: String::from(&quot;pants&quot;) };
    static_dispatch::&lt;Person&gt;(&amp;mut ballfish); // ::&lt;Person&gt; 可省
    dynamic_dispatch(&amp;mut ballfish);
}
</code></pre></pre>
<h3 id="impl-trait"><a class="header" href="#impl-trait">impl Trait</a></h3>
<ul>
<li>是靜態分配的抽象類型</li>
</ul>
<pre><pre class="playground"><code class="language-rust">trait Fly {
    fn fly(&amp;self) -&gt; bool;
}

struct Duck;

impl Fly for Duck {
    fn fly(&amp;self) -&gt; bool {
        return true;
    }
}

fn fly_static (s: impl Fly) -&gt; bool {
    s.fly()
}

fn can_fly (s: impl Fly) -&gt; impl Fly {
    if s.fly() {
        println!(&quot;fly!&quot;);
    } else {
        println!(&quot;fell!&quot;)
    }
    s // return s
}

fn main () {
    let duck = can_fly(Duck);
}
</code></pre></pre>
<ul>
<li>雖然這個語法很有趣，但有些情況編譯器會誤判，例如下面的例子，<code>a</code> 跟 <code>b</code>，被編譯器認定為不同的 type，所以 <code>sum</code> 會報錯</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;
fn sum&lt;T&gt;(a: impl Add&lt;Output=T&gt;, b: impl Add&lt;Output=T&gt;) -&gt; T {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>與靜態分配型態相對的是 <code>dyn Trait</code> 動態分配的型態</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dyn_can_fly (s: impl Fly+'static) -&gt; Box&lt;dyn Fly&gt; {
    if s.fly() {
        println!(&quot;fly!&quot;);
    } else {
        println!(&quot;fell!&quot;);
    }
    Box::new(s)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="標籖"><a class="header" href="#標籖">標籖</a></h3>
<ul>
<li>
<p>Rust一共提供5個常用的標籖• 被定義在 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::marker
<span class="boring">}
</span></code></pre></pre>
<p>裡e</p>
<ul>
<li><code>Sized</code> 用來標識編譯期可確定大小的類型，大部份類型都預設定義實作 Sized</li>
<li><code>Unsize</code> 用來標識動態大小類型</li>
<li><code>Copy</code> 用來標識可安全按位複製類型</li>
<li><code>Send</code> 用來標識可跨執行緒安全傳遞值的類型，也就是可以跨執行緒傳遞所有權</li>
<li><code>Sync</code> 用來標識可在執行緒間安全共用參考的類型</li>
</ul>
</li>
<li>
<p>標籤類 trait，都是用下面這種寫法標示他的標籤性質</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[lang = &quot;sized&quot;] // lang 表示 Sized trait 供 Rust 語言本身使用
pub trait Sized {} // 此程式為空，無實作方法
<span class="boring">}
</span></code></pre></pre>
<h1 id="類型轉換"><a class="header" href="#類型轉換">類型轉換</a></h1>
<h2 id="deref"><a class="header" href="#deref">Deref</a></h2>
<ul>
<li>參考使用<code>&amp;</code></li>
<li>設定值使用<code>*</code></li>
<li>可以實作Deref的trait來自訂設定值的操作</li>
<li>Deref是強制轉型的，如果某個類型<code>T</code>實作<code>Deref&lt;Target=U&gt;</code>，則使用<code>T</code>的參考時，參考會被轉型成<code>U</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn foo (s: &amp;[i32]) {
    println!(&quot;{:?}&quot;, s[0]);
}

fn main () {
    let a = &quot;hello&quot;.to_string();
    let b = &quot; world&quot;.to_string();
    // b 被自動 deref
    let c = a + &amp;b;
    println!(&quot;{:?}&quot;, c);

    /// &amp;Vec&lt;T&gt; -&gt; &amp;[T]
    let v = vec![1, 2, 3];
    foo(&amp;v);

    let x = Rc::new(&quot;hello&quot;);
    let y = x.clone(); // Rc&lt;&amp;str&gt;
    // 如果想要呼叫 &amp;str 的 clone，必須要自己 deref
    let z = (*x).clone(); // &amp;str
}
</code></pre></pre>
<h2 id="as-運算符號"><a class="header" href="#as-運算符號">as 運算符號</a></h2>
<h3 id="類型轉換含生命週期"><a class="header" href="#類型轉換含生命週期">類型轉換（含生命週期）</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let a = 1u32;
    let b = a as u64;
    println!(&quot;{:?}&quot;, a);
    println!(&quot;{:?}&quot;, b);
    let c = std::u32::MAX;
    let d = c as u16;
    println!(&quot;{:?}&quot;, c);
    println!(&quot;{:?}&quot;, d);
    let e = -1i32;
    let f = e as u32;
    println!(&quot;{:?}&quot;, e);
    println!(&quot;{:?}&quot;, f);
    let a: &amp;'static str = &quot;hello&quot;; // &amp;'static str
    let b: &amp;str = a as &amp;str;
    let c: &amp;'static str = b as &amp;'static str;
}
</code></pre></pre>
<h3 id="限定用法"><a class="header" href="#限定用法">限定用法</a></h3>
<pre><pre class="playground"><code class="language-rust">struct S(i32);
trait A {
    fn test(&amp;self, i: i32);
}

trait B {
    fn test(&amp;self, i: i32);
}

impl A for S {
    fn test(&amp;self, i: i32) {
        println!(&quot;From A: {:?}&quot;, i);
    }
}

impl B for S {
    fn test(&amp;self, i: i32) {
        println!(&quot;From B: {:?}&quot;, i)
    }
}

fn main () {
    let s = S(1);
    A::test(&amp;s, 2);
    B::test(&amp;s, 3);
    &lt;S as A&gt;::test(&amp;s, 4);
    &lt;S as B&gt;::test(&amp;s, 5);
}
</code></pre></pre>
<h3 id="from與into"><a class="header" href="#from與into">From與Into</a></h3>
<ul>
<li>定義於<code>std::convert</code></li>
<li>互為反向操作</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person { name: String }
impl Person {
    fn new&lt;T: Into&lt;String&gt;&gt;(name: T) -&gt; Person {
        Person { name: name.into() }
    }
}

fn main () {
    let person = Person::new(&quot;Alex&quot;);
    let person = Person::new(&quot;Alex&quot;.to_string());
    println!(&quot;{:?}&quot;, person);

    // String from 的方法
    let to_string = &quot;hello&quot;.to_string();
    let from_string = String::from(&quot;hello&quot;);
    assert_eq!(to_string, from_string);

    // 如果 U 實現了 From&lt;T&gt;，則 T 類型的實例，都可以呼叫 into 方法轉換為 U
    let a = &quot;hello&quot;;
    let b: String = a.into();
    // 所以一般情況只要實作 From 即可，除非 From 很難實作，才需要實作 Into
}
</code></pre></pre>
<h1 id="trait系統的不足"><a class="header" href="#trait系統的不足">Trait系統的不足</a></h1>
<h2 id="孤兒原則"><a class="header" href="#孤兒原則">孤兒原則</a></h2>
<ul>
<li><a href="https://www.notion.so/Rust-e160ff83074d4a6585e4281297687a34">孤兒原則解說</a></li>
<li>若下游程式想要使用擴充某些 crate，就必須包裝成新的 type，以迴避孤兒原則</li>
<li>而對一些本地端的類型，在被 Option，或是 Rc 等 interface 包裝後，就會被認定為非本地端類型，擴充時就會發生問題</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;
#[derive(PartialEq)]
struct Int(i32);
impl Add&lt;i32&gt; for Int {
    type Output = i32;
    fn add (self, other: i32) -&gt; Self::Output {
        (self.0) + other
    }
}

impl Add&lt;i32&gt; for Option&lt;Int&gt; {} // (X)

// 因為 Rust 裡 Box 有 #[fundamental] 標籤
impl Add&lt;i32&gt; for Box&lt;Int&gt; {
    type Output = i32;
    fn add (self, other: i32) -&gt; Self::Output {
        (self.0) + other
    }
}

fn main () {
    assert_eq!(Int(3) + 3, 6);
    assert_eq!(Box::new(Int(3)) + 3, 6);
}
</code></pre></pre>
<h2 id="程式複用率不高"><a class="header" href="#程式複用率不高">程式複用率不高</a></h2>
<ul>
<li>
<p>重複原則</p>
<ul>
<li>規定不可以為重疊的類型實作同一個 trait</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; AnyTrait for T {}
impl&lt;T&gt; AnyTrait for T where T: Copy {}
impl&lt;T&gt; AnyTrait for i32 {}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  效能問題
// 這裡實作了 += 的對應方法
impl&lt;R, T: Add&lt;R&gt; + Clone&gt; AddAssign&lt;R&gt; for T {
    fn add_assign(&amp;mut self, rhs: R) {
        // clone 會造成效能的負擔，有些類型不需要用 clone 這個方法
        // 但因為重複原則，無法限縮實作對象，所以為了效能，很多作法是位每個類型實作 trait
        // 造成程式複用度不高
        let tmp = self.clone() + rhs;
        *self = tmp;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="join-with-dataframe"><a class="header" href="#join-with-dataframe">join with Dataframe</a></h2>
<pre><pre class="playground"><code class="language-rust">use polars::df;
use polars::prelude::*;

fn join_test() -&gt; Result&lt;DataFrame, PolarsError&gt; {
    let df1: DataFrame = df!(&quot;Wavelength (nm)&quot; =&gt; &amp;[480.0, 650.0, 577.0, 1201.0, 100.0])?;
    let df2: DataFrame = df!(&quot;Color&quot; =&gt; &amp;[&quot;Blue&quot;, &quot;Yellow&quot;, &quot;Red&quot;],
                         &quot;Wavelength nm&quot; =&gt; &amp;[480.0, 577.0, 650.0])?;

    let df3: DataFrame = df1.left_join(&amp;df2, [&quot;Wavelength (nm)&quot;], [&quot;Wavelength nm&quot;])?;
    // println!(&quot;{:?}&quot;, df3);
    Ok(df3)
}

fn main() {
    let df = join_test();
    println!(&quot;{:#?}&quot;, df)
    // match join_test() {
    //     Ok(df) =&gt; println!(&quot;DataFrame: {:#?}&quot;, df),
    //     Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    // }
}
</code></pre></pre>
<pre><code class="language-toml">[package]
name = &quot;polars_test&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
polars = { version = &quot;0.27.2&quot;, features = [&quot;json&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-c-dynamic-library-in-rust"><a class="header" href="#call-c-dynamic-library-in-rust">Call C dynamic library in rust</a></h1>
<h2 id="前言-1"><a class="header" href="#前言-1">前言</a></h2>
<p>c語言作為系統編程語言統治bit世界已經很久，留下了大量的代碼遺產。rust作為新興語言在一些冷門領域開發，真是裹足前行。rust如果可以調用c，那真是再好不過。</p>
<h2 id="一初始化rust工程"><a class="header" href="#一初始化rust工程">一、初始化rust工程</a></h2>
<p>如果是vim寫代碼的用戶，可以直接使用，如果是ide，自行創建工程。</p>
<pre><code class="language-bash">cargo new --bin test_rust_call_c
</code></pre>
<h2 id="二生成一個c動態庫"><a class="header" href="#二生成一個c動態庫">二、生成一個c動態庫</a></h2>
<p>如果瞭解在c裡面生成動態庫的流程可不看，這個使用簡單的add函數(返回兩個入參的和)，演示流程，至於更多的類型轉化可看官方文檔。</p>
<h3 id="1addh"><a class="header" href="#1addh">1.<code>add.h</code></a></h3>
<pre><code class="language-c">#ifndef _ADD_H
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
int add(int a, int b);
#ifdef __cplusplus
}
#endif
#endif
</code></pre>
<h3 id="2addc"><a class="header" href="#2addc">2.<code>add.c</code></a></h3>
<pre><code class="language-c">#include &quot;add.h&quot;
int add(int a, int b) {
    return a + b;
}
</code></pre>
<h3 id="3addso"><a class="header" href="#3addso">3.<code>add.so</code></a></h3>
<pre><code class="language-bash">gcc -fPIC -shared add.c -o libadd.so
</code></pre>
<h2 id="三在rust裡面調用動態庫"><a class="header" href="#三在rust裡面調用動態庫">三、在rust裡面調用動態庫</a></h2>
<h3 id="1mainrs內容"><a class="header" href="#1mainrs內容">1.<code>main.rs</code>內容</a></h3>
<p>現在開始在rust調用c。這裡需要告訴rust編譯器，c函數原型，使用 extern &quot;C&quot; 包裹下。 使用c函數的地方必須用unsafe塊包裹，默認編譯器使用很嚴格的檢查標準，加上unsafe塊編譯器會把檢查權利讓給開發人員自己。</p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn add(a: i32, b: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;{}&quot;, add(1, 2));
    }
}
</code></pre></pre>
<h3 id="2編譯"><a class="header" href="#2編譯">2.編譯</a></h3>
<p>這裡面要告訴rust編譯器要鏈接的動態庫是誰，-l add 會自動補齊然後找libadd.so的文件。-L path。下面的例子是在當前目錄下面找。</p>
<pre><code class="language-bash">rustc src/main.rs -l add -L .
</code></pre>
<h3 id="3運行"><a class="header" href="#3運行">3.運行</a></h3>
<p>運行時也要通過LD_LIBRARY_PATH告知動態庫的位置。剩下的就是運行。</p>
<pre><code class="language-bash">env LD_LIBRARY_PATH=. ./main
</code></pre>
<h2 id="四優化工程更符合rust的方式"><a class="header" href="#四優化工程更符合rust的方式">四、優化工程，更符合rust的方式</a></h2>
<h3 id="使用buildrs編譯和三2同樣的效果"><a class="header" href="#使用buildrs編譯和三2同樣的效果">使用<code>build.rs</code>編譯，和<code>三、2</code>同樣的效果</a></h3>
<p>這裡對上面的編譯方式做些優化，在rust裡面一般是編寫build.rs，生成依賴，以後在生成protobuf或者grpc代碼還可以看到類似套路。</p>
<pre><pre class="playground"><code class="language-rust">// build.rs rust的編譯腳本
fn main() {
    println!(&quot;cargo:rustc-link-search=.&quot;); // 等於rustc -L .
    println!(&quot;cargo:rustc-link-lib=dylib=add&quot;); // 等於rustc -ladd
}
</code></pre></pre>
<h2 id="參考資料-2"><a class="header" href="#參考資料-2">參考資料</a></h2>
<p>https://doc.rust-lang.org/cargo/reference/build-scripts.html</p>
<p>https://zhuanlan.zhihu.com/p/70095462</p>
<p>http://liufuyang.github.io/2020/02/02/call-c-in-rust.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="給-c-使用者的-rust-簡介"><a class="header" href="#給-c-使用者的-rust-簡介">給 C++ 使用者的 Rust 簡介</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> 是最近受到廣泛注目的新語言。最早由 Mozilla 資助開發，後來因為 Dropbox 使用 Rust 改寫檔案系統服務[<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn1">1]</a>而聲明大噪。目前 Rust 是很活躍的開源專案，有超過一千名開發者共同開發，大約一至兩個月就會有一次 minor release。</p>
<p>設計程式語言最困難的地方在於選擇，沒有一個語言是上山下海無所不能的，而 Rust 也不例外。Rust 的目標是成為高效率、易於平行運算的系統程式語言，因此它選擇了以下的特性：</p>
<ul>
<li>靜態型別 (static-typed)</li>
<li>區分 mutable 與 immutable，所有變數預設為 immutable，盡可能減少 mutable state</li>
<li>使用 tagged union 與 pattern matching</li>
<li>不使用動態垃圾回收 (garbage collection)，而使用靜態的 RAII</li>
<li>使用 Move semantics 避免複製物件</li>
<li>使用 borrow checker 確保 memory safety 與 thread safety</li>
</ul>
<p>因此，對於習慣主流程式語言的使用者來說，Rust 的學習曲線非常陡峭，光是要讓程式碼通過編譯就要花上不少時間。接下來這一系列的文章，是以 C++ 使用者為對象，介紹 Rust 的各種語言功能以及背後的設計目標，希望各位可以看得很愉快。</p>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello World</a></h2>
<p>先從每個語言都會有的 hello world 開始吧：</p>
<pre><pre class="playground"><code class="language-rust">// hello.rs
fn main() {
    println!(&quot;hello world&quot;);
}
</code></pre></pre>
<p>編譯與執行方法如下：</p>
<pre><code>$ rustc -o hello hello.rs
$ ./hello
hello world
</code></pre>
<p>從這個最簡單的範例可以看出與 C++ 相同的地方：</p>
<ul>
<li>註解也是 <code>//</code>，你也可以用 <code>/* */</code> 寫多行註解。</li>
<li>程式也是以 <code>main</code> 為進入點。</li>
<li>函式也同樣用大括號包起整個結構，每行敘述使用 <code>;</code> 作為結尾。</li>
</ul>
<p>不一樣的地方則是：</p>
<ul>
<li>沒有 <code>#include</code>。</li>
<li>需要用 <code>fn</code> 關鍵字來定義函式。</li>
<li><code>main</code> 沒有回傳值。</li>
<li><code>println!</code> 函式名稱多了一個驚嘆號。</li>
</ul>
<p><code>rustc</code> 會自動幫你引入一部份的標準函式庫 (std::prelude)，因此你不需要為了印一行字額外引入函式庫。另外 <code>println</code> 後面的驚嘆號代表它其實不是函式，而是巨集 (macro)。由於本文重點不在巨集，因此我們只要先知道 <code>println!</code> 可以拿來當 <code>printf</code> 那樣用就可以了。</p>
<h2 id="型別與變數"><a class="header" href="#型別與變數">型別與變數</a></h2>
<p>宣告變數的方法是使用 <code>let</code> 關鍵字：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 10;
    let y: f32 = 3.14;
    println!(&quot;x = {}, y = {}&quot;, x, y); // x = 10, y = 3.14
}
</code></pre></pre>
<p>Rust 會自動推導型別，因此 <code>x</code> 的型別是 <code>i32</code>，意指 32bit signed integer。你也可以在變數名稱後加上冒號來指定型別，因此 <code>y</code> 的型別是 32bit floating point，而不是 floating point literal 預設的 <code>f64</code>。</p>
<p>Rust 的內建型別及對應的 C++ 型別如下：</p>
<table><thead><tr><th style="text-align: left">Rust type</th><th style="text-align: left">C++ type</th><th style="text-align: left">說明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>bool</code></td><td style="text-align: left"><code>bool</code></td><td style="text-align: left">布林值</td></tr>
<tr><td style="text-align: left"><code>i8</code></td><td style="text-align: left"><code>int8_t</code></td><td style="text-align: left">8-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u8</code></td><td style="text-align: left"><code>uint8_t</code></td><td style="text-align: left">8-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>i16</code></td><td style="text-align: left"><code>int16_t</code></td><td style="text-align: left">16-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u16</code></td><td style="text-align: left"><code>uint16_t</code></td><td style="text-align: left">16-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>i32</code></td><td style="text-align: left"><code>int32_t</code></td><td style="text-align: left">32-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u32</code></td><td style="text-align: left"><code>uint32_t</code></td><td style="text-align: left">32-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>i64</code></td><td style="text-align: left"><code>int64_t</code></td><td style="text-align: left">64-bit 有號整數，使用二補數表示負值</td></tr>
<tr><td style="text-align: left"><code>u64</code></td><td style="text-align: left"><code>uint64_t</code></td><td style="text-align: left">64-bit 無號整數</td></tr>
<tr><td style="text-align: left"><code>usize</code></td><td style="text-align: left"><code>size_t</code></td><td style="text-align: left">可表達記憶體空間內最大物件大小的無號整數型別，常用來表示 array index</td></tr>
<tr><td style="text-align: left"><code>isize</code></td><td style="text-align: left"><code>ptrdiff_t</code></td><td style="text-align: left">上述型別的有號版本，可用來表達兩個 array index 的差異</td></tr>
<tr><td style="text-align: left"><code>f32</code></td><td style="text-align: left"><code>float</code> [<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn2">2]</a></td><td style="text-align: left">IEEE754 規範的 32-bit 浮點數</td></tr>
<tr><td style="text-align: left"><code>f64</code></td><td style="text-align: left"><code>double</code> [<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn2">2]</a></td><td style="text-align: left">IEEE754 規範的 64-bit 浮點數</td></tr>
<tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>char32_t</code> [<a href="https://electronic.blue/blog/2016/10/10-rust-an-introduction/#fn3">3]</a></td><td style="text-align: left">使用 UTF-32 表達的 Unicode 字元</td></tr>
</tbody></table>
<h2 id="mutable--immutable"><a class="header" href="#mutable--immutable">Mutable &amp; Immutable</a></h2>
<p>雖然講起來很矛盾，但預設情況下變數是不可變的 (immutable)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
x = x + 1; // error: re-assignment of immutable variable `x`
<span class="boring">}
</span></code></pre></pre>
<p>若要讓變數可以重新賦值，需要使用 <code>mut</code> 關鍵字來宣告：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut y = 10;
y = y + 1; // ok
<span class="boring">}
</span></code></pre></pre>
<p>有很多理由支持讓 immutable 成為預設，比如說 compiler 的最佳化或是減少 race condition。在後續的文章中，我會更進一步討論。</p>
<h2 id="struct--tuple"><a class="header" href="#struct--tuple">Struct &amp; Tuple</a></h2>
<p>Rust 的 struct 宣告方式與 C++ 大同小異，差別僅在於各成員型別的位置、使用逗號作為分隔、以及結尾不需要加分號：</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
    y: f64,
}

fn main() {
    let foo = Foo { x: 10, y: 2.5 };
    println!(&quot;foo.x = {}, foo.y = {}&quot;, foo.x, foo.y);
}
</code></pre></pre>
<p>而 tuple 其實是個語法糖 (syntactic sugar)，相當於使用編號當作成員名稱的 struct：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let triple = (10, 3.14, 'x');
println!(&quot;triple = ({}, {}, {})&quot;, triple.0, triple.1, triple.2)
<span class="boring">}
</span></code></pre></pre>
<p>編譯器會把它轉變成這樣 (以下為示意，實際上宣告 struct 時不能拿數字當成員名稱)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Triple {
    0: i32,
    1: f64,
    2: char,
}
let triple = Triple { 0: 10, 1: 3.14, 2: 'x'};
println!(&quot;triple = ({}, {}, {})&quot;, triple.0, triple.1, triple.2)
<span class="boring">}
</span></code></pre></pre>
<p>值得注意的是，沒有任何元素的 tuple，也就是 0-tuple，也是一個合法的型別，稱之為 <em>unit type</em>。它具有唯一一個可能的值，就是空的 tuple，稱之為 <em>unit</em>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit: () = (); // 完全合法，雖然你沒辦法拿這個變數做什麼事
<span class="boring">}
</span></code></pre></pre>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h2>
<p>若是沒有覆載賦值運算子，C++ 的 struct 具備 value-type semantics，意即使用等號賦值或進行參數傳遞時，會複製整個物件的內容。而 Java class 則具備 reference-type semantics，使用等號僅僅複製物件的位址，它們仍然會影響同一個物件的內容。</p>
<p>Rust 並沒有 class，那麼 rust 的 struct 是 value-type 還是 reference-type 呢？我們試著用最簡單的做法來判定 value-type 與 reference-type：宣告一個物件，用等號賦值給另一個物件並修改其內容，然後檢查原物件的值是否變動。對 value-type 來說是不變動的，而對 reference-type 來說，因為兩個變數實際指向同一塊記憶體，因此內容會變動。然而，這兩種狀況都不會發生在 Rust 上面，因為 compiler 把它擋下來了。</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
	x: i32,
	y: i32,
}

fn main() {
	let mut foo = Point { x: 10, y: 20 };
	let mut bar = foo;
	bar.x = 30;
	println!(&quot;foo.x = {}&quot;, foo.x); // error: use of moved value `foo.x`
}
</code></pre></pre>
<p>Rust struct 具備了 move semantics，使用等號賦值時，資料並不是「複製」，而是「移動」到左值上。右值在移動後，就會成為未初始化的物件，因此 Rust 禁止你對它進行操作。如果你還是有點難以想像，把它理解成 C++11 的 <code>std::move</code> 就可以了：</p>
<pre><code class="language-c++">#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Point {
    int x, y;
};

int main() {
    auto foo = Point { x: 10, y: 20 };
    auto bar = std::move(foo);
    bar.x = 30;
    std::cout &lt;&lt; &quot;foo.x = &quot; &lt;&lt; foo.x &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>這段程式碼可以通過編譯，然而如果你把 <code>Point</code> 換成其它實作 move constructor 的物件 (比如 <code>std::string</code>)，那麼在 <code>std::move(foo)</code> 之後，很可能 <code>foo</code> 會成為內容未初始化的物件，印出其內容會造成 undefined behavior。</p>
<p>為了使用上的方便，Rust 的基本型別，也就是上面那張表格中的所有型別，都具備可複製的特性。因此使用等號賦值時，進行的動作是「複製」，讓你可以繼續操作右值。在後續的文章中，我會更進一步講解 Rust 的 move semantics。</p>
<h2 id="表達式"><a class="header" href="#表達式">表達式</a></h2>
<p>Rust 是 expression-oriented language，大部份的流程控制結構，比如說 <code>if</code>，其實都是可以求值的表達式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = -10;
let abs_x = if x &gt;= 0 {
                x
            } else {
                -x
            };
<span class="boring">}
</span></code></pre></pre>
<p>這看起來其實就是 C++ 的 <code>?:</code> 運算子。然而，Rust 可以在表達式中用分號進行區隔，並使用最後一個表達式當作結果，因此可以組合出複雜的表達式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let year = 2016;
let is_leap = {
                  let div_4 = (year % 4 == 0);
                  let div_100 = (year % 100 == 0);
                  let div_400 = (year % 400 == 0);
                  if div_400 || (div_4 &amp;&amp; !div_100) {
                      &quot;is&quot;
                  } else {
                      &quot;is not&quot;
                  }
              };
println!(&quot;Year {} {} a leap year.&quot;, year, is_leap);
<span class="boring">}
</span></code></pre></pre>
<p>分號可以用來分隔表達式，最後一個不帶分號的表達式會成為整個表達式的結果，因此 <code>is_leap</code> 會根據條件判斷，成為 <code>&quot;is&quot;</code> 或 <code>&quot;is not&quot;</code>。注意第七行與第九行都不能加分號，要是最後一個運算式也加上分號，那麼整個運算式的結果會變成 <code>()</code>，也就是那個沒啥用的 0-tuple。而在第 11 行的分號則用來區隔 <code>let</code> 變數宣告與 <code>println!</code>，是一定要加上去的。</p>
<h2 id="函式"><a class="header" href="#函式">函式</a></h2>
<p>前面提到 Rust 使用 <code>fn</code> 來宣告函式，而且回傳型別寫在後面，看起來很像 C++11 裡面新的函式宣告法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn square(x: f64) -&gt; f64 {
    return x * x;
}
<span class="boring">}
</span></code></pre></pre>
<p>函式本體也是可以使用分號區隔的表達式，最後一個不帶分號的表達式會自動成為函式的回傳值，因此上一段檢查閏年的函式可以這樣寫：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_leap(year: i32) -&gt; bool {
    let div_4 = (year % 4 == 0);
    let div_100 = (year % 100 == 0);
    let div_400 = (year % 400 == 0);

    div_400 || (div_4 &amp;&amp; !div_100)
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以用 tuple 輕易讓函式回傳多個值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 對兩個數字做排序
fn reorder(x: i32, y: i32) -&gt; (i32, i32) {
    if x &gt; y {
        (y, x)
    } else {
        (x, y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>即使函式不回傳任何值，它還是有回傳型別，也就是上面提到那個好像沒啥用的 0-tuple。</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello() -&gt; () { // -&gt; () 可省略
    println!(&quot;hello world&quot;);
}

fn main() { // 若無回傳型別，rust 會自動加上 -&gt; ()
    let result = say_hello(); // 合法，result 的值為 ()
}
</code></pre></pre>
<p>這看起來好像沒什麼用，畢竟 0-tuple 什麼事都做不了。然而，當你要寫泛型函式 (generic function) 時，你會跪在電腦前感謝這個設計。</p>
<h2 id="泛型-1"><a class="header" href="#泛型-1">泛型</a></h2>
<p>如同 C++ 那般，Rust 也可以利用模版 (template) 來達成泛型程式設計，語法也非常接近 C++：</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; { // 相當於 template&lt;typename T&gt; struct Point
    x: T,
    y: T,
    z: T,
}

fn main() {
    let point_i32 = Point { x: 10, y: 20, z: 30 };
    let point_f64 = Point { x: 2.078, y: 0.454, z: 3.1415 };
}
</code></pre></pre>
<p>與 C++ 不同的是，大部份情況下 Rust 都能藉由前後文來自動推導出正確的模版型別，因此上面的例子中並不需要特別加入 <code>&lt;i32&gt;</code> 或是 <code>&lt;f64&gt;</code>，直接用 <code>Point</code> 即可。</p>
<p>泛型非常適合用來實作容器型別，比如 Rust 提供的 <code>Vec</code> 泛型容器，就相當於 C++ 的 <code>std::vector</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut array = Vec::new();
    array.push(1);
    array.push(2);

    println!(&quot;{}&quot;, array[0] + array[1]);
}
</code></pre></pre>
<p>同樣地，因為 Rust 從第三行的 <code>push(1)</code> 判斷出 array 的元素型別為 <code>i32</code>，因此在第二行就不需要寫明 <code>Vec&lt;i32&gt;::new()</code>，直接寫 <code>Vec::new()</code> 即可。</p>
<p>除了泛型類別，模版也可以用來定義泛型函式，然而與目前 C++ 不同的地方是，在 Rust 中，對泛型型別進行操作前，必需為它標上 constraint：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum&lt;T: Add&gt;(a: T, b: T) -&gt; T::Output {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>這邊 <code>Add</code> 意指 <code>T</code> 必需是可以使用加號相加的型別，包括整數及浮點數都包括在內。由於相加後輸出型別不一定仍然為 T，因此這個函式的回傳型別是 <code>T::Output</code>。Rust 也支援運算子覆載 (operator overloading)，只要你的自訂型別定義了加號操作以及輸出型別，那麼這個自訂型別也可以直接傳入 <code>sum</code> 進行運算。</p>
<h2 id="總結-3"><a class="header" href="#總結-3">總結</a></h2>
<p>這篇文章中，我把重點放在 Rust 最核心的語言功能上，甚至省略了陣列與字串處理，因為講解這部份就無可避免會提到 borrow checker。在後續幾篇文章中，我將會繼續深入解釋 move semantics 與 borrow checker。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文鏈接: https://www.youtube.com/watch?v=rDoqT-a6UFg</p>
<p><strong>翻譯：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>選題：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻譯，<a href="https://hirust.cn">RustCn</a> 榮譽推出</p>
</blockquote>
<img src="rust/images/202205051415470.png"  />
<h1 id="可視化-rust-各數據類型的內存佈局"><a class="header" href="#可視化-rust-各數據類型的內存佈局">可視化 Rust 各數據類型的內存佈局</a></h1>
<blockquote>
<p>本文已獲得作者翻譯許可。由於譯者個人能力有限，如有翻譯錯誤，希望讀者加以指正。<br />
視頻版翻譯：<a href="https://www.bilibili.com/video/BV1KT4y167f1/">B站視頻鏈接</a> </p>
</blockquote>
<pre><code class="language-rs">// file: main.rs
fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre>
<p>當我們使用 Rust 中編寫程序時，由於 Rust 的 生命週期和所有權模型，你最好為程序可能用到的數據結構做一些前期設計，不然 Rust
編譯器可能讓你十分痛苦。瞭解每個數據類型的內存佈局有助於鍛鍊你的直覺，可以提前規避一些編譯錯誤和性能問題。</p>
<p>在這個文章裡，我們會討論</p>
<ul>
<li>在計算機運行二進制文件時發生了什麼？</li>
<li>常見數據類型的內存佈局 (包括：整形，元組，切片，向量，字符串，結構體，枚舉，智能指針，特徵對象，還有各種 <code>Fn</code> 特徵)</li>
</ul>
<h2 id="二進制數據段"><a class="header" href="#二進制數據段">二進制數據段</a></h2>
<p>當你編寫一個 Rust 程序時，要麼直接調用 rustc，要不就是通過 cargo 去生成一個可執行文件。</p>
<pre><code class="language-shell">$ rustc main.rs
$ cargo build
</code></pre>
<p>這個二進制文件以一種特定的格式存儲數據。對於 linux 系統，最常見的格式是 <code>elf64</code> 。不同的操作系統比如 linux, mac, windows
使用不同的格式。雖然二進制文件的格式不盡相同，但是它在各種的操作系統中的運行方式幾乎相同。</p>
<p>常見的二進制文件一般由 <strong>文件頭 + 分區</strong> 組成。 對於 <code>elf</code> 格式的二進制文件，它的結構大致如下圖所示：</p>
<img src="rust/images/202205031746097.png"  height = "250"  />
<blockquote>
<p>段的數量根據編譯器而不同。這裡只展示了一些重要的一些段。</p>
</blockquote>
<p>當你運行二進制文件時</p>
<p>以 <code>elf64</code> 格式的二進制文件為例，在程序運行時，內核會為程序分配一段連續的內存地址，並將這些分區映射到內存中去。</p>
<img src="rust/images/202205031816710.png"  height = "400" />
<p><strong>注意</strong>：這裡的內存地址並不是內存條裡實際的內存地址。但是當程序開始使用內存時，內核和硬件會把它們映射到真正的物理內存地址。這被稱為
<strong>虛擬地址空間</strong>。一個正在運行的程序被稱為一個進程。從進程的角度來看，它只能看到一段連續的內存，從 0 到地址高位的最大值。</p>
<p>下面我們會介紹進程地址空間中各個區域的作用：</p>
<ol>
<li>
<p>代碼段 (text)</p>
<p>代碼段包含了可執行指令的集合。</p>
<p>編譯器能把我們用高級語言寫的程序轉換為 CPU 可以執行的機器指令，代碼段就包含了這些指令。這些指令根據 CPU 架構而有所不同。編譯給 x86-64
架構 CPU 運行的二進制文件不能在 ARM 架構的 CPU 上運行。</p>
<p>代碼段是 <strong>只讀</strong> 的，運行的程序不能更改它。</p>
</li>
<li>
<p>數據段 (data)</p>
<p>數據段包含 <strong>已經初始化</strong> 過的數據。比如全局變量，全局靜態變量，局部靜態變量。</p>
</li>
<li>
<p>BSS 段 (bss)</p>
<p>bss 代表 <code>Block started by symbol</code>, 這裡保存著 <strong>未被初始化</strong> 過的全局變量。由於 bss
段的變量未被初始化，這一段並不會直接佔據二進制文件的體積，它只負責記錄數據所需空間的大小</p>
</li>
<li>
<p>地址高位</p>
<p>內核會把一些額外的數據，比如環境變量，傳遞給程序的參數和參數的數量映射到地址高位。</p>
</li>
</ol>
<h2 id="堆--棧"><a class="header" href="#堆--棧">堆 &amp; 棧</a></h2>
<h3 id="堆棧簡介"><a class="header" href="#堆棧簡介">堆棧簡介</a></h3>
<p>當程序運行時（運行態），還需要需要另外兩個域：堆和棧</p>
<img src="rust/images/202205031946093.png"  height = "400" />
<p><strong>棧</strong>：</p>
<ul>
<li>
<p>操作系統使用棧存儲一個進程的抽象細節，包括 (進程名字，進程 ID 等)。</p>
</li>
<li>
<p>一個進程至少有一個執行線程，每一個線程都有自己的棧內存。</p>
</li>
<li>
<p>在 64 位的 linux 系統上，Rust 程序為主線程分配 8MB 的棧內存。對於用戶創建的其他線程，rust 標準庫支持自定義大小，默認的大小是
2MB。</p>
</li>
<li>
<p>棧內存的空間會從地址高位向低位增長，但是不會超過線程可以擁有的最大值。對於主線程來說就是 8MB。如果它使用的棧內存超過了
8MB，程序就會被內核終止，並返回一個 <code>stackoverflow</code> 錯誤。</p>
</li>
<li>
<p>棧內存被用於執行函數 (見下方對棧的具體講解)。</p>
</li>
</ul>
<blockquote>
<p>雖然主線程的棧內存大小有 8MB，但是這 8MB 也不會被立即分配，只有當程序開始使用時，內核才會開始為它分配內存。</p>
</blockquote>
<p><strong>堆</strong>：</p>
<ul>
<li>所有線程共享一塊堆內存</li>
<li>堆內存從地址低位向高位增長。</li>
</ul>
<p>操作系統通常會提供一些接口讓我們檢查程序運行時的內存映射狀態，對於 linux 系統，你可以在 <em>/proc/PID/maps</em> 文件中查看</p>
<p>下面展示了一個進程的映射狀態（部分）：</p>
<pre><code>$ cat /proc/844154/maps
55e6c3f44000-55e6c412c000 r-xp 00000000 103:03 22331679                  /usr/bin/fish
55e6c412c000-55e6c4133000 r--p 001e7000 103:03 22331679                  /usr/bin/fish
55e6c4133000-55e6c4134000 rw-p 001ee000 103:03 22331679                  /usr/bin/fish
55e6c4134000-55e6c4135000 rw-p 00000000 00:00 0
55e6c4faa000-55e6c5103000 rw-p 00000000 00:00 0                          [heap]
7fd62326d000-7fd62326f000 r--p 00034000 103:03 22285665                  /usr/lib/ld-linux-x86-64.so.2
7fd62326f000-7fd623271000 rw-p 00036000 103:03 22285665                  /usr/lib/ld-linux-x86-64.so.2
7ffecf8c5000-7ffecf8f5000 rw-p 00000000 00:00 0                          [stack]
</code></pre>
<p>你可能會想問：堆內存和棧內存是否會相互覆蓋？因為他們兩個向對方的方向增長。</p>
<p>通過用 stack 的低位減去 heap 的高位</p>
<pre><code class="language-py">&gt;&gt;&gt; (0x7ffecf8c5000 - 0x55e6c5103000) / (10 ** 12)
46.282743488512
</code></pre>
<p>差距為 47TB，所以棧堆衝突的情況幾乎不可能出現</p>
<p>如果確實發生了，內核會提供守衛去終止程序。注意，這裡的內存是指虛擬內存，並非電腦的真實內存大小。</p>
<h3 id="cpu-字長"><a class="header" href="#cpu-字長">CPU 字長</a></h3>
<p>虛擬內存地址的範圍由 CPU 字長 (word size) 決定，字長是指 CPU 一次可以並行處理的二進制位數，對於 64 位的 CPU 來說，它的字長為
64 位 (8 字節)。CPU 中大多數或者全部寄存器一般都是一樣大。</p>
<img src="rust/images/202205031946032.png" height=80px />
<p>因此可以得出：64 位 CPU 的尋址空間為 0 ~ 2^64-1。而對於 32 位的 CPU 來說，它的尋址空間只有從 0 到 2^32，大概 4GB。</p>
<p>目前，在 64 位 CPU 上，我們一般只使用前 48 位用於尋址，大小大概是 282TB 的內存</p>
<pre><code>&gt;&gt;&gt; 2**48 / (10**12)
281.474976710656
</code></pre>
<p>這其中，只有前 47 位是分配給用戶空間使用，這意味著大概有 141TB 的虛擬內存空間是為我們的程序分配的，剩下的位於地址高位的 141TB
是為保留給內核使用的。如果你去查看程序的虛擬內存映射，你能使用的最大內存地址應該是 <code>0x7fffffffffff</code></p>
<pre><code>&gt;&gt;&gt; hex(2**47-1)
'0x7fffffffffff'
</code></pre>
<h3 id="棧內存"><a class="header" href="#棧內存">棧內存</a></h3>
<p>接下來讓我們深入瞭解棧內存的用途</p>
<p>在這個例子中，整個程序只有一個主線程在運行，我們在 <code>main</code> 裡調用了 <code>add1</code> 函數。</p>
<pre><code class="language-rs">fn main() {
    let a = 22;
    let b = add_one(a);
}

fn add_one(i: i32) -&gt; i32 {
    i + 1
}
</code></pre>
<p>棧主要用來保存正在調用的函數的數據 (包括函數參數，函數的局部變量，和它的返回地址)。為一個運行中的函數分配的總內存被稱為一個 <strong>棧幀</strong>。</p>
<ol>
<li>
<p><code>main</code> 函數是程序的入口，首先 <code>main</code> 函數的棧幀被創建。</p>
<p><code>main</code> 函數內部有一個兩個 <code>i32</code> 類型的局部變量 <code>a</code> 和 <code>b</code>，大小都是 4 個字節，其中 <code>a</code> 的值為 22。<code>main</code>
函數的棧幀會確保有足夠的空間去保存這些局部變量。</p>
<p>ESP 和 EBP 寄存器內分別保存著棧頂指針和棧底指針，用來追蹤當前的棧的頂部和底部。</p>
<img src="rust/images/202205032036717.png"  height = "350" alt="圖片名稱" align=center />
</li>
<li>
<p>當 <code>main</code> 函數調用 <code>add1</code> 時，一個新的棧幀被創建用來保存 <code>add1</code> 函數的數據。棧頂指針被修改為新棧的頂部。</p>
<img src="rust/images/202205032039168.png"  height = "350" alt="圖片名稱" align=center />
<ol>
<li><code>add1</code> 函數要接受一個 <code>i32</code> 類型的參數，因此 4 字節的空間會被保留在 <code>add1</code> 函數的棧幀上。</li>
<li><code>add1</code> 函數並沒有局部變量</li>
<li>棧幀還會保存一個返回地址，當函數運行結束後，會根據該返回地址回到之前的指令。</li>
</ol>
</li>
<li>
<p>函數調用結束</p>
<p>當函數調用結束後，就會把返回值 23 賦值給局部變量 <code>b</code>。同時棧頂指針也被修改。</p>
<img src="rust/images/202205032040616.png"  height = "350" alt="圖片名稱" align=center />
<blockquote>
<p>注意：函數運行結束後，add1
的棧幀並沒有被釋放。當你的程序開始調用下一個函數時，新的棧幀會直接將其覆蓋。對於棧來說，開闢和釋放內存只需要修改棧指針即可。</p>
</blockquote>
</li>
</ol>
<p>由此可見，因為在棧上開闢和釋放內存只需要移動指針，不需要進行任何系統調用，它的效率是很高的。</p>
<p>當然棧也有一些限制：</p>
<ul>
<li>只有在編譯時已知大小的變量才能被存儲在棧上。</li>
<li>函數不能返回一個位於函數內部的局部變量的引用</li>
</ul>
<p>如果你把 add_one 改成下面的樣子，就會編譯失敗：</p>
<pre><code class="language-rs">fn add_one(i: i32) -&gt; &amp;'static i32 {
    let result = i + 1;
    &amp;result
}
</code></pre>
<pre><code>error[E0515]: cannot return reference to local variable `result`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;result
  |     ^^^^^^^ returns a reference to data owned by the current function
</code></pre>
<p>根據我們之前介紹過棧的工作原理，假設你現在返回了一個函數內局部變量的引用，但是當函數返回時，本質上函數的內存就被釋放了。當下一個函數被調用時，它的棧幀就會重寫這塊內存空間。</p>
<p>在一個帶有 GC 的語言裡，編譯器能夠檢測到這種覆蓋，並在會為這個變量在堆上分配一塊空間，並返回它的引用。但是在堆上分配會帶來部分額外開銷。因為 Rust 沒有
GC，而且不會強制你去顯式的分配堆內存，所以這裡會編譯失敗。</p>
<h3 id="堆內存"><a class="header" href="#堆內存">堆內存</a></h3>
<p>在這個例子裡，我們在 <code>main</code> 函數中調用了 <code>heap</code> 函數。</p>
<pre><code class="language-rs">fn main() {
    let result = heap();
}

fn heap() -&gt; Box&lt;i32&gt; {
    let b = Box::new(23);
    b
}
</code></pre>
<p>首先會為兩個函數再棧上創建棧幀。接著使用 <code>box</code> 將 23 分配在堆上。然後把 23 在堆上的地址賦值給了變量 <code>b</code>。<code>box</code>
只是一個指針，所以棧上有足夠的空間去保存 <code>box</code>。</p>
<img src="rust/images/202205032154186.png"  height = "400" alt="圖片名稱" align=center />
<blockquote>
<p>在 64 位系統上，指針的大小是 8 字節，所以在棧上的變量 b 的大小是 8 字節。而 b 指向的變量 23 是 <code>i32</code> 類型，它在堆上只需要佔用 4
字節。</p>
</blockquote>
<p>當函數調用結束後，<code>heap</code> 函數返回的 <code>box</code> 指針就會被保存在 main 函數的局部變量裡。</p>
<img src="rust/images/202205032155624.png"  height = "400" alt="圖片名稱" align=center />
<p>當你對棧上的數據進行賦值操作時，它的棧內存就會被直接 <code>copy</code> 過去。在這個例子裡，用來保存 <code>box</code> 的 8 個字節就是從 <code>heap</code>
函數的棧幀直接複製到 <code>main</code> 的局部變量 <code>result</code>。現在即使 <code>heap</code> 函數的棧幀被釋放，<code>result</code>
變量依然保存著數據的地址。堆允許你共享變量。</p>
<h3 id="內存分配器"><a class="header" href="#內存分配器">內存分配器</a></h3>
<p>我們之前提到過每個線程都有各自的棧內存，他們共享一塊堆內存。</p>
<p>假設你的程序不斷在堆上分配新的數據，現在堆內存幾乎耗盡了，需要對堆內存進行擴容。</p>
<img src="rust/images/202205032243927.png"  height = "400" alt="圖片名稱" align=center />
<p>程序的內存分配器一般會使用系統調用請求操作系統分配更多內存。對於 linux 系統來說，一般是 <code>brk</code> 或者 <code>sbrk</code> 系統調用。</p>
<p>在 Rust 裡，堆內存分配器需要實現 <code>GlobalAlloc</code> 特徵。你幾乎不會直接用到它，編譯器會在需要時插入合適的系統調用。</p>
<pre><code class="language-rs">// /rust/library/std/src/sys/unix/alloc.rs
#[stable(feature = &quot;alloc_system_type&quot;, since = &quot;1.28.0&quot;)]
unsafe impl GlobalAlloc for System {
    #[inline]
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= layout.size() {
            libc::malloc(layout.size()) as *mut u8
        }
        ...
    }
    ...
}
</code></pre>
<p>你可能很熟悉 C 語言裡的 <code>malloc</code> 函數，但是它並不是系統調用，<code>malloc</code> 依然會調用 <code>brk</code> 或者 <code>sbrk</code> 去請求內核。Rust
的內存分配器依靠 C 標準庫裡提供的 <code>malloc</code> 函數，如果你使用像 <code>ldd</code> 這樣的工具去檢查二進制文件依賴的動態鏈接庫，你應該會看到 <code>libc</code></p>
<pre><code class="language-shell">$ ldd target/debug/demo
    linux-vdso.so.1 (0x00007fff60bd8000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f08d0c21000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f08d0ebf000)
</code></pre>
<blockquote>
<p>Linux 下 Rust 默認使用 GNU 作為鏈接器，因此 Rust 二進制文件依賴於操作系統上的 C 標準庫或者 <code>libc</code> 庫。<code>libc</code>
更像是操作系統的一部分，使用像 <code>libc</code> 這樣的動態鏈接庫有助於減少二進制文件體積。</p>
</blockquote>
<p>同時，內存分配器也不總是依賴於系統調用在堆上分配內存：</p>
<ol>
<li>
<p>每次程序使用 box 等把數據分配在堆上時，程序的內存分配器都會成塊的請求內存去減少系統調用的次數。</p>
</li>
<li>
<p>堆和棧不一樣，內存不一定總是在堆的末尾被釋放。當一些地方的內存被釋放後，它並沒有立即返還給操作系統，內存分配器會追蹤內存分頁，知道那些頁正在使用，那些頁被釋放了。所以當需要更多堆內存時，它可以直接使用這些已經釋放但還未歸還的內存分頁。</p>
</li>
</ol>
<p>現在你應該知道為什麼分配堆內存比棧內存更消耗性能了。分配堆內存可能使用到系統調用，而且內存分配器每一次分配內前，都必須從堆上找到一個空閒內存塊。</p>
<h2 id="rust-各數據類型的內存佈局"><a class="header" href="#rust-各數據類型的內存佈局">Rust 各數據類型的內存佈局</a></h2>
<h3 id="整形"><a class="header" href="#整形">整形</a></h3>
<table><thead><tr><th>長度 (byte)</th><th>長度 (bit)</th><th>有符號</th><th>無符號</th></tr></thead><tbody>
<tr><td>1 字節</td><td>8 位</td><td>i8</td><td>u8</td></tr>
<tr><td>2 字節</td><td>16 位</td><td>i16</td><td>u16</td></tr>
<tr><td>4 字節</td><td>32 位</td><td>i32</td><td>u32</td></tr>
<tr><td>8 字節</td><td>64 位</td><td>i64</td><td>u64</td></tr>
<tr><td>16 字節</td><td>128 位</td><td>i128</td><td>u128</td></tr>
</tbody></table>
<p>有符號和無符號整形的名字已經展示了它所佔的位數，比如 <code>i16</code> 和 <code>u16</code> 在內存都是 16 位 (2 字節)。它們都被完整的分配在函數的棧幀上。</p>
<img src="rust/images/202205041123992.png" height=180px />
<p><code>isize</code> 和 <code>usize</code> 的大小則取決於你的系統，32 位系統就佔用 4 字節，64 位系統就佔用 8 字節。</p>
<h3 id="字符型"><a class="header" href="#字符型">字符型</a></h3>
<p><code>char</code> Rust 的字符不僅僅是 ASCII，所有的 Unicode 值都可以作為 Rust 字符。 例如
<code>a</code>、<code>\u{CA0}</code>、<code>*</code>、<code>字</code>、<code>\n</code>、<code>🦀</code></p>
<p>char 類型長度是 4 字節，直接分配在棧上</p>
<img src="rust/images/202205041113512.png" height=180px />
<h3 id="元組"><a class="header" href="#元組">元組</a></h3>
<p>元組是一些類型的集合</p>
<pre><code class="language-rs">let a: (char, u8, i32) = ('a', 7, 354);
</code></pre>
<p>比如這裡，變量 a 包含了 char, u8, i32 三種數據類型，它的內存佈局就是將各個成員依次排列。</p>
<p>在這裡 char 佔用 4 字節，u8 佔用 1 字節，i32 佔用 4 字節。因為這三種類型都是隻在棧上分配的，所以整個元組也全在棧上分配。</p>
<img src="rust/images/202205041124139.png" height=200px />
<p>雖然看起來這個元組只會佔用 9 字節的空間，但是其實並不是這樣，你可以用 <code>size_of</code> 去查看這個元組佔用的真正字節數</p>
<pre><code class="language-rs">std::mem::size_of::&lt;T&gt;()
</code></pre>
<h3 id="size_of-和-align_of"><a class="header" href="#size_of-和-align_of">size_of 和 align_of</a></h3>
<pre><code class="language-rs">use std::mem::{size_of, align_of};

size_of::&lt;(char, u8, i32)&gt;(); // 12 字節

align_of::&lt;(char, u8, i32)&gt;(); // 4 字節
</code></pre>
<p>所有的數據類型還有一個對齊屬性，你可以通過 <code>align_of</code> 查看。</p>
<p>數據類型的大小必須是對齊屬性的整數倍。這一點不僅僅是 Rust，所有的編譯器都是這樣。數據對齊對 CPU 操作及緩存都有較大的好處，有助於 CPU
更快的讀取數據。</p>
<p>對於這個元組，它的對齊屬性值是 4，因此它佔用的字節數是 12。剩下的 3 字節會被編譯器填充空白數據</p>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<p>接下來是引用類型 <code>&amp;T</code></p>
<pre><code class="language-rs">let a: i32 = 25;

let b: &amp;i32 = &amp;a;
</code></pre>
<p><code>a</code> 是 i32 類型，<code>b</code> 是對 <code>a</code> 的引用。</p>
<blockquote>
<p>接下來，我不會在詳細展示每個數據的字節大小，我們將重點去關注整體，關注他們是存儲在堆上還是棧上。</p>
</blockquote>
<p>在這裡，<code>a</code> 存儲在棧上，它佔據 4 個字節。<code>b</code> 也存儲在棧上，裡面保存了變量 <code>a</code> 的地址。引用類型的大小取決於你的機器位數，所以 64 位系統上它佔
8 字節。</p>
<img src="rust/images/202205041147802.png" height=200px />
<p>如果我們再用 <code>c</code> 保存 <code>b</code> 的引用，c 的類型就是 <code>&amp;&amp;i32</code></p>
<pre><code class="language-rs">let c: &amp;&amp;i32 = &amp;b;
</code></pre>
<img src="rust/images/202205041147049.png" height=200px />
<p>引用也能指向堆上的數據。</p>
<img src="rust/images/202205041147762.png" height=280px />
<p>可變引用也有相同的內存佈局。</p>
<p>可變引用和不可變引用的區別是他們的使用方式，以及編譯器為可變引用添加的額外限制。</p>
<h3 id="數組"><a class="header" href="#數組">數組</a></h3>
<pre><code class="language-rs">let a: [i32; 3] = [55, 66, 77];
</code></pre>
<img src="rust/images/202205041201858.png" height=130px />
<p>一個數組的大小是固定的，而且它的大小是數據類型的一部分。數組中的每個元素都會在棧上相鄰排放。但是當數組創建後，它的大小就不能再改變。</p>
<blockquote>
<p>注意：只有大小固定而且在編譯時已知的數據類型才能存儲在棧上。</p>
</blockquote>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<p>Vec 類型是可擴容的，它的大小能夠改變，你可以用它代替數組。</p>
<pre><code class="language-rs">let v: Vec&lt;i32&gt; = vec![55, 66, 77];
</code></pre>
<img src="rust/images/202205041443929.png" height=300px />
<p>這裡我們的變量 <code>v</code> 存儲了和數組相同的數據，但是它是在堆上分配的。</p>
<p>變量 <code>v</code> 在棧上佔用的大小是固定的，包含 3 個 <code>usize</code>：</p>
<ul>
<li>第一個表示數據在堆上的地址，</li>
<li>剩下的兩個表示 Vec 的容量和長度。</li>
</ul>
<p>容量表示 Vec 的最大空間。當我們向 Vec 中添加更多數據時，如果元素個數還沒有達到容量大小，Rust 就不必為堆內存分配更多空間。</p>
<p>如果長度和容量已經相等了，我們還要向 Vec 添加更多數據，Rust 就會在堆中重新分配出一塊更大的內存，將原數據複製到新的內存區域，並更新棧中的指針。</p>
<h3 id="切片"><a class="header" href="#切片">切片</a></h3>
<pre><code class="language-rs">let s1: [i32] = a[0..2];

let s2: [i32] = v[0..2];
</code></pre>
<p>切片 <code>[T]</code> 和數組非常相似，但是不用指定大小。切片就像是底層數組的一個視圖，s1 表示數組 a 的前兩個元素，s2 表示向量的前兩個元素。</p>
<p>由於切片沒有指定元素數量，編譯時 Rust
編譯器不知道它具體佔了多少字節。同時，你也不能將切片存在變量中，因為它沒有已知大小，所以不能被分配在棧上，這樣的類型被稱為 <strong>DST 動態大小類型</strong> 。</p>
<blockquote>
<p>還有其他的 DST 類型，比如字符串切片和特徵對象。</p>
</blockquote>
<p>如果你嘗試運行上面的代碼，應該會編譯失敗：</p>
<pre><code class="language-rs">error[E0277]: the size for values of type `[i32]` cannot be known at compilation time
 --&gt; examples/vec.rs:8:9
  |
8 |     let s1: [i32] = a[0..2];
  |         ^^ doesn't have a size known at compile-time
  |
help: consider borrowing here
  |
8 |     let s1: [i32] = &amp;a[0..2];
  |                     +
</code></pre>
<p>因此，幾乎在任何情況下，我們只會使用到切片的引用 <strong><code>&amp;[T]</code></strong>。被引用的數據既能在棧上，也能在堆上：</p>
<img src="rust/images/202205042149818.png" height=400px />
<p>我們之前說過，引用只是一個指針，它佔據一個 <code>usize</code> 去存儲它所指向的數據的地址。</p>
<p>但是當你用指針去指向一個動態大小類型時 (比如切片)，Rust 會使用一個額外的 <code>usize</code> 去存儲數據的長度。這種引用也叫做 <strong>胖指針</strong>
(將一些附加信息和指針一起存儲)。</p>
<p>切片引用可以用兩個 <code>usize</code> 表示，所以它可以存在棧上。</p>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>與字符串相關的有三種類型：<code>String</code>, <code>str</code>, <code>&amp;str</code>，他們分別對應 <code>Vec</code>, <code>[T]</code>， <code>&amp;[T}</code></p>
<p>字符串類型 <code>String</code> 的內存佈局和向量相同，唯一的區別是，字符串類型必須是 UTF-8 編碼。</p>
<p>以下面的代碼為例：</p>
<pre><code class="language-rs">let s1: String = String::from(&quot;hello&quot;);
</code></pre>
<img src="rust/images/202205041444837.png" height=300px />
<p>但是，如果你把一個字符串直接保存在變量中：</p>
<pre><code class="language-rs">let s2: &amp;str = &quot;hello&quot;;
</code></pre>
<p><code>s2</code> 的類型就會變成字符串切片的引用，這個字符串的數據不會在堆上，而是直接存儲在編譯好的二進制文件中。這種字符串有 <code>'static</code>
的生命週期，它永遠不會被釋放，在程序運行時都是可用的。</p>
<img src="rust/images/202205041445745.png" height=380px />
<blockquote>
<p>據我所知，Rust 不會指定字符串被保存在文件的那個部分，但是很可能就在代碼段 (text segment)</p>
</blockquote>
<p>和切片引用一樣，對字符串的切片的引用也是一個胖指針，包含兩個 <code>usize</code>，一個用來存儲字符串的內存起始地址，另一個存儲字符串長度。</p>
<p>你不能直接使用字符串切片 <code>str</code>:</p>
<pre><code class="language-rs">// error: size can not be known at compile time
let s: str = s1[1..3];
</code></pre>
<p>對字符串的切片引用是可行的：</p>
<pre><code class="language-rs">let s: &amp;str = &amp;s1[1..3];
</code></pre>
<img src="rust/images/202205042150544.png" height=400px />
<h3 id="結構體"><a class="header" href="#結構體">結構體</a></h3>
<p>Rust 有三種結構體類型：結構體，元組結構體 (Tuple Struct) 和單元結構體 (Unit-like Struct)。</p>
<p>普通結構體：</p>
<pre><code class="language-rs">struct Data {
    nums: Vec&lt;usize&gt;,
    dimension: (usize, usize),
}
</code></pre>
<p>元組結構體：</p>
<pre><code class="language-rs">struct Data(Vec&lt;usize&gt;);
</code></pre>
<p>單元結構體：</p>
<pre><code class="language-rs">struct Data;
</code></pre>
<p>單元結構體不保存任何數據，所以 Rust 編譯器甚至不會為他分配內存。</p>
<p>另外兩種結構體的內存排布非常類似於之前所說的元組，我們以普通的結構體為例：</p>
<pre><code class="language-rs">struct Data {
    nums: Vec&lt;usize&gt;,
    dimension: (usize, usize),
}
</code></pre>
<p>它有兩個字段，一個 Vec 和一個元組，結構體的各個成員會在棧上依次相鄰排列。</p>
<ul>
<li>Vec 需要佔用 3 個 <code>usize</code>，nums 的成員會被分配在堆上。</li>
<li>元組需要佔用 2 個 <code>usize</code>。</li>
</ul>
<img src="rust/images/202205041441096.png" height=300px />
<blockquote>
<p>注意：我們在這裡忽視了內存對齊和編譯器填充的 padding。</p>
</blockquote>
<h3 id="枚舉"><a class="header" href="#枚舉">枚舉</a></h3>
<p>像結構體一樣，Rust 支持用不同的語法表示枚舉。</p>
<p>下面展示的是一個 C 風格的枚舉，在內存中他們被保存為從零開始的整數，Rust 編譯器會自動選擇最短的整數類型。</p>
<pre><code class="language-rs">enum HTTPStatus {
    Ok,
    NotFound,
}
</code></pre>
<img src="rust/images/202205041451028.png" height=200px />
<p>在這裡最大值為 1，因此該枚舉可以使用 1 字節存儲。</p>
<p>你也可以手動為枚舉的每個變體指定它的值：</p>
<pre><code class="language-rs">enum HTTPStatus {
    Ok = 200,
    NotFound = 404,
}
</code></pre>
<p>這個例子裡最大的數是 404，需要至少 2 字節存儲。所以這個枚舉的每種變體都需要 2 字節。</p>
<img src="rust/images/202205041452340.png" height=200px />
<p>枚舉值也可以選擇具體的類型</p>
<pre><code class="language-rs">enum Data {
    Empty,
    Number(i32),
    Array(Vec&lt;i32&gt;)
}
</code></pre>
<p>在這個例子中</p>
<ul>
<li><code>Empty</code> 變體不存儲任何數據</li>
<li><code>Number</code> 內部有一個 <code>i32</code></li>
<li><code>Array</code> 裡面有個 <code>Vec</code></li>
</ul>
<p>它們的內存佈局如下圖所示：</p>
<img src="rust/images/202205041511443.png" height=400px />
<p>首先我們看 <code>Array</code> 變體：</p>
<p>首先是一個整數標記 2 佔用 1 字節，接著就是 <code>Vec</code> 所需的三個 <code>usize</code> ，編譯器還會填充一些空白區域讓他們內存對齊，所以這個變體需要 32
字節 (1 + 7 + 3 * 8)。</p>
<p>接著是 <code>Number</code> 變體，首先是整數標記 1，接著是 Number 裡存儲的 i32，佔用 4
字節。因為所有變體的大小應該是一致的，所以編譯器會為它們兩個都添加 Padding 達到 32 字節</p>
<p>對於 <code>Empty</code>，它只需要一個字節去存儲整數標記，但是編譯器也必須添加 31 字節的 Padding</p>
<p>所以，枚舉佔用的空間取決於最大變體佔用的空間。</p>
<p>減少內存使用的一個技巧就是降低枚舉最大變體佔用的內存：</p>
<pre><code class="language-rs">enum Data {
    Empty,
    Number(i32),
    Array(Box&lt;Vec&lt;i32&gt;&gt;) // 使用 Box 代替
}
</code></pre>
<p>在這個例子裡，我們存除了 Vec 的指針，此時 Array 變體需要的內存只有 16 字節：</p>
<img src="rust/images/202205041523525.png" height=400px />
<h3 id="box"><a class="header" href="#box">Box</a></h3>
<p>Box 是一個指針指向堆上的數據，所以 Box 在棧上只需要 1 個 <code>usize</code> 去存儲地址。</p>
<p>在上個例子中，Box 指向了一個在堆上分配的 Vec。</p>
<blockquote>
<p>如果向量裡面有值，這些值也會被存儲在堆上。指向數據的指針將保存在 Vec 的指針字段裡</p>
</blockquote>
<h3 id="對-option-的優化"><a class="header" href="#對-option-的優化">對 Option 的優化</a></h3>
<pre><code class="language-rs">pub enum Option&lt;T&gt; {
    None,
    Some(T)
}
</code></pre>
<p>由於 Rust 不允許出現空指針，想要實現同樣的效果，你需要使用</p>
<pre><code class="language-rs">Option&lt;Box&lt;i32&gt;&gt;
</code></pre>
<p>這能夠讓 Rust 編譯器確保不會出現空指針異常。</p>
<img src="rust/images/202205041541105.png" height=300px />
<p>在其他語言裡，使用一個指針就能表示這兩種狀態。但是 Rust 卻需要一個額外的整數標記和隨之帶來的 padding，這會造成內存浪費。</p>
<p>編譯器能對此做出一些優化，如果 <code>Option</code> 裡是 <code>Box</code> 或者是類似的指針類型，編譯器就會省略掉整數標記，並使用值為 0 的指針表示 None。</p>
<img src="rust/images/202205041703687.png" height=300px />
<p>這種特性使得 Rust 中被包裝在 <code>Option</code> 內的智能指針像其他語言裡的指針一樣，不會佔用多餘的內存。同時還能夠提前找到並消除空指針異常</p>
<h3 id="copy-和-move"><a class="header" href="#copy-和-move">Copy 和 Move</a></h3>
<p>在繼續向下討論之前，讓我們先了解一下 Copy 和 Move</p>
<pre><code class="language-rs">let num：i32 = 42;
let num_copy = num;
</code></pre>
<p>對於原始類型數據，他們的大小是在編譯時已知的，會被存儲在棧上。如果你將一個變量賦值給另一個變量，它得到的實際上是原始數據的一份拷，Rust 會逐位進行復制。</p>
<img src="rust/images/202205041713211.png" height=200px />
<p>這兩個變量之後能同時使用</p>
<p>對於在堆上存儲的數據來說：</p>
<pre><code class="language-rs">let v: Vec&lt;String&gt; = vec![
    &quot;Odin&quot;.to_String(),
    &quot;Thor&quot;.to_String(),
    &quot;Loki&quot;.to_String(),
]
</code></pre>
<p>在這個例子裡，我們有一個在堆上分配的字符串向量。</p>
<p>變量 v 被保存在棧上，它需要 3 個 <code>usize</code> 去存儲 Vec 的信息，並指向數據在堆中的地址。</p>
<p>每個字符串也需要 3 個 <code>usize</code> 來存儲實際字符串的信息。</p>
<p>真正的字符串會被分配到堆上的其他地方。</p>
<img src="rust/images/202205041728077.png" height=400px />
<p>從所有權角度來說，變量 v 擁有所有在堆上分配的內存。因為 Rust 沒有 GC，當變量 v 自己超出作用域後，它需要自己釋放自己擁有的堆內存。</p>
<p>接下來我們將 v 賦值給了 v2：</p>
<pre><code class="language-rs">let v2 = v;
</code></pre>
<p>對於有 GC 的語言來說，程序會對變量 <code>v</code> 在棧上的數據進行了按位複製，最後 <code>v2</code> 也將擁有指向堆上數據的指針。</p>
<img src="rust/images/202205041741726.png" height=400px />
<p>這種方案很節省內存，無論在堆中的數據有多大，我們只需要複製棧上的數據。垃圾回收器會追蹤堆內存的引用數量，當引用計數歸零，垃圾回收器會幫我們釋放堆內存。</p>
<p>但是 Rust 沒有 GC，它只有所有權模型。我們不清楚到底哪個變量需要對釋放內存負責。</p>
<p>另一種方案是：在賦值時為堆內存也創建一個副本。但是這會導致內存使用量升高，降低性能。</p>
<p>Rust 的選擇是讓用戶必須做出選擇：如果你在對變量賦值時想讓它擁有一份屬於自己的堆內存，你應該使用 <code>clone</code> 方法。如果你不使用 <code>clone</code>
方法，Rust 編譯器就不允許你再使用之前的變量。</p>
<img src="rust/images/202205041754565.png" height=400px />
<p>我們把它稱為：變量 v 已經被 move 了，現在 v2 是數據的擁有者。當 v2 超出作用域時，它會負責釋放堆上的數據。</p>
<h3 id="rc"><a class="header" href="#rc">Rc</a></h3>
<p>有時候我們想讓一個值擁有多個擁有者，大多數情況下，你可以用普通的引用去解決。但是這種方法的問題在於，當數據的擁有者超出作用域後，所有的引用也不能再繼續使用。</p>
<p>我們想要的是所有變量都是數據的擁有者，只有所有變量都超出作用域後，數據才會被釋放。Rc 智能指針通過引用計數能夠實現這個功能：</p>
<pre><code class="language-rs">use std::rc::Rc;

let v: Rc&lt;Vec&lt;String&gt;&gt; = Rc::new(vec![
    &quot;Odin&quot;.to_String(),
    &quot;Thor&quot;.to_String(),
    &quot;Loki&quot;.to_String(),
]);

let v2 = v.clone();
println!(&quot;{}, {}&quot;, v.capacity(), v2.capacity())
</code></pre>
<p>當你使用 Rc 去包裹一個 Vec 時，Vec 的 3 個 <code>usize</code> 會和引用計數一起分配在堆上。變量 v 在棧只佔用一個 <code>usize</code>，裡面存儲了
Rc 在堆上的地址。</p>
<img src="rust/images/202205041812961.png" height=400px />
<p>現在你能通過克隆 v 來創建 v2，這個克隆不會克隆任何位於堆上的數據，他只會克隆一份棧上的地址，然後將 Rc 的引用計數加 1，現在 v 和 v2
都持有相同的一份數據，這就是為什麼它被稱為引用計數指針。</p>
<img src="rust/images/202205041814163.png" height=400px />
<p>但是 Rc 也有限制，Rc 內部的數據是不可變的，你可以使用內部可變性可以解決這個問題。</p>
<p>每當有一個共享者超出作用域，引用計數就會減 1，讓引用計數減到 0 時，整個堆內存就會被釋放。</p>
<h3 id="send-和-sync"><a class="header" href="#send-和-sync">Send 和 Sync</a></h3>
<p>Rust 有一些特殊的標記特徵，例如 Send 和 Sync。</p>
<p>如果一個類型實現了 Send，那就意味著數據可以從一個線程移動到另一個線程。</p>
<p>如果一個類型實現了 Sync，多個線程就可以使用引用去共享該數據。</p>
<p>Rc 沒有實現 Send 和 Sync。假設兩個線程在某個時間點同時擁有對某數據的引用，並且同時對該引用進行克隆。兩個線程同時更新引用計數就會引發線程安全問題。</p>
<img src="rust/images/202205041839368.png" height=300px />
<h3 id="arc"><a class="header" href="#arc">Arc</a></h3>
<p>如果你真的想要在線程間共享數據，你應該使用 <strong>原子</strong> 引用計數指針 <strong>Arc</strong>。</p>
<p>Arc 的工作方式幾乎和 Rc 相同，只是引用計數的更新是原子性的，它是線程安全的。但是原子操作會帶來一些微小的性能損耗。如果你只需要在單線程內共享數據，使用
Rc 就夠了。</p>
<p>默認情況下 Arc 也是不變的，如果你想讓數據是可變的，你可以使用 <code>Mutex</code>。</p>
<pre><code class="language-rs">// Arc&lt;Mutex&lt;T&gt;&gt;

let data: Arc&lt;Mutex&lt;i32&gt;&gt; = Arc::new(Mutex::new(0));
</code></pre>
<p>現在即使有兩個線程嘗試同時修改數據，他們需要首先獲取鎖，同時只有有一個線程能拿到鎖，因此只能由一個線程修改數據。</p>
<h3 id="特徵對象"><a class="header" href="#特徵對象">特徵對象</a></h3>
<p>實現了特徵的實例被稱為特徵對象。</p>
<p>下面列舉了將一種具體類型轉化為特徵對象的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Write;

let mut buffer: Vec&lt;u8&gt; = vec![];
let w: &amp;mut dyn Write = &amp;mut buffer;
<span class="boring">}
</span></code></pre></pre>
<p>第一個例子中，轉化發生在為變量 <code>w</code> 賦值時</p>
<pre><code class="language-rs">fn main() {
    let mut buffer: Vec&lt;u8&gt; = vec![];
    writer(&amp;mut buffer);
}

fn writer(w: &amp;mut dyn Write) {
    // ...
}
</code></pre>
<p>第二個例子中，轉化發生在將具體類型變量傳遞給接受特徵對象的函數時</p>
<p>這兩個例子裡 <code>Vec&lt;u8&gt;</code> 類型的變量都被轉化為實現了 <code>Write</code> 的特徵對象。</p>
<p>Rust 用胖指針表示一個特徵對象。該胖指針由兩個普通指針組成，佔用 2 個機器字長。</p>
<ul>
<li>第一個指針指向值，這裡就是 <code>Vec&lt;u8&gt;</code></li>
<li>另一個指針指向 vtable (虛表)。</li>
</ul>
<img src="rust/images/202205042022927.png" height=400px />
<p><code>vtable</code> 在編譯時生成，被所有相同類型的對象共享。<code>vtable</code> 包含了實現 <code>Writer</code>
必須實現的方法的指針。當你在調用特徵對象的方法時，Rust 自動使用 <code>vtable</code> 找到對應的方法。</p>
<p>注意：<code>dyn Write</code> 也是動態大小類型，因此我們總是使用它的引用，即 <code>&amp;dyn Write</code>。</p>
<p>我們能把 <code>Vec&lt;u8&gt;</code> 轉換成特徵對象是因為標準庫已經為它實現了 <code>Write</code> 特徵。</p>
<pre><code class="language-rs">impl Write for Vec&lt;u8&gt;
</code></pre>
<p>Rust 不僅能將普通引用轉化為特徵對象，rust 也能將智能指針轉換為特徵對象：</p>
<pre><code class="language-rs">// Box
use std::io::Write;

let mut buffer: Vec&lt;u8&gt; = vec![];
let w: Box&lt;dyn Write&gt; = Box::new(buffer);
</code></pre>
<pre><code class="language-rs">// Rc
use std::io::Write;
use std::rc::Rc;

let mut buffer: Vec&lt;u8&gt; = vec![]

let mut w: Rc&lt;dyn Write&gt; = Rc::new(buffer);
</code></pre>
<p>無論是普通引用還是智能指針，在轉換髮生的時候，Rust 只是添加了適當的 <code>vtable</code> 指針，把原始指針轉換為了一個胖指針。</p>
<h3 id="函數指針"><a class="header" href="#函數指針">函數指針</a></h3>
<p>函數指針只需要一個 <code>usize</code> 去存儲函數的地址。</p>
<p><code>test_func</code> 是一個會返回 bool 的函數，我們可以把它存在了一個變量裡。</p>
<pre><code class="language-rs">fn main() {
    let f: fn() -&gt; bool = test_func;
}

fn test_func() -&gt; bool {
    true
}
</code></pre>
<img src = "images/202205042044987.png" height = 200px>
<h3 id="閉包"><a class="header" href="#閉包">閉包</a></h3>
<p>Rust 沒有具體的閉包類型，它制定了 3 個特徵 <code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>。</p>
<h4 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h4>
<p>首先是 <code>FnOnce</code>，<code>create_closere</code> 函數返回了一個實現 <code>FnOnce</code> 的對象</p>
<pre><code class="language-rs">fn main() {
    let c = create_closure();
}

fn create_closure() -&gt; impl FnOnce() {
    let name = String::from(&quot;john&quot;);
    || {
        drop(name);
    }
}
</code></pre>
<p>在函數體內部我們創建了一個局部變量 <code>name</code>，它是字符串類型，在棧上佔據 3 個 <code>usize</code>
，接著又創建了一個閉包，閉包可以捕獲函數內的局部變量。在閉包內部，我們 drop 了 name。</p>
<p>FnOnce 只是一個特徵，它只定義了一個對象的行為或方法。Rust
內部會使用結構體表示閉包，它會根據閉包捕獲的變量創建對應的結構體，併為該結構體實現最合適的特徵</p>
<pre><code class="language-rs">struct MyClosure {
    name: String
}

impl FnOnce for MyClosure {
    fn call_once(self) {
        drop(self.name)
    }
}
</code></pre>
<blockquote>
<p><code>FnOnce</code> 特徵的真實函數簽名比較複雜，這裡只展示一個簡化版本。</p>
</blockquote>
<p>結構體內部只有一個 name 字段，是閉包從 <code>create_closure</code> 函數內部捕獲而來，<code>call_once</code> 是 <code>FnOnce</code>
特徵必須實現的方法。因為閉包對應的結構體只有一個 String 類型字段，所以他的內存佈局和 String 一樣。</p>
<img src="rust/images/202205042058375.png" height = 200px/>
<p>注意 call_once 函數的參數，他需要一個 <code>self</code> ，這意味著 <code>call_once</code>
只能調用一次。原因也很簡單，如果我們調用兩次這個閉包，拿他就會 drop <code>name</code> 兩次。</p>
<h4 id="fnmut"><a class="header" href="#fnmut">FnMut</a></h4>
<p>在這個例子裡，我們創建了一個可變的閉包：</p>
<pre><code class="language-rs">let mut i: i32 = 0;

let mut f = || {
    i += 1;
};

f();
f();
println!(&quot;{}&quot;, i); // 2
</code></pre>
<p>這個閉包的類型是 <code>FnMut</code> ，因為我們在閉包裡嘗試修改變量 i 。因此該閉包生成的結構體中將會有一個對變量 i 的可變引用，<code>call_mut</code>
方法也需要一個對 <code>self</code> 的可變引用：</p>
<pre><code class="language-rs">struct MyClosure {
    i: &amp;mut i32
}

impl FnMut for MyClosure {
    fn call_mut(&amp;mut self) {
        *self.i += 1;
    }
}
</code></pre>
<img src="rust/images/202205042118777.png" height=200px/>
<p>如果你在閉包 f 改為不可變的：</p>
<pre><code class="language-rs">let f = || {
    i += 1;
};
</code></pre>
<p>就會編譯失敗：</p>
<pre><code class="language-rs">error[E0596]: cannot borrow `f` as mutable, as it is not declared as mutable
  --&gt; src/main.rs:16:5
   |
12 |     let f = || {
   |         - help: consider changing this to be mutable: `mut f`
13 |         i += 1;
   |         - calling `f` requires mutable binding due to mutable borrow of `i`
...
16 |     f();
   |     ^ cannot borrow as mutable
For more information about this error, try `rustc --explain E0596`.
</code></pre>
<p>錯誤信息提示我們，該閉包需要設為可變的</p>
<h4 id="fn"><a class="header" href="#fn">Fn</a></h4>
<p>最後是 <code>Fn</code> 特徵：</p>
<pre><code class="language-rs">fn create_closure() {
    let msg = String::from(&quot;hello&quot;);

    let my_print = || {
        println!(&quot;{}&quot;, msg);
    };

    my_print();
    my_print();
}
</code></pre>
<p>在這個例子裡，我們的閉包只是打印了一下它捕獲到的 msg 變量，<code>print</code> 宏接受的是變量的引用，所以 Rust 會自動為閉包實現 Fn 特徵：</p>
<pre><code class="language-rs">struct MyClosure {
    msg: &amp;String,
}

impl Fn for MyClosure {
    fn call(&amp;self) {
        println!(&quot;{}&quot;, self.msg);
    }
}
</code></pre>
<p>生成的結構體內部只有一個對 <code>msg</code> 的引用。<code>call</code> 方法只需要一個 <code>self</code> 的引用，因此這個閉包能夠被多次調用。</p>
<img src="rust/images/202205042118165.png" height=200px/>
<h4 id="move"><a class="header" href="#move">move</a></h4>
<p>這個例子中我們將使用和剛剛相同的閉包，只不過是用一個函數去返回：</p>
<pre><code class="language-rs">fn create_closure() -&gt; impl Fn() {
    let msg = String::from(&quot;hello&quot;);

    || {
        println!(&quot;{}&quot;, msg);
    }
}
</code></pre>
<p>但是這樣會編譯錯誤：</p>
<pre><code class="language-rs">error[E0597]: `msg` does not live long enough
  --&gt; src/main.rs:30:24
   |
29 |     || {
   |     -- value captured here
30 |         println!(&quot;{}&quot;, msg);
   |                        ^^^ borrowed value does not live long enough
31 |     }
32 | }
   | -- borrow later used here
   | |
   | `msg` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
</code></pre>
<p>錯誤信息提示我們，變量 <code>msg</code> 的生命週期可能比閉包短。</p>
<p>現在回想一下閉包的內存佈局，閉包的結構體內部只有一個對 <code>msg</code> 的引用。所以當函數調用結束後，它的棧幀將被釋放，閉包就不能再引用到該函數棧幀裡的局部變量。</p>
<p>Rust 希望我們使用 <code>move</code> 關鍵字去明確表示我們想讓閉包拿走閉包捕獲到的變量的所有權</p>
<pre><code class="language-rs">fn create_closure() -&gt; impl Fn() {
    let msg = String::from(&quot;hello&quot;);

    move || {
        println!(&quot;{}&quot;, msg);
    }
}
</code></pre>
<p>當我們使用 move 之後，閉包的結構體就不再是引用，而是字符串本身。</p>
<pre><code class="language-rs">struct MyClosure {
    msg: String,
}

impl Fn for MyClosure {
    fn call(&amp;self) {
        println!(&quot;{}&quot;, self.msg);
    }
}
</code></pre>
<img src="rust/images/202205042120583.png" height=200px />
<h4 id="捕獲多個變量"><a class="header" href="#捕獲多個變量">捕獲多個變量</a></h4>
<p>到目前為止，我們的閉包還只是捕獲一個變量，在這個例子裡閉包捕獲了兩個對象，一個字符串和一個 Vec：</p>
<pre><code class="language-rs">fn create_closure() -&gt; impl Fn() {
    let msg = String::from(&quot;hello&quot;);
    let v: Vec&lt;i32&gt; = vec![1, 2];

    move || {
        println!(&quot;{}&quot;, msg);
        println!(&quot;{:?}&quot;, v);
    }
}
</code></pre>
<p>它的結構體大致如下：</p>
<pre><code class="language-rs">struct MyClosure {
    msg: String,
    v: Vec&lt;i32&gt;,
}

impl Fn for MyClosure {
    fn call(&amp;self) {
        println!(&quot;{}&quot;, self.msg);
        println!(&quot;{:?}&quot;, self.v);
    }
}
</code></pre>
<p>它的內存佈局和結構體的一樣，並沒有什麼特殊的。</p>
<img src="rust/images/202205042120232.png" height=200px />
<p>這個模式在其他地方也遵循，比如 異步生態中大量使用的 Future 特徵。在內存中編譯器會使用枚舉表示實際的對象，併為這個枚舉實現 Future
特徵。這裡不會詳細講解 Future 的實現細節，我提供了一個鏈接，視頻裡詳細的解釋了異步函數的實現細節。</p>
<h2 id="資料"><a class="header" href="#資料">資料</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZHP9sUqB3Qs">異步函數的一生 RustFest Barcelona - Tyler Mandry: Life of an async fn</a></li>
<li><a href="https://lwn.net/Articles/738975/">堆棧 KAISER: hiding the kernel from user space</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/virtual-address-spaces">虛擬地址空間 Virtual address spaces</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="學習順序"><a class="header" href="#學習順序">學習順序</a></h2>
<p>Rust 是一個學習曲線比較陡峭的語言，即使有其他語言基礎，如果沒有先讀書，而是直接上，那在 compile 階段就會有很多挫折並且無法理解。以下是我覺得對已經有其他語言基礎的人，用這樣的學習順序是不錯的</p>
<ol>
<li><a href="https://tourofrust.com/TOC_zh-tw.html">Rust 語言之旅</a>：1 - 3 天就可以走完，並且因為是使用 playground，可以同時改改他的範例額外觀察一些自己有興趣的行為。走完之後大概會對於 Rust 與其他語言的差別有些感覺</li>
<li><a href="https://doc.rust-lang.org/book/">Rust book</a>：Offical 的教學文，雖然寫的不算瑣碎，但若一開始就看這個可能還是會讓人失去耐心，畢竟一次會累績接收太多新東西。如果已經有了步驟 1，對於 Rust 跟其他語言的異同有感覺，那很多部分就可以參照其他本來就會的語言，因此有一個立足點，比較不會太挫折並失去耐心。不一定要一行一行看的很仔細，因為其實畢竟光看也會真的懂，所以就只是大概知道有哪些東西有個印象就行。可能會花到一週以上的時間，取決於看得多仔細以及多久失去耐心… 和下一步的 <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a> 順序可能可以調換，看你的習慣是比較喜歡讀書還是看 code…，如果很不愛讀文字的話甚至也可以跳過 Rust book，直接從 <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a> 開始也可以，如果有 Example 看不懂的地方再來翻翻看 Rust book</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a>：一些基礎 pattern 的範例，可以熟悉 Rust 語法和他的一些特別設計，尤其如 <a href="https://doc.rust-lang.org/stable/rust-by-example/custom_types/enum/testcase_linked_list.html">Enum</a>、<code>match</code>、<a href="https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html">Closure</a>… 等等其他語言可能也有，但 Rust 卻在其上花更多功夫的部分。全部大概 3 天以內可以看完。如果有無法理解的地方，可能還是要回去翻 <a href="https://doc.rust-lang.org/book/">Rust book</a></li>
</ol>
<p>到這裡就結束了讀書階段，總共花了 1~2 週的時間，往下就是練習了</p>
<ol>
<li><a href="https://cheats.rs/">Chest sheet</a>：可以開始上工了，學習語言這種東西是沒辦法只用看的，開始著手寫 project 才能真的學會，寫的過程就可以快速用這個 Chest sheet 查看語法，大部分在 <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a> 介紹到的 pattern 都有被以一行簡潔的收錄在 Chest sheet，反過來說，若看了 Chest sheet 還是有疑惑，可以回去翻 <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a></li>
<li><a href="https://github.com/rust-lang/rustlings/">rustlings</a>：Rust 官方提供的練習，可以開始練習小程式，範圍有可能是單一 <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a>，也有可能是複合。其實 rustlings 基本上就是 <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a>，只是之前 Rust by Example 你可能就只是光看，透過 rustlings 你可以真的動手寫一次，過程中 <a href="https://cheats.rs/">Chest sheet</a> 就是好幫手</li>
<li><a href="https://rust-algo.club/index.html">Rust Algorithm Club</a>：基礎演衣料結構和算法的實作</li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust cookbook</a>：完成之前的步驟之後，你基本上已經可以用 Rust 完成大部分的需求，但可以進一步再讀這個 Rust cookbook。他是官方收集了常用的情境，示範最專業的寫法。在往後你的實際專案中，你的程式的需求一定都用得到這些東西，也就是說當成為一個職業 Rust developer，<a href="https://cheats.rs/">Chest sheet</a>、<a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a>、<a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust cookbook</a> 就是三個開在旁邊隨時參考的東西。其實，如果是其他語言，當想找什麼語法我們可能都會選擇直接 Google，然後就會看到吐出 Stack Overflow 的結果可以直接參考，不過可能 Rust 是一個相對新的語言，加上他的學習曲線比較陡峭，所以 Stack Overflow 的回答可能會出現不太正確或者過於模糊的狀況，所以才建議從官方資源出發，扎實一點的學，往後就可以更有能力判斷別人的回答是對是錯。也不用全看啦，瀏覽一下他有哪些範例，然後挑幾個有興趣看一下就可以，之後真的開始寫專案，要來複製貼上的時候，再來把他看懂就可以</li>
<li>另外也有非官方的練習如 <a href="https://exercism.io/my/tracks/rust">Exercism</a> 提供更進階的題目。LeetCode 也有 Rust 啦，不過他畢竟主要是 for 面試情境，所以是以思考演算法為主要導向的，因此用高階一點的語言去刷比如 Python, Java 還是比較適合的。Rust 作為一個 system programming language，直接用它來開始寫 system application 就很好</li>
<li>可以開始寫完整的 project 了，如果沒有主題的話，可以從 <a href="https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html">Rust book 建議的</a> 開始</li>
</ol>
<hr />
<h2 id="chest-sheet"><a class="header" href="#chest-sheet">Chest sheet</a></h2>
<p><a href="https://cheats.rs/">Chest sheet</a></p>
<h3 id="reference-1"><a class="header" href="#reference-1">Reference</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust cookbook</a></li>
<li><a href="https://rust-algo.club/index.html">Rust Algorithm Club</a></li>
<li><a href="https://doc.rust-lang.org/std/">Official std</a></li>
</ul>
<h3 id="data-type"><a class="header" href="#data-type">Data Type</a></h3>
<h4 id="basic"><a class="header" href="#basic">Basic</a></h4>
<ul>
<li>
<p>integer</p>
<blockquote>
<p>Length Signed Unsigned
8-bit <code>i8</code> <code>u8</code>
16-bit <code>i16</code> <code>u16</code>
32-bit <code>i32</code>(default) <code>u32</code>
64-bit <code>i64</code> <code>u64</code>
128-bit <code>i128</code> <code>u128</code>
arch <code>isize</code> <code>usize</code></p>
</blockquote>
</li>
<li>
<p>float: <code>f32</code>, <code>f64</code>(default)</p>
</li>
<li>
<p><code>bool</code></p>
</li>
<li>
<p><code>char</code>: Fixed 4 bytes in size and represents a Unicode Scalar Value</p>
</li>
</ul>
<h4 id="advanced"><a class="header" href="#advanced">Advanced</a></h4>
<ul>
<li><strong>Tuple</strong>: <code>()</code> Fixed length. Group different types.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup = (500, 6.4, 1);
let (x, y, z) = tup; // it's copying, not moving because it's on stack
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>Array</strong>: <code>[]</code> Same type. Fixed length</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5]; //[3 ,3 ,3, 3, ,3]

let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = a[1];
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="https://chungchris.github.io/2021/06/30/software/language/rust-note/#toc-heading-18">Vector</a></li>
<li><a href="https://chungchris.github.io/2021/06/30/software/language/rust-note/#toc-heading-12">string</a></li>
<li><a href="https://chungchris.github.io/2021/06/30/software/language/rust-note/#toc-heading-19">HashMap</a></li>
</ul>
<hr />
<blockquote>
<p>往下是我自己補充 Chest sheet 中沒有的，或者一些比較難懂的概念</p>
</blockquote>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Rust 的 <code>*</code> 和 <code>&amp;</code> 在一開始不建議直接用 C 的方式來理解，而建議理解為 <code>&amp;</code> 表達的是 <code>借用</code>，而不是 <code>取址</code>。
雖然其實基礎上就都是 reference，所以以底層來說實際上跟 C 差異不大，只是語法上如果直接想成跟 C 一樣，那會有好些 compile error 無法順利理解。</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
}

fn do_something(f: Foo) {
    println!(&quot;{}&quot;, f.x);
    // f is dropped here
}

fn main() {
    let mut foo = Foo { x: 42 };
    let f = &amp;mut foo;

    // FAILURE: do_something(foo) would fail because
    // foo cannot be moved while mutably borrowed

    // FAILURE: foo.x = 13; would fail here because
    // foo is not modifiable while mutably borrowed

    f.x = 13;
    // f is dropped here because it's no longer used after this point
    
    println!(&quot;{}&quot;, foo.x);
    
    // this works now because all mutable references were dropped
    foo.x = 7;
    
    // move foo's ownership to a function
    do_something(foo);
}
</code></pre></pre>
<ul>
<li>Rust 只允許 一個 mut reference 或者 多個 unmut reference，但不會同時發生</li>
<li>一個 reference 絕對不能活得比它的擁有者還長</li>
</ul>
<p>對於借用而來的變數，操作時會使用到 <code>*</code>，雖然也叫做 <code>dereferencing</code>，但在 rust 來說一樣是要用 ownership 的概念來準確理解。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut foo = 42;
    let f = &amp;mut foo;
    let bar = *f; // get a copy of the owner's value
    *f = 13;      // set the reference's owner's value
    println!(&quot;{}&quot;, bar);
    println!(&quot;{}&quot;, foo);
}
</code></pre></pre>
<p>注意 <code>let bar = *f</code> 是讓 bar 得到 f 的值的複製品，前提是 f 的型別有 Copy 屬性。</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Borrow checker 其實是個大魔王，他非常嚴格，可以寫寫這一題例子就會更有感覺
[<a href="https://chungchris.github.io/2021/07/09/software/leecode/Remove-Nth-Node-From-End-of-List/#toc-heading-5">LeeCode] #19 Remove Nth Node From End of List</a></p>
<hr />
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<p>Lifetime 就是為了 borrow checker 而存在，確保一個 reference 一定不會 refer 到一塊已經死掉的實體。大部分的狀況都 Elision，編譯器會幫忙補上，但編譯器無法判斷的狀況自然就要自己寫</p>
<pre><pre class="playground"><code class="language-rust">// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    let y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // Create variables to be borrowed below.
    let (four, nine) = (4, 9);
    
    // Borrows (`&amp;`) of both variables are passed into the function.
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}
</code></pre></pre>
<p><code>fn failed_borrow&lt;'a&gt;()</code> 代表 <code>'a</code> 這個 lifetime 要 &gt;= <code>failed_borrow()</code> 這個 funtcion 的 lifetime
但 <code>main()</code> 裡面呼叫到 <code>failed_borrow()</code> 的時候，沒有指定 <code>'a</code> 是什麼，那就預設 <code>'a</code> 就是 <code>'static</code>，而 <code>'static</code> 這個 lifetime 一定 &gt;= <code>failed_borrow()</code> 的 lifetime</p>
<p><code>fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code> 規範 <code>print_refs()</code> 這個 function 的 lifetime，一定要 &lt;= <code>'a</code>,<code>'b</code> 這兩個 lifetime，也就是他的兩個參數的 lifetime</p>
<h3 id="coercion"><a class="header" href="#coercion">Coercion</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}
<span class="boring">}
</span></code></pre></pre>
<p><code>first</code> <code>second</code> 兩個參數的 lifetime 不見得相同，但會取其小者，有就是 <code>multiply()</code> 這個 function 的 lifetime 一定要小於等於其兩個參數之中 lifetime 更小的那個</p>
<h3 id="static"><a class="header" href="#static">static</a></h3>
<ul>
<li>
<p>一個靜態變量是在編譯時間就被產生的記憶體資源，它從程式一開始就存在，直到結束</p>
</li>
<li>
<p>一定要明確的表示型別</p>
</li>
<li>
<p>永遠不會被 <code>drop</code></p>
</li>
<li>
<p>如果靜態生命週期資源包含了 reference，那它們必須都得是 <code>static</code></p>
</li>
<li>
<p>修改靜態變量本質上就是危險的，因為任何人在任何地方都可以存取它們，而這有可能會造成 data racing</p>
</li>
<li>
<p>Rust 允許使用 <code>unsafe { ... }</code> 操作一些編譯器無法確保的記憶體行為</p>
</li>
</ul>
<hr />
<h2 id="collections--string"><a class="header" href="#collections--string">Collections- string</a></h2>
<p><code>utf-8</code>，有 1-4 個 bytes 的<em>可變長度</em></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = &quot;hi 🦀&quot;;
    println!(&quot;{}&quot;, a.len());
    let first_word = &amp;a[0..2]; // 2 bytes =&gt; 2 Eng chars
    let second_word = &amp;a[3..7]; // 4 bytes =&gt; 1 emoji
    // let half_crab = &amp;a[3..5]; FAILS
    // Rust does not accept slices of invalid unicode characters
    println!(&quot;{} {}&quot;, first_word, second_word);
}
</code></pre></pre>
<pre><code class="language-bash">7
hi 🦀
</code></pre>
<p>因為可變長度的關係，查找字元時無法快速地以 <code>O(1)</code> 常數時間用索引完成，例如以 <code>my_text[3]</code> 取得第 4 個元)。取而代之的是必定得迭代整個 <code>utf-8</code> 位元序列，才有辦法知道各個 char 的開始點，所以是 <code>O(n)</code> 線性時間</p>
<h3 id="push_str--to_uppercase-to_lowercase-trim-replace-concat-join"><a class="header" href="#push_str--to_uppercase-to_lowercase-trim-replace-concat-join">push_str, +, to_uppercase, to_lowercase, trim, replace, concat, join</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut helloworld = String::from(&quot;hello&quot;);
    helloworld.push_str(&quot; world&quot;);
    helloworld = helloworld + &quot;!&quot;;
    println!(&quot;{}&quot;, helloworld);
    println!(&quot;{}&quot;, helloworld.to_uppercase());
    println!(&quot;{}&quot;, helloworld.trim()); // 切除空白
    println!(&quot;{}&quot;, helloworld.replace(&quot;world&quot;, &quot;taiwan&quot;));

    let helloworld = [&quot;hello&quot;, &quot; &quot;, &quot;world&quot;, &quot;!&quot;].concat();
    let abc = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].join(&quot;,&quot;);
    println!(&quot;{}&quot;, helloworld);
    println!(&quot;{}&quot;,abc);
}
</code></pre></pre>
<pre><code class="language-bash">hello world!
HELLO WORLD!
hello world!
hello taiwan!
hello world!
a,b,c
</code></pre>
<h3 id="to_string-parse"><a class="header" href="#to_string-parse">to_string, parse</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), std::num::ParseIntError&gt; {
    let a = 42;
    let a_string = a.to_string();
    let b = a_string.parse::&lt;i32&gt;()?;
    println!(&quot;{} {}&quot;, a, b);
    Ok(())
}
</code></pre></pre>
<h3 id="format"><a class="header" href="#format">format!</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>format!(&quot;Hello&quot;);                 // =&gt; &quot;Hello&quot;
format!(&quot;Hello, {}!&quot;, &quot;world&quot;);   // =&gt; &quot;Hello, world!&quot;
format!(&quot;The number is {}&quot;, 1);   // =&gt; &quot;The number is 1&quot;
format!(&quot;{:?}&quot;, (3, 4));          // =&gt; &quot;(3, 4)&quot;
format!(&quot;{value}&quot;, value=4);      // =&gt; &quot;4&quot;
format!(&quot;{} {}&quot;, 1, 2);           // =&gt; &quot;1 2&quot;
format!(&quot;{:04}&quot;, 42);             // =&gt; &quot;0042&quot; with leading zeros
format!(&quot;{:#?}&quot;, (100, 200));     // =&gt; &quot;(
                                  //       100,
                                  //       200,
                                  //     )&quot;
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/">more…</a></p>
<h3 id="include_str"><a class="header" href="#include_str">include_str</a></h3>
<p>如果你有一些非常長的文字，可以考慮使用 marco <code>include_str!</code> 將 string 從 file 讀到程式裡</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_html = include_str!(&quot;hello.html&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="chars"><a class="header" href="#chars">chars</a></h3>
<p>Rust 提供了一個方法可以取得一個 <code>utf-8</code> 位元組的字元向量，它的型別是 <code>char</code>。一個 <code>char</code> 的大小永遠是 4 bytes</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // collect the characters as a vector of char
    let chars = &quot;hi 🦀&quot;.chars().collect::&lt;Vec&lt;char&gt;&gt;();
    println!(&quot;{}&quot;, chars.len()); // should be 4
    // since chars are 4 bytes we can convert to u32
    println!(&quot;{}&quot;, chars[3] as u32);
}
</code></pre></pre>
<p><code>string</code> 的 <code>chars()</code> 方法將 string 分離為各個有意義的 character，並放入空間一律為 4 bytes 的 <code>char</code> 型別中，串成一個 <code>Vec</code> 回傳。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in my_str.chars() { 
    // do something with `c`
}

for (i, c) in my_str.chars().enumerate() {
    // do something with character `c` and index `i`
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2 id="collections--vector"><a class="header" href="#collections--vector">Collections- Vector</a></h2>
<ul>
<li>can only store values of the same type</li>
<li>puts all the values next to each other in memory</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Iterators can be collected into vectors
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    let mut xs = vec![1 i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // Insert new element at the end of the vector
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // Error! Immutable vectors can't grow
    collected_iterator.push(0);
    // FIXME ^ Comment out this line

    // The `len` method yields the number of elements currently stored in a vector
    println!(&quot;Vector length: {}&quot;, xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` removes the last element from the vector and returns it
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // Out of bounds indexing yields a panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<hr />
<h2 id="collections--hashmap"><a class="header" href="#collections--hashmap">Collections- HashMap</a></h2>
<p>All of the keys must have the same type, and all of the values must have the same type. Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in HashMap. This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code></li>
<li>You can easily implement Eq and Hash for a custom type with just one line: <code>#[derive(PartialEq, Eq, Hash)]</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
// `HashMap::insert()` returns `None`
// if the inserted value is new, `Some(value)` otherwise
scores.insert(String::from(&quot;Blue&quot;), 10);
let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50); // Only Inserting a Value If the Key Has No Value

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}

contacts.remove(&amp;&quot;Yellow&quot;); 

let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];
let mut scores: HashMap&lt;_, _&gt; =
    teams.into_iter().zip(initial_scores.into_iter()).collect();

// `HashMap::iter()` returns an iterator that yields 
// (&amp;'a key, &amp;'a value) pairs in arbitrary order.
for (name, &amp;number) in teams.iter() {
    println!(&quot;Calling {}: {}&quot;, name, call(number)); 
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="hashset"><a class="header" href="#hashset">HashSet</a></h3>
<p>Consider a HashSet as a HashMap where we just care about the keys ( <code>HashSet&lt;T&gt;</code> is, in actuality, just a wrapper around <code>HashMap&lt;T, ()&gt;</code>).
A HashSet’s unique feature is that it is guaranteed to not have duplicate elements. That’s the contract that any set collection fulfills. HashSet is just one implementation.</p>
<hr />
<h2 id="trait"><a class="header" href="#trait">Trait</a></h2>
<ul>
<li>可理解為其他語言（如 python）的 <code>Interface</code></li>
<li>Trait 裡面的 method 可以有 default 實作，但他無法操作 struct 的 inner fields，也就是說一個 trait 只能定義需要有哪些 method，無法定義需要有哪些成員</li>
<li>trait 可以繼承另一個 trait (<code>Supertraits</code>)：<code>trait LoudNoiseMaker: NoiseMaker</code>。代表 <code>LoudNoiseMaker</code> 也要有 <code>NoiseMaker</code> 規範的所有 method</li>
</ul>
<h3 id="handling-unsized-data"><a class="header" href="#handling-unsized-data">Handling Unsized Data</a></h3>
<p>When we want to store them within another struct, traits obfuscate the original struct thus it also obfuscates the original size. Unsized values being stored in structs are handled in two ways in Rust:</p>
<ul>
<li>generics - Using parameterized types effectively create struct/functions known types and thus known sizes. 即使用 <code>impl Trait</code></li>
<li>indirection - Putting instances on the heap gives us a level of indirection that allow us to not have to worry about the size of the actual type and just store a pointer to it. 即使用 <code>Box&lt;dyn Trait&gt;</code></li>
</ul>
<h3 id="trait-bound-aka-impl-trait"><a class="header" href="#trait-bound-aka-impl-trait">Trait bound (a.k.a. impl Trait)</a></h3>
<pre><pre class="playground"><code class="language-rust">fn animal_talk(a: impl Animal) {
  a.talk();
}
/* same as
fn animal_talk&lt;T&gt;(a: T)
where
    T: Animal
{
  a.talk();
}
*/

fn main() {
  let c = Cat{};
  let d = Dog{};
 
  animal_talk(c);
  animal_talk(d);
}
</code></pre></pre>
<p><code>impl Animal</code> There is no <code>&amp;</code> there. <code>impl</code> here makes the compiler determine the type at the compile time. One that takes Dog and another that takes Cat. This is called monomorphization and will not have any runtime overhead.</p>
<p>For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn animal () -&gt; impl Animal {
  if (is_dog_available()) {
    return Dog {};
  }
  Cat {}
}
<span class="boring">}
</span></code></pre></pre>
<p>It fails! because, the types here are determined at the compile time (static dispatch) .</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn animal() -&gt; Box&lt;dyn Animal&gt; {
  if (is_dog_available()) {
    return Box::new(Dog {});
  } 
    
  Box::new(Cat {})
}
<span class="boring">}
</span></code></pre></pre>
<p>This works!</p>
<h3 id="static-vs-dynamic-dispatch-aka-dyn-trait"><a class="header" href="#static-vs-dynamic-dispatch-aka-dyn-trait">Static vs Dynamic Dispatch (a.k.a. dyn Trait)</a></h3>
<p><code>&amp;dyn NoiseMaker</code> is a <code>trait object</code>. It represents a pointer to the concrete type and a pointer to a vtable of function pointers. (<code>Box&lt;dyn Animal&gt;</code>, <code>Rc&lt;dyn Animal&gt;</code> are also trait Objects.) A <code>trait object</code> is what allows us to indirectly call the correct methods of an instance. A <code>trait object</code> is a struct that holds the pointer of our instance with a <code>list</code> of function pointers to our instance’s methods. This <code>list</code> of functions is known in <code>C++</code> as a <code>vtable</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct SeaCreature {
    pub name: String,
    noise: String,
}

impl SeaCreature {
    pub fn get_sound(&amp;self) -&gt; &amp;str {
        &amp;self.noise
    }
}

trait NoiseMaker {
    fn make_noise(&amp;self);
}

impl NoiseMaker for SeaCreature {
    fn make_noise(&amp;self) {
        println!(&quot;{}&quot;, &amp;self.get_sound());
    }
}

fn static_make_noise(creature: &amp;SeaCreature) {
    // we know the real type
    creature.make_noise();
}

fn dynamic_make_noise(noise_maker: &amp;dyn NoiseMaker) {
    // we don't know the real type
    noise_maker.make_noise();
}

fn main() {
    let creature = SeaCreature {
        name: String::from(&quot;Ferris&quot;),
        noise: String::from(&quot;blub&quot;),
    };
    static_make_noise(&amp;creature);
    dynamic_make_noise(&amp;creature);
}
</code></pre></pre>
<p>Dynamic dispatch is slightly slower because of the pointer chasing to find the real function call.</p>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, PartialOrd)]
<span class="boring">}
</span></code></pre></pre>
<p>讓編譯器自動幫忙補上一些基本的 trait，如下</p>
<ul>
<li>Comparison traits: <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code>.</li>
<li><code>Clone</code>, to create <code>T</code> from <code>&amp;T</code> via a copy. Introduce <code>.clone().</code></li>
<li><code>Copy</code>, to give a type ‘copy semantics’ instead of ‘move semantics’. Introct <code>.copy()</code>.</li>
<li><code>Hash</code>, to compute a hash from <code>&amp;T</code>.</li>
<li><code>Default</code>, to create an empty instance of a data type.</li>
<li><code>Debug</code>, to format a value using the <code>{:?}</code> formatter.</li>
<li><code>Add</code>, <code>Sub</code>, inctoduce <code>+</code>, <code>-</code> operators.</li>
<li><code>Drop</code>, you can override <code>.drop()</code></li>
<li><code>Iterator</code></li>
</ul>
<hr />
<h2 id="rc-arc-refcell-mutex"><a class="header" href="#rc-arc-refcell-mutex">Rc, Arc, Refcell, Mutex</a></h2>
<p><code>Rc</code>. Reference Count. 用來裝一個 (smart) pointer，如此便提供了 <code>clone()</code> 的能力，也就是兩個不同的 pointer 指向同一塊資料。
(<a href="https://tourofrust.com/95_zh-tw.html">為什麼叫 smart pointer 可以參考這裡</a>)
為什麼需要這個？記得 Rust 的理念，ownership 基本上只有一個，所以不是 move 就是 borrow，如果不是 move 也不是 borrow，那隻能 copy，那實際上就是兩塊獨立的資料自然可以各有各的 ownership。藉由單一擁有者，就可以透過該擁有者的作用域（scope），在正確的時間做 drop 回收記憶體。
但若牽扯到指標，就變成要確保已經沒有任何指標指到某一塊資料，才可以 drop，所以需要導入 <code>Rc</code>，只要是透過 Rc clone 的指標都會被記錄，確保在 count 歸零時才把記憶體釋放。</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

struct Pie;

impl Pie {
    fn eat(&amp;self) {
        println!(&quot;tastes better on the heap!&quot;)
    }
}

fn main() {
    let heap_pie = Rc::new(Pie);
    let heap_pie2 = heap_pie.clone();
    let heap_pie3 = heap_pie2.clone();

    heap_pie3.eat();
    heap_pie2.eat();
    heap_pie.eat();

    // all reference count smart pointers are dropped now
    // the heap data Pie finally deallocates
}
</code></pre></pre>
<p><code>Refcell</code> 用來裝一個 (smart) pointer，提供 borrow mutable/immutable references 的能力，好處是 <code>Refcell</code> 負責確保 <em>Only one mutable reference OR multiple immutable references, but not both!</em>
為什麼需要這個？因為 <code>Rc</code> 只提供了複製指標的能力，讓我們可以有複數個指標指向同一塊資料，因此也負責確保了 drop 該資料記憶體的時機。但他沒有確保 mutablility 的部分，同時有兩個活著的 mutable references 指向同一塊資料是危險的。</p>
<p>如下面這例子，<code>ferris</code> 和 <code>sarah</code> 的 pie 其實是指向同一塊資料，並非擁有各自的 pie</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

struct Pie {
    slices: u8,
}

impl Pie {
    fn eat_slice(&amp;mut self, name: &amp;str) {
        println!(&quot;{} took a slice!&quot;, name);
        self.slices -= 1;
    }
}

struct SeaCreature {
    name: String,
    pie: Rc&lt;RefCell&lt;Pie&gt;&gt;,
}

impl SeaCreature {
    fn eat(&amp;self) {
        // use smart pointer to pie for a mutable borrow
        let mut p = self.pie.borrow_mut();
        // take a bite!
        p.eat_slice(&amp;self.name);
    }
}

fn main() {
    let pie = Rc::new(RefCell::new(Pie { slices: 8 }));
    // ferris and sarah are given clones of smart pointer to pie
    let ferris = SeaCreature {
        name: String::from(&quot;ferris&quot;),
        pie: pie.clone(),
    };
    let sarah = SeaCreature {
        name: String::from(&quot;sarah&quot;),
        pie: pie.clone(),
    };
    ferris.eat();
    sarah.eat();

    let p = pie.borrow();
    println!(&quot;{} slices left&quot;, p.slices);
}
</code></pre></pre>
<p>如果說兩個 pointer 會由不同的 thread 擁有，<code>Rc</code> 就要換成使用 <code>Arc</code></p>
<p>且如果說會跨 thread，<code>Refcell</code> 就變成要使用 <code>Mutex</code>。所以經常看到的組合就是</p>
<ul>
<li>within thread: <code>Rc&lt;RefCell&lt;...&gt;&gt;</code></li>
<li>across thread: <code>Arc&lt;Mutex&lt;...&gt;&gt;</code></li>
</ul>
<p>此時可能會產生一個疑問，在跨 thread 狀況下有 data racing 的風險這我們知道，因此需要導入 Arc 和 Mutex 合理；但若為 single thread 的狀況，需要 Rc 來知道 drop 時機可以理解，不過為何需要 Refcell？既然只有 single thread，怎麼可能會有同一時間存在兩個 mutable reference 的狀況？
會有這個疑問可能是忽略了 Rust 畢竟還是一個與 C 相同層級的語言，他是可以提供記憶體位址等級的操作的。也就是說你可以拿到一個 instance 的 address，並透過該 address 對該 instance 操作。問題是，若透過這樣的方式，這些操作就是不是 compiler 可以追蹤到並且介入規範的，自由當然是自由，但風險就要自負。這種操作在 Rust 叫做 <code>Unsafe</code>，比如 dereferencing a raw pointer 操作，只要用 <code>Unsafe</code> block 包起來，Rust compiler 就會不管你裡面的操作。因此，如果我們對於 pointer 這種透過指標去操作一塊資料的行為，都透過 <code>Rc</code>, <code>RefCell</code> 這種 wrapper，那就可以讓 compiler 介入幫我們確保我們對於指標的使用安全，順帶一提，可以想見這個 wrapper 的內部實作終究還是會有 Unsafe block，只是說他在外包了一層，加入了一些 metadata，讓編譯器可以藉由這些 metadata 此來幫助我們追蹤和確保。</p>
<h2 id="conversion"><a class="header" href="#conversion">Conversion</a></h2>
<p>透過 impl <code>From</code> 或 <code>Into</code> 這兩個 traits，可以讓你的 type 擁有 <code>::from()</code> 或 <code>::into()</code> 的方法來做型別轉換</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // Try removing the type declaration
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<p><code>TryFrom</code>/<code>TryInto</code> traits are used for fallible conversions, and as such, return Results.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<hr />
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<h3 id="print-display"><a class="header" href="#print-display">print Display</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::fmt; // Import the `fmt` module.

// Define a structure named `List` containing a `Vec`.
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Extract the value using tuple indexing,
        // and create a reference to `vec`.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // Iterate over `v` in `vec` while enumerating the iteration
        // count in `count`.
        for (count, v) in vec.iter().enumerate() {
            // For every element except the first, add a comma.
            // Use the ? operator to return on errors.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // Close the opened bracket and return a fmt::Result value.
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<hr />
<h2 id="module"><a class="header" href="#module">Module</a></h2>
<ul>
<li>
<p>一個 <em>Program</em> 有一個 <code>main.rs</code>，裡面實作 <code>main()</code> 方法</p>
</li>
<li>
<p>一個 <em>Lib</em> 有一個 root module <code>lib.rs</code>，可以再包含數個 module 作為 submodule</p>
</li>
<li>
<p><em>Program</em> 或者 <em>Lib</em> 都稱為一個 <em>crate</em>，是一個 compilation unit，也可以對應到其他語言 package 的概念，是一個導入第三方函式庫的單位，透過 <code>use</code> 來導入 namespace</p>
</li>
<li>
<p>一個</p>
<p>(Sub)Module</p>
<p>有兩個方式，取決於 code 大小，比如創一個 submodule foo</p>
<ul>
<li><code>./foo.rs</code>：所有該 foo module 的 code 都在這個 rs file 裡</li>
<li><code>./foo/mod.rs</code>：foo 這個資料夾底下還可以有其他 rs file，他們合起來完整 foo 這個 module</li>
</ul>
</li>
<li>
<p>access 一個 (sub)module 與 file path 強相關，並且有三個關鍵字可作為起點</p>
<ul>
<li><code>crate</code> - the root module of your crate</li>
<li><code>super</code> - the parent module of your current module</li>
<li><code>self</code> - the current module</li>
</ul>
</li>
</ul>
<p>所以一個 crate 可能就長這樣</p>
<pre><code class="language-bash">├── lib.rs
├── main.rs
├── submod1.rs
└── submod2
    ├── file1.rs
    ├── file2.rs
    ├── mod.rs
    └── submod3
        ├── file3.rs
        └── mod.rs
</code></pre>
<p>除了 file 層級的 module 劃分，單一 rs 裡面也可以用 <code>mod</code> 定義自己的 submodule</p>
<h3 id="share-lib"><a class="header" href="#share-lib">share lib</a></h3>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p><code>rary</code> is actuaylly refer to the whole acssociated <code>crate</code>. It does not imply only build single <code>rary.rs</code> file.</p>
<p>To using a Library</p>
<pre><pre class="playground"><code class="language-rust">// extern crate rary; // May be required for Rust 2015 edition or earlier
fn main() {
    rary::public_function();
}
</code></pre></pre>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre><code>Option` 和 `Result` 都有 `unwrap()` 和 `?` 可以使用，基本上一個 function 的 return 值建議就是從這兩者選其一，並且不建議 caller 直接使用 `unwarp()` 處理，因為這會造成 `panic
</code></pre>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<p><code>map()</code> 是 <code>Option</code> 提供的方法，參數是一個 <code>closure</code>，他其實就是在這種情境中 match 語法的簡化，如下範例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}
/* instead of
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    match chopped {
        Some(Chopped(food)) =&gt; Some(Cooked(food)),
        None =&gt; None
    }
}
*/
<span class="boring">}
</span></code></pre></pre>
<p>在串兩的都是 return Option 的 function 的時候，如果兩個 function 的 return Option<Type> 相同，那可以直接使用 <code>?</code>；若不同，則要做轉換，但應換成使用 <code>Option</code> 的 <code>and_then()</code> 方法，因為若使用 <code>map()</code>，會多一層 Option，因為 <code>map()</code> 包含一個簡化是會幫你加上 <code>Some()</code> 裝起來</p>
<p>下面這個範例就是串 <code>have_recipe()</code> 和 <code>have_ingredients()</code> 兩個 function</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
    // instead of have_recipe(food).map(|f| have_ingredients(f))
    //   becauset his will return Option&lt;Option&lt;Food&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="as_ref-as_mut"><a class="header" href="#as_ref-as_mut">as_ref(), as_mut()</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Converts from <code>&amp;Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code>.</p>
<p>這東西的重要性在於可以產生一個被包在 Option 裡面的東西的 reference 而不用 take ownership</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Converts from <code>&amp;mut Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Some(2);
match x.as_mut() {
    Some(v) =&gt; *v = 42,
    None =&gt; {},
}
assert_eq!(x, Some(42));
<span class="boring">}
</span></code></pre></pre>
<p>注意轉換過之後都還是包在 <code>Option</code> 裡面</p>
<blockquote>
<p><code>Option</code>, <code>Box</code>, <code>Result</code> 三種類型才有支持預設，其他要實作 <code>AsRef</code> trait</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a = Some(Box::new(5));
    let p1 = a.as_ref(); // p 沒有 take ownership 喔. 5 的 ownership 還是在 a

    println!(&quot;{:?}&quot;, a);
    println!(&quot;{:?}&quot;, p1);
    
    let p11 = p1.unwrap();
    println!(&quot;p11:{:?}&quot;, p11); // 可以透過 p11 拿到 5
    println!(&quot;a:{:?}&quot;, a);
    
    // 以下是犯一些如果不使用 as_ref()，會遇到的 ownership 問題
    
    let p2 = &amp;mut a;
    //let p22 = p2.unwrap(); // cannot move out of `*p2` which is behind a shared reference

    /*let p22 = match *p2 { // cannot move out of `p2.0` which is behind a mutable reference
        Some(v) =&gt; *v, // v: data moved here
        None =&gt; 0
    };*/
    
    let p22 = match *p2 {
        Some(ref v) =&gt; **v, // 處理上面錯誤的方法就是用 ref 來接
        None =&gt; 0
    };
    println!(&quot;p22:{:?} {:p}&quot;, p22, &amp;p22);
    //println!(&quot;a:{:?}&quot;, a); // cannot borrow `a` as immutable because it is also borrowed as mutable
    // 這個時候 5 的 ownership 都還是在 a，所以當這裡要用 a 就會有這個衝突

    let p23 = match p2.take() { // 或者要把原本 a 的 ownership take 過來到 p2，p2 才有權把裡面的東西移去 v
        Some(v) =&gt; *v,
        None =&gt; 0
    };
    println!(&quot;p23:{:?} {:p}&quot;, p23, &amp;p23);
    println!(&quot;a:{:?}&quot;, a); // 因為原本 a 的 ownership 已經被轉移去 p2，所以 a 已經變 None 自然也不再有衝突
}
</code></pre></pre>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p>對於一個 module 而言，最完整的 erro propagation 做法為</p>
<ol>
<li>定義自己的 error 型別，比如 <code>enum MyError {}</code>，列舉各種可能產生的 error，同時也包含當使用到其他 module 時，各個其他 moduel 的 error 歸類到 MyError 中的其中一個可能值</li>
<li><code>impl fmt::Display for MyError</code></li>
<li><code>impl error::Error for MyError</code> 實作 <code>source()</code> 方法，<code>source()</code> 方法使跨抽象層的狀況讓上層 module 也能取得更多其<em>下下層</em> module 的 error 細節的可能性。也就是說，這一步可以不做，但不做的結果就是，假設 某A 使用你的 module，當你的 module 發生了 call 另一個 moduleB 時產生的該 moduleB 的 error 因此導致你的 moduel 也 report error 給 某A，某A 所能得到的唯一資訊就是你翻譯過的 error，無法進一步透過 source() 進到 moduleB 裡去提取更多資訊</li>
<li><code>impl From&lt;OtherModuleErrorType&gt; for MyError</code> 讓 <code>?</code> 可用。也可以不做，若不做就變成當要 call 其他 module 時，要用 <code>method_provided_by_another_module().ok_or(MyError::SomeTranslatedError)?</code> 來做轉換。相當於 <code>?</code> 其實就是會去找 <code>From</code> 方法存不存在，若存在就會依據 From 的內容做轉換</li>
</ol>
<p>下面範例</p>
<pre><pre class="playground"><code class="language-rust">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>假設這就是我們的 module，裡面用了其他兩個 moduel 的方法 <code>first()</code> 和 <code>parse()</code>，他們都會產生各自定義的 error type。下面就是依據上述的步驟改寫的結果，我們定義了自己的 error type <code>DoubleError</code> 把他們包起來並個別翻譯</p>
<pre><pre class="playground"><code class="language-rust">use std::error;
use std::error::Error as _;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // The wrapped error contains additional information and is available
            // via the source() method.
            DoubleError::Parse(..) =&gt;
                write!(f, &quot;the provided string could not be parsed as int&quot;),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    // Here we implicitly use the `ParseIntError` implementation of `From` (which
    // we defined above) in order to create a `DoubleError`.
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; {
            println!(&quot;Error: {}&quot;, e);
            if let Some(source) = e.source() {
                println!(&quot;  Caused by: {}&quot;, source);
            }
        },
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<hr />
<h2 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        let child = thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!(&quot;thread {} finished&quot;, id);
        });

        children.push(child);
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }
    
    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect(&quot;oops! the child thread panicked&quot;);
    }

    // Show the order in which the messages were sent
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<hr />
<h2 id="exec"><a class="header" href="#exec">exec</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;, why),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;, why),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre></pre>
<p>If you’d like to wait for a process::Child to finish, you must call Child::wait, which will return a <code>process::ExitStatus</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre></pre>
<hr />
<h2 id="argument-parsing"><a class="header" href="#argument-parsing">Argument parsing</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        _ =&gt; {
            // show a help message
            help();
        }
    }
}
</code></pre></pre>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://tourofrust.com/TOC_zh-tw.html">Rust 語言之旅</a></li>
<li><a href="https://doc.rust-lang.org/book/">Rust book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a></li>
<li><a href="https://cotigao.medium.com/dyn-impl-and-trait-objects-rust-fd7280521bea">dyn , impl and Trait Objects — Rust</a></li>
</ul>
<p>From: A Po
Author: Chris Chung
Link: https://chungchris.github.io/2021/06/30/software/language/rust-note/
本文章成功權歸作者所有，形式的轉載都請註明出處。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="學-rust-要有大局觀"><a class="header" href="#學-rust-要有大局觀">學 Rust 要有大局觀</a></h1>
<h1 id="crash-rust"><a class="header" href="#crash-rust">Crash Rust</a></h1>
<p>學習一種新的語言，首先需要了解的就是該語言的基本設計思路，工程架構特點，本文希望可以幫住大多數對 Rust 感興趣的同學快速進入具體工程開發，並掃清大部分除基本語法之外的障礙; 具體涉及到的主題包括安裝，運行，發佈，三方包引入等等;</p>
<h2 id="rust-安裝"><a class="header" href="#rust-安裝">Rust 安裝</a></h2>
<h3 id="install"><a class="header" href="#install">install</a></h3>
<p>安裝 Rust 非常簡單，只需要一條命令，但是注意部分機器 curl 版本可能導致命令執行失敗，比如樑小孩自己的開發機 ubuntu20.04 自帶的 curl 提示 ssl 443 錯誤，如果遇到的話，嘗試重新安裝 curl</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h3 id="check"><a class="header" href="#check">check</a></h3>
<p>執行 Rustup 命令, 注意如果是第一次全新安裝, 先執行 <code>source $HOME/.cargo/env</code></p>
<pre><code>root@ecs-x86 :~/docs/Rust/CrashRustIn2Hours# source $HOME/.cargo/env
root@ecs-x86 :~/docs/Rust/CrashRustIn2Hours# rustup
Rustup 1.24.2 (755e2b07e 2021-05-12)
...
</code></pre>
<h2 id="hello-rust"><a class="header" href="#hello-rust">Hello Rust!</a></h2>
<p>接下來我們完成第一個 Rust 項目，功能只有一句打印輸出，但是大家在此章節應該學到的是如何編譯並運行 Rust 代碼程序;</p>
<h3 id="編碼"><a class="header" href="#編碼">編碼</a></h3>
<p>創建第一個<code>rs</code>文件 (<code>hello.rs</code>)，文件內容如下:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;hello Rust!&quot;);
}
</code></pre></pre>
<p>文件目錄結構簡單，代碼目錄下只有一個單獨的<code>hello.rs</code>文件如下:</p>
<pre><code>root@ecs-x86 CrashRustIn2Hours# tree code/
code/
└── hello.rs
0 directories, 1 file
</code></pre>
<h3 id="編譯--執行"><a class="header" href="#編譯--執行">編譯 &amp; 執行</a></h3>
<p>Rust 的編譯器叫做<code>rustc</code>，編譯時直接後跟待編譯的<code>rs</code>文件即可, 不執行輸出文件名則生成同名的可執行文件, 可以直接執行輸出文件得到程序結果</p>
<pre><code>root@ecs-x86 code# rustc hello.rs 
root@ecs-x86 code# tree 
.
├── hello
└── hello.rs
0 directories, 2 files
root@ecs-x86 code# ls -lhF
total 3.3M
-rwxr-xr-x 1 root root 3.3M Jun  2 13:32 hello*
-rw-rw-rw- 1 root root   42 Jun  2 13:29 hello.rs
root@ecs-x86 code# ./hello 
hello Rust!
</code></pre>
<p>到此你看到的是純手工開發流程，包括編譯，文件創建，目錄組織等等都需要自行維護，為了方便工程化，並且快速創建工程，Rust 提供了自己的自動化工具鏈<code>cargo</code>;</p>
<h4 id="hello-cargo"><a class="header" href="#hello-cargo">Hello Cargo!</a></h4>
<p><code>cargo之於Rust</code>猶如<code>npm之於node</code>, <code>cargo</code>可以幫助你維護包依賴關係，安裝三方包，自動編譯代碼，執行結果，完善<code>debug</code>和<code>release</code>的各種部署需求;</p>
<p><code>cargo</code>三板斧:</p>
<p>•<code>cargo init</code> 自動創建工程，包括基本的配置文件，<code>main.rs</code>生成等等</p>
<pre><code>root@ecs-x86 code# cargo init
     Created binary (application) package
root@ecs-x86 code# tree
.
├── Cargo.toml
└── src
    └── main.rs
1 directory, 2 filese
</code></pre>
<p>•<code>cargo run</code> 自動編譯並執行; 注意，此時編譯選項均為 debug 模式，所以 target 目錄下只有一個 debug 目錄自動生成 (可執行文件亦在其中)</p>
<pre><code>root@ecs-x86 code# cargo run
   Compiling code v0.1.0 (/root/docs/Rust/CrashRustIn2Hours/code)
    Finished dev [unoptimized + debuginfo] target(s) in 1.34s
     Running `target/debug/code`
Hello, world!
root@ecs-x86 code# tree -L 2
.
├── Cargo.lock
├── Cargo.toml
├── src
│   └── main.rs
└── target
    ├── CACHEDIR.TAG
    └── debug
</code></pre>
<p>•<code>cargo build</code> 單獨編譯，如果需要單獨 build 可能是最終發佈二進製程序，此時一般附帶參數<code>--release</code></p>
<pre><code>root@ecs-x86 code# cargo build --release
   Compiling code v0.1.0 (/root/docs/Rust/CrashRustIn2Hours/code)
    Finished release [optimized] target(s) in 0.35s
root@ecs-x86 code# tree -L 2
.
├── Cargo.lock
├── Cargo.toml
├── src
│   └── main.rs
└── target
    ├── CACHEDIR.TAG
    ├── debug
    └── release
4 directories, 4 files
</code></pre>
<h2 id="crate-和-module"><a class="header" href="#crate-和-module">crate 和 module</a></h2>
<p>•<code>crate</code>是 rust 對外分發和代碼共享的單位，類似 jar 包，類似 so 庫，是三方庫的概念 •<code>crate</code>是編譯打包的概念 •<code>crate</code>的核心標誌就是一個單獨的<code>Cargo.toml</code>文件，是一個邏輯可編譯的功能庫 •<code>cargo package</code>可以在<code>target/package/</code>目錄下生成對應的<code>*.crate</code>打包文件 •<code>module</code>是模塊的概念，是代碼組織方式，類似於 c++ 的<code>namespace</code>, 類似於 golang 的<code>package</code>的概念 •<code>module</code>的核心標誌是語法層面的<code>use &lt;module_name&gt;</code>的導入和聲明 •<code>module</code>有三種文件組織方式 (假設建立一個叫做<code>string_util</code>的 module)1. 內嵌文件中使用<code>mod string_util { ... }</code>的方式進行定義, 內部可以包含任意多函數，結構體等等 2. 建立一個獨立文件名<code>string_util.rs</code>，內部無上面的顯式<code>mod &lt;module_name&gt;</code>聲明 3. 建立一個文件夾<code>string_util</code>內部包含一個<code>mod.rs</code>文件，還有其他<code>submodule</code>的話文件夾中一般使用第二種創建新文件 • 三者取其一，如果發現都沒有或者有多重情況定義同一個<code>mod</code>的時候 rustc 便會報錯.</p>
<p>關於<code>crate</code>的其他理解可以參考官方 doc 的部分描述:</p>
<blockquote>
<p>A crate is a compilation unit in Rust. Whenever <code>rustc some_file.rs</code> is called, <code>some_file.rs is treated as the crate file.</code> If some_file.rs has mod declarations in it, then the contents of the module files would be inserted in places where mod declarations in the crate file are found, before running the compiler over it. In other words, modules do not get compiled individually, <code>only crates get compiled.</code></p>
</blockquote>
<blockquote>
<p>Rust thinks in modules, not files. There is no such thing as file imports, Important concepts in the Rust Module System are <code>packages</code>, <code>crates</code>, <code>modules</code>, and <code>paths</code></p>
</blockquote>
<p>學習<code>module</code>和<code>crate</code>的時候需要了解的基本前提知識如下:</p>
<blockquote>
<p>rust 的<code>pubilc</code>和<code>private</code>的作用域控制結構體層面提升到了<code>mod</code>範圍，結構體本身沒有類似的概念，這一點相比 c++,java，golang 均不同，此處的修改省去了<code>friend 友元</code>, <code>gettter</code>, <code>setter</code>等等一些列不必要的麻煩, 同一個<code>module</code>內部的所有結構體函數等等可以緊密合作，簡單直接，對外暴露的函數和類型單獨增加<code>pub</code>關鍵字導出, 優雅而且編碼友好</p>
</blockquote>
<h3 id="crate-的直觀理解"><a class="header" href="#crate-的直觀理解">crate 的直觀理解</a></h3>
<p>rust 共享代碼模塊的公網地址為<code>crates.io</code>, 如果使用過<code>maven</code>，<code>rpm</code>等類似工具應該對此類地址並不陌生；</p>
<p>現在我們拆解一個<code>crates.io</code>上下載最多的<code>rand</code>模塊看一下其中的目錄結構，瞭解一下一個 rust crate 大致有什麼樣的目錄和文件結構</p>
<pre><code>➜  rand git:(master) tree -L 1
.
├── CHANGELOG.md
├── COPYRIGHT
├── Cargo.toml       # 核心的Cargo.toml文件
├── LICENSE-APACHE
├── LICENSE-MIT
├── README.md
├── SECURITY.md
├── benches
├── examples
├── rand_chacha
├── rand_core       # 一個單獨的子crate
├── rand_distr
├── rand_hc
├── rand_pcg
├── rustfmt.toml
├── src              # `rand`的src目錄 
└── utils
9 directories, 8 files


## lib.rs 是比較特殊的一個文件名，一個crate一般只有一個，是默認的crate的導出點和入口文件.
➜  rand git:(master) tree -L 1 src
src
├── distributions
├── lib.rs
├── prelude.rs
├── rng.rs
├── rngs
└── seq
3 directories, 3 files
## 仔細研究`rand_core`你會發現它和外部的`rand`是同構的
➜  rand git:(master) tree -L 2 rand_core
rand_core
├── CHANGELOG.md
├── COPYRIGHT
├── Cargo.toml        # `rand_core`的`Cargo.toml` crate描述文件
├── LICENSE-APACHE
├── LICENSE-MIT
├── README.md
└── src
    ├── block.rs
    ├── error.rs
    ├── impls.rs
    ├── le.rs
    ├── lib.rs      # `rand_core`的`src/lib.rs`文件
    └── os.rs
1 directory, 12 files
</code></pre>
<p>可以看到，<code>rand crate</code>本身是以<code>外部依賴</code>其他<code>crate</code>(比如<code>rand_core</code>), 我們自己寫代碼的時候也可以按照這種方式組織代碼，雖然工程上看代碼屬於同一個目錄結構和工程內，但是實際上其中的代碼編譯關係是有明確的分割關係的. 因為<code>crate</code>本質上是類庫的同等地位，所以一個<code>crate</code>只允許一個<code>lib</code> (lib.rs) 編譯入口文件，但是可以允許有多個<code>main</code>函數（依賴核心的 lib.rs）單獨編譯可執行文件 (<code>binary crate</code>);</p>
<h2 id="註釋和文檔"><a class="header" href="#註釋和文檔">註釋和文檔</a></h2>
<p>相比於 C++ 等古老的語言生態，rust 的生態支持解決了太多痛點，比如<code>crates.io</code>的存在保證了代碼的編寫，發佈，文檔的一體化，一切都是簡單的 cargo 命令即可完成；既然說到了文檔，就要知道 cargo 還有<code>cargo doc</code>命令，只要使用<code>markdown編寫的註釋便可直接生成對應的html文檔</code>，其開發友好程度讓人大呼過癮.</p>
<p>rust 的註釋寫法簡單說有如下幾種:</p>
<p>•<code>// 普通註釋</code>，此類註釋<code>cargo doc</code>會忽略 •<code>/// 文檔註釋</code> ，一般函數結構提元素的註釋寫法，內容可以是 markdown 語法，如果包含代碼段，代碼會被自動生成測試代碼 •<code>//! 高層的文檔註釋</code>，此類註釋生成的是高層模塊描述和簡介</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo new --lib myutil
<span class="boring">修改src/lib.rs為如下內容
</span>//! # The first line
//! The second line
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -&gt; i32 {
/// #     x + 1
/// # }
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>以上面代碼為例，生成文檔的過程如下:</p>
<pre><code>cargo doc --no-deps
cargo doc --open
</code></pre>
<p>得到的自動化文檔如下:</p>
<p><img src="rust/images/de23b998195be9dd171682a027da.png" alt="img" /></p>
<h1 id="學-rust-要有大局觀--二--rust-的精髓"><a class="header" href="#學-rust-要有大局觀--二--rust-的精髓">學 Rust 要有大局觀 -二- Rust 的精髓</a></h1>
<p>上一篇 (<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTYyNDU4Nw==&amp;mid=2247483663&amp;idx=1&amp;sn=a3bbd0c90e01328529ac673b43e35254&amp;scene=21#wechat_redirect">學 Rust 要有大局觀</a>) 我們從 rust 的安裝部署，到 cargo 的基本使用，給大家做了科普，為了保證可以降低 Rust 的學習難度，一開始我們必須掃除掉除了基本語法之外的核心難點，這一篇我們關注於<code>所有權</code>（+ 生命週期) 這個 Rust 最難學的部分, 但是樑小孩今天十分鐘之內爭取讓你有學習 Rust 的戰略思維，知道 rust 應該怎麼學～</p>
<h2 id="rust-精髓"><a class="header" href="#rust-精髓">Rust 精髓</a></h2>
<p>我嘗試用幾個簡單的詞彙說明 Rust 的設計精髓和底層原理，方便對比其他語言和 Rust 的不同之處</p>
<p>•Rust 變量具有<code>閱後即焚</code>的特性, 相比之下其他語言的變量都是<code>耐用品</code>, 而 Rust 的變量屬於<code>一次性用品</code>•Rust 語言中<code>變量使用</code>和<code>值擁有</code>是明確區分的，而且其他語言的變量等號基本都是賦值，但是 Rust 是<code>所有權讓渡</code></p>
<h3 id="三種常見的內存模式"><a class="header" href="#三種常見的內存模式">三種常見的內存模式</a></h3>
<p>從下面三行簡單的賦值語句, 我們直觀感受一下 c++，python, 還有 Rust 的不同處理方式</p>
<pre><code class="language-cpp"># c++代碼，僅僅用來說明簡單邏輯
auto s = std::vector&lt;std::string&gt;{ &quot;udon&quot;, &quot;ramen&quot;, &quot;soba&quot; }; 
auto t = s;    // 第一次使用s
auto u = s;    // 第二次使用s
</code></pre>
<h4 id="c-will-copy"><a class="header" href="#c-will-copy">c++ will copy</a></h4>
<p><img src="rust/images/3b21efe1f4060755c36e7301edc8.png" alt="img" /></p>
<p>c++-copy</p>
<p>棧內的變量一直增長 (從左往右)，變量也一直可以被訪問使用. 而且<code>棧到堆的指向關係互相交織</code>(網狀); 由於 C++ 默認採用 copy 的方式進行<code>operator=</code>的操作，即使是<code>std::vector</code>複雜的 STL 結構，都是直接複製, 鑑於這種默認動作開銷比較大，一般程序員會手工引入<code>引用</code>或者<code>指針</code>來優化 (問題隨之而來，棧到堆的指針遲早變成網)</p>
<h4 id="python-will-count"><a class="header" href="#python-will-count">Python will count</a></h4>
<p><img src="rust/images/f0086ccdce0ba6810f77546911d4.png" alt="img" /></p>
<p>python3-count</p>
<p>對於 python 而言，由於有 gc 的存在，gc 採用了<code>reference count</code>技術，所以邏輯層次上多了一個 PyObject 的中間層，保存了計數信息, 由於採用的是計數機制，而 python 棧上的變量都是對同一個值的多個引用，修改其中一個總是會讓其他變量的值也都一起變化</p>
<h4 id="rust-will-move-and-crush"><a class="header" href="#rust-will-move-and-crush">Rust will move (and crush!!)</a></h4>
<p><img src="rust/images/1cc4ecda0adda9c2ea29d6511593.png" alt="img" /></p>
<p>rust-will-move-and-crush</p>
<p>對於 Rust 而言，變量的賦值操作等同於<code>值擁有權的讓渡</code>, 它的意義就是<code>auto t = s;</code>這種語句一旦執行，相當於<code>棧變量t取代了棧變量s,擁有了底層的值</code>, 隨之而來的就是<code>s在編譯階段就被編譯器標識為不再可用</code>; 這是 rust 編譯器處理代碼的邏輯，所以<code>auto u = s;</code>這樣的語句根本不會通過編譯，更無需再考慮代碼執行; x 這一切都發生在代碼分析階段，編譯過程中, 不管是簡單的賦值，還是被函數形參，還是一個值被從函數返回: 都是直接的<code>管理權讓渡</code></p>
<h4 id="思考題"><a class="header" href="#思考題">思考題</a></h4>
<blockquote>
<p>一個 for 循環，內部一個 print 函數打印了上面列表，這樣一個簡單的邏輯不同的語言會出現什麼樣的內存結果?</p>
</blockquote>
<p>•c++ OK, s 可以再次被賦值使用，打印，進行各種操作 •Python OK, s 也可以正常使用 •Rust OK, 可以正常打印，但是 for 訓話結束之後，所有字符串<code>堆中的資源</code>都被釋放了, s 變成了不可再用的變量</p>
<p>好了，是不是感覺<code>太神奇了～～</code>, Rust 對變量的使用就是直接拿來，如果沒有新的上下文接受讓渡, 變量就被直接銷燬了, 這個神奇的設定就是 Rust 有別於其他各種語言，並且會有<code>move sematic</code>，<code>borrow</code>, <code>lifetime</code>的最底層設定, 這就是 rust 的遊戲規則.</p>
<p>簡單發散思考, 這個<code>神奇的move sematic</code>設定會導致什麼樣的直觀現象呢，類似與 c++,java,python 各種語言其實隨著程序一點一點執行，可能會有成百上千的 object 產生，其中的變量指針，引用，copy 互相交織在一起，看起來就會亂糟糟的，這常被稱之為<code>對象之海</code>（如下圖)</p>
<p><img src="rust/images/919a360eb35dfb0aa82d7a3ada97.png" alt="img" /></p>
<p>a sea of objects</p>
<p>由於 rust 特立獨行的底層遊戲規則，不管程序運行了多久，邏輯上看來，不管對象內部有多少子元素，列表還是字典，永遠只有一個 root（擁有它), 再加上我們將要說到的<code>使用權</code>的限制，Rust 的堆棧變量總是非常乾淨清楚 (<code>給你了，你就是owner</code>), 你不會有類似 c++ 中<code>三方庫函數返回了一個指針, 我應該free?</code>的疑問.（如下圖)</p>
<p><img src="rust/images/d1ca7f01ba514f63c9490fe8f5a2.png" alt="img" /></p>
<p>rust object tree</p>
<p>本文簡答說明瞭 Rust 最核心的底層設計，關於所有權的相關內容，我們可以詳細展開了, 敬請期待</p>
<h1 id="學-rust-要有大局觀--三--最痛就這麼痛了"><a class="header" href="#學-rust-要有大局觀--三--最痛就這麼痛了">學 Rust 要有大局觀 -三- 最痛就這麼痛了</a></h1>
<h1 id="導語"><a class="header" href="#導語">導語</a></h1>
<p>讀過上一篇 (<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTYyNDU4Nw==&amp;mid=2247483686&amp;idx=1&amp;sn=4e078a7e273d62fdbda099b908036603&amp;scene=21#wechat_redirect">學 Rust 要有大局觀 (二) Rust 的精髓</a>) 的同學直接給我反饋的問題主要是: 為什麼 Rust 要有<code>move sematic</code>這個神奇設定，你說的都懂，但是好處在哪裡呢？(歡迎大家有問題直接在公眾號 &quot;Rust 工程實踐&quot; 留言提問, 讀者的反饋真的是寫作的原始反饋和動力). 所以在開始今天的<code>reference &amp; lifetime</code>主題之前，我們簡單回顧一下轉移語義到底的好壞之處有哪些:</p>
<h2 id="move-sematic-的好壞"><a class="header" href="#move-sematic-的好壞">move sematic 的好壞</a></h2>
<h3 id="好處rust-的承諾"><a class="header" href="#好處rust-的承諾"><code>好處</code>（rust 的承諾)</a></h3>
<ol>
<li>方便編譯器編譯階段跟蹤內存值的使用情況，可以讓編譯器無比強大地分析堆棧狀態.2. 編譯階段排除了非常多內存不安全的內存 (代碼寫法), 不會存在懸空指針 (<code>dangling pointer</code>)</li>
</ol>
<h3 id="壞處"><a class="header" href="#壞處"><code>壞處</code></a></h3>
<p>• 學習曲線陡峭的重要原因之一，會進一步引出引用，生命週期等概念，容易讓初學者遭遇挫敗感 • 連一個<code>賦值</code>都 TM 編譯不過!?• 為什麼一個 print 打印之後，變量就沒了!?</p>
<h2 id="rust-痛點排行"><a class="header" href="#rust-痛點排行">rust 痛點排行</a></h2>
<p>根據<code>Rust Survey 2020 Results</code>[1] 調查結果顯示，rust 最難學的部分以<code>lifetime</code>排第一位. 全局觀很重要，今天我們就開始帶大家看一看最難的部分到底有多難，<code>最痛也就這麼痛了.</code> 可以看到生存週期，所有權，還有 trait，是大家掌握起來比較棘手主題.</p>
<p><img src="rust/images/03d152a010ed398c27ca4c122b5a.png" alt="img" /></p>
<p>rating-of-topics-difficulties</p>
<h2 id="rust-reference"><a class="header" href="#rust-reference">rust reference</a></h2>
<p>上一篇的末尾我們提到過一個簡單的思考，基於<code>move sematic</code>編寫代碼的時候，一個簡單的 for 循環 print 語句就會導致一個數組變量被使用後釋放掉，這其中的核心原因就是 for 循環語句理論上應該是<code>租借使用權</code>, 而不應該取得<code>所有權</code>; 為瞭解決這個問題，rust 提供了<code>reference類型的可copy變量</code>;</p>
<p>作為一個 c/c++ 程序員的你, 請思考，把上面 for 循環和打印語句作為函數體的情況下 (僅有外部變量的讀取需求)，如果在其他語言中，如此簡單的函數有可能造成程序崩潰嗎？或者會有什麼陷阱?</p>
<p>你的答案可能是這樣的; 函數的參數應該是<code>const &amp;</code>, 常量引用，這樣我即避免了外部變量的拷貝，節省了內存和調用開銷，同時通過 const 保證了不改變使用的變量內容.</p>
<p>我想說的是，這都是沒問題的，但是這樣並不能保證你的<code>完美print</code>函數 core 掉，原因是，你通過<code>const &amp;</code>對編譯器承諾了自己不改變變量，僅僅是使用，也不做 copy，然而<code>gcc</code>編譯器並不給你任何承諾，所以：</p>
<ol>
<li>變量其他地方被改掉了. 你讀取到了奇怪的內容.2. 變量被銷燬了，你讀取到了不應該操作的內存，程序崩掉了.</li>
</ol>
<p>為什麼可以這樣？因為<code>程序員承諾我不修改我使用的內容</code>，但 c++ 語言本身，編譯器並<code>不承諾這個變量它自己不會變</code>(這種承諾不是相互的);</p>
<p>在 Rust 中, 程序員通過<code>borrow</code>得到一個<code>reference</code>來承諾僅讀取，或者肯定會修改一個變量</p>
<p><code>borrow</code>的承諾寫法是在變量前增加一個<code>&amp;</code>, 比如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32 
}
let point = Point { x: 1000, y: 729 };
let r: &amp;Point = &amp;point;     // r現在是point的`只讀使用權`
let rr: &amp;&amp;Point = &amp;r;        // rr現在是`只讀使用權`的`只讀使用權`
let rrr: &amp;&amp;&amp;Point = &amp;rr;    // rr現在是`只讀使用權`的`只讀使用權`的`只讀使用權`
<span class="boring">}
</span></code></pre></pre>
<p>上面的代碼的內存模型是這樣的:</p>
<p><img src="rust/images/0b9b32941a863ab18fd21b06e16e.png" alt="" /></p>
<p>A-chain-of-references-to-references</p>
<p>so~ 很明顯，如果使用<code>r</code>來訪問<code>point</code>的話，並不會影響 point 的所有權關係，即使<code>r被閱後即焚了也不影響point</code>, 內存上它倆使用的<code>棧資源</code>沒關係.</p>
<p>於此同時，編譯器同時許諾你在你使用這個 reference 期間, 任何對原有變量所有權的變動的代碼，及修改，我都拒絕編譯! 編譯器通過如下圖所示的規則來判斷是否拒絕代碼的編譯, 詳細來說，rustc 通過兩條規則來兌現它的承諾 (下圖的中間和最右則情況):</p>
<p><img src="rust/images/c9d886c8d843fa706bfaf2e5543d.png" alt="" /></p>
<p>reference-and-ownership</p>
<p>詳細來說就是，編譯器做代碼靜態分析的時候，僅通過<code>閱讀文本符號</code>就知道是否要編譯此代碼還是直接拒絕繼續編譯代碼，因為<code>borrow</code>語意的語法是精確的，就是程序員給出的承諾. 以一個簡單的結構體來說，內部還有一個其他結構體，那麼它的內存模型大致就是上圖最左邊的樣子 (棧上是變量本身的空間，內容是指向堆內的資源的樹形結構). 下面以程序員要操作<code>結構體內部的結構體子元素</code>為例:</p>
<ol>
<li>當程序員承諾對一個子成員變量僅讀取的時候 (中圖)，編譯器承諾的兌現動作就是 • 對象樹 root 所有權變動的代碼編譯不可以通過 • 修改子成員內容的代碼編譯不可以通過 • 值 owner 也最多做讀取不能再多了 <code>2. 當程序員承諾對一個子成員變量要修改的時候 (右圖)，編譯器承諾的兌現動作就是 •</code>非承諾的引用`之外的所有試圖接觸這個值的代碼都不可以通過 • 即使是通過值的 owner 也不行讀取</li>
</ol>
<p>基於以上兩條規則，請自己編寫 rust 的編譯器，給出下面代碼是否違反給程序員的承諾?(注意同樣的代碼寫法，若是 c++ 肯定是可以通過編譯的)</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = 10;    // v是一個可以改變的變量
    let r = &amp;v;    // `&amp;v` 就是程序員的承諾: 用r(reference)來借用變量v的使用權(讀取)
    let rr = &amp;r;    // 程序員二次承諾還要用rr也讀取v, 並且
    v += 10        // 要改變v了，編譯過還是不過? 
    myprint(r);    // 打印函數, 使用r來訪問 
    myprint(rr);    // 打印函數, 使用rr來訪問
}
</code></pre></pre>
<p>你是否疑惑上面的文字裡，樑小孩反覆地寫程序員得到一個引用是<code>承諾</code>對一個變量做只讀操作? 我就是讀取一下，有什麼要承諾的?</p>
<p>現在我要告訴你，rust 的語法規則之精確，讓你寫任何一句話都是在給編譯器訴說自己的承諾. 比如當你寫一個任意函數的時候，函數的聲明形式就是你給編譯器的承諾, 承諾對變量是如何使用的, 當你承諾只讀，但是函數體內部出現了寫操作，編譯器有權根據你先前的承諾拒絕編譯你的代碼.</p>
<p>再思考另外一種情況，多個變量的函數，一個只讀承諾，一個寫引用的承諾，還有一個是直接 move 語意的所有權取得；這就是你給編譯器的承諾，變量會被函數形參拿去值的所有權，如果使用不當被銷燬，是程序員自己一開始就不應該做出的<code>此函數對所有權負責</code>的承諾. 所以程序員一定要編碼之前想好頂層架構，因為一旦有變動，可能很多函數需要重寫.</p>
<h2 id="生命週期"><a class="header" href="#生命週期">生命週期</a></h2>
<p>為了適應<code>move sematic</code>而引入的<code>borrow &amp; reference</code>會帶來的新的問題是, 讓所有權和使用權發生了切割分離之後，引用和原始值的內存空間獨立，但是二者的邏輯關係要求: 原始值必須存在的前提下，引用才有存在的意義. 如果遇到<code>返回值引用了的函數</code>這樣的代碼是否要停止編譯? 很明顯函數返回了<code>使用權</code>, 如果此時不發生<code>move</code>需要有其他維度幫忙判斷代碼的邏輯合理性. 答案就是需要考慮<code>lifetime</code>生命週期.</p>
<p>從最原始的疑問開始: 你編寫了一個函數，並且返回了一個<code>reference</code>, 假如被引用的值是函數內部 local 變量，那麼基於安全考慮我們要拒絕它，如果引用的傳入參數的某個子元素，那麼我們要知道傳入參數的存活時間能否支撐這個引用是有效的. 所以編譯器一定跟蹤引用和對應變量是否存在衝突的讀寫情況，還要跟蹤每個變量的有效範圍，發現程序員讀寫違反承諾, 或者引用的生命週期不是被引用值生命週期的子集的時候，<code>合情合理</code>地拒絕編譯.</p>
<p><img src="rust/images/15e5dbfd399bfb2b891c616c61bb.png" alt="img" /></p>
<p>reference-with-a-lifetime</p>
<p>說了這麼多，其實只有圖中表示的一個核心原理，那就是 rust 編譯代碼要檢查是否存在像這樣的合理的嵌套 (cover) 關係.</p>
<p>如果事情到此為止的話一切完美，不過有很多中情況作用域的嵌套比上面的例子要更加隱晦, 比如一個結構體的成員<code>borrow</code>的外部資源, 比如一個函數調用其實就是變量進入新的作用域, 這種情況可能還會產生組合: 你得到一個內部包含了<code>reference</code>的結構體作為函數參數， 這時候資源跟蹤情況就很複雜了。此時，rust 編譯器要求你給出<code>明確的關於資源存活時間的承諾</code>. 這種承諾的表現方式就是讓很多同學看不懂的<code>生命週期語法</code>. 我們不關心語法，僅僅是回到原始問題上來，不管什麼樣的語法，我們應該通過這個語法給編譯器傳遞什麼信息呢? 程序員做的任何承諾，rust 編譯器都會仔細檢查，針對這種情況，程序要要做出的承諾無非就是類似<code>我絕對不會胡亂引用</code>這樣的信息，比如<code>我不會引用比結構體本身存活時間還短的變量</code>.</p>
<h3 id="宣稱使用範圍"><a class="header" href="#宣稱使用範圍">宣稱使用範圍</a></h3>
<p>生命週期不是作用域, 是變量被使用的那段時間, 一個結構體有兩個引用類型的成員, 其中一個引用失效時，只要可以保證它也永遠不再被用到，那也是 OK 的. 所以我建議大家將生命週期理解成為程序員宣稱的<code>引用的合理使用範圍</code>;</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    r32: &amp;i32;
    r64: &amp;i64;
}
let s;
<span class="boring">}
</span></code></pre></pre>
<h4 id="給sr32承諾範圍1"><a class="header" href="#給sr32承諾範圍1"><code>給s.r32承諾範圍1</code></a></h4>
<p>1.<code>s.r32</code>存活時間 (reference) 一定要小於等於被引用值的存活時間(所有人都是必死的)2.<code>s.r32</code>存活時間和<code>s</code>一樣 (蘇格拉底是人)3. 所以<code>s</code>的存活時間必須小於等於<code>s.r32</code>引用的值的存活時間 (蘇格拉底是必死的)</p>
<h4 id="給sr64承諾範圍2"><a class="header" href="#給sr64承諾範圍2"><code>給s.r64承諾範圍2</code></a></h4>
<p>1.<code>s.r64</code>存活時間 (reference) 一定要小於等於被引用值的存活時間(所有人都是必死的)2.<code>s.r64</code>存活時間和<code>s</code>一樣 (蘇格拉底是人)3. 所以<code>s</code>的存活時間必須小於等於<code>s.r64</code>引用的值的存活時間 (蘇格拉底是必死的)</p>
<p>三段論裡<code>蘇格拉底是人</code>這個特殊陳述應該是問題的核心，因為當有多個成員變量的時候，被引用的具體值的生命週期可能一樣, r32 和 r64 原始值作用域會不同，但是無論如何<code>s</code>都是兩者之中<code>更小的那一個</code>.</p>
<p>編譯器處理上面的代碼的時候需要程序員承諾: 到底<code>s.r32</code>和<code>s.64</code>的範圍一樣還是不一樣，你若是宣稱一樣，那麼我檢查<code>s</code>的存在多久就可以了，你若是宣稱不一樣, 那麼我就得按照相對小的那個來判斷<code>s</code>的使用範圍是否合理.</p>
<p>OK, 是時候看一下實際代碼了~</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;'a&gt; {
    r32: &amp;'a i32;
    r64: &amp;'a i64;
}
struct S&lt;'a, 'b&gt; {
    r32: &amp;'a i32;
    r64: &amp;'b i64;
}
<span class="boring">}
</span></code></pre></pre>
<p>這就是添加了<code>lifetime</code>聲明的結構體，其中<code>A</code>宣稱<code>A.r32</code>和<code>A.r64</code>的<code>預期使用範圍一樣</code>, 此時 rustc 編譯器按照 A 的實例存活時間判斷就可以了跟蹤實際引用的值是否滿足要求, 但是<code>S</code>現在宣稱<code>S.r32</code>和<code>S.r64</code>是兩個不同的使用範圍，此時 rustc 將分別跟蹤被引用的兩個值的存活時間是否都比<code>S</code>要大.</p>
<p>重新回到<code>返回引用的函數</code>這個原始問題上, 怎麼寫才合適?</p>
<pre><code>// 程序員宣稱函數使用的時候, 返回值使用範圍和入參肯定一樣(或更小), rust會檢查確認是否真的這樣
fn smallest&lt;'a&gt;(v1: &amp;'a [i32], v2:&amp;'a [i32]) -&gt; &amp;'a i32 { ... }
</code></pre>
<p>到這裡你應該明白了，<code>lifetime</code>真的是一個編譯期概念，是程序員做出的承諾，rustc 會根據你的承諾檢查代碼是否是你宣稱的那樣，被引用的值是不是一直比引用時間更久.</p>
<p>到此為止，我們應該可以更清楚地理解一下<code>move sematic</code>到<code>borrow &amp; reference</code>再到<code>liftime</code>的整個邏輯鏈條。他們到底都在解決什麼問題, 這正學習的時候需要大量的例子加深細節把握. 我們僅關心概念和概念提出的場景，解決的問題.</p>
<p>以上是我自己對這些概念的理解和思考，難免會有重大錯誤，但是應該能幫到大家. 下一篇咱們看<code>trait</code>是個什麼東西, 再會～～</p>
<h4 id="引用鏈接"><a class="header" href="#引用鏈接">引用鏈接</a></h4>
<p><code>[1]</code> <code>Rust Survey 2020 Results</code>: <em>https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html</em></p>
<h1 id="學-rust-要有大局觀--四--rust-trait-的概念認知"><a class="header" href="#學-rust-要有大局觀--四--rust-trait-的概念認知">學 Rust 要有大局觀 -四- rust trait 的概念認知</a></h1>
<h1 id="導語-1"><a class="header" href="#導語-1">導語</a></h1>
<p>通過前三篇 (<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTYyNDU4Nw==&amp;mid=2247483686&amp;idx=1&amp;sn=4e078a7e273d62fdbda099b908036603&amp;scene=21#wechat_redirect">學 Rust 要有大局觀 (三)</a>) 我們分別看了<code>move sematic</code>, <code>borrow &amp; reference</code>以及<code>liftime</code>三個核心概念; 之前其實並沒有深入到任何 rust 的語法細節上，或者說盡量規避語法的講解，來到第四篇, 樑小孩仍然希望主要講解核心概念為主，代碼儘量用偽碼, 避免大家進入語法的細枝末節. 今天我們關注<code>traits</code></p>
<h2 id="traits-是什麼"><a class="header" href="#traits-是什麼">traits 是什麼</a></h2>
<p>如果你沒有其他語言中 traits 的認知，那麼你將無法瞬間明白<code>特性</code>這個中文翻譯背後的實際意義，通常大家會說 traits 是 interface，而實際上 interface 和 traits 的關係更像是 “錘子必須可以砸釘子” 和“給錘子添加砸核桃功能”，理解這兩二者的區別之處在於，是否允許 “錘子” 製造的時候就知道它將來可以被用來砸核桃，這個時間差就是理解 traits 和 interface 微妙差異的精髓所在，錘子製造商和錘子使用者通常不是同一個人；換言之：traits 可以作用在一個預定義的類型上，給它添加某些<code>特性</code>, 並且無需修改該類型本身的所有聲明和原始定義的代碼，這樣不接觸原始類型定義和聲明代碼就可以給一個類型添加功能 (function) 的特性 (traits) 使得你無須將 “錘子” 重新封裝成為 “砸核桃工具” 這樣的新類型，沒有了這層封裝，代碼上寫法將靈活許多，第一次體會到這一點的程序員肯定會感覺非常震撼，</p>
<p>本篇的整體精髓大局觀，其實就是上面一段話而已，下面所有內容都是細節，下面讓我們一起看一下 traits 的實際實現細節.</p>
<h2 id="traits-的內存表示"><a class="header" href="#traits-的內存表示">traits 的內存表示</a></h2>
<p>通過如下代碼我們可以得到一個<strong>特型目標</strong>，它在內存中實際上就是一個胖指針.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Write;

let mut buf: Vec&lt;u8&gt; = vec![];
let writer: &amp;mut Write = &amp;mut buf;
<span class="boring">}
</span></code></pre></pre>
<p><img src="rust/images/e9fca92c1519f728a717e461ec4a.png" alt="img" /></p>
<p>vtable</p>
<p>看明白上面圖的內存表示的話，如果你是 C++ 程序員應該就可以說基本上接近掌握了 traits 的精髓了。相比於 c++ 將 vptr 和對象成員保存在一起，rust 中類型數據就是數據本身，單獨實現的 traits 方法則是單獨聚合為一個胖指針這其中的好處非常微妙；明白了這個機制你也就可以知道為什麼對於標準類型 int 和 string 你還可以給它們擴展自己的方法; 而這是 c++ 做不到的。</p>
<p>同時，上面的內存模型是編譯期確定的，這也是 traits 為什麼是一種<code>static dispatch</code>;</p>
<h2 id="語言內置-traits"><a class="header" href="#語言內置-traits">語言內置 traits</a></h2>
<p>rust 語言默認提供了 traits 的常見實現，編譯器可以自動處理已有類型擴展這些 traits；它們分別是：</p>
<p>•Eq, PartialEq, Ord, PartialOrd•Clone, 用來從 &amp;T 創建副本 T。•Copy，使類型具有 “複製語義”（copy semantics）而非 “移動語義”（move semantics）。•Hash，從 &amp;T 計算哈希值（hash）。•Default, 創建數據類型的一個空實例。•Debug，使用 {:?} formatter 來格式化一個值。</p>
<h4 id="內置-traits-用起來就像特定的註解"><a class="header" href="#內置-traits-用起來就像特定的註解">內置 traits 用起來就像特定的註解</a></h4>
<p>閱讀代碼吧，並且體會它與 java 註解的使用體驗，或許你會馬上理解其精髓。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  CppStruct變量綁定、函數參數傳遞、函數返回值傳遞時將被複制, 而不是borrow

// 1. 編譯器支持的Copy traits
 #[derive(Copy, Debug)]
 pub struct CppStruct {
     pub x: i32,
     pub y: i32,
 }

impl Clone for CppStruct {
    fn clone(&amp;self) -&gt; Self {
        Self {
            x: self.x + 1,
            y: self.y + 1,
        }
    }
}

// 2. 用法及生效情況, 注意x1和x2的區別
let x0 = CppStruct { x: 0, y: 1 };
let x1 = x0;
let x2 = x0.clone();
println!(&quot;x1.value={:?}, x1.address={:p}&quot;, x1, &amp;x1);
println!(&quot;x2.value={:?}, x2.address={:p}&quot;, x2, &amp;x2);
println!(&quot;reuse variable x0={:?}, x0.address={:p}&quot;, x0, &amp;x0);

// 輸出結果
x1.value=CppStruct { x: 0, y: 1 }, x1.address=0x16d24f0e8
x2.value=CppStruct { x: 1, y: 2 }, x2.address=0x16d24f0f0
reuse variable x0=CppStruct { x: 0, y: 1 }, x0.address=0x16d24f0e0
<span class="boring">}
</span></code></pre></pre>
<h2 id="編碼自己的-traits"><a class="header" href="#編碼自己的-traits">編碼自己的 traits</a></h2>
<h4 id="自定義-traits-時它更像是一種接口聲明"><a class="header" href="#自定義-traits-時它更像是一種接口聲明">自定義 traits 時，它更像是一種接口聲明</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// STEP1:   抽象一個機器學習Optimizer應該具有的核心功能，定義為一個trait
pub trait Optimizer&lt;'a&gt; {
    // 有默認實現的函數build_params
    fn build_params&lt;U, T: From&lt;U&gt;&gt;(params: Vec&lt;U&gt;) -&gt; Vec&lt;T&gt; {
        let mut vec = Vec::with_capacity(params.len());
        for param in params {
            vec.push(T::from(param));
        }
        vec
    }
    // 無默認實現的函數，get_lr
    fn get_lr(&amp;self) -&gt; f32;

    // 無默認實現的函數，set_lr
    fn set_lr(&amp;self, lr: f32);
}

/// STEP2: 實現一個SGD優化邏輯，並重載核心函數
pub struct SGD&lt;'a, T&gt; {
    params: RefCell&lt;Vec&lt;SGDParam&lt;'a&gt;&gt;&gt;,
    lr: Cell&lt;f32&gt;,
    penalty: T,
}

impl&lt;'a, T: Penalty&gt; Optimizer&lt;'a&gt; for SGD&lt;'a, T&gt; {

    fn get_lr(&amp;self) -&gt; f32 {
        self.lr.get()
    }

    fn set_lr(&amp;self, lr: f32) {
        self.lr.set(lr)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>將 trait 理解為接口是一種很符合直覺的簡化，但是你只要知道它不等同於接口，只是可以<code>用起來很像接口</code></p>
<h2 id="結語20220213-0334-成文"><a class="header" href="#結語20220213-0334-成文">結語（2022/02/13 03:34 成文）</a></h2>
<p>這次關於 trait 最核心的內容就總結到此，實際使用時能明白其中的精髓就好了，關於 trait 的實際功能其實比本次介紹的要更多，但是筆者認為<code>有大局觀，知道它是什麼，對它有清晰的概念認知</code>的話，上面的內容已經足夠。收集更多問題後，後續找更多的例子來詳細展開用法也不遲。</p>
<h1 id="學-rust-要有大局觀--五--屬性的功能"><a class="header" href="#學-rust-要有大局觀--五--屬性的功能">學 Rust 要有大局觀 -五- 屬性的功能</a></h1>
<h2 id="什麼是-attribute"><a class="header" href="#什麼是-attribute">什麼是 attribute？</a></h2>
<p>attribute 是 rust 編譯器留給程序員的交互接口，一段代碼可以編譯產出為二進制機器碼的過程通常來說，用戶的代碼是編譯器的輸入，當編譯器認為代碼有問題，而程序員認為沒問題的時候，必須允許程序員和編譯器有交互，允許程序員指導個別代碼的處理方式。</p>
<p>下面列舉幾個比較有代表性的場景：</p>
<h2 id="讓編譯器閉嘴"><a class="header" href="#讓編譯器閉嘴">讓編譯器閉嘴</a></h2>
<p>rustc 要求結構體的命名需為駱駝體，否則就會給出警告，假如程序員‘故意’要給出一個結構體，但是用了 python 的下劃線命名，為了讓編譯器忽略對命名格式的‘異議’，可以通過</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(non_camlel_case_types)]
<span class="boring">}
</span></code></pre></pre>
<p>這個標記，把它放在結構體聲明之前，編譯器就可以按照程序員的意願主動放過。而不是輸出一堆警告。</p>
<h2 id="讓編譯器臨場應變"><a class="header" href="#讓編譯器臨場應變">讓編譯器臨場應變</a></h2>
<p>所謂的臨場應變經典場景主要是硬件和操作系統環境區別，比如當前這個程序員的操作系統是<code>windows</code>, CPU 架構是<code>x86_64</code>又或者是<code>arm64</code>, 代碼編譯的時候有些別人的代碼確實不可能編譯通過，程序員需要主動處理條件編譯規則，指導編譯器不同架構下同一個代碼應該編譯哪一個具體實現。對應的 attribute 類似<code>#[cfg(windows)]</code>的標記說明具體信息。</p>
<h2 id="讓編譯器改變默認行為"><a class="header" href="#讓編譯器改變默認行為">讓編譯器改變默認行為</a></h2>
<p>rust 瞭解之後你會知道有很多特有的術語，比如‘氧化’表示用 rust 去重寫一些現有的庫，或者用 rust 去實現一個特定的功能，但是畢竟很多東西編譯之後會有一些歷史命名習慣或者接口規則，不能按照 rust 本身的約定輸出，我們可以通過</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![crate_type = &quot;cdylib&quot;]
#![create_name=''crypto3]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>這樣我們得到的名字是<code>libcrypto3.so</code>，我們還特意多加了一個<code>3</code>在<code>o</code>後面，表示這個庫是我們自己用 rust 氧化之後的版本; 否則我們得到的是一個原版命名的<code>libcrate.rlib</code>這樣的 rust 二進制庫名字.</p>
<h2 id="讓編譯器區別對待一些函數和代碼"><a class="header" href="#讓編譯器區別對待一些函數和代碼">讓編譯器區別對待一些函數和代碼</a></h2>
<p>單測就是這樣一個典型場景，相比於其他語言用文件名後綴，前綴，或者是引入某些包單獨編碼而言，rust 支持的更為簡單直接，只要有 <code>#[test]</code>修飾的函數都會標記為測試函數，會在<code>cargo test</code>命令下被拉出來單獨執行。</p>
<h2 id="讓編譯自動添加一些行為"><a class="header" href="#讓編譯自動添加一些行為">讓編譯自動添加一些行為</a></h2>
<p>這個用法就非常多樣了，典型場景是用<code>#[derive(Debug)]</code> 類似的標記好，以便編譯器自動給我們的類型添加特性.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point {
    x:f32,
    y:f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>編譯器現在會給 Point 類自動添加一個<code>fmt</code>函數，這個函數功能類似 java 的<code>toString</code>， 或者 python 的<code>__repr__</code>等，注意：derive 的意義為派生，但這裡並沒有一個<code>默認的父類實現</code>, 代碼都是編譯器根據當前的類程成員變量自動添加並編譯的。</p>
<p><code>derive</code>和<code>trait</code>搭配使用共同左右，想要明白其中細節可以閱讀本系列上關於<code>trait</code>的單獨篇章.</p>
<h2 id="結語"><a class="header" href="#結語">結語</a></h2>
<p>看了一些快速簡單的例子，你應該知道 attribute 這個概念是什麼內涵了，知道了內涵也就明白了概念，遇到的時候就不會有疑惑了。下一篇我們講一下 rust 惱人的宏，用不用不重要，重要的時候通過瞭解 rust，大家一起思考一下手頭使用的語言到底哪裡不好，為什麼有新的設計。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="理解-rust-字符串"><a class="header" href="#理解-rust-字符串">理解 Rust 字符串</a></h1>
<p>Rust 中有多種表示字符串的數據類型，其中最常用的是 str 和 String 兩種類型。</p>
<p><strong>str 類型</strong></p>
<p>Rust 中有一個表示字符串的原始（primitive）類型 str。str 是字符串切片（slice），每個字符串切片具有固定的大小並且是不可變的。通常不能直接訪問 str ，因為切片屬於動態大小類型（DST）。所以，只能通過引用（&amp;str）間接訪問字符串切片。關於這一點，會在以後的文章中介紹。在下面的內容將不加區分的使用 str 和 &amp;str。</p>
<p>可以通過字符串字面量構造 &amp;str 類型的對象：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，字符串字面量的類型是 &amp; 'static str，因為它是被直接儲存在編譯後的二進制文件中的。</p>
<p>還可以使用切片的語法，從一個&amp;str 對象構造出另一個 &amp;str 對象：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ss = &amp;s[..3];
<span class="boring">}
</span></code></pre></pre>
<p>也可以將切片轉換成相應的指針類型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = s as *const str;
<span class="boring">}
</span></code></pre></pre>
<p><strong>String 類型</strong></p>
<p>像大部分常見的編程語言一樣，String 是一個分配在堆上的可增長的字符串類型，它的定義如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct String { 
    vec: Vec&lt;u8&gt; 
}
<span class="boring">}
</span></code></pre></pre>
<p>從源碼可以看出，String 是對 Vec<u8> 的簡單包裝。</p>
<p>String 保存的總是有效的 UTF-8 編碼的字節序列。</p>
<p>構造一個空字符串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p>還可以通過字符串字面量構造 String 類型的對象：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>String 和 &amp;str 之間有著非常緊密的關系，後者可以用來表示前者的被借用（Borrowed）的副本。</p>
<p><strong>str 和 String 類型的轉換</strong></p>
<p>前面已經看到，字符串字面量可以轉換成 String。反過來，String 也可以轉換成str。這是通過解引用操作實現的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Deref for String { 
    fn deref(&amp;self) -&gt; &amp;str { 
        unsafe { str::from_utf8_unchecked(&amp;self.vec) } 
    } 
} 
<span class="boring">}
</span></code></pre></pre>
<p>利用解引用操作就可以將 String 轉換成 str：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: String = String::from(&quot;Hello&quot;);
let ss: &amp;str = &amp;s;
<span class="boring">}
</span></code></pre></pre>
<p>String 還可以連接一個 str 字符串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hello&quot;); 
let b = &quot;, world!&quot;; 
let f = s + b; // f == &quot;Hello, world!&quot;
<span class="boring">}
</span></code></pre></pre>
<p>如果要連接兩個 String 對象，不能簡單地直接相加。必須先通過解引用將後一個對象轉換為 &amp;str 才能進行連接：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hello&quot;);
let b = String::from(&quot;, world!&quot;);
let f = s + &amp;b; // f == &quot;Hello, world!&quot;
<span class="boring">}
</span></code></pre></pre>
<p>注意這裡字符串連接之後，s的所有權發生了轉移，而b的內容復制到了新的字符串中。</p>
<p>從 String 到 str 的轉換是廉價的，反之，從 str 轉為 String 需要分配新的內存。</p>
<p>一般來說，當定義函數的參數時， &amp;str 會比 String 更加通用：因為此時既可以傳遞 &amp;str 對象也可以傳遞 String 對象。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="更新"><a class="header" href="#更新">更新</a></h2>
<p><img src="https://github.com/kumakichi/easy_rust_chs/workflows/github%20pages/badge.svg" alt="example workflow name" /></p>
<p>2021年2月1日: <a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">Youtube視頻</a></p>
<p>2021年1月4日: 支持在線查看 <a href="https://kumakichi.github.io/easy_rust_chs">點擊閱讀</a></p>
<h2 id="介紹-2"><a class="header" href="#介紹-2">介紹</a></h2>
<p>Rust是一種新的語言，已經有了很好的教科書。但是有時候它的教材很難，因為它的教材是給以英語為母語的人看的。現在很多公司和人學習Rust，如果有一本英語簡單的書，他們可以學得更快。這本教材就是給這些公司和人用簡單的英語來學習Rust的。</p>
<p>Rust是一門很新的語言，但已經非常流行。它之所以受歡迎，是因為它給你提供了C或C++的速度和控制力，但也給你提供了Python等其他較新語言的內存安全。它用一些新的想法來實現這一點，這些想法有時與其他語言不同。這意味著有一些新的東西需要學習，你不能只是 &quot;邊走邊想&quot;。Rust是一門語言，你必須思考一段時間才能理解。但如果你懂其他語言的話，它看起來還是很熟悉的，它是為了幫助你寫好代碼而生的。</p>
<h2 id="我是誰"><a class="header" href="#我是誰">我是誰？</a></h2>
<p>我是一個生活在韓國的加拿大人，我在寫Easy Rust的同時，也在思考如何讓這裡的公司開始使用它。我希望其他不以英語為第一語言的國家也能使用它。</p>
<h2 id="簡單英語學rust"><a class="header" href="#簡單英語學rust">簡單英語學Rust</a></h2>
<p><em>簡單英語學Rust</em>寫於2020年7月至8月，長達400多頁。如果你有任何問題，可以在這裡或<a href="https://www.linkedin.com/in/davemacleod">在LinkedIn上</a>或<a href="https://twitter.com/mithridates">在Twitter上</a>聯繫我。如果你發現有什麼不對的地方，或者要提出pull request，請繼續。已經有超過20人幫助我們修復了代碼中的錯別字和問題，所以你也可以。我不是世界上最好的Rust專家，所以我總是喜歡聽到新的想法，或者看看哪裡可以讓這本書變得更好。</p>
<ul>
<li><a href="rust/easy_rust.html#%E7%AC%AC1%E9%83%A8%E5%88%86---%E7%80%8F%E8%A6%BD%E5%99%A8%E4%B8%AD%E7%9A%84Rust">第1部分 - 瀏覽器中的Rust</a>
<ul>
<li><a href="rust/easy_rust.html#rust-playground">Rust Playground</a></li>
<li><a href="rust/easy_rust.html#%E5%92%8C%EF%B8%8F">🚧 and ⚠️</a></li>
<li><a href="rust/easy_rust.html#%E8%A8%BB%E9%87%8B">註釋</a></li>
<li><a href="rust/easy_rust.html#%E9%A1%9E%E5%9E%8B">類型</a>
<ul>
<li><a href="rust/easy_rust.html#%E5%8E%9F%E5%A7%8B%E9%A1%9E%E5%9E%8B">原始類型</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E9%A1%9E%E5%9E%8B%E6%8E%A8%E5%B0%8E">類型推導</a>
<ul>
<li><a href="rust/easy_rust.html#%E6%B5%AE%E9%BB%9E%E6%95%B8">浮點數</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E6%89%93%E5%8D%B0hello-world">打印hello, world!</a>
<ul>
<li><a href="rust/easy_rust.html#%E8%81%B2%E6%98%8E%E8%AE%8A%E9%87%8F%E5%92%8C%E4%BB%A3%E7%A2%BC%E5%A1%8A">聲明變量和代碼塊</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E9%A1%AF%E7%A4%BA%E5%92%8C%E8%AA%BF%E8%A9%A6">顯示和調試</a>
<ul>
<li><a href="rust/easy_rust.html#%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B8">最小和最大的數</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%8F%AF%E8%AE%8A%E6%80%A7">可變性</a>
<ul>
<li><a href="rust/easy_rust.html#%E9%81%AE%E8%94%BD">遮蔽</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E6%A3%A7%E5%A0%86%E5%92%8C%E6%8C%87%E9%87%9D">棧，堆和指針</a></li>
<li><a href="rust/easy_rust.html#%E9%97%9C%E6%96%BC%E6%89%93%E5%8D%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">關於打印的更多信息</a></li>
<li><a href="rust/easy_rust.html#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="rust/easy_rust.html#const%E5%92%8Cstatic">const和static</a></li>
<li><a href="rust/easy_rust.html#%E9%97%9C%E6%96%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">關於引用的更多信息</a></li>
<li><a href="rust/easy_rust.html#%E5%8F%AF%E8%AE%8A%E5%BC%95%E7%94%A8">可變引用</a>
<ul>
<li><a href="rust/easy_rust.html#%E5%86%8D%E8%AB%87shadowing">再談shadowing</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%87%BD%E6%95%B8%E7%9A%84%E5%BC%95%E7%94%A8">函數的引用</a></li>
<li><a href="rust/easy_rust.html#%E6%8B%B7%E8%B2%9D%E9%A1%9E%E5%9E%8B">拷貝類型</a>
<ul>
<li><a href="rust/easy_rust.html#%E7%84%A1%E5%80%BC%E8%AE%8A%E9%87%8F">無值變量</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E9%9B%86%E5%90%88%E9%A1%9E%E5%9E%8B">集合類型</a>
<ul>
<li><a href="rust/easy_rust.html#%E6%95%B8%E7%B5%84">數組</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%90%91%E9%87%8F">向量</a></li>
<li><a href="rust/easy_rust.html#%E5%85%83%E7%B5%84">元組</a></li>
<li><a href="rust/easy_rust.html#%E6%8E%A7%E5%88%B6%E6%B5%81">控制流</a></li>
<li><a href="rust/easy_rust.html#%E7%B5%90%E6%A7%8B%E9%AB%94">結構體</a></li>
<li><a href="rust/easy_rust.html#%E6%9E%9A%E8%88%89">枚舉</a>
<ul>
<li><a href="rust/easy_rust.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A8%AE%E9%A1%9E%E5%9E%8B%E7%9A%84%E6%9E%9A%E8%88%89">使用多種類型的枚舉</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%BE%AA%E7%92%B0">循環</a></li>
<li><a href="rust/easy_rust.html#%E5%AF%A6%E7%8F%BE%E7%B5%90%E6%A7%8B%E5%92%8C%E6%9E%9A%E8%88%89">實現結構和枚舉</a></li>
<li><a href="rust/easy_rust.html#%E8%A7%A3%E6%A7%8B">解構</a></li>
<li><a href="rust/easy_rust.html#%E5%BC%95%E7%94%A8%E5%92%8C%E9%BB%9E%E9%81%8B%E7%AE%97%E7%AC%A6">引用和點運算符</a></li>
<li><a href="rust/easy_rust.html#%E6%B3%9B%E5%9E%8B">泛型</a></li>
<li><a href="rust/easy_rust.html#%E9%81%B8%E9%A0%85%E5%92%8C%E7%B5%90%E6%9E%9C">選項和結果</a>
<ul>
<li><a href="rust/easy_rust.html#%E9%81%B8%E9%A0%85">選項</a></li>
<li><a href="rust/easy_rust.html#%E7%B5%90%E6%9E%9C">結果</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E9%A1%9E%E5%9E%8B">其他集合類型</a>
<ul>
<li><a href="rust/easy_rust.html#HashMap%E5%92%8CBTreeMap">HashMap和BTreeMap</a></li>
<li><a href="rust/easy_rust.html#hashset%E5%92%8Cbtreeset">HashSet和BTreeSet</a></li>
<li><a href="rust/easy_rust.html#%E4%BA%8C%E5%8F%89%E5%A0%86">二叉堆</a></li>
<li><a href="rust/easy_rust.html#vecdeque">VecDeque</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E6%93%8D%E4%BD%9C%E7%AC%A6">?操作符</a>
<ul>
<li><a href="rust/easy_rust.html#when-panic-and-unwrap-are-good">When panic and unwrap are good</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#trait">trait</a>
<ul>
<li><a href="rust/easy_rust.html#from-trait">From trait</a></li>
<li><a href="rust/easy_rust.html#%E5%9C%A8%E5%87%BD%E6%95%B8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C&amp;str">在函數中使用字符串和&amp;str</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E9%8F%88%E5%BC%8F%E6%96%B9%E6%B3%95">鏈式方法</a></li>
<li><a href="rust/easy_rust.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="rust/easy_rust.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">迭代器如何工作</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E9%96%89%E5%8C%85">閉包</a>
<ul>
<li><a href="rust/easy_rust.html#%E9%96%89%E5%8C%85%E4%B8%AD%E7%9A%84_">閉包中的_</a></li>
<li><a href="rust/easy_rust.html#%E9%96%89%E5%8C%85%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%9C%89%E7%94%A8%E6%96%B9%E6%B3%95">閉包和迭代器的有用方法</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#dbg%E5%AE%8F%E5%92%8Cinspect">dbg! 宏和.檢查器</a></li>
<li><a href="rust/easy_rust.html#str%E7%9A%84%E9%A1%9E%E5%9E%8B">&amp;str的類型</a></li>
<li><a href="rust/easy_rust.html#%E7%94%9F%E5%91%BD%E6%9C%9F">生命期</a></li>
<li><a href="rust/easy_rust.html#%E5%85%A7%E9%83%A8%E5%8F%AF%E8%AE%8A%E6%80%A7">內部可變性</a>
<ul>
<li><a href="rust/easy_rust.html#cell">Cell</a></li>
<li><a href="rust/easy_rust.html#refcell">RefCell</a></li>
<li><a href="rust/easy_rust.html#mutex">Mutex</a></li>
<li><a href="rust/easy_rust.html#rwlock">RwLock</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#cow">Cow</a></li>
<li><a href="rust/easy_rust.html#%E9%A1%9E%E5%9E%8B%E5%88%A5%E5%90%8D">類型別名</a>
<ul>
<li><a href="rust/easy_rust.html#%E5%9C%A8%E5%87%BD%E6%95%B8%E4%B8%AD%E5%B0%8E%E5%85%A5%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">在函數中導入和重命名</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#todo%E5%AE%8F">todo!宏</a></li>
<li><a href="rust/easy_rust.html#rc">Rc</a></li>
<li><a href="rust/easy_rust.html#%E5%A4%9A%E7%B7%9A%E7%A8%8B">多線程</a></li>
<li><a href="rust/easy_rust.html#%E5%87%BD%E6%95%B8%E4%B8%AD%E7%9A%84%E9%96%89%E5%8C%85">函數中的閉包</a></li>
<li><a href="rust/easy_rust.html#impl-trait">impl Trait</a></li>
<li><a href="rust/easy_rust.html#arc">Arc</a></li>
<li><a href="rust/easy_rust.html#channels">Channels</a></li>
<li><a href="rust/easy_rust.html#%E9%96%B1%E8%AE%80Rust%E6%96%87%E6%AA%94">閱讀Rust文檔</a>
<ul>
<li><a href="rust/easy_rust.html#assert_eq">assert_eq! </a></li>
<li><a href="rust/easy_rust.html#%E6%90%9C%E7%B4%A2">搜索</a></li>
<li><a href="rust/easy_rust.html#src-%E6%8C%89%E9%88%95">[src]按鈕</a></li>
<li><a href="rust/easy_rust.html#trait%E4%BF%A1%E6%81%AF">trait信息</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%B1%AC%E6%80%A7">屬性</a></li>
<li><a href="rust/easy_rust.html#box">Box</a></li>
<li><a href="rust/easy_rust.html#box-around-traits">Box around traits</a></li>
<li><a href="rust/easy_rust.html#%E9%BB%98%E8%AA%8D%E5%80%BC%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">默認值和建造者模式</a></li>
<li><a href="rust/easy_rust.html#Deref%E5%92%8CDerefMut">Deref和DerefMut</a></li>
<li><a href="rust/easy_rust.html#Crate%E5%92%8C%E6%A8%A1%E5%A1%8A">Crate和模塊</a></li>
<li><a href="rust/easy_rust.html#%E6%B8%AC%E8%A9%A6">測試</a>
<ul>
<li><a href="rust/easy_rust.html#%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E7%9A%84%E9%96%8B%E7%99%BC">測試驅動的開發</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E5%A4%96%E9%83%A8crate">外部crate</a>
<ul>
<li><a href="rust/easy_rust.html#rand">rand</a></li>
<li><a href="rust/easy_rust.html#rayon">rayon</a></li>
<li><a href="rust/easy_rust.html#serde">serde</a></li>
<li><a href="rust/easy_rust.html#regex">regex</a></li>
<li><a href="rust/easy_rust.html#chrono">chrono</a></li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E6%A8%99%E6%BA%96%E5%BA%AB%E4%B9%8B%E6%97%85">標準庫之旅</a>
<ul>
<li><a href="rust/easy_rust.html#%E6%95%B8%E7%B5%84-1">數組</a></li>
<li><a href="rust/easy_rust.html#char">char</a></li>
<li><a href="rust/easy_rust.html#integers">Integer</a></li>
<li><a href="rust/easy_rust.html#floats">Floats</a></li>
<li><a href="rust/easy_rust.html#bool">Bool</a></li>
<li><a href="rust/easy_rust.html#vec">Vec</a></li>
<li><a href="rust/easy_rust.html#string">String</a></li>
<li><a href="rust/easy_rust.html#OsString%E5%92%8CCString">OsString和CString</a></li>
<li><a href="rust/easy_rust.html#mem">Mem</a></li>
<li><a href="rust/easy_rust.html#prelude">Prelude</a></li>
<li><a href="rust/easy_rust.html#time">Time</a></li>
<li><a href="rust/easy_rust.html#%E5%85%B6%E4%BB%96%E5%AE%8F">其他宏</a></li>
<li><a href="rust/easy_rust.html#%E7%B7%A8%E5%AF%AB%E5%AE%8F">編寫宏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="rust/easy_rust.html#%E7%AC%AC2%E9%83%A8%E5%88%86---%E9%9B%BB%E8%85%A6%E4%B8%8A%E7%9A%84Rust">第2部分 - 電腦上的Rust</a>
<ul>
<li><a href="rust/easy_rust.html#cargo">cargo</a></li>
<li><a href="rust/easy_rust.html#%E6%8E%A5%E5%8F%97%E7%94%A8%E6%88%B6%E8%BC%B8%E5%85%A5">接受用戶輸入</a></li>
<li><a href="rust/easy_rust.html#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6">使用文件</a></li>
<li><a href="rust/easy_rust.html#cargo%E6%96%87%E6%AA%94">cargo文檔</a></li>
<li><a href="rust/easy_rust.html#%E7%B5%90%E6%9D%9F%E4%BA%86%E5%97%8E%EF%BC%9F">結束了嗎？</a></li>
</ul>
</li>
</ul>
<h1 id="第1部分---瀏覽器中的rust"><a class="header" href="#第1部分---瀏覽器中的rust">第1部分 - 瀏覽器中的Rust</a></h1>
<p>本書有兩個部分。第1部分，你將在瀏覽器中就能學到儘可能多的Rust知識。實際上你幾乎可以在不安裝Rust的情況下學到所有你需要知道的東西，所以第1部分非常長。最後是第二部分。它要短得多，是關於電腦上的Rust。在這裡，你將學習到其他一切你需要知道的、只能在瀏覽器之外進行的事情。例如:處理文件、接受用戶輸入、圖形和個人設置。希望在第一部分結束時，你會喜歡Rust，以至於你會安裝它。如果你不喜歡，也沒問題--第一部分教了你很多，你不會介意的。</p>
<h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>也許你還不想安裝Rust，這也沒關係。你可以去<a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>，在不離開瀏覽器的情況下開始寫Rust。你可以在那裡寫下你的代碼，然後點擊Run來查看結果。你可以在瀏覽器的Playground裡面運行本書中的大部分示例。只有在接近結尾的時候，你才會看到無法在Playground運行的示例(比如打開文件)。</p>
<p>以下是使用Rust Playground時的一些提示。</p>
<ul>
<li>
<p>用&quot;Run&quot;來運行你的代碼</p>
</li>
<li>
<p>如果你想讓你的代碼更快，就把Debug改為Release。Debug:編譯速度更快，運行速度更慢，包含調試信息。Release:編譯速度更慢，運行速度更快，刪除調試信息。</p>
</li>
<li>
<p>點擊Share，得到一個網址鏈接，你可以用它來分享你的代碼。如果你需要幫助，可以用它來分享你的代碼。點擊分享後，你可以點擊<code>Open a new thread in the Rust user forum</code>，馬上向那裡的人尋求幫助。</p>
</li>
<li>
<p>Rustfmt工具: Rustfmt會很好地格式化你的代碼。</p>
</li>
<li>
<p>TOOLS: Rustfmt會很好地格式化你的代碼。Clippy會給你額外的信息，告訴你如何讓你的代碼更好。</p>
</li>
<li>
<p>CONFIG: 在這裡你可以把你的主題改成黑暗模式，這樣你就可以在晚上工作了，還有很多其他配置。</p>
</li>
</ul>
<p>如果你想安裝Rust，請到這裡<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>，然後按照說明操作。通常你會使用<code>rustup</code>來安裝和更新Rust。</p>
<h2 id="和"><a class="header" href="#和">🚧和⚠️</a></h2>
<p>有時書中的代碼例子不能用。如果一個例子不工作，它將會有一個🚧或⚠️在裡面。🚧就像 &quot;正在建設中&quot;一樣:它意味著代碼不完整。Rust需要一個<code>fn main()</code>(一個主函數)來運行，但有時我們只是想看一些小的代碼，所以它不會有<code>fn main()</code>。這些例子是正確的，但需要一個<code>fn main()</code>讓你運行。而有些代碼示例向你展示了一個問題，我們將解決這個問題。那些可能有一個<code>fn main()</code>，但會產生一個錯誤，所以它們會有一個⚠️。</p>
<h2 id="註釋"><a class="header" href="#註釋">註釋</a></h2>
<p>註釋是給程序員看的，而不是給電腦看的。寫註釋是為了幫助別人理解你的代碼。 這也有利於幫助你以後理解你的代碼。 (很多人寫了很好的代碼，但後來卻忘記了他們為什麼要寫它。)在Rust中寫註釋，你通常使用 <code>//</code>．</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Rust programs start with fn main()
    // You put the code inside a block. It starts with { and ends with }
    let some_number = 100; // We can write as much as we want here and the compiler won't look at it
}
</code></pre></pre>
<p>當你這樣做時，編譯器不會看<code>//</code>右邊的任何東西。</p>
<p>還有一種註釋，你用<code>/*</code>開始寫，<code>*/</code>結束寫。這個寫在你的代碼中間很有用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number/*: i16*/ = 100;
}
</code></pre></pre>
<p>對編譯器來說，<code>let some_number/*: i16*/ = 100;</code>看起來像<code>let some_number = 100;</code>。</p>
<p><code>/* */</code>形式對於超過一行的非常長的註釋也很有用。在這個例子中，你可以看到你需要為每一行寫<code>//</code>。但是如果您輸入 <code>/*</code>，它不會停止，直到您用 <code>*/</code> 完成它。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 100; /* Let me tell you
    a little about this number.
    It's 100, which is my favourite number.
    It's called some_number but actually I think that... */

    let some_number = 100; // Let me tell you
    // a little about this number.
    // It's 100, which is my favourite number.
    // It's called some_number but actually I think that...
}
</code></pre></pre>
<h2 id="類型"><a class="header" href="#類型">類型</a></h2>
<p>Rust有很多類型，讓你可以處理數字、字符等。有些類型很簡單，有些類型比較複雜，你甚至可以創建自己的類型。</p>
<h3 id="原始類型"><a class="header" href="#原始類型">原始類型</a></h3>
<p>Rust有簡單的類型，這些類型被稱為<strong>原始類型</strong>(原始=非常基本)。我們將從整數和<code>char</code>(字符)開始。整數是沒有小數點的整數。整數有兩種類型。</p>
<ul>
<li>有符號的整數</li>
<li>無符號整數</li>
</ul>
<p>符號是指<code>+</code>(加號)和<code>-</code>(減號)，所以有符號的整數可以是正數，也可以是負數(如+8，-8)。但無符號整數只能是正數，因為它們沒有符號。</p>
<p>有符號的整數是 <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, 和 <code>isize</code>。</p>
<p>無符號的整數是 <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, 和 <code>usize</code>。</p>
<p>i或u後面的數字表示該數字的位數，所以位數多的數字可以大一些。8位=一個字節，所以<code>i8</code>是一個字節，<code>i64</code>是8個字節，以此類推。尺寸較大的數字類型可以容納更大的數字。例如，<code>u8</code>最多可以容納255，但<code>u16</code>最多可以容納65535。而<code>u128</code>最多可以容納340282366920938463463374607431768211455。</p>
<p>那麼什麼是<code>isize</code>和<code>usize</code>呢？這表示你電腦的位數。(你的電腦上的位數叫做你電腦的<strong>架構</strong>)。所以32位計算機上的<code>isize</code>和<code>usize</code>就像<code>i32</code>和<code>u32</code>，64位計算機上的<code>isize</code>和<code>usize</code>就像<code>i64</code>和<code>u64</code>。</p>
<p>整數類型不同的原因有很多。其中一個原因是計算機性能:較小的字節數處理速度更快。例如，數字-10作為<code>i8</code>是<code>11110110</code>，但作為<code>i128</code>是<code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>。但這裡還有一些其他用法。</p>
<p>Rust中的字符叫做<code>char</code>. 每一個<code>char</code>都有一個數字:字母<code>A</code>是數字65，而字符<code>友</code>(中文的 &quot;朋友&quot;)是數字21451。這個數字列表被稱為 &quot;Unicode&quot;。Unicode對使用較多的字符使用較小的數字，如A到Z，或0到9的數字，或空格。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_letter = 'A';
    let space = ' '; // A space inside ' ' is also a char
    let other_language_char = 'Ꮔ'; // Thanks to Unicode, other languages like Cherokee display just fine too
    let cat_face = '😺'; // Emojis are chars too
}
</code></pre></pre>
<p>使用最多的字符的數字小於256，它們可以裝進<code>u8</code>。記住，<code>u8</code>是0加上255以內的所有數字，總共256個。這意味著 Rust 可以使用 <code>as</code> 將 <code>u8</code> 安全地 <strong>cast</strong>成 <code>char</code>。(&quot;把 <code>u8</code> cast成 <code>char</code>&quot;意味著 &quot;把 <code>u8</code> 假裝成 <code>char</code>&quot;)</p>
<p>用 <code>as</code> cast是有用的，因為 Rust 是非常嚴格的。它總是需要知道類型。
而不會讓你同時使用兩種不同的類型，即使它們都是整數。例如，這將無法工作:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() is where Rust programs start to run. Code goes inside {} (curly brackets)

    let my_number = 100; // We didn't write a type of integer,
                         // so Rust chooses i32. Rust always
                         // chooses i32 for integers if you don't
                         // tell it to use a different type

    println!(&quot;{}&quot;, my_number as char); // ⚠️
}
</code></pre></pre>
<p>原因是這樣的:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:3:20
  |
3 |     println!(&quot;{}&quot;, my_number as char);
  |                    ^^^^^^^^^^^^^^^^^
</code></pre>
<p>幸運的是，我們可以用<code>as</code>輕鬆解決這個問題。我們不能把<code>i32</code>轉成<code>char</code>，但我們可以把<code>i32</code>轉成<code>u8</code>，然後把<code>u8</code>轉換成<code>char</code>。所以在一行中，我們使用 <code>as</code> 將 my_number 變為 <code>u8</code>，再將其變為 <code>char</code>。現在可以編譯了。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 100;
    println!(&quot;{}&quot;, my_number as u8 as char);
}
</code></pre></pre>
<p>它打印的是<code>d</code>，因為那是100對應的<code>char</code>。</p>
<p>然而，更簡單的方法是告訴 Rust <code>my_number</code> 是 <code>u8</code>。下面是你的做法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 100; //  change my_number to my_number: u8
    println!(&quot;{}&quot;, my_number as char);
}
</code></pre></pre>
<p>所以這就是Rust中所有不同數字類型的兩個原因。這裡還有一個原因:<code>usize</code>是Rust用於<em>索引</em>的大小。(索引的意思是 &quot;哪項是第一&quot;，&quot;哪項是第二&quot;等等)<code>usize</code>是索引的最佳大小，因為:</p>
<ul>
<li>索引不能是負數，所以它需要是一個帶u的數字</li>
<li>它應該是大的，因為有時你需要索引很多東西，但。</li>
<li>不可能是u64，因為32位電腦不能使用u64。</li>
</ul>
<p>所以Rust使用了<code>usize</code>，這樣你的計算機就可以得到它能讀到的最大的數字進行索引。</p>
<p>我們再來瞭解一下<code>char</code>。你看到<code>char</code>總是一個字符，並且使用<code>''</code>而不是<code>&quot;&quot;</code>。</p>
<p>所有的 <code>字符</code> 都使用4個字節的內存，因為4個字節足以容納任何種類的字符:</p>
<ul>
<li>基本字母和符號通常需要4個字節中的1個：<code>a b 1 2 + - = $ @</code></li>
<li>其他字母，如德語的 Umlauts 或重音，需要4個字節中的2個： <code>ä ö ü ß è é à ñ</code></li>
<li>韓文、日文或中文字符需要3或4個字節： <code>國 안 녕</code></li>
</ul>
<p>當使用字符作為字符串的一部分時，字符串被編碼以使用每個字符所需的最小內存量。</p>
<p>我們可以用<code>.len()</code>來看一下。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Size of a char: {}&quot;, std::mem::size_of::&lt;char&gt;()); // 4 bytes
    println!(&quot;Size of string containing 'a': {}&quot;, &quot;a&quot;.len()); // .len() gives the size of the string in bytes
    println!(&quot;Size of string containing 'ß': {}&quot;, &quot;ß&quot;.len());
    println!(&quot;Size of string containing '國': {}&quot;, &quot;國&quot;.len());
    println!(&quot;Size of string containing '𓅱': {}&quot;, &quot;𓅱&quot;.len());
}
</code></pre></pre>
<p>這樣打印出來。</p>
<pre><code class="language-text">Size of a char: 4
Size of string containing 'a': 1
Size of string containing 'ß': 2
Size of string containing '國': 3
Size of string containing '𓅱': 4
</code></pre>
<p>可以看到，<code>a</code>是一個字節，德文的<code>ß</code>是兩個字節，日文的<code>國</code>是三個字節，古埃及的<code>𓅱</code>是4個字節。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice = &quot;Hello!&quot;;
    println!(&quot;Slice is {} bytes.&quot;, slice.len());
    let slice2 = &quot;안녕!&quot;; // Korean for &quot;hi&quot;
    println!(&quot;Slice2 is {} bytes.&quot;, slice2.len());
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Slice is 6 bytes.
Slice2 is 7 bytes.
</code></pre>
<p><code>slice</code>的長度是6個字符，6個字節，但<code>slice2</code>的長度是3個字符，7個字節。</p>
<p>如果<code>.len()</code>給出的是以字節為單位的大小，那麼以字符為單位的大小呢？這些方法我們後面會學習，但你只要記住<code>.chars().count()</code>就可以了。<code>.chars().count()</code> 將你寫的東西變成字符，然後計算有多少個字符。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice = &quot;Hello!&quot;;
    println!(&quot;Slice is {} bytes and also {} characters.&quot;, slice.len(), slice.chars().count());
    let slice2 = &quot;안녕!&quot;;
    println!(&quot;Slice2 is {} bytes but only {} characters.&quot;, slice2.len(), slice2.chars().count());
}
</code></pre></pre>
<p>這就打印出來了。</p>
<pre><code class="language-text">Slice is 6 bytes and also 6 characters.
Slice2 is 7 bytes but only 3 characters.
</code></pre>
<h2 id="類型推導"><a class="header" href="#類型推導">類型推導</a></h2>
<p>類型推導的意思是，如果你不告訴編譯器類型，但它可以自己決定，它就會決定。編譯器總是需要知道變量的類型，但你並不總是需要告訴它。實際上，通常你不需要告訴它。例如，對於<code>let my_number = 8</code>，<code>my_number</code>將是一個<code>i32</code>。這是因為如果你不告訴它，編譯器會選擇i32作為整數。但是如果你說<code>let my_number: u8 = 8</code>，它就會把<code>my_number</code>變成<code>u8</code>，因為你告訴它<code>u8</code>。</p>
<p>通常編譯器都能猜到。但有時你需要告訴它，原因有兩個。</p>
<ol>
<li>你正在做一些非常複雜的事情，而編譯器不知道你想要的類型。</li>
<li>你想要一個不同的類型(例如，你想要一個<code>i128</code>，而不是<code>i32</code>)。</li>
</ol>
<p>要指定一個類型，請在變量名後添加一個冒號。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let small_number: u8 = 10;
}
</code></pre></pre>
<p>對於數字，你可以在數字後面加上類型。你不需要空格--只需要在數字後面直接輸入。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let small_number = 10u8; // 10u8 = 10 of type u8
}
</code></pre></pre>
<p>如果你想讓數字便於閱讀，也可以加上<code>_</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let small_number = 10_u8; // This is easier to read
    let big_number = 100_000_000_i32; // 100 million is easy to read with _
}
</code></pre></pre>
<p><code>_</code>不會改變數字。它只是為了讓你方便閱讀。而且你用多少個<code>_</code>都沒有關係。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 0________u8;
    let number2 = 1___6______2____4______i32;
    println!(&quot;{}, {}&quot;, number, number2);
}
</code></pre></pre>
<p>這樣打印出的是<code>0, 1624</code>。</p>
<h3 id="浮點數"><a class="header" href="#浮點數">浮點數</a></h3>
<p>浮點數是帶有小數點的數字。5.5是一個浮點數，6是一個整數。5.0也是一個浮點數，甚至5.也是一個浮點數。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float = 5.; // Rust sees . and knows that it is a float
}
</code></pre></pre>
<p>但類型不叫<code>float</code>，叫<code>f32</code>和<code>f64</code>。這和整數一樣:<code>f</code>後面的數字顯示的是位數。如果你不寫類型，Rust會選擇<code>f64</code>。</p>
<p>當然，只有同一類型的浮點數可以一起使用。所以你不能把<code>f32</code>加到<code>f64</code>上。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f64 = 5.0; // This is an f64
    let my_other_float: f32 = 8.5; // This is an f32

    let third_float = my_float + my_other_float; // ⚠️
}
</code></pre></pre>
<p>當你嘗試運行這個時，Rust會說。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src\main.rs:5:34
  |
5 |     let third_float = my_float + my_other_float;
  |                                  ^^^^^^^^^^^^^^ expected `f64`, found `f32`
</code></pre>
<p>當你使用錯誤的類型時，編譯器會寫 &quot;expected (type), found (type)&quot;。它這樣讀取你的代碼。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f64 = 5.0; // The compiler sees an f64
    let my_other_float: f32 = 8.5; // The compiler sees an f32. It is a different type.
    let third_float = my_float + // You want to add my_float to something, so it must be an f64 plus another f64. Now it expects an f64...
    let third_float = my_float + my_other_float;  // ⚠️ but it found an f32. It can't add them.
}
</code></pre></pre>
<p>所以，當你看到 &quot;expected(type)，found(type)&quot;時，你必須找到為什麼編譯器預期的是不同的類型。</p>
<p>當然，用簡單的數字很容易解決。你可以用<code>as</code>把<code>f32</code>轉成<code>f64</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f64 = 5.0;
    let my_other_float: f32 = 8.5;

    let third_float = my_float + my_other_float as f64; // my_other_float as f64 = use my_other_float like an f64
}
</code></pre></pre>
<p>或者更簡單，去掉類型聲明。(&quot;聲明一個類型&quot;=&quot;告訴Rust使用該類型&quot;)Rust會選擇可以加在一起的類型。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float = 5.0; // Rust will choose f64
    let my_other_float = 8.5; // Here again it will choose f64

    let third_float = my_float + my_other_float;
}
</code></pre></pre>
<p>Rust編譯器很聰明，如果你需要f32，就不會選擇f64。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f32 = 5.0;
    let my_other_float = 8.5; // Usually Rust would choose f64,

    let third_float = my_float + my_other_float; // but now it knows that you need to add it to an f32. So it chooses f32 for my_other_float too
}
</code></pre></pre>
<h2 id="打印hello-world"><a class="header" href="#打印hello-world">打印hello, world!</a></h2>
<p>當你啟動一個新的Rust程序時，它總是有這樣的代碼。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li>
<p><code>fn</code>的意思是函數。</p>
</li>
<li>
<p><code>main</code>是啟動程序的函數。</p>
</li>
<li>
<p><code>()</code>表示我們沒有給函數任何變量來啟動。</p>
</li>
</ul>
<p><code>{}</code>被稱為<strong>代碼塊</strong>。這是代碼所在的空間。</p>
<p><code>println!</code>是一個<strong>宏</strong>，打印到控制檯。一個<strong>宏</strong>就像一個函數，為你寫代碼。宏後面有一個<code>!</code>。我們以後會學習如何創建宏。現在，請記住，<code>!</code>表示它是一個宏。</p>
<p>為了學習<code>;</code>，我們將創建另一個函數。首先，在<code>main</code>中，我們將打印一個數字8。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world number {}!&quot;, 8);
}
</code></pre></pre>
<p><code>println!</code>中的<code>{}</code>的意思是 &quot;把變量放在這裡面&quot;。這樣就會打印出<code>Hello, world number 8!</code>。</p>
<p>我們可以像之前一樣，放更多的東西進去。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, worlds number {} and {}!&quot;, 8, 9);
}
</code></pre></pre>
<p>這將打印出 <code>Hello, worlds number 8 and 9!</code>。</p>
<p>現在我們來創建函數。</p>
<pre><pre class="playground"><code class="language-rust">fn number() -&gt; i32 {
    8
}

fn main() {
    println!(&quot;Hello, world number {}!&quot;, number());
}
</code></pre></pre>
<p>這也會打印出 <code>Hello, world number 8!</code>。當Rust查看<code>number()</code>時，它看到一個函數。這個函數:</p>
<ul>
<li>沒有參數(因為它有<code>()</code>)</li>
<li>返回一個<code>i32</code>。<code>-&gt;</code>(稱為 &quot;瘦箭&quot;)顯示了函數返回的內容</li>
</ul>
<p>函數內部只有<code>8</code>。因為沒有<code>;</code>，所以這就是它返回的值。如果它有一個<code>;</code>，它將不會返回任何東西(它會返回一個<code>()</code>)。如果它有 <code>;</code>，Rust 不會編譯通過，因為需要返回的是 <code>i32</code>，而 <code>;</code> 返回 <code>()</code>，不是 <code>i32</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world number {}&quot;, number());
}

fn number() -&gt; i32 {
    8;  // ⚠️
}
</code></pre></pre>
<pre><code class="language-text">5 | fn number() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
6 |     8;
  |      - help: consider removing this semicolon
</code></pre>
<p>這意味著 &quot;你告訴我<code>number()</code>返回的是<code>i32</code>，但你加了一個<code>;</code>，所以它什麼都不返回&quot;。所以編譯器建議去掉分號。</p>
<p>你也可以寫<code>return 8;</code>，但在Rust中，正常情況下只需將<code>;</code>改為<code>return</code>即可。</p>
<p>當你想給一個函數賦予變量時，把它們放在<code>()</code>裡面。你必須給它們起個名字，寫上類型。</p>
<pre><pre class="playground"><code class="language-rust">fn multiply(number_one: i32, number_two: i32) { // Two i32s will enter the function. We will call them number_one and number_two.
    let result = number_one * number_two;
    println!(&quot;{} times {} is {}&quot;, number_one, number_two, result);
}

fn main() {
    multiply(8, 9); // We can give the numbers directly
    let some_number = 10; // Or we can declare two variables
    let some_other_number = 2;
    multiply(some_number, some_other_number); // and put them in the function
}
</code></pre></pre>
<p>我們也可以返回一個<code>i32</code>。只要把最後的分號去掉就可以了:</p>
<pre><pre class="playground"><code class="language-rust">fn multiply(number_one: i32, number_two: i32) -&gt; i32 {
    let result = number_one * number_two;
    println!(&quot;{} times {} is {}&quot;, number_one, number_two, result);
    result // this is the i32 that we return
}

fn main() {
    let multiply_result = multiply(8, 9); // We used multiply() to print and to give the result to multiply_result
}
</code></pre></pre>
<h3 id="聲明變量和代碼塊"><a class="header" href="#聲明變量和代碼塊">聲明變量和代碼塊</a></h3>
<p>使用<code>let</code>聲明一個變量(聲明一個變量=告訴Rust創建一個變量)。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    println!(&quot;Hello, number {}&quot;, my_number);
}
</code></pre></pre>
<p>變量在代碼塊<code>{}</code>內開始和結束。在這個例子中，<code>my_number</code>在我們調用<code>println!</code>之前結束，因為它在自己的代碼塊裡面。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let my_number = 8; // my_number starts here
                           // my_number ends here!
    }

    println!(&quot;Hello, number {}&quot;, my_number); // ⚠️ there is no my_number and
                                             // println!() can't find it
}
</code></pre></pre>
<p>你可以使用代碼塊來返回一個值。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = {
    let second_number = 8;
        second_number + 9 // No semicolon, so the code block returns 8 + 9.
                          // It works just like a function
    };

    println!(&quot;My number is: {}&quot;, my_number);
}
</code></pre></pre>
<p>如果在代碼塊內部添加分號，它將返回 <code>()</code> (無)。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = {
    let second_number = 8; // declare second_number,
        second_number + 9; // add 9 to second_number
                           // but we didn't return it!
                           // second_number dies now
    };

    println!(&quot;My number is: {:?}&quot;, my_number); // my_number is ()
}
</code></pre></pre>
<p>那麼為什麼我們要寫<code>{:?}</code>而不是<code>{}</code>呢？我們現在就來談談這個問題。</p>
<h2 id="顯示和調試"><a class="header" href="#顯示和調試">顯示和調試</a></h2>
<p>Rust中簡單的變量可以用<code>{}</code>裡面的<code>println!</code>打印。但是有些變量不能，你需要<strong>debug print</strong>。Debug打印是給程序員打印的，因為它通常會顯示更多的信息。Debug有時看起來並不漂亮，因為它有額外的信息來幫助你。</p>
<p>你怎麼知道你是否需要<code>{:?}</code>而不是<code>{}</code>？編譯器會告訴你。比如說</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let doesnt_print = ();
    println!(&quot;This will not print: {}&quot;, doesnt_print); // ⚠️
}
</code></pre></pre>
<p>當我們運行這個時，編譯器會說:</p>
<pre><code class="language-text">error[E0277]: `()` doesn't implement `std::fmt::Display`
 --&gt; src\main.rs:3:41
  |
3 |     println!(&quot;This will not print: {}&quot;, doesnt_print);
  |                                         ^^^^^^^^^^^^ `()` cannot be formatted with the default formatter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: required by `std::fmt::Display::fmt`
  = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>信息比較多，但重要的部分是 <code>you may be able to use {:?} (or {:#?} for pretty-print) instead</code>. 這意味著你可以試試<code>{:?}</code>，也可以試試<code>{:#?}</code> <code>{:#?}</code>叫做 &quot;漂亮打印&quot;。它和<code>{:?}</code>一樣，但是在更多的行上打印出不同的格式。</p>
<p>所以Display就是用<code>{}</code>打印，Debug就是用<code>{:?}</code>打印。</p>
<p>還有一點:如果你不想要新的一行，你也可以使用<code>print!</code>而不用<code>ln</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!(&quot;This will not print a new line&quot;);
    println!(&quot; so this will be on the same line&quot;);
}
</code></pre></pre>
<p>這將打印<code>This will not print a new line so this will be on the same line</code>。</p>
<h3 id="最小和最大的數"><a class="header" href="#最小和最大的數">最小和最大的數</a></h3>
<p>如果你想看最小和最大的數字，你可以用MIN和MAX。<code>std</code>的意思是 &quot;標準庫&quot;，擁有Rust的所有主要函數等。我們將在以後學習標準庫。但與此同時，你可以記住，這就是你如何獲得一個類型的最小和最大的數字。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;The smallest i8 is {} and the biggest i8 is {}.&quot;, std::i8::MIN, std::i8::MAX); // hint: printing std::i8::MIN means &quot;print MIN inside of the i8 section in the standard library&quot;
    println!(&quot;The smallest u8 is {} and the biggest u8 is {}.&quot;, std::u8::MIN, std::u8::MAX);
    println!(&quot;The smallest i16 is {} and the biggest i16 is {}.&quot;, std::i16::MIN, std::i16::MAX);
    println!(&quot;The smallest u16 is {} and the biggest u16 is {}.&quot;, std::u16::MIN, std::u16::MAX);
    println!(&quot;The smallest i32 is {} and the biggest i32 is {}.&quot;, std::i32::MIN, std::i32::MAX);
    println!(&quot;The smallest u32 is {} and the biggest u32 is {}.&quot;, std::u32::MIN, std::u32::MAX);
    println!(&quot;The smallest i64 is {} and the biggest i64 is {}.&quot;, std::i64::MIN, std::i64::MAX);
    println!(&quot;The smallest u64 is {} and the biggest u64 is {}.&quot;, std::u64::MIN, std::u64::MAX);
    println!(&quot;The smallest i128 is {} and the biggest i128 is {}.&quot;, std::i128::MIN, std::i128::MAX);
    println!(&quot;The smallest u128 is {} and the biggest u128 is {}.&quot;, std::u128::MIN, std::u128::MAX);

}
</code></pre></pre>
<p>將會打印:</p>
<pre><code class="language-text">The smallest i8 is -128 and the biggest i8 is 127.
The smallest u8 is 0 and the biggest u8 is 255.
The smallest i16 is -32768 and the biggest i16 is 32767.
The smallest u16 is 0 and the biggest u16 is 65535.
The smallest i32 is -2147483648 and the biggest i32 is 2147483647.
The smallest u32 is 0 and the biggest u32 is 4294967295.
The smallest i64 is -9223372036854775808 and the biggest i64 is 9223372036854775807.
The smallest u64 is 0 and the biggest u64 is 18446744073709551615.
The smallest i128 is -170141183460469231731687303715884105728 and the biggest i128 is 170141183460469231731687303715884105727.
The smallest u128 is 0 and the biggest u128 is 340282366920938463463374607431768211455.
</code></pre>
<h2 id="可變性"><a class="header" href="#可變性">可變性</a></h2>
<p>當你用<code>let</code>聲明一個變量時，它是不可改變的(不能改變)。</p>
<p>這將無法工作:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    my_number = 10; // ⚠️
}
</code></pre></pre>
<p>編譯器說:<code>error[E0384]: cannot assign twice to immutable variable my_number</code>。這是因為如果你只寫<code>let</code>，變量是不可變的。</p>
<p>但有時你想改變你的變量。要創建一個可以改變的變量，就在<code>let</code>後面加上<code>mut</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 8;
    my_number = 10;
}
</code></pre></pre>
<p>現在沒有問題了。</p>
<p>但是，你不能改變類型:甚至<code>mut</code>也不能讓你這樣做:這將無法工作。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_variable = 8; // it is now an i32. That can't be changed
    my_variable = &quot;Hello, world!&quot;; // ⚠️
}
</code></pre></pre>
<p>你會看到編譯器發出的同樣的 &quot;預期&quot;信息。<code>expected integer, found &amp;str</code>. <code>&amp;str</code>是一個字符串類型，我們很快就會知道。</p>
<h3 id="遮蔽"><a class="header" href="#遮蔽">遮蔽</a></h3>
<p>shadowing是指使用<code>let</code>聲明一個與另一個變量同名的新變量。它看起來像可變性，但完全不同。shadowing看起來是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8; // This is an i32
    println!(&quot;{}&quot;, my_number); // prints 8
    let my_number = 9.2; // This is an f64 with the same name. But it's not the first my_number - it is completely different!
    println!(&quot;{}&quot;, my_number) // Prints 9.2
}
</code></pre></pre>
<p>這裡我們說我們用一個新的 &quot;let綁定&quot;對<code>my_number</code>進行了 &quot;shadowing&quot;。</p>
<p>那麼第一個<code>my_number</code>是否被銷燬了呢？沒有，但是當我們調用<code>my_number</code>時，我們現在得到<code>my_number</code>的<code>f64</code>。因為它們在同一個作用域塊中(同一個 <code>{}</code>)，我們不能再看到第一個 <code>my_number</code>。</p>
<p>但如果它們在不同的塊中，我們可以同時看到兩個。
例如:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8; // This is an i32
    println!(&quot;{}&quot;, my_number); // prints 8
    {
        let my_number = 9.2; // This is an f64. It is not my_number - it is completely different!
        println!(&quot;{}&quot;, my_number) // Prints 9.2
                                  // But the shadowed my_number only lives until here.
                                  // The first my_number is still alive!
    }
    println!(&quot;{}&quot;, my_number); // prints 8
}
</code></pre></pre>
<p>因此，當你對一個變量進行shadowing處理時，你不會破壞它。你<strong>屏蔽</strong>了它。</p>
<p>那麼shadowing的好處是什麼呢？當你需要經常改變一個變量的時候，shadowing是很好的。想象一下，你想用一個變量做很多簡單的數學運算。</p>
<pre><pre class="playground"><code class="language-rust">fn times_two(number: i32) -&gt; i32 {
    number * 2
}

fn main() {
    let final_number = {
        let y = 10;
        let x = 9; // x starts at 9
        let x = times_two(x); // shadow with new x: 18
        let x = x + y; // shadow with new x: 28
        x // return x: final_number is now the value of x
    };
    println!(&quot;The number is now: {}&quot;, final_number)
}
</code></pre></pre>
<p>如果沒有shadowing，你將不得不考慮不同的名稱，儘管你並不關心x。</p>
<pre><pre class="playground"><code class="language-rust">fn times_two(number: i32) -&gt; i32 {
    number * 2
}

fn main() {
    // Pretending we are using Rust without shadowing
    let final_number = {
        let y = 10;
        let x = 9; // x starts at 9
        let x_twice = times_two(x); // second name for x
        let x_twice_and_y = x_twice + y; // third name for x!
        x_twice_and_y // too bad we didn't have shadowing - we could have just used x
    };
    println!(&quot;The number is now: {}&quot;, final_number)
}
</code></pre></pre>
<p>一般來說，你在Rust中看到的shadowing就是這種情況。它發生在你想快速取用變量，對它做一些事情，然後再做其他事情的地方。而你通常將它用於那些你不太關心的快速變量。</p>
<h2 id="棧堆和指針"><a class="header" href="#棧堆和指針">棧、堆和指針</a></h2>
<p>棧、堆和指針在Rust中非常重要。</p>
<p>棧和堆是計算機中保存內存的兩個地方。重要的區別是:</p>
<p>棧的速度非常快, 但堆的速度就不那麼快了. 它也不是超慢，但棧總是更快。但是你不能一直使用棧，因為:</p>
<ul>
<li>Rust需要在編譯時知道一個變量的大小。所以像<code>i32</code>這樣的簡單變量就放在堆棧上，因為我們知道它們的確切大小。你總是知道<code>i32</code>要4字節，因為32位=4字節。所以<code>i32</code>總是可以放在棧上。</li>
<li>但有些類型在編譯時不知道大小。但是棧需要知道確切的大小。那麼你該怎麼做呢？首先你把數據放在堆中，因為堆中可以有任何大小的數據。然後為了找到它，一個指針就會進入棧。這很好，因為我們總是知道指針的大小。所以，計算機就會先去棧，讀取指針，然後跟著指針到數據所在的堆。</li>
</ul>
<p>指針聽起來很複雜，但它們很容易。指針就像一本書的目錄。想象一下這本書。</p>
<pre><code class="language-text">MY BOOK

TABLE OF CONTENTS

Chapter                        Page
Chapter 1: My life              1
Chapter 2: My cat               15
Chapter 3: My job               23
Chapter 4: My family            30
Chapter 5: Future plans         43
</code></pre>
<p>所以這就像五個指針。你可以閱讀它們，找到它們所說的信息。&quot;我的生活&quot;這一章在哪裡？在第1頁(它<em>指向</em>第1頁)。&quot;我的工作&quot;這一章在哪裡？它在第23頁。</p>
<p>在Rust中通常看到的指針叫做<strong>引用</strong>。這是重要的部分，要知道:一個引用指向另一個值的內存。引用意味著你<em>借</em>了這個值，但你並不擁有它。這和我們的書一樣:目錄並不擁有信息。章節才是信息的主人。在Rust中，引用文獻的前面有一個<code>&amp;</code>。所以:</p>
<ul>
<li><code>let my_variable = 8</code>是一個普通的變量，但是:</li>
<li><code>let my_reference = &amp;my_variable</code>是一個引用。</li>
</ul>
<p>你把 <code>my_reference = &amp;my_variable</code> 讀成這樣: &quot;my_reference是對my_variable的引用&quot;. 或者:&quot;my_reference是對my_variable的引用&quot;。</p>
<p>這意味著<code>my_reference</code>只看<code>my_variable</code>的數據。<code>my_variable</code>仍然擁有它的數據。</p>
<p>你也可以有一個引用的引用，或者任何數量的引用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 15; // This is an i32
    let single_reference = &amp;my_number; //  This is a &amp;i32
    let double_reference = &amp;single_reference; // This is a &amp;&amp;i32
    let five_references = &amp;&amp;&amp;&amp;&amp;my_number; // This is a &amp;&amp;&amp;&amp;&amp;i32
}
</code></pre></pre>
<p>這些都是不同的類型，就像 &quot;朋友的朋友&quot;和 &quot;朋友&quot;不同一樣。</p>
<h2 id="關於打印的更多信息"><a class="header" href="#關於打印的更多信息">關於打印的更多信息</a></h2>
<p>在Rust中，你幾乎可以用任何你想要的方式打印東西。這裡有一些關於打印的事情需要知道。</p>
<p>添加 <code>\n</code> 將會產生一個新行，而 <code>\t</code> 將會產生一個標籤。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Note: this is print!, not println!
    print!(&quot;\t Start with a tab\nand move to a new line&quot;);
}
</code></pre></pre>
<p>這樣就可以打印了。</p>
<pre><code class="language-text">         Start with a tab
and move to a new line
</code></pre>
<p><code>&quot;&quot;</code>裡面可以寫過很多行都沒有問題，但是要注意間距。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Note: After the first line you have to start on the far left.
    // If you write directly under println!, it will add the spaces
    println!(&quot;Inside quotes
you can write over
many lines
and it will print just fine.&quot;);

    println!(&quot;If you forget to write
    on the left side, the spaces
    will be added when you print.&quot;);
}
</code></pre></pre>
<p>這個打印出來的。</p>
<pre><code class="language-text">Inside quotes
you can write over
many lines
and it will print just fine.
If you forget to write
    on the left side, the spaces
    will be added when you print.
</code></pre>
<p>如果你想打印<code>\n</code>這樣的字符(稱為 &quot;轉義字符&quot;)，你可以多加一個<code>\</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Here are two escape characters: \\n and \\t&quot;);
}
</code></pre></pre>
<p>這樣就可以打印了。</p>
<pre><code class="language-text">Here are two escape characters: \n and \t
</code></pre>
<p>有時你有太多的 <code>&quot;</code> 和轉義字符，並希望 Rust 忽略所有的字符。要做到這一點，您可以在開頭添加 <code>r#</code>，在結尾添加 <code>#</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;He said, \&quot;You can find the file at c:\\files\\my_documents\\file.txt.\&quot; Then I found the file.&quot;); // We used \ five times here
    println!(r#&quot;He said, &quot;You can find the file at c:\files\my_documents\file.txt.&quot; Then I found the file.&quot;#)
}
</code></pre></pre>
<p>這打印的是同樣的東西，但使用 <code>r#</code> 使人類更容易閱讀。</p>
<pre><code class="language-text">He said, &quot;You can find the file at c:\files\my_documents\file.txt.&quot; Then I found the file.
He said, &quot;You can find the file at c:\files\my_documents\file.txt.&quot; Then I found the file.
</code></pre>
<p>如果你需要在裡面打印<code>#</code>，那麼你可以用<code>r##</code>開頭，用<code>##</code>結尾。如果你需要打印多個連續的<code>#</code>，可以在每邊多加一個#。</p>
<p>下面是四個例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let my_string = &quot;'Ice to see you,' he said.&quot;; // single quotes
    let quote_string = r#&quot;&quot;Ice to see you,&quot; he said.&quot;#; // double quotes
    let hashtag_string = r##&quot;The hashtag #IceToSeeYou had become very popular.&quot;##; // Has one # so we need at least ##
    let many_hashtags = r####&quot;&quot;You don't have to type ### to use a hashtag. You can just use #.&quot;&quot;####; // Has three ### so we need at least ####

    println!(&quot;{}\n{}\n{}\n{}\n&quot;, my_string, quote_string, hashtag_string, many_hashtags);

}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">'Ice to see you,' he said.
&quot;Ice to see you,&quot; he said.
The hashtag #IceToSeeYou had become very popular.
&quot;You don't have to type ### to use a hashtag. You can just use #.&quot;
</code></pre>
<p><code>r#</code>還有另一個用途:使用它，你可以使用關鍵字(如<code>let</code>、<code>fn</code>等)作為變量名。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r#let = 6; // The variable's name is let
    let mut r#mut = 10; // This variable's name is mut
}
</code></pre></pre>
<p><code>r#</code>之所以有這個功能，是因為舊版本的Rust的關鍵字比現在的Rust少。所以有了<code>r#</code>就可以避免以前不是關鍵字的變量名的錯誤。</p>
<p>又或者因為某些原因，你<em>確實</em>需要一個函數的名字，比如<code>return</code>。那麼你可以這樣寫:</p>
<pre><pre class="playground"><code class="language-rust">fn r#return() -&gt; u8 {
    println!(&quot;Here is your number.&quot;);
    8
}

fn main() {
    let my_number = r#return();
    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>這樣打印出來的結果是:</p>
<pre><code class="language-text">Here is your number.
8
</code></pre>
<p>所以你可能不需要它，但是如果你真的需要為一個變量使用一個關鍵字，那麼你可以使用<code>r#</code>。</p>
<p>如果你想打印<code>&amp;str</code>或<code>char</code>的字節，你可以在字符串前寫上<code>b</code>就可以了。這適用於所有ASCII字符。這些是所有的ASCII字符。</p>
<pre><code class="language-text">☺☻♥♦♣♠♫☼►◄↕‼¶§▬↨↑↓→∟↔▲▼123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<p>所以，當你打印這個</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{:?}&quot;, b&quot;This will look like numbers&quot;);
}
</code></pre></pre>
<p>這就是結果:</p>
<pre><code class="language-text">[84, 104, 105, 115, 32, 119, 105, 108, 108, 32, 108, 111, 111, 107, 32, 108, 105, 107, 101, 32, 110, 117, 109, 98, 101, 114, 115]
</code></pre>
<p>對於<code>char</code>來說，這叫做一個<em>字節</em>，對於<code>&amp;str</code>來說，這叫做一個<em>字節字符串</em>。</p>
<p>如果你需要的話，也可以把<code>b</code>和<code>r</code>放在一起。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{:?}&quot;, br##&quot;I like to write &quot;#&quot;.&quot;##);
}
</code></pre></pre>
<p>這將打印出 <code>[73, 32, 108, 105, 107, 101, 32, 116, 111, 32, 119, 114, 105, 116, 101, 32, 34, 35, 34, 46]</code>。</p>
<p>還有一個Unicode轉義，可以讓你在字符串中打印任何Unicode字符: <code>\u{}</code>。<code>{}</code>裡面有一個十六進制數字可以打印。下面是一個簡短的例子，說明如何獲得Unicode數字，以及如何再次打印它。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{:X}&quot;, '행' as u32); // Cast char as u32 to get the hexadecimal value
    println!(&quot;{:X}&quot;, 'H' as u32);
    println!(&quot;{:X}&quot;, '居' as u32);
    println!(&quot;{:X}&quot;, 'い' as u32);

    println!(&quot;\u{D589}, \u{48}, \u{5C45}, \u{3044}&quot;); // Try printing them with unicode escape \u
}
</code></pre></pre>
<p>我們知道，<code>println!</code>可以和<code>{}</code>(用於顯示)或<code>{:?}</code>(用於調試)一起打印，再加上<code>{:#?}</code>就可以進行漂亮的打印。但是還有很多其他的打印方式。</p>
<p>例如，如果你有一個引用，你可以用<code>{:p}</code>來打印<em>指針地址</em>。指針地址指的是電腦內存中的位置。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 9;
    let number_ref = &amp;number;
    println!(&quot;{:p}&quot;, number_ref);
}
</code></pre></pre>
<p>這可以打印<code>0xe2bc0ffcfc</code>或其他地址。每次可能都不一樣，這取決於你的計算機存儲的位置。</p>
<p>或者你可以打印二進制、十六進制和八進制。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 555;
    println!(&quot;Binary: {:b}, hexadecimal: {:x}, octal: {:o}&quot;, number, number, number);
}
</code></pre></pre>
<p>這將打印出<code>Binary: 1000101011, hexadecimal: 22b, octal: 1053</code>。</p>
<p>或者你可以添加數字來改變順序。第一個變量將在索引0中，下一個在索引1中，以此類推。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let father_name = &quot;Vlad&quot;;
    let son_name = &quot;Adrian Fahrenheit&quot;;
    let family_name = &quot;Țepeș&quot;;
    println!(&quot;This is {1} {2}, son of {0} {2}.&quot;, father_name, son_name, family_name);
}
</code></pre></pre>
<p><code>father_name</code>在0位，<code>son_name</code>在1位，<code>family_name</code>在2位。所以它打印的是<code>This is Adrian Fahrenheit Țepeș, son of Vlad Țepeș</code>。</p>
<p>也許你有一個非常複雜的字符串要打印，<code>{}</code>大括號內有太多的變量。或者你需要不止一次的打印一個變量。那麼在<code>{}</code>中添加名稱就會有幫助。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(
        &quot;{city1} is in {country} and {city2} is also in {country},
but {city3} is not in {country}.&quot;,
        city1 = &quot;Seoul&quot;,
        city2 = &quot;Busan&quot;,
        city3 = &quot;Tokyo&quot;,
        country = &quot;Korea&quot;
    );
}
</code></pre></pre>
<p>這樣就可以打印了。</p>
<pre><code class="language-text">Seoul is in Korea and Busan is also in Korea,
but Tokyo is not in Korea.
</code></pre>
<p>如果你願意，也可以在Rust中進行非常複雜的打印。下面展示怎樣做：</p>
<p>{variable:padding alignment minimum.maximum}</p>
<p>要理解這一點，請看</p>
<ol>
<li>你想要一個變量名嗎？先寫出來，就像我們上面寫{country}一樣。
(如果你想做更多的事情，就在後面加一個<code>:</code>)</li>
<li>你想要一個填充字符嗎？例如，55加上三個 &quot;填充零&quot;就像00055。</li>
<li>padding的對齊方式(左/中/右)？</li>
<li>你想要一個最小長度嗎？(寫一個數字就可以了) </li>
<li>你想要一個最大長度嗎？(寫一個數字，前面有一個<code>.</code>)</li>
</ol>
<p>例如，我想寫 &quot;a&quot;，左邊有五個ㅎ，右邊有五個ㅎ。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letter = &quot;a&quot;;
    println!(&quot;{:ㅎ^11}&quot;, letter);
}
</code></pre></pre>
<p>這樣打印出來的結果是<code>ㅎㅎㅎㅎㅎaㅎㅎㅎㅎㅎ</code>。我們看看1)到5)的這個情況，就能明白編譯器是怎麼解讀的：</p>
<ul>
<li>你要不要變量名？<code>{:ㅎ^11}</code>沒有變量名。<code>:</code>之前沒有任何內容。</li>
<li>你需要一個填充字符嗎？<code>{:ㅎ^11}</code> 是的:ㅎ&quot;在<code>:</code>後面，有一個<code>^</code>。<code>&lt;</code>表示變量在填充字符左邊，<code>&gt;</code>表示在填充字符右邊，<code>^</code>表示在填充字符中間。</li>
<li>要不要設置最小長度？<code>{:ㅎ^11}</code>是:後面有一個11。</li>
<li>你想要一個最大長度嗎？<code>{:ㅎ^11}</code> 不是:前面沒有<code>.</code>的數字。</li>
</ul>
<p>下面是多種類型的格式化的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let title = &quot;TODAY'S NEWS&quot;;
    println!(&quot;{:-^30}&quot;, title); // no variable name, pad with -, put in centre, 30 characters long
    let bar = &quot;|&quot;;
    println!(&quot;{: &lt;15}{: &gt;15}&quot;, bar, bar); // no variable name, pad with space, 15 characters each, one to the left, one to the right
    let a = &quot;SEOUL&quot;;
    let b = &quot;TOKYO&quot;;
    println!(&quot;{city1:-&lt;15}{city2:-&gt;15}&quot;, city1 = a, city2 = b); // variable names city1 and city2, pad with -, one to the left, one to the right
}
</code></pre></pre>
<p>它打印出來了。</p>
<pre><code class="language-text">---------TODAY'S NEWS---------
|                            |
SEOUL--------------------TOKYO
</code></pre>
<h2 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h2>
<p>Rust有兩種主要類型的字符串。<code>String</code>和<code>&amp;str</code>. 有什麼區別呢？</p>
<ul>
<li><code>&amp;str</code>是一個簡單的字符串。當你寫<code>let my_variable = &quot;Hello, world!&quot;</code>時，你會創建一個<code>&amp;str</code>。<code>&amp;str</code>是非常快的。</li>
<li><code>String</code>是一個更復雜的字符串。它比較慢，但它有更多的功能。<code>String</code>是一個指針，數據在堆上。</li>
</ul>
<p>另外注意，<code>&amp;str</code>前面有<code>&amp;</code>，因為你需要一個引用來使用<code>str</code>。這是因為我們上面看到的原因:堆需要知道大小。所以我們給它一個<code>&amp;</code>，它知道大小，然後它就高興了。另外，因為你用一個<code>&amp;</code>與一個<code>str</code>交互，你並不擁有它。但是一個<code>String</code>是一個<em>擁有</em>的類型。我們很快就會知道為什麼這一點很重要。</p>
<p><code>&amp;str</code>和<code>String</code>都是UTF-8。例如，你可以寫</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name = &quot;서태지&quot;; // This is a Korean name. No problem, because a &amp;str is UTF-8.
    let other_name = String::from(&quot;Adrian Fahrenheit Țepeș&quot;); // Ț and ș are no problem in UTF-8.
}
</code></pre></pre>
<p>你可以在<code>String::from(&quot;Adrian Fahrenheit Țepeș&quot;)</code>中看到，很容易從<code>&amp;str</code>中創建一個<code>String</code>。這兩種類型雖然不同，但聯繫非常緊密。</p>
<p>你甚至可以寫表情符號，這要感謝UTF-8。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name = &quot;😂&quot;;
    println!(&quot;My name is actually {}&quot;, name);
}
</code></pre></pre>
<p>在你的電腦上，會打印<code>My name is actually 😂</code>，除非你的命令行不能打印。那麼它會顯示<code>My name is actually �</code>。但Rust對emojis或其他Unicode沒有問題。</p>
<p>我們再來看看<code>str</code>使用<code>&amp;</code>的原因，以確保我們理解。</p>
<ul>
<li><code>str</code>是一個動態大小的類型(動態大小=大小可以不同)。比如 &quot;서태지&quot;和 &quot;Adrian Fahrenheit Țepeș&quot;這兩個名字的大小是不一樣的。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {

    println!(&quot;A String is always {:?} bytes. It is Sized.&quot;, std::mem::size_of::&lt;String&gt;()); // std::mem::size_of::&lt;Type&gt;() gives you the size in bytes of a type
    println!(&quot;And an i8 is always {:?} bytes. It is Sized.&quot;, std::mem::size_of::&lt;i8&gt;());
    println!(&quot;And an f64 is always {:?} bytes. It is Sized.&quot;, std::mem::size_of::&lt;f64&gt;());
    println!(&quot;But a &amp;str? It can be anything. '서태지' is {:?} bytes. It is not Sized.&quot;, std::mem::size_of_val(&quot;서태지&quot;)); // std::mem::size_of_val() gives you the size in bytes of a variable
    println!(&quot;And 'Adrian Fahrenheit Țepeș' is {:?} bytes. It is not Sized.&quot;, std::mem::size_of_val(&quot;Adrian Fahrenheit Țepeș&quot;));
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">A String is always 24 bytes. It is Sized.
And an i8 is always 1 bytes. It is Sized.
And an f64 is always 8 bytes. It is Sized.
But a &amp;str? It can be anything. '서태지' is 9 bytes. It is not Sized.
And 'Adrian Fahrenheit Țepeș' is 25 bytes. It is not Sized.
</code></pre>
<p>這就是為什麼我們需要一個 &amp;，因為 <code>&amp;</code> 是一個指針，而 Rust 知道指針的大小。所以指針會放在棧中。如果我們寫<code>str</code>，Rust就不知道該怎麼做了，因為它不知道指針的大小。</p>
<p>有很多方法可以創建<code>String</code>。下面是一些。</p>
<ul>
<li><code>String::from(&quot;This is the string text&quot;);</code> 這是String的一個方法，它接受文本並創建一個String.</li>
<li><code>&quot;This is the string text&quot;.to_string()</code>. 這是&amp;str的一個方法，使其成為一個String。</li>
<li><code>format!</code> 宏。
這和<code>println!</code>一樣，只是它創建了一個字符串，而不是打印。所以你可以這樣做:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Billybrobby&quot;;
    let my_country = &quot;USA&quot;;
    let my_home = &quot;Korea&quot;;

    let together = format!(
        &quot;I am {} and I come from {} but I live in {}.&quot;,
        my_name, my_country, my_home
    );
}
</code></pre></pre>
<p>現在我們有了一個一起命名的字符串，但還沒有打印出來。</p>
<p>還有一種創建String的方法叫做<code>.into()</code>，但它有點不同，因為<code>.into()</code>並不只是用來創建<code>String</code>。有些類型可以很容易地使用<code>From</code>和<code>.into()</code>轉換為另一種類型，並從另一種類型轉換出來。而如果你有<code>From</code>，那麼你也有<code>.into()</code>。<code>From</code> 更加清晰，因為你已經知道了類型:你知道 <code>String::from(&quot;Some str&quot;)</code> 是一個來自 <code>&amp;str</code> 的 <code>String</code>。但是對於<code>.into()</code>，有時候編譯器並不知道。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = &quot;Try to make this a String&quot;.into(); // ⚠️
}
</code></pre></pre>
<p>Rust不知道你要的是什麼類型，因為很多類型都可以從一個<code>&amp;str</code>創建出來。它說:&quot;我可以把一個&amp;str做成很多東西。你想要哪一種？&quot;</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src\main.rs:2:9
  |
2 |     let my_string = &quot;Try to make this a String&quot;.into();
  |         ^^^^^^^^^ consider giving `my_string` a type
</code></pre>
<p>所以你可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string: String = &quot;Try to make this a String&quot;.into();
}
</code></pre></pre>
<p>現在你得到了一個字符串。</p>
<h2 id="const和static"><a class="header" href="#const和static">const和static</a></h2>
<p>有兩種聲明值的方法，不僅僅是用<code>let</code>。它們是<code>const</code>和<code>static</code>。另外，Rust不會使用類型推理：你需要為它們編寫類型。這些都是用於不改變的值（<code>const</code>意味著常量）。區別在於:</p>
<ul>
<li><code>const</code>是用於不改變的值，當使用它時，名字會被替換成值。</li>
<li><code>static</code>與<code>const</code>類似，但有一個固定的內存位置，可以作為一個全局變量使用。</li>
</ul>
<p>所以它們幾乎是一樣的。Rust程序員幾乎總是使用<code>const</code>。</p>
<p>一般用全大寫字母作為名字，而且通常在<code>main</code>之外，這樣它們就可以在整個程序中生存。</p>
<p>兩個例子是 <code>const NUMBER_OF_MONTHS: u32 = 12;</code> 和 <code>static SEASONS: [&amp;str; 4] = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;];</code></p>
<h2 id="關於引用的更多信息"><a class="header" href="#關於引用的更多信息">關於引用的更多信息</a></h2>
<p>引用在Rust中非常重要。Rust使用引用來確保所有的內存訪問是安全的。我們知道，我們使用<code>&amp;</code>來創建一個引用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from(&quot;Austria&quot;);
    let ref_one = &amp;country;
    let ref_two = &amp;country;

    println!(&quot;{}&quot;, ref_one);
}
</code></pre></pre>
<p>這樣就會打印出<code>Austria</code>。</p>
<p>在代碼中，<code>country</code>是一個<code>String</code>。然後我們創建了兩個<code>country</code>的引用。它們的類型是<code>&amp;String</code>，你說這是一個 &quot;字符串的引用&quot;。我們可以創建三個引用或者一百個對 <code>country</code> 的引用，這都沒有問題。</p>
<p>但這是一個問題。</p>
<pre><pre class="playground"><code class="language-rust">fn return_str() -&gt; &amp;str {
    let country = String::from(&quot;Austria&quot;);
    let country_ref = &amp;country;
    country_ref // ⚠️
}

fn main() {
    let country = return_str();
}
</code></pre></pre>
<p><code>return_str()</code>函數創建了一個String，然後它創建了一個對String的引用。然後它試圖返回引用。但是<code>country</code>這個String只活在函數裡面，然後它就死了。一旦一個變量消失了，計算機就會清理內存，並將其用於其他用途。所以在函數結束後，<code>country_ref</code>引用的是已經消失的內存，這是不對的。Rust防止我們在這裡犯內存的錯誤。</p>
<p>這就是我們上面講到的 &quot;擁有&quot;類型的重要部分。因為你擁有一個<code>String</code>，你可以把它傳給別人。但是如果 <code>&amp;String</code> 的 <code>String</code> 死了，那麼 <code>&amp;String</code> 就會死掉，所以你不能把它的 &quot;所有權&quot;傳給別人。</p>
<h2 id="可變引用"><a class="header" href="#可變引用">可變引用</a></h2>
<p>如果您想使用一個引用來改變數據，您可以使用一個可變引用。對於可變引用，您可以寫 <code>&amp;mut</code> 而不是 <code>&amp;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 8; // don't forget to write mut here!
    let num_ref = &amp;mut my_number;
}
</code></pre></pre>
<p>那麼這兩種類型是什麼呢？<code>my_number</code>是<code>i32</code>，<code>num_ref</code>是<code>&amp;mut i32</code>(我們說是 &quot;可變引用<code>i32</code>&quot;)。</p>
<p>所以我們用它來給my_number加10。但是你不能寫<code>num_ref += 10</code>，因為<code>num_ref</code>不是<code>i32</code>的值，它是一個<code>&amp;i32</code>。其實這個值就在<code>i32</code>裡面。為了達到值所在的地方，我們用<code>*</code>。<code>*</code>的意思是 &quot;我不要引用，我要引用對應的值&quot;。換句話說，一個<code>*</code>與<code>&amp;</code>是相反的。另外，一個<code>*</code>抹去了一個<code>&amp;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 8;
    let num_ref = &amp;mut my_number;
    *num_ref += 10; // Use * to change the i32 value.
    println!(&quot;{}&quot;, my_number);

    let second_number = 800;
    let triple_reference = &amp;&amp;&amp;second_number;
    println!(&quot;Second_number = triple_reference? {}&quot;, second_number == ***triple_reference);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">18
Second_number = triple_reference? true
</code></pre>
<p>因為使用<code>&amp;</code>叫做 &quot;引用&quot;，所以使用<code>*</code>叫做 &quot;<strong>de</strong>referencing&quot;。</p>
<p>Rust有兩個規則，分別是可變引用和不可變引用。它們非常重要，但也很容易記住，因為它們很有意義。</p>
<ul>
<li><strong>規則1</strong>。如果你只有不可變引用，你可以有任意多的引用。1個也行，3個也行，1000個也行，沒問題。</li>
<li><strong>規則2</strong>: 如果你有一個可變引用，你只能有一個。另外，你不能同時使用一個不可變引用<strong>和</strong>一個可變引用。</li>
</ul>
<p>這是因為可變引用可以改變數據。如果你在其他引用讀取數據時改變數據，你可能會遇到問題。</p>
<p>一個很好的理解方式是思考一個Powerpoint演示。</p>
<p>情況一是關於<strong>只有一個可變引用</strong></p>
<p>情境一 一個員工正在編寫一個Powerpoint演示文稿，他希望他的經理能幫助他。他希望他的經理能幫助他。該員工將自己的登錄信息提供給經理，並請他幫忙進行編輯。現在，經理對該員工的演示文稿有了一個 &quot;可變引用&quot;。經理可以做任何他想做的修改，然後把電腦還給他。這很好，因為沒有人在看這個演示文稿。</p>
<p>情況二是關於<strong>只有不可變引用</strong></p>
<p>情況二 該員工要給100個人做演示。現在這100個人都可以看到該員工的數據。
他們都有一個 &quot;不可改變的引用&quot;，即員工的介紹。這很好，因為他們可以看到它，但沒有人可以改變數據。</p>
<p>情況三是<strong>有問題的情況</strong></p>
<p>情況三 員工把他的登錄信息給了經理 他的經理現在有了一個 &quot;可變引用&quot;。然後員工去給100個人做演示，但是經理還是可以登錄。這是不對的，因為經理可以登錄，可以做任何事情。也許他的經理會登錄電腦，然後開始給他的母親打一封郵件! 現在這100人不得不看著經理給他母親寫郵件，而不是演示。這不是他們期望看到的。</p>
<p>下面是一個可變借用與不可變借用的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 10;
    let number_ref = &amp;number;
    let number_change = &amp;mut number;
    *number_change += 10;
    println!(&quot;{}&quot;, number_ref); // ⚠️
}
</code></pre></pre>
<p>編譯器打印了一個有用的信息來告訴我們問題所在。</p>
<pre><code class="language-text">error[E0502]: cannot borrow `number` as mutable because it is also borrowed as immutable
 --&gt; src\main.rs:4:25
  |
3 |     let number_ref = &amp;number;
  |                      ------- immutable borrow occurs here
4 |     let number_change = &amp;mut number;
  |                         ^^^^^^^^^^^ mutable borrow occurs here
5 |     *number_change += 10;
6 |     println!(&quot;{}&quot;, number_ref);
  |                    ---------- immutable borrow later used here
</code></pre>
<p>然而，這段代碼可以工作。為什麼會這樣？</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 10;
    let number_change = &amp;mut number; // create a mutable reference
    *number_change += 10; // use mutable reference to add 10
    let number_ref = &amp;number; // create an immutable reference
    println!(&quot;{}&quot;, number_ref); // print the immutable reference
}
</code></pre></pre>
<p>它打印出<code>20</code>沒有問題。它能工作是因為編譯器足夠聰明，能夠理解我們的代碼。它知道我們使用了<code>number_change</code>來改變<code>number</code>，但沒有再使用它。所以這裡沒有問題。我們並沒有將不可變和可變引用一起使用。</p>
<p>早期在Rust中，這種代碼實際上會產生錯誤，但現在的編譯器更聰明瞭。它不僅能理解我們輸入的內容，還能理解我們如何使用所有的東西。</p>
<h3 id="再談shadowing"><a class="header" href="#再談shadowing">再談shadowing</a></h3>
<p>還記得我們說過，shadowing不會<strong>破壞</strong>一個值，而是<strong>屏蔽</strong>它嗎？現在我們可以用引用來看看這個問題。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from(&quot;Austria&quot;);
    let country_ref = &amp;country;
    let country = 8;
    println!(&quot;{}, {}&quot;, country_ref, country);
}
</code></pre></pre>
<p>這是打印<code>Austria, 8</code>還是<code>8, 8</code>？它打印的是<code>Austria, 8</code>。首先我們聲明一個<code>String</code>，叫做<code>country</code>。然後我們給這個字符串創建一個引用<code>country_ref</code>。然後我們用8來shadowing國家，這是一個<code>i32</code>。但是第一個<code>country</code>並沒有被銷燬，所以<code>country_ref</code>仍然寫著 &quot;Austria&quot;，而不是 &quot;8&quot;。下面是同樣的代碼，並加了一些註釋來說明它的工作原理。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from(&quot;Austria&quot;); // Now we have a String called country
    let country_ref = &amp;country; // country_ref is a reference to this data. It's not going to change
    let country = 8; // Now we have a variable called country that is an i8. But it has no relation to the other one, or to country_ref
    println!(&quot;{}, {}&quot;, country_ref, country); // country_ref still refers to the data of String::from(&quot;Austria&quot;) that we gave it.
}
</code></pre></pre>
<h2 id="函數的引用"><a class="header" href="#函數的引用">函數的引用</a></h2>
<p>引用對函數非常有用。Rust中關於值的規則是:一個值只能有一個所有者。</p>
<p>這段代碼將無法工作:</p>
<pre><pre class="playground"><code class="language-rust">fn print_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Austria&quot;);
    print_country(country); // We print &quot;Austria&quot;
    print_country(country); // ⚠️ That was fun, let's do it again!
}
</code></pre></pre>
<p>它不能工作，因為<code>country</code>被破壞了。下面是如何操作的。</p>
<ul>
<li>第一步，我們創建<code>String</code>，稱為<code>country</code>。<code>country</code>是所有者。</li>
<li>第二步:我們把<code>country</code>給<code>print_country</code>。<code>print_country</code>沒有<code>-&gt;</code>，所以它不返回任何東西。<code>print_country</code>完成後，我們的<code>String</code>現在已經死了。</li>
<li>第三步:我們嘗試把<code>country</code>給<code>print_country</code>，但我們已經這樣做了。我們已經沒有<code>country</code>可以給了。</li>
</ul>
<p>我們可以讓<code>print_country</code>給<code>String</code>回來，但是有點尷尬。</p>
<pre><pre class="playground"><code class="language-rust">fn print_country(country_name: String) -&gt; String {
    println!(&quot;{}&quot;, country_name);
    country_name // return it here
}

fn main() {
    let country = String::from(&quot;Austria&quot;);
    let country = print_country(country); // we have to use let here now to get the String back
    print_country(country);
}
</code></pre></pre>
<p>現在打印出來了。</p>
<pre><code class="language-text">Austria
Austria
</code></pre>
<p>更好的解決方法是增加<code>&amp;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn print_country(country_name: &amp;String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Austria&quot;);
    print_country(&amp;country); // We print &quot;Austria&quot;
    print_country(&amp;country); // That was fun, let's do it again!
}
</code></pre></pre>
<p>現在 <code>print_country()</code> 是一個函數，它接受 <code>String</code> 的引用: <code>&amp;String</code>。另外，我們給country一個引用，寫作<code>&amp;country</code>。這表示 &quot;你可以看它，但我要保留它&quot;。</p>
<p>現在讓我們用一個可變引用來做類似的事情。下面是一個使用可變變量的函數的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn add_hungary(country_name: &amp;mut String) { // first we say that the function takes a mutable reference
    country_name.push_str(&quot;-Hungary&quot;); // push_str() adds a &amp;str to a String
    println!(&quot;Now it says: {}&quot;, country_name);
}

fn main() {
    let mut country = String::from(&quot;Austria&quot;);
    add_hungary(&amp;mut country); // we also need to give it a mutable reference.
}
</code></pre></pre>
<p>此打印<code>Now it says: Austria-Hungary</code>。</p>
<p>所以得出結論:</p>
<ul>
<li><code>fn function_name(variable: String)</code>接收了<code>String</code>，並擁有它。如果它不返回任何東西，那麼這個變量就會在函數裡面死亡。</li>
<li><code>fn function_name(variable: &amp;String)</code> 借用 <code>String</code> 並可以查看它</li>
<li><code>fn function_name(variable: &amp;mut String)</code>借用<code>String</code>，可以更改。</li>
</ul>
<p>下面是一個看起來像可變引用的例子，但它是不同的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from(&quot;Austria&quot;); // country is not mutable, but we are going to print Austria-Hungary. How?
    adds_hungary(country);
}

fn adds_hungary(mut country: String) { // Here's how: adds_hungary takes the String and declares it mutable!
    country.push_str(&quot;-Hungary&quot;);
    println!(&quot;{}&quot;, country);
}
</code></pre></pre>
<p>這怎麼可能呢？因為<code>mut country</code>不是引用。<code>adds_hungary</code>現在擁有<code>country</code>。(記住，它佔用的是<code>String</code>而不是<code>&amp;String</code>)。當你調用<code>adds_hungary</code>的那一刻，它就完全成了country的主人。<code>country</code>與<code>String::from(&quot;Austria&quot;)</code>沒有關係了。所以，<code>adds_hungary</code>可以把<code>country</code>當作可變的，這樣做是完全安全的。</p>
<p>還記得我們上面的員工Powerpoint和經理的情況嗎？在這種情況下，就好比員工只是把自己的整臺電腦交給了經理。員工不會再碰它，所以經理可以對它做任何他想做的事情。</p>
<h2 id="拷貝類型"><a class="header" href="#拷貝類型">拷貝類型</a></h2>
<p>Rust中的一些類型非常簡單。它們被稱為<strong>拷貝類型</strong>。這些簡單的類型都在棧中，編譯器知道它們的大小。這意味著它們非常容易複製，所以當你把它發送到一個函數時，編譯器總是會複製。它總是複製，因為它們是如此的小而簡單，沒有理由不復制。所以你不需要擔心這些類型的所有權問題。</p>
<p>這些簡單的類型包括:整數、浮點數、布爾值(<code>true</code>和<code>false</code>)和<code>char</code>。</p>
<p>如何知道一個類型是否<strong>實現</strong>複製？(實現 = 能夠使用)你可以查看文檔。例如，這裡是 char 的文檔:</p>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>在左邊你可以看到<strong>Trait Implementations</strong>。例如你可以看到<strong>Copy</strong>, <strong>Debug</strong>, 和 <strong>Display</strong>。所以你知道，當你把一個<code>char</code>:</p>
<ul>
<li>當你把它發送到一個函數(<strong>Copy</strong>)時，它就被複制了。</li>
<li>可以用<code>{}</code>打印(<strong>Display</strong>)</li>
<li>可以用<code>{:?}</code>打印(<strong>Debug</strong>)</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_number(number: i32) { // There is no -&gt; so it's not returning anything
                             // If number was not copy type, it would take it
                             // and we couldn't use it again
    println!(&quot;{}&quot;, number);
}

fn main() {
    let my_number = 8;
    prints_number(my_number); // Prints 8. prints_number gets a copy of my_number
    prints_number(my_number); // Prints 8 again.
                              // No problem, because my_number is copy type!
}
</code></pre></pre>
<p>但是如果你看一下String的文檔，它不是拷貝類型。</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>在左邊的<strong>Trait Implementations</strong>中，你可以按字母順序查找。A、B、C......C中沒有<strong>Copy</strong>，但是有<strong>Clone</strong>。<strong>Clone</strong>和<strong>Copy</strong>類似，但通常需要更多的內存。另外，你必須用<code>.clone()</code>來調用它--它不會自己克隆。</p>
<p>在這個例子中，<code>prints_country()</code>打印的是國家名稱，一個<code>String</code>。我們想打印兩次，但我們不能。</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country);
    prints_country(country); // ⚠️
}
</code></pre></pre>
<p>但現在我們明白了這個信息。</p>
<pre><code class="language-text">error[E0382]: use of moved value: `country`
 --&gt; src\main.rs:4:20
  |
2 |     let country = String::from(&quot;Kiribati&quot;);
  |         ------- move occurs because `country` has type `std::string::String`, which does not implement the `Copy` trait
3 |     prints_country(country);
  |                    ------- value moved here
4 |     prints_country(country);
  |                    ^^^^^^^ value used here after move
</code></pre>
<p>重要的部分是<code>which does not implement the Copy trait</code>。但是在文檔中我們看到String實現了<code>Clone</code>的特性。所以我們可以在代碼中添加<code>.clone()</code>。這樣就創建了一個克隆，然後我們將克隆發送到函數中。現在 <code>country</code> 還活著，所以我們可以使用它。</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country.clone()); // make a clone and give it to the function. Only the clone goes in, and country is still alive
    prints_country(country);
}
</code></pre></pre>
<p>當然，如果<code>String</code>非常大，<code>.clone()</code>就會佔用很多內存。一個<code>String</code>可以是一整本書的長度，我們每次調用<code>.clone()</code>都會複製這本書。所以，如果可以的話，使用<code>&amp;</code>來做引用是比較快的。例如，這段代碼將<code>&amp;str</code>推送到<code>String</code>上，然後每次在函數中使用時都會進行克隆。</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: String) { // Takes ownership of a String
    println!(&quot;It's {} words long.&quot;, input.split_whitespace().count()); // splits to count the number of words
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Here are some more words &quot;); // push the words on
        get_length(my_string.clone()); // gives it a clone every time
    }
}
</code></pre></pre>
<p>它的打印。</p>
<pre><code class="language-text">It's 5 words long.
It's 10 words long.
...
It's 250 words long.
</code></pre>
<p>這就是50個克隆。這裡是用引用代替更好:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: &amp;String) {
    println!(&quot;It's {} words long.&quot;, input.split_whitespace().count());
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Here are some more words &quot;);
        get_length(&amp;my_string);
    }
}
</code></pre></pre>
<p>不是50個克隆，而是0個。</p>
<h3 id="無值變量"><a class="header" href="#無值變量">無值變量</a></h3>
<p>一個沒有值的變量叫做 &quot;未初始化&quot;變量。未初始化的意思是 &quot;還沒有開始&quot;。它們很簡單:只需寫上<code>let</code>和變量名。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_variable; // ⚠️
}
</code></pre></pre>
<p>但是你還不能使用它，如果任何東西都沒有被初始化，Rust就不會編譯。</p>
<p>但有時它們會很有用。一個很好的例子是當:</p>
<ul>
<li>你有一個代碼塊，而你的變量值就在裡面，並且</li>
<li>變量需要活在代碼塊之外。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn loop_then_return(mut counter: i32) -&gt; i32 {
    loop {
        counter += 1;
        if counter % 50 == 0 {
            break;
        }
    }
    counter
}

fn main() {
    let my_number;

    {
        // Pretend we need to have this code block
        let number = {
            // Pretend there is code here to make a number
            // Lots of code, and finally:
            57
        };

        my_number = loop_then_return(number);
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>這將打印出 <code>100</code>。</p>
<p>你可以看到 <code>my_number</code> 是在 <code>main()</code> 函數中聲明的，所以它一直活到最後。但是它的值是在循環裡面得到的。然而，這個值和<code>my_number</code>一樣長，因為<code>my_number</code>有這個值。而如果你在塊裡面寫了<code>let my_number = loop_then_return(number)</code>，它就會馬上死掉。</p>
<p>如果你簡化代碼，對想象是有幫助的。<code>loop_then_return(number)</code>給出的結果是100，所以我們刪除它，改寫<code>100</code>。另外，現在我們不需要 <code>number</code>，所以我們也刪除它。現在它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number;
    {
        my_number = 100;
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>所以說<code>let my_number = { 100 };</code>差不多。</p>
<p>另外注意，<code>my_number</code>不是<code>mut</code>。我們在給它50之前並沒有給它一個值，所以它的值一直沒有改變。最後，<code>my_number</code>的真正代碼只是<code>let my_number = 100;</code>。</p>
<h2 id="集合類型"><a class="header" href="#集合類型">集合類型</a></h2>
<p>Rust有很多類型用於創建集合。當你需要在一個地方有多個值時，就可以使用集合。例如，你可以在一個變量中包含你所在國家的所有城市的信息。我們先從數組開始，數組的速度最快，但功能也最少。它們在這方面有點像<code>&amp;str</code>。</p>
<h3 id="數組-1"><a class="header" href="#數組-1">數組</a></h3>
<p>數組是方括號內的數據。<code>[]</code>. 數組:</p>
<ul>
<li>不能改變其大小。</li>
<li>必須只包含相同的類型。</li>
</ul>
<p>但是，它們的速度非常快。</p>
<p>數組的類型是:<code>[type; number]</code>。例如，<code>[&quot;One&quot;, &quot;Two&quot;]</code>的類型是<code>[&amp;str; 2]</code>。這意味著，即使這兩個數組也有不同的類型。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array1 = [&quot;One&quot;, &quot;Two&quot;]; // This one is type [&amp;str; 2]
    let array2 = [&quot;One&quot;, &quot;Two&quot;, &quot;Five&quot;]; // But this one is type [&amp;str; 3]. Different type!
}
</code></pre></pre>
<p>這裡有一個很好的提示:要想知道一個變量的類型，你可以通過給編譯器下壞指令來 &quot;詢問&quot;它。比如說</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    let seasons2 = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    seasons.ddd(); // ⚠️
    seasons2.thd(); // ⚠️ as well
}
</code></pre></pre>
<p>編譯器說:&quot;什麼？seasons沒有<code>.ddd()</code>的方法，seasons2也沒有<code>.thd()</code>的方法！！&quot;你可以看到:</p>
<pre><code class="language-text">error[E0599]: no method named `ddd` found for array `[&amp;str; 4]` in the current scope
 --&gt; src\main.rs:4:13
  |
4 |     seasons.ddd(); // 
  |             ^^^ method not found in `[&amp;str; 4]`

error[E0599]: no method named `thd` found for array `[&amp;str; 5]` in the current scope
 --&gt; src\main.rs:5:14
  |
5 |     seasons2.thd(); // 
  |              ^^^ method not found in `[&amp;str; 5]`
</code></pre>
<p>所以它告訴你<code>method not found in `[&amp;str; 4]`</code>，這就是類型。</p>
<p>如果你想要一個數值都一樣的數組，你可以這樣聲明。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_array = [&quot;a&quot;; 10];
    println!(&quot;{:?}&quot;, my_array);
}
</code></pre></pre>
<p>這樣就打印出了<code>[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</code>。</p>
<p>這個方法經常用來創建緩衝區。例如，<code>let mut buffer = [0; 640]</code>創建一個640個零的數組。然後我們可以將零改為其他數字，以便添加數據。</p>
<p>你可以用[]來索引(獲取)數組中的條目。第一個條目是[0]，第二個是[1]，以此類推。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_numbers = [0, 10, -20];
    println!(&quot;{}&quot;, my_numbers[1]); // prints 10
}
</code></pre></pre>
<p>你可以得到一個數組的一個片斷(一塊)。首先你需要一個&amp;，因為編譯器不知道大小。然後你可以使用<code>..</code>來顯示範圍。</p>
<p>例如，讓我們使用這個數組。<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array_of_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let three_to_five = &amp;array_of_ten[2..5];
    let start_at_two = &amp;array_of_ten[1..];
    let end_at_five = &amp;array_of_ten[..5];
    let everything = &amp;array_of_ten[..];

    println!(&quot;Three to five: {:?}, start at two: {:?}, end at five: {:?}, everything: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>記住這一點。</p>
<ul>
<li>索引號從0開始(不是1)</li>
<li>索引範圍是<strong>不包含的</strong>(不包括最後一個數字)。</li>
</ul>
<p>所以<code>[0..2]</code>是指第一個指數和第二個指數(0和1)。或者你也可以稱它為 &quot;零點和第一&quot;指數。它沒有第三項，也就是索引2。</p>
<p>你也可以有一個<strong>包含的</strong>範圍，這意味著它也包括最後一個數字。要做到這一點。
添加<code>=</code>，寫成<code>..=</code>，而不是<code>..</code>。所以，如果你想要第一項、第二項和第三項，可以寫成<code>[0..=2]</code>，而不是<code>[0..2]</code>。</p>
<h2 id="向量"><a class="header" href="#向量">向量</a></h2>
<p>就像我們有<code>&amp;str</code>和<code>String</code>一樣，我們有數組和向量。數組的功能少了就快，向量的功能多了就慢。(當然，Rust的速度一直都是非常快的，所以向量並不慢，只是比數組慢<em>一點</em>)。類型寫成<code>Vec</code>，你也可以直接叫它 &quot;vec&quot;。</p>
<p>向量的聲明主要有兩種方式。一種是像<code>String</code>一樣使用<code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name1 = String::from(&quot;Windy&quot;);
    let name2 = String::from(&quot;Gomesy&quot;);

    let mut my_vec = Vec::new();
    // If we run the program now, the compiler will give an error.
    // It doesn't know the type of vec.

    my_vec.push(name1); // Now it knows: it's Vec&lt;String&gt;
    my_vec.push(name2);
}
</code></pre></pre>
<p>你可以看到<code>Vec</code>裡面總是有其他東西，這就是<code>&lt;&gt;</code>(角括號)的作用。<code>Vec&lt;String&gt;</code>是一個有一個或多個<code>String</code>的向量。你還可以在裡面有更多的類型。比如說</p>
<ul>
<li><code>Vec&lt;(i32, i32)&gt;</code> 這是一個 <code>Vec</code> 其中每個元素是一個元組。<code>(i32, i32)</code>.</li>
<li><code>Vec&lt;Vec&lt;String&gt;&gt;</code>這是一個<code>Vec</code>，其中有<code>Vec</code>的<code>Strings</code>。比如說你想把你喜歡的書保存為<code>Vec&lt;String&gt;</code>。然後你再用另一本書來做，就會得到另一個<code>Vec&lt;String&gt;</code>。為了保存這兩本書，你會把它們放入另一個<code>Vec</code>中，這就是<code>Vec&lt;Vec&lt;String&gt;&gt;</code>。</li>
</ul>
<p>與其使用 <code>.push()</code> 讓 Rust 決定類型，不如直接聲明類型。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec: Vec&lt;String&gt; = Vec::new(); // The compiler knows the type
                                              // so there is no error.
}
</code></pre></pre>
<p>你可以看到，向量中的元素必須具有相同的類型。</p>
<p>另一個創建向量的簡單方法是使用 <code>vec!</code> 宏。它看起來像一個數組聲明，但前面有 <code>vec!</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![8, 10, 10];
}
</code></pre></pre>
<p>類型是<code>Vec&lt;i32&gt;</code>。你稱它為 &quot;i32的Vec&quot;。而<code>Vec&lt;String&gt;</code>是 &quot;String的Vec&quot;。<code>Vec&lt;Vec&lt;String&gt;&gt;</code>是 &quot;String的Vec的Vec&quot;。</p>
<p>你也可以對一個向量進行分片，就像在數組中一樣。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec_of_ten = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    // Everything is the same as above except we added vec!.
    let three_to_five = &amp;vec_of_ten[2..5];
    let start_at_two = &amp;vec_of_ten[1..];
    let end_at_five = &amp;vec_of_ten[..5];
    let everything = &amp;vec_of_ten[..];

    println!(&quot;Three to five: {:?},
start at two: {:?}
end at five: {:?}
everything: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>因為Vector比數組慢，我們可以用一些方法讓它更快。一個vec有一個<strong>容量</strong>，也就是給向量的空間。當你在向量上推送一個新的元素時，它會越來越接近容量。然後，如果你超過了容量，它將使其容量翻倍，並將元素複製到新的空間。這就是所謂的重新分配。我們將使用一種名為<code>.capacity()</code>的方法來查看向量的容量，在我們向它添加元素時。</p>
<p>例如，我們將使用名為<code>.capacity()</code>的方法來觀察一個向量的容量。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::new();
    println!(&quot;{}&quot;, num_vec.capacity()); // 0 elements: prints 0
    num_vec.push('a'); // add one character
    println!(&quot;{}&quot;, num_vec.capacity()); // 1 element: prints 4. Vecs with 1 item always start with capacity 4
    num_vec.push('a'); // add one more
    num_vec.push('a'); // add one more
    num_vec.push('a'); // add one more
    println!(&quot;{}&quot;, num_vec.capacity()); // 4 elements: still prints 4.
    num_vec.push('a'); // add one more
    println!(&quot;{}&quot;, num_vec.capacity()); // prints 8. We have 5 elements, but it doubled 4 to 8 to make space
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">0
4
4
8
</code></pre>
<p>所以這個向量有兩次重分配: 0到4，4到8。我們可以讓它更快:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::with_capacity(8); // Give it capacity 8
    num_vec.push('a'); // add one character
    println!(&quot;{}&quot;, num_vec.capacity()); // prints 8
    num_vec.push('a'); // add one more
    println!(&quot;{}&quot;, num_vec.capacity()); // prints 8
    num_vec.push('a'); // add one more
    println!(&quot;{}&quot;, num_vec.capacity()); // prints 8.
    num_vec.push('a'); // add one more
    num_vec.push('a'); // add one more // Now we have 5 elements
    println!(&quot;{}&quot;, num_vec.capacity()); // Still 8
}
</code></pre></pre>
<p>這個向量有0個重分配，這是比較好的。所以如果你認為你知道你需要多少元素，你可以使用<code>Vec::with_capacity()</code>來使它更快。</p>
<p>你記得你可以用<code>.into()</code>把<code>&amp;str</code>變成<code>String</code>。你也可以用它把一個數組變成<code>Vec</code>。你必須告訴 <code>.into()</code> 你想要一個 <code>Vec</code>，但你不必選擇 <code>Vec</code> 的類型。如果你不想選擇，你可以寫<code>Vec&lt;_&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;u8&gt; = [1, 2, 3].into();
    let my_vec2: Vec&lt;_&gt; = [9, 0, 10].into(); // Vec&lt;_&gt; means &quot;choose the Vec type for me&quot;
                                             // Rust will choose Vec&lt;i32&gt;
}
</code></pre></pre>
<h2 id="元組-1"><a class="header" href="#元組-1">元組</a></h2>
<p>Rust中的元組使用<code>()</code>。我們已經見過很多空元組了，因為函數中的<em>nothing</em>實際上意味著一個空元組。</p>
<pre><code class="language-text">fn do_something() {}
</code></pre>
<p>其實是它的簡寫:</p>
<pre><code class="language-text">fn do_something() -&gt; () {}
</code></pre>
<p>這個函數什麼也得不到(一個空元組)，也不返回什麼(一個空元組)。所以我們已經經常使用元組了。當你在一個函數中不返回任何東西時，你實際上返回的是一個空元組。</p>
<pre><pre class="playground"><code class="language-rust">fn just_prints() {
    println!(&quot;I am printing&quot;); // Adding ; means we return an empty tuple
}

fn main() {}
</code></pre></pre>
<p>但是元組可以容納很多東西，也可以容納不同的類型。元組裡面的元素也是用數字0、1、2等來做索引的，但要訪問它們，你要用<code>.</code>而不是<code>[]</code>。讓我們把一大堆類型放到一個元組中。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let random_tuple = (&quot;Here is a name&quot;, 8, vec!['a'], 'b', [8, 9, 10], 7.7);
    println!(
        &quot;Inside the tuple is: First item: {:?}
Second item: {:?}
Third item: {:?}
Fourth item: {:?}
Fifth item: {:?}
Sixth item: {:?}&quot;,
        random_tuple.0,
        random_tuple.1,
        random_tuple.2,
        random_tuple.3,
        random_tuple.4,
        random_tuple.5,
    )
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Inside the tuple is: First item: &quot;Here is a name&quot;
Second item: 8
Third item: ['a']
Fourth item: 'b'
Fifth item: [8, 9, 10]
Sixth item: 7.7
</code></pre>
<p>這個元組的類型是 <code>(&amp;str, i32, Vec&lt;char&gt;, char, [i32; 3], f64)</code>。</p>
<p>你可以使用一個元組來創建多個變量。看看這段代碼。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
}
</code></pre></pre>
<p><code>str_vec</code>裡面有三個元素。如果我們想把它們拉出來呢？這時我們可以使用元組。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (a, b, c) = (str_vec[0], str_vec[1], str_vec[2]); // call them a, b, and c
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<p>這就打印出<code>&quot;two&quot;</code>，也就是<code>b</code>。這就是所謂的<em>解構</em>。這是因為首先變量是在結構體裡面的，但是我們又做了<code>a</code>、<code>b</code>、<code>c</code>這些不是在結構體裡面的變量。</p>
<p>如果你需要解構，但又不想要所有的變量，你可以使用<code>_</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (_, _, variable) = (str_vec[0], str_vec[1], str_vec[2]);
}
</code></pre></pre>
<p>現在它只創建了一個叫<code>variable</code>的變量，但沒有為其他值做變量。</p>
<p>還有很多集合類型，還有很多使用數組、vec和tuple的方法。我們也將學習更多關於它們的知識，但首先我們將學習控制流。</p>
<h2 id="控制流"><a class="header" href="#控制流">控制流</a></h2>
<p>控制流的意思是告訴你的代碼在不同的情況下該怎麼做。最簡單的控制流是<code>if</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;It's seven&quot;);
    }
}
</code></pre></pre>
<p>另外注意，你用的是<code>==</code>而不是<code>=</code>。<code>==</code>是用來比較的，<code>=</code>是用來<em>賦值</em>的(給一個值)。另外注意，我們寫的是<code>if my_number == 7</code>而不是<code>if (my_number == 7)</code>。在Rust中，你不需要用<code>if</code>的括號。</p>
<p><code>else if</code>和<code>else</code>給你更多的控制:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;It's seven&quot;);
    } else if my_number == 6 {
        println!(&quot;It's six&quot;)
    } else {
        println!(&quot;It's a different number&quot;)
    }
}
</code></pre></pre>
<p>這打印出<code>It's a different number</code>，因為它不等於7或6。</p>
<p>您可以使用 <code>&amp;&amp;</code>(和)和 <code>||</code>(或)添加更多條件。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number % 2 == 1 &amp;&amp; my_number &gt; 0 { // % 2 means the number that remains after diving by two
        println!(&quot;It's a positive odd number&quot;);
    } else if my_number == 6 {
        println!(&quot;It's six&quot;)
    } else {
        println!(&quot;It's a different number&quot;)
    }
}
</code></pre></pre>
<p>這打印出的是<code>It's a positive odd number</code>，因為當你把它除以2時，你有一個1的餘數，它大於0。</p>
<p>你可以看到，過多的<code>if</code>、<code>else</code>和<code>else if</code>會很難讀。在這種情況下，你可以使用<code>match</code>來代替，它看起來更乾淨。但是您必須為每一個可能的結果進行匹配。例如，這將無法工作:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;it's zero&quot;),
        1 =&gt; println!(&quot;it's one&quot;),
        2 =&gt; println!(&quot;it's two&quot;),
        // ⚠️
    }
}
</code></pre></pre>
<p>編譯器說:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `3u8..=std::u8::MAX` not covered
 --&gt; src\main.rs:3:11
  |
3 |     match my_number {
  |           ^^^^^^^^^ pattern `3u8..=std::u8::MAX` not covered
</code></pre>
<p>這就意味著 &quot;你告訴我0到2，但<code>u8</code>可以到255。那3呢？那4呢？5呢？&quot; 以此類推。所以你可以加上<code>_</code>，意思是 &quot;其他任何東西&quot;。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;it's zero&quot;),
        1 =&gt; println!(&quot;it's one&quot;),
        2 =&gt; println!(&quot;it's two&quot;),
        _ =&gt; println!(&quot;It's some other number&quot;),
    }
}
</code></pre></pre>
<p>那打印<code>It's some other number</code>。</p>
<p>記住匹配的規則:</p>
<ul>
<li>你寫下<code>match</code>，然後創建一個<code>{}</code>的代碼塊。</li>
<li>在左邊寫上<em>模式</em>，用<code>=&gt;</code>胖箭頭說明匹配時該怎麼做。</li>
<li>每一行稱為一個 &quot;arm&quot;。</li>
<li>在arm之間放一個逗號(不是分號)。</li>
</ul>
<p>你可以用匹配來聲明一個值。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    let second_number = match my_number {
        0 =&gt; 0,
        5 =&gt; 10,
        _ =&gt; 2,
    };
}
</code></pre></pre>
<p><code>second_number</code>將是10。你看到最後的分號了嗎？那是因為，在match結束後，我們實際上告訴了編譯器這個信息:<code>let second_number = 10;</code></p>
<p>你也可以在更復雜的事情上進行匹配。你用一個元組來做。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sky = &quot;cloudy&quot;;
    let temperature = &quot;warm&quot;;

    match (sky, temperature) {
        (&quot;cloudy&quot;, &quot;cold&quot;) =&gt; println!(&quot;It's dark and unpleasant today&quot;),
        (&quot;clear&quot;, &quot;warm&quot;) =&gt; println!(&quot;It's a nice day&quot;),
        (&quot;cloudy&quot;, &quot;warm&quot;) =&gt; println!(&quot;It's dark but not bad&quot;),
        _ =&gt; println!(&quot;Not sure what the weather is.&quot;),
    }
}
</code></pre></pre>
<p>這打印了<code>It's dark but not bad</code>，因為它與<code>sky</code>和<code>temperature</code>的 &quot;多雲&quot;和 &quot;溫暖&quot;相匹配。</p>
<p>你甚至可以把<code>if</code>放在<code>match</code>裡面。這就是所謂的 &quot;match guard&quot;。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let children = 5;
    let married = true;

    match (children, married) {
        (children, married) if married == false =&gt; println!(&quot;Not married with {} children&quot;, children),
        (children, married) if children == 0 &amp;&amp; married == true =&gt; println!(&quot;Married but no children&quot;),
        _ =&gt; println!(&quot;Married? {}. Number of children: {}.&quot;, married, children),
    }
}
</code></pre></pre>
<p>這將打印<code>Married? true. Number of children: 5.</code></p>
<p>在一次匹配中，你可以隨意使用 _ 。在這個關於顏色的匹配中，我們有三個顏色，但一次只能選中一個。</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    match rbg {
        (r, _, _) if r &lt; 10 =&gt; println!(&quot;Not much red&quot;),
        (_, b, _) if b &lt; 10 =&gt; println!(&quot;Not much blue&quot;),
        (_, _, g) if g &lt; 10 =&gt; println!(&quot;Not much green&quot;),
        _ =&gt; println!(&quot;Each colour has at least 10&quot;),
    }
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);

}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">Not much blue
Each colour has at least 10
Not much green
</code></pre>
<p>這也說明瞭<code>match</code>語句的作用，因為在第一個例子中，它只打印了<code>Not much blue</code>。但是<code>first</code>也沒有多少綠色。<code>match</code>語句總是在找到一個匹配項時停止，而不檢查其他的。這就是一個很好的例子，代碼編譯得很好，但不是你想要的代碼。</p>
<p>你可以創建一個非常大的 <code>match</code> 語句來解決這個問題，但是使用 <code>for</code> 循環可能更好。我們將很快討論循環。</p>
<p>匹配必須返回相同的類型。所以你不能這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;
    let some_variable = match my_number {
        10 =&gt; 8,
        _ =&gt; &quot;Not ten&quot;, // ⚠️
    };
}
</code></pre></pre>
<p>編譯器告訴你:</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
  --&gt; src\main.rs:17:14
   |
15 |       let some_variable = match my_number {
   |  _________________________-
16 | |         10 =&gt; 8,
   | |               - this is found to be of type `{integer}`
17 | |         _ =&gt; &quot;Not ten&quot;,
   | |              ^^^^^^^^^ expected integer, found `&amp;str`
18 | |     };
   | |_____- `match` arms have incompatible types
</code></pre>
<p>這樣也不行，原因同上。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_variable = if my_number == 10 { 8 } else { &quot;something else &quot;}; // ⚠️
}
</code></pre></pre>
<p>但是這樣就可以了，因為不是<code>match</code>，所以你每次都有不同的<code>let</code>語句。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;

    if my_number == 10 {
        let some_variable = 8;
    } else {
        let some_variable = &quot;Something else&quot;;
    }
}
</code></pre></pre>
<p>你也可以使用 <code>@</code> 給 <code>match</code> 表達式的值起一個名字，然後你就可以使用它。在這個例子中，我們在一個函數中匹配一個 <code>i32</code> 輸入。如果是4或13，我們要在<code>println!</code>語句中使用這個數字。否則，我們不需要使用它。</p>
<pre><pre class="playground"><code class="language-rust">fn match_number(input: i32) {
    match input {
    number @ 4 =&gt; println!(&quot;{} is an unlucky number in China (sounds close to 死)!&quot;, number),
    number @ 13 =&gt; println!(&quot;{} is unlucky in North America, lucky in Italy! In bocca al lupo!&quot;, number),
    _ =&gt; println!(&quot;Looks like a normal number&quot;),
    }
}

fn main() {
    match_number(50);
    match_number(13);
    match_number(4);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Looks like a normal number
13 is unlucky in North America, lucky in Italy! In bocca al lupo!
4 is an unlucky number in China (sounds close to 死)!
</code></pre>
<h2 id="結構體-1"><a class="header" href="#結構體-1">結構體</a></h2>
<p>有了結構體，你可以創建自己的類型。在 Rust 中，你會一直使用結構體，因為它們非常方便。結構體是用關鍵字 <code>struct</code> 創建的。結構體的名稱應該用UpperCamelCase(每個字用大寫字母，不要用空格)。如果你用全小寫的結構，編譯器會告訴你。</p>
<p>有三種類型的結構。一種是 &quot;單元結構&quot;。單元的意思是 &quot;沒有任何東西&quot;。對於一個單元結構，你只需要寫名字和一個分號。</p>
<pre><pre class="playground"><code class="language-rust">struct FileDirectory;
fn main() {}
</code></pre></pre>
<p>接下來是一個元組結構，或者說是一個未命名結構。之所以是 &quot;未命名&quot;，是因為你只需要寫類型，而不是字段名。當你需要一個簡單的結構，並且不需要記住名字時，元組結構是很好的選擇。</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8);

fn main() {
    let my_colour = Colour(50, 0, 50); // Make a colour out of RGB (red, green, blue)
    println!(&quot;The second part of the colour is: {}&quot;, my_colour.1);
}
</code></pre></pre>
<p>這時打印出<code>The second part of the colour is: 0</code>。</p>
<p>第三種類型是命名結構。這可能是最常見的結構。在這個結構中，你在一個 <code>{}</code> 代碼塊中聲明字段名和類型。請注意，在命名結構後面不要寫分號，因為後面有一整個代碼塊。</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
    size: u32,
    colour: Colour, // And we put it in our new named struct
}

fn main() {
    let my_colour = Colour(50, 0, 50);

    let size_and_colour = SizeAndColour {
        size: 150,
        colour: my_colour
    };
}
</code></pre></pre>
<p>在一個命名結構中，你也可以用逗號來分隔字段。對於最後一個字段，你可以加一個逗號或不加--這取決於你。<code>SizeAndColour</code> 在 <code>colour</code> 後面有一個逗號。</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
    size: u32,
    colour: Colour, // And we put it in our new named struct
}

fn main() {}
</code></pre></pre>
<p>但你不需要它。但總是放一個逗號可能是個好主意，因為有時你會改變字段的順序。</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
    size: u32,
    colour: Colour // No comma here
}

fn main() {}
</code></pre></pre>
<p>然後我們決定改變順序...</p>
<pre><pre class="playground"><code class="language-rust">struct SizeAndColour {
    colour: Colour // ⚠️ Whoops! Now this doesn't have a comma.
    size: u32,
}

fn main() {}
</code></pre></pre>
<p>但無論哪種方式都不是很重要，所以你可以選擇是否使用逗號。</p>
<p>我們創建一個<code>Country</code>結構來舉例說明。<code>Country</code>結構有<code>population</code>、<code>capital</code>和<code>leader_name</code>三個字段。</p>
<pre><pre class="playground"><code class="language-rust">struct Country {
    population: u32,
    capital: String,
    leader_name: String
}

fn main() {
    let population = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let leader_name = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Country {
        population: population,
        capital: capital,
        leader_name: leader_name,
    };
}
</code></pre></pre>
<p>你有沒有注意到，我們把同樣的東西寫了兩次？我們寫了<code>population: population</code>、<code>capital: capital</code>和<code>leader_name: leader_name</code>。實際上，你不需要這樣做:如果字段名和變量名是一樣的，你就不用寫兩次。</p>
<pre><pre class="playground"><code class="language-rust">struct Country {
    population: u32,
    capital: String,
    leader_name: String
}

fn main() {
    let population = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let leader_name = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Country {
        population,
        capital,
        leader_name,
    };
}
</code></pre></pre>
<h2 id="枚舉-1"><a class="header" href="#枚舉-1">枚舉</a></h2>
<p><code>enum</code>是enumerations的簡稱。它們看起來與結構體非常相似，但又有所不同。這就是區別:</p>
<ul>
<li>當你想要一個東西<strong>和</strong>另一個東西時，使用<code>struct</code>.</li>
<li>當你想要一個東西<strong>或</strong>另一個東西時，請使用 <code>enum</code>。</li>
</ul>
<p>所以，結構體是用於<strong>多個事物</strong>在一起，而枚舉則是用於<strong>多個選擇</strong>在一起。</p>
<p>要聲明一個枚舉，請寫<code>enum</code>，並使用一個包含選項的代碼塊，用逗號分隔。就像 <code>struct</code> 一樣，最後一部分可以有逗號，也可以沒有。我們將創建一個名為 <code>ThingsInTheSky</code> 的枚舉。</p>
<pre><pre class="playground"><code class="language-rust">enum ThingsInTheSky {
    Sun,
    Stars,
}

fn main() {}
</code></pre></pre>
<p>這是一個枚舉，因為你可以看到太陽，<strong>或</strong>星星:你必須選擇一個。這些叫做<strong>變體</strong>。</p>
<pre><pre class="playground"><code class="language-rust">// create the enum with two choices
enum ThingsInTheSky {
    Sun,
    Stars,
}

// With this function we can use an i32 to create ThingsInTheSky.
fn create_skystate(time: i32) -&gt; ThingsInTheSky {
    match time {
        6..=18 =&gt; ThingsInTheSky::Sun, // Between 6 and 18 hours we can see the sun
        _ =&gt; ThingsInTheSky::Stars, // Otherwise, we can see stars
    }
}

// With this function we can match against the two choices in ThingsInTheSky.
fn check_skystate(state: &amp;ThingsInTheSky) {
    match state {
        ThingsInTheSky::Sun =&gt; println!(&quot;I can see the sun!&quot;),
        ThingsInTheSky::Stars =&gt; println!(&quot;I can see the stars!&quot;)
    }
}

fn main() {
    let time = 8; // it's 8 o'clock
    let skystate = create_skystate(time); // create_skystate returns a ThingsInTheSky
    check_skystate(&amp;skystate); // Give it a reference so it can read the variable skystate
}
</code></pre></pre>
<p>這將打印出<code>I can see the sun!</code>。</p>
<p>你也可以將數據添加到一個枚舉中。</p>
<pre><pre class="playground"><code class="language-rust">enum ThingsInTheSky {
    Sun(String), // Now each variant has a string
    Stars(String),
}

fn create_skystate(time: i32) -&gt; ThingsInTheSky {
    match time {
        6..=18 =&gt; ThingsInTheSky::Sun(String::from(&quot;I can see the sun!&quot;)), // Write the strings here
        _ =&gt; ThingsInTheSky::Stars(String::from(&quot;I can see the stars!&quot;)),
    }
}

fn check_skystate(state: &amp;ThingsInTheSky) {
    match state {
        ThingsInTheSky::Sun(description) =&gt; println!(&quot;{}&quot;, description), // Give the string the name description so we can use it
        ThingsInTheSky::Stars(n) =&gt; println!(&quot;{}&quot;, n), // Or you can name it n. Or anything else - it doesn't matter
    }
}

fn main() {
    let time = 8; // it's 8 o'clock
    let skystate = create_skystate(time); // create_skystate returns a ThingsInTheSky
    check_skystate(&amp;skystate); // Give it a reference so it can read the variable skystate
}
</code></pre></pre>
<p>這樣打印出來的結果是一樣的:<code>I can see the sun!</code>。</p>
<p>你也可以 &quot;導入&quot;一個枚舉，這樣你就不用打那麼多字了。下面是一個例子，我們每次在心情上匹配時都要輸入 <code>Mood::</code>。</p>
<pre><pre class="playground"><code class="language-rust">enum Mood {
    Happy,
    Sleepy,
    NotBad,
    Angry,
}

fn match_mood(mood: &amp;Mood) -&gt; i32 {
    let happiness_level = match mood {
        Mood::Happy =&gt; 10, // Here we type Mood:: every time
        Mood::Sleepy =&gt; 6,
        Mood::NotBad =&gt; 7,
        Mood::Angry =&gt; 2,
    };
    happiness_level
}

fn main() {
    let my_mood = Mood::NotBad;
    let happiness_level = match_mood(&amp;my_mood);
    println!(&quot;Out of 1 to 10, my happiness is {}&quot;, happiness_level);
}
</code></pre></pre>
<p>它打印的是<code>Out of 1 to 10, my happiness is 7</code>。讓我們導入，這樣我們就可以少打點字了。要導入所有的東西，寫<code>*</code>。注意:它和<code>*</code>的解引用鍵是一樣的，但完全不同。</p>
<pre><pre class="playground"><code class="language-rust">enum Mood {
    Happy,
    Sleepy,
    NotBad,
    Angry,
}

fn match_mood(mood: &amp;Mood) -&gt; i32 {
    use Mood::*; // We imported everything in Mood. Now we can just write Happy, Sleepy, etc.
    let happiness_level = match mood {
        Happy =&gt; 10, // We don't have to write Mood:: anymore
        Sleepy =&gt; 6,
        NotBad =&gt; 7,
        Angry =&gt; 2,
    };
    happiness_level
}

fn main() {
    let my_mood = Mood::Happy;
    let happiness_level = match_mood(&amp;my_mood);
    println!(&quot;Out of 1 to 10, my happiness is {}&quot;, happiness_level);
}
</code></pre></pre>
<p><code>enum</code> 的部分也可以變成一個整數。這是因為 Rust 給 <code>enum</code> 的每個arm提供了一個以 0 開頭的數字，供它自己使用。如果你的枚舉中沒有任何其他數據，你可以用它來做一些事情。</p>
<pre><pre class="playground"><code class="language-rust">enum Season {
    Spring, // If this was Spring(String) or something it wouldn't work
    Summer,
    Autumn,
    Winter,
}

fn main() {
    use Season::*;
    let four_seasons = vec![Spring, Summer, Autumn, Winter];
    for season in four_seasons {
        println!(&quot;{}&quot;, season as u32);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">0
1
2
3
</code></pre>
<p>不過如果你想的話，你可以給它一個不同的數字--Rust並不在意，可以用同樣的方式來使用它。只需在你想要的變體上加一個 <code>=</code> 和你的數字。你不必給所有的都分配一個數字。但如果你不這樣做，Rust就會從前一個arm加1來賦值給當前arm。</p>
<pre><pre class="playground"><code class="language-rust">enum Star {
    BrownDwarf = 10,
    RedDwarf = 50,
    YellowStar = 100,
    RedGiant = 1000,
    DeadStar, // Think about this one. What number will it have?
}

fn main() {
    use Star::*;
    let starvec = vec![BrownDwarf, RedDwarf, YellowStar, RedGiant];
    for star in starvec {
        match star as u32 {
            size if size &lt;= 80 =&gt; println!(&quot;Not the biggest star.&quot;), // Remember: size doesn't mean anything. It's just a name we chose so we can print it
            size if size &gt;= 80 =&gt; println!(&quot;This is a good-sized star.&quot;),
            _ =&gt; println!(&quot;That star is pretty big!&quot;),
        }
    }
    println!(&quot;What about DeadStar? It's the number {}.&quot;, DeadStar as u32);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Not the biggest star.
Not the biggest star.
This is a good-sized star.
This is a good-sized star.
What about DeadStar? It's the number 1001.
</code></pre>
<p><code>DeadStar</code>本來是4號，但現在是1001。</p>
<h3 id="使用多種類型的枚舉"><a class="header" href="#使用多種類型的枚舉">使用多種類型的枚舉</a></h3>
<p>你知道<code>Vec</code>、數組等中的元素都需要相同的類型(只有tuple不同)。但其實你可以用一個枚舉來放不同的類型。想象一下，我們想有一個<code>Vec</code>，有<code>u32</code>或<code>i32</code>。當然，你可以創建一個<code>Vec&lt;(u32, i32)&gt;</code>(一個帶有<code>(u32, i32)</code>元組的vec)，但是我們每次只想要一個。所以這裡可以使用一個枚舉。下面是一個簡單的例子。</p>
<pre><pre class="playground"><code class="language-rust">enum Number {
    U32(u32),
    I32(i32),
}

fn main() {}
</code></pre></pre>
<p>所以有兩個變體:<code>U32</code>變體裡面有<code>u32</code>，<code>I32</code>變體裡面有<code>i32</code>。<code>U32</code>和<code>I32</code>只是我們起的名字。它們可能是<code>UThirtyTwo</code>或<code>IThirtyTwo</code>或其他任何東西。</p>
<p>現在，如果我們把它們放到 <code>Vec</code> 中，我們就會有一個 <code>Vec&lt;Number&gt;</code>，編譯器很高興，因為都是同一個類型。編譯器並不在乎我們有 <code>u32</code> 或 <code>i32</code>，因為它們都在一個叫做 <code>Number</code> 的單一類型裡面。因為它是一個枚舉，你必須選擇一個，這就是我們想要的。我們將使用<code>.is_positive()</code>方法來挑選。如果是 <code>true</code>，那麼我們將選擇 <code>U32</code>，如果是 <code>false</code>，那麼我們將選擇 <code>I32</code>。</p>
<p>現在的代碼是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">enum Number {
    U32(u32),
    I32(i32),
}

fn get_number(input: i32) -&gt; Number {
    let number = match input.is_positive() {
        true =&gt; Number::U32(input as u32), // change it to u32 if it's positive
        false =&gt; Number::I32(input), // otherwise just give the number because it's already i32
    };
    number
}


fn main() {
    let my_vec = vec![get_number(-800), get_number(8)];

    for item in my_vec {
        match item {
            Number::U32(number) =&gt; println!(&quot;It's a u32 with the value {}&quot;, number),
            Number::I32(number) =&gt; println!(&quot;It's an i32 with the value {}&quot;, number),
        }
    }
}
</code></pre></pre>
<p>這就打印出了我們想看到的東西。</p>
<pre><code class="language-text">It's an i32 with the value -800
It's a u32 with the value 8
</code></pre>
<h2 id="循環"><a class="header" href="#循環">循環</a></h2>
<p>有了循環，你可以告訴 Rust 繼續某事，直到你想讓它停止。您使用 <code>loop</code> 來啟動一個不會停止的循環，除非您告訴它何時<code>break</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // This program will never stop
    loop {

    }
}
</code></pre></pre>
<p>所以，我們要告訴編譯器什麼時候能停止:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0; // set a counter to 0
    loop {
        counter +=1; // increase the counter by 1
        println!(&quot;The counter is now: {}&quot;, counter);
        if counter == 5 { // stop when counter == 5
            break;
        }
    }
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">The counter is now: 1
The counter is now: 2
The counter is now: 3
The counter is now: 4
The counter is now: 5
</code></pre>
<p>如果你在一個循環裡面有一個循環，你可以給它們命名。有了名字，你可以告訴 Rust 要從哪個循環中 <code>break</code> 出來。使用 <code>'</code> (稱為 &quot;tick&quot;) 和 <code>:</code> 來給它命名。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;
    let mut counter2 = 0;
    println!(&quot;Now entering the first loop.&quot;);

    'first_loop: loop {
        // Give the first loop a name
        counter += 1;
        println!(&quot;The counter is now: {}&quot;, counter);
        if counter &gt; 9 {
            // Starts a second loop inside this loop
            println!(&quot;Now entering the second loop.&quot;);

            'second_loop: loop {
                // now we are inside 'second_loop
                println!(&quot;The second counter is now: {}&quot;, counter2);
                counter2 += 1;
                if counter2 == 3 {
                    break 'first_loop; // Break out of 'first_loop so we can exit the program
                }
            }
        }
    }
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">Now entering the first loop.
The counter is now: 1
The counter is now: 2
The counter is now: 3
The counter is now: 4
The counter is now: 5
The counter is now: 6
The counter is now: 7
The counter is now: 8
The counter is now: 9
The counter is now: 10
Now entering the second loop.
The second counter is now: 0
The second counter is now: 1
The second counter is now: 2
</code></pre>
<p><code>while</code>循環是指在某件事情還在<code>true</code>時繼續的循環。每一次循環，Rust 都會檢查它是否仍然是 <code>true</code>。如果變成<code>false</code>，Rust會停止循環。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    while counter &lt; 5 {
        counter +=1;
        println!(&quot;The counter is now: {}&quot;, counter);
    }
}
</code></pre></pre>
<p><code>for</code>循環可以讓你告訴Rust每次要做什麼。但是在 <code>for</code> 循環中，循環會在一定次數後停止。<code>for</code>循環經常使用<strong>範圍</strong>。你使用 <code>..</code> 和 <code>..=</code> 來創建一個範圍。</p>
<ul>
<li><code>..</code>創建一個<strong>排他的</strong>範圍:<code>0..3</code>創建了<code>0, 1, 2</code>.</li>
<li><code>..=</code>創建一個<strong>包含的</strong>範圍: <code>0..=3</code>創建<code>0, 1, 2</code>。<code>0..=3</code> = <code>0, 1, 2, 3</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in 0..3 {
        println!(&quot;The number is: {}&quot;, number);
    }

    for number in 0..=3 {
        println!(&quot;The next number is: {}&quot;, number);
    }
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">The number is: 0
The number is: 1
The number is: 2
The next number is: 0
The next number is: 1
The next number is: 2
The next number is: 3
</code></pre>
<p>同時注意到，<code>number</code>成為0..3的變量名。我們可以把它叫做 <code>n</code>，或者 <code>ntod_het___hno_f</code>，或者任何名字。然後，我們可以在<code>println!</code>中使用這個名字。</p>
<p>如果你不需要變量名，就用<code>_</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..3 {
        println!(&quot;Printing the same thing three times&quot;);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Printing the same thing three times
Printing the same thing three times
Printing the same thing three times
</code></pre>
<p>因為我們每次都沒有給它任何數字來打印。</p>
<p>而實際上，如果你給了一個變量名卻不用，Rust會告訴你:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in 0..3 {
        println!(&quot;Printing the same thing three times&quot;);
    }
}
</code></pre></pre>
<p>這打印的內容和上面一樣。程序編譯正常，但Rust會提醒你沒有使用<code>number</code>:</p>
<pre><code class="language-text">warning: unused variable: `number`
 --&gt; src\main.rs:2:9
  |
2 |     for number in 0..3 {
  |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_number`
</code></pre>
<p>Rust 建議寫 <code>_number</code> 而不是 <code>_</code>。在變量名前加上 <code>_</code> 意味著 &quot;也許我以後會用到它&quot;。但是隻用<code>_</code>意味著 &quot;我根本不關心這個變量&quot;。所以，如果你以後會使用它們，並且不想讓編譯器告訴你，你可以在變量名前面加上<code>_</code>。</p>
<p>你也可以用<code>break</code>來返回一個值。
你把值寫在 <code>break</code> 之後，並使用 <code>;</code>。下面是一個用 <code>loop</code> 和一個斷點給出 <code>my_number</code> 值的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 5;
    let my_number = loop {
        counter +=1;
        if counter % 53 == 3 {
            break counter;
        }
    };
    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>這時打印出<code>56</code>。<code>break counter;</code>的意思是 &quot;中斷並返回計數器的值&quot;。而且因為整個塊以<code>let</code>開始，所以<code>my_number</code>得到值。</p>
<p>現在我們知道了如何使用循環，這裡有一個更好的解決方案來解決我們之前的顏色 &quot;匹配&quot;問題。這是一個更好的解決方案，因為我們要比較所有的東西，而 &quot;for&quot;循環會查看每一項。</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    println!(&quot;Comparing a colour with {} red, {} blue, and {} green:&quot;, rbg.0, rbg.1, rbg.2);
    let new_vec = vec![(rbg.0, &quot;red&quot;), (rbg.1, &quot;blue&quot;), (rbg.2, &quot;green&quot;)]; // Put the colours in a vec. Inside are tuples with the colour names
    let mut all_have_at_least_10 = true; // Start with true. We will set it to false if one colour is less than 10
    for item in new_vec {
        if item.0 &lt; 10 {
            all_have_at_least_10 = false; // Now it's false
            println!(&quot;Not much {}.&quot;, item.1) // And we print the colour name.
        }
    }
    if all_have_at_least_10 { // Check if it's still true, and print if true
        println!(&quot;Each colour has at least 10.&quot;)
    }
    println!(); // Add one more line
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Comparing a colour with 200 red, 0 blue, and 0 green:
Not much blue.
Not much green.

Comparing a colour with 50 red, 50 blue, and 50 green:
Each colour has at least 10.

Comparing a colour with 200 red, 50 blue, and 0 green:
Not much green.
</code></pre>
<h2 id="實現結構體和枚舉"><a class="header" href="#實現結構體和枚舉">實現結構體和枚舉</a></h2>
<p>在這裡你可以開始賦予你的結構體和枚舉一些真正的力量。要調用 <code>struct</code> 或 <code>enum</code> 上的函數，請使用 <code>impl</code> 塊。這些函數被稱為<strong>方法</strong>。<code>impl</code>塊中有兩種方法。</p>
<ul>
<li>方法：這些方法取<strong>self</strong>（或 <strong>&amp;self</strong> 或 <strong>&amp;mut self</strong> ）。常規方法使用&quot;.&quot;（一個句號）。<code>.clone()</code>是一個常規方法的例子。</li>
<li>關聯函數（在某些語言中被稱為 &quot;靜態 &quot;方法）：這些函數不使用self。關聯的意思是 &quot;與之相關&quot;。它們的書寫方式不同，使用<code>::</code>。<code>String::from()</code>是一個關聯函數，<code>Vec::new()</code>也是。你看到的關聯函數最常被用來創建新的變量。</li>
</ul>
<p>在我們的例子中，我們將創建Animal並打印它們。</p>
<p>對於新的<code>struct</code>或<code>enum</code>，如果你想使用<code>{:?}</code>來打印，你需要給它<strong>Debug</strong>，所以我們將這樣做:如果你在結構體或枚舉上面寫了<code>#[derive(Debug)]</code>，那麼你就可以用<code>{:?}</code>來打印。這些帶有<code>#[]</code>的信息被稱為<strong>屬性</strong>。你有時可以用它們來告訴編譯器給你的結構體一個能力，比如<code>Debug</code>。屬性有很多，我們以後會學習它們。但是<code>derive</code>可能是最常見的，你經常在結構體和枚舉上面看到它。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Animal {
    age: u8,
    animal_type: AnimalType,
}

#[derive(Debug)]
enum AnimalType {
    Cat,
    Dog,
}

impl Animal {
    fn new() -&gt; Self {
        // Self means Animal.
        //You can also write Animal instead of Self

        Self {
            // When we write Animal::new(), we always get a cat that is 10 years old
            age: 10,
            animal_type: AnimalType::Cat,
        }
    }

    fn change_to_dog(&amp;mut self) { // because we are inside Animal, &amp;mut self means &amp;mut Animal
                                  // use .change_to_dog() to change the cat to a dog
                                  // with &amp;mut self we can change it
        println!(&quot;Changing animal to dog!&quot;);
        self.animal_type = AnimalType::Dog;
    }

    fn change_to_cat(&amp;mut self) {
        // use .change_to_cat() to change the dog to a cat
        // with &amp;mut self we can change it
        println!(&quot;Changing animal to cat!&quot;);
        self.animal_type = AnimalType::Cat;
    }

    fn check_type(&amp;self) {
        // we want to read self
        match self.animal_type {
            AnimalType::Dog =&gt; println!(&quot;The animal is a dog&quot;),
            AnimalType::Cat =&gt; println!(&quot;The animal is a cat&quot;),
        }
    }
}



fn main() {
    let mut new_animal = Animal::new(); // Associated function to create a new animal
                                        // It is a cat, 10 years old
    new_animal.check_type();
    new_animal.change_to_dog();
    new_animal.check_type();
    new_animal.change_to_cat();
    new_animal.check_type();
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">The animal is a cat
Changing animal to dog!
The animal is a dog
Changing animal to cat!
The animal is a cat
</code></pre>
<p>記住，Self(類型Self)和self(變量self)是縮寫。(縮寫=簡寫方式)</p>
<p>所以，在我們的代碼中，Self = Animal。另外，<code>fn change_to_dog(&amp;mut self)</code>的意思是<code>fn change_to_dog(&amp;mut Animal)</code>。</p>
<p>下面再舉一個小例子。這次我們將在<code>enum</code>上使用<code>impl</code>。</p>
<pre><pre class="playground"><code class="language-rust">enum Mood {
    Good,
    Bad,
    Sleepy,
}

impl Mood {
    fn check(&amp;self) {
        match self {
            Mood::Good =&gt; println!(&quot;Feeling good!&quot;),
            Mood::Bad =&gt; println!(&quot;Eh, not feeling so good&quot;),
            Mood::Sleepy =&gt; println!(&quot;Need sleep NOW&quot;),
        }
    }
}

fn main() {
    let my_mood = Mood::Sleepy;
    my_mood.check();
}
</code></pre></pre>
<p>打印出<code>Need sleep NOW</code>。</p>
<h2 id="解構"><a class="header" href="#解構">解構</a></h2>
<p>我們再來看一些解構。你可以通過使用<code>let</code>倒過來從一個結構體或枚舉中獲取值。我們瞭解到這是<code>destructuring</code>，因為你得到的變量不是結構體的一部分。現在你分別得到了它們的值。首先是一個簡單的例子。</p>
<pre><pre class="playground"><code class="language-rust">struct Person { // make a simple struct for a person
    name: String,
    real_name: String,
    height: u8,
    happiness: bool
}

fn main() {
    let papa_doc = Person { // create variable papa_doc
        name: &quot;Papa Doc&quot;.to_string(),
        real_name: &quot;Clarence&quot;.to_string(),
        height: 170,
        happiness: false
    };

    let Person { // destructure papa_doc
        name: a,
        real_name: b,
        height: c,
        happiness: d
    } = papa_doc;

    println!(&quot;They call him {} but his real name is {}. He is {} cm tall and is he happy? {}&quot;, a, b, c, d);
}
</code></pre></pre>
<p>這個打印:<code>They call him Papa Doc but his real name is Clarence. He is 170 cm tall and is he happy? false</code></p>
<p>你可以看到，這是倒過來的。首先我們說<code>let papa_doc = Person { fields }</code>來創建結構。然後我們說 <code>let Person { fields } = papa_doc</code> 來解構它。</p>
<p>你不必寫<code>name: a</code>--你可以直接寫<code>name</code>。但這裡我們寫 <code>name: a</code> 是因為我們想使用一個名字為 <code>a</code> 的變量。</p>
<p>現在再舉一個更大的例子。在這個例子中，我們有一個 <code>City</code> 結構。我們給它一個<code>new</code>函數來創建它。然後我們有一個 <code>process_city_values</code> 函數來處理這些值。在函數中，我們只是創建了一個 <code>Vec</code>，但你可以想象，我們可以在解構它之後做更多的事情。</p>
<pre><pre class="playground"><code class="language-rust">struct City {
    name: String,
    name_before: String,
    population: u32,
    date_founded: u32,
}

impl City {
    fn new(name: String, name_before: String, population: u32, date_founded: u32) -&gt; Self {
        Self {
            name,
            name_before,
            population,
            date_founded,
        }
    }
}

fn process_city_values(city: &amp;City) {
    let City {
        name,
        name_before,
        population,
        date_founded,
    } = city;
        // now we have the values to use separately
    let two_names = vec![name, name_before];
    println!(&quot;The city's two names are {:?}&quot;, two_names);
}

fn main() {
    let tallinn = City::new(&quot;Tallinn&quot;.to_string(), &quot;Reval&quot;.to_string(), 426_538, 1219);
    process_city_values(&amp;tallinn);
}
</code></pre></pre>
<p>這將打印出<code>The city's two names are [&quot;Tallinn&quot;, &quot;Reval&quot;]</code>。</p>
<h2 id="引用和點運算符"><a class="header" href="#引用和點運算符">引用和點運算符</a></h2>
<p>我們瞭解到，當你有一個引用時，你需要使用<code>*</code>來獲取值。引用是一種不同的類型，所以這是無法運行的:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 9;
    let reference = &amp;my_number;

    println!(&quot;{}&quot;, my_number == reference); // ⚠️
}
</code></pre></pre>
<p>編譯器打印。</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src\main.rs:5:30
  |
5 |     println!(&quot;{}&quot;, my_number == reference);
  |                              ^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>所以我們把第5行改成<code>println!(&quot;{}&quot;, my_number == *reference);</code>，現在打印的是<code>true</code>，因為現在是<code>i32</code> == <code>i32</code>，而不是<code>i32</code> == <code>&amp;i32</code>。這就是所謂的解引用。</p>
<p>但是當你使用一個方法時，Rust會為你解除引用。方法中的 <code>.</code> 被稱為點運算符，它可以免費進行遞歸。</p>
<p>首先，讓我們創建一個有一個 <code>u8</code> 字段的結構。然後，我們將對它進行引用，並嘗試進行比較。它將無法工作。</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    number: u8,
}

fn main() {
    let item = Item {
        number: 8,
    };

    let reference_number = &amp;item.number; // reference number type is &amp;u8

    println!(&quot;{}&quot;, reference_number == 8); // ⚠️ &amp;u8 and u8 cannot be compared
}
</code></pre></pre>
<p>為了讓它工作，我們需要取消定義。<code>println!(&quot;{}&quot;, *reference_number == 8);</code>.</p>
<p>但如果使用點運算符，我們不需要<code>*</code>。例如</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    number: u8,
}

fn main() {
    let item = Item {
        number: 8,
    };

    let reference_item = &amp;item;

    println!(&quot;{}&quot;, reference_item.number == 8); // we don't need to write *reference_item.number
}
</code></pre></pre>
<p>現在讓我們為 <code>Item</code> 創建一個方法，將 <code>number</code> 與另一個數字進行比較。我們不需要在任何地方使用 <code>*</code>。</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    number: u8,
}

impl Item {
    fn compare_number(&amp;self, other_number: u8) { // takes a reference to self
        println!(&quot;Are {} and {} equal? {}&quot;, self.number, other_number, self.number == other_number);
            // We don't need to write *self.number
    }
}

fn main() {
    let item = Item {
        number: 8,
    };

    let reference_item = &amp;item; // This is type &amp;Item
    let reference_item_two = &amp;reference_item; // This is type &amp;&amp;Item

    item.compare_number(8); // the method works
    reference_item.compare_number(8); // it works here too
    reference_item_two.compare_number(8); // and here

}
</code></pre></pre>
<p>所以只要記住:當你使用<code>.</code>運算符時，你不需要擔心<code>*</code>。</p>
<h2 id="泛型-2"><a class="header" href="#泛型-2">泛型</a></h2>
<p>在函數中，你要寫出採取什麼類型作為輸入。</p>
<pre><pre class="playground"><code class="language-rust">fn return_number(number: i32) -&gt; i32 {
    println!(&quot;Here is your number.&quot;);
    number
}

fn main() {
    let number = return_number(5);
}
</code></pre></pre>
<p>但是如果你想用的不僅僅是<code>i32</code>呢？你可以用泛型來解決。Generics的意思是 &quot;也許是一種類型，也許是另一種類型&quot;。</p>
<p>對於泛型，你可以使用角括號，裡面加上類型，像這樣。<code>&lt;T&gt;</code> 這意味著 &quot;任何類型你都可以放入函數中&quot; 通常情況下，generics使用一個大寫字母的類型(T、U、V等)，儘管你不必只使用一個字母。</p>
<p>這就是你如何改變函數使其通用的方法。</p>
<pre><pre class="playground"><code class="language-rust">fn return_number&lt;T&gt;(number: T) -&gt; T {
    println!(&quot;Here is your number.&quot;);
    number
}

fn main() {
    let number = return_number(5);
}
</code></pre></pre>
<p>重要的部分是函數名後的<code>&lt;T&gt;</code>。如果沒有這個，Rust會認為T是一個具體的(具體的=不是通用的)類型。
如<code>String</code>或<code>i8</code>。</p>
<p>如果我們寫出一個類型名，這就更容易理解了。看看我們把 <code>T</code> 改成 <code>MyType</code> 會發生什麼。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_number(number: MyType) -&gt; MyType { // ⚠️
    println!(&quot;Here is your number.&quot;);
    number
}
<span class="boring">}
</span></code></pre></pre>
<p>大家可以看到，<code>MyType</code>是具體的，不是通用的。所以我們需要寫這個，所以現在就可以了。</p>
<pre><pre class="playground"><code class="language-rust">fn return_number&lt;MyType&gt;(number: MyType) -&gt; MyType {
    println!(&quot;Here is your number.&quot;);
    number
}

fn main() {
    let number = return_number(5);
}
</code></pre></pre>
<p>所以單字母<code>T</code>是人的眼睛，但函數名後面的部分是編譯器的 &quot;眼睛&quot;。沒有了它，就不通用了。</p>
<p>現在我們再回到類型<code>T</code>，因為Rust代碼通常使用<code>T</code>。</p>
<p>你會記得Rust中有些類型是<strong>Copy</strong>，有些是<strong>Clone</strong>，有些是<strong>Display</strong>，有些是<strong>Debug</strong>，等等。用<strong>Debug</strong>，我們可以用<code>{:?}</code>來打印。所以現在大家可以看到，我們如果要打印<code>T</code>就有問題了。</p>
<pre><pre class="playground"><code class="language-rust">fn print_number&lt;T&gt;(number: T) {
    println!(&quot;Here is your number: {:?}&quot;, number); // ⚠️
}

fn main() {
    print_number(5);
}
</code></pre></pre>
<p><code>print_number</code>需要<strong>Debug</strong>打印<code>number</code>，但是<code>T</code>與<code>Debug</code>是一個類型嗎？也許不是。也許它沒有<code>#[derive(Debug)]</code>，誰知道呢？編譯器也不知道，所以它給出了一個錯誤。</p>
<pre><code class="language-text">error[E0277]: `T` doesn't implement `std::fmt::Debug`
  --&gt; src\main.rs:29:43
   |
29 |     println!(&quot;Here is your number: {:?}&quot;, number);
   |                                           ^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`
</code></pre>
<p>T沒有實現<strong>Debug</strong>。那麼我們是否要為T實現Debug呢？不，因為我們不知道T是什麼。但是我們可以告訴函數。&quot;別擔心，因為任何T類型的函數都會有Debug&quot;</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug; // Debug is located at std::fmt::Debug. So now we can just write 'Debug'.

fn print_number&lt;T: Debug&gt;(number: T) { // &lt;T: Debug&gt; is the important part
    println!(&quot;Here is your number: {:?}&quot;, number);
}

fn main() {
    print_number(5);
}
</code></pre></pre>
<p>所以現在編譯器知道:&quot;好的，這個類型T要有Debug&quot;。現在代碼工作了，因為<code>i32</code>有Debug。現在我們可以給它很多類型。<code>String</code>, <code>&amp;str</code>, 等等，因為它們都有Debug.</p>
<p>現在我們可以創建一個結構，並用#[derive(Debug)]給它Debug，所以現在我們也可以打印它。我們的函數可以取<code>i32</code>，Animal結構等。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

#[derive(Debug)]
struct Animal {
    name: String,
    age: u8,
}

fn print_item&lt;T: Debug&gt;(item: T) {
    println!(&quot;Here is your item: {:?}&quot;, item);
}

fn main() {
    let charlie = Animal {
        name: &quot;Charlie&quot;.to_string(),
        age: 1,
    };

    let number = 55;

    print_item(charlie);
    print_item(number);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Here is your item: Animal { name: &quot;Charlie&quot;, age: 1 }
Here is your item: 55
</code></pre>
<p>有時候，我們在一個通用函數中需要不止一個類型。我們必須寫出每個類型的名稱，並考慮如何使用它。在這個例子中，我們想要兩個類型。首先我們要打印一個類型為T的語句。用<code>{}</code>打印比較好，所以我們會要求用<code>Display</code>來打印<code>T</code>。</p>
<p>其次是類型U，<code>num_1</code>和<code>num_2</code>這兩個變量的類型為U(U是某種數字)。我們想要比較它們，所以我們需要<code>PartialOrd</code>。這個特性讓我們可以使用<code>&lt;</code>、<code>&gt;</code>、<code>==</code>等。我們也想打印它們，所以我們也需要<code>Display</code>來打印<code>U</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::cmp::PartialOrd;

fn compare_and_display&lt;T: Display, U: Display + PartialOrd&gt;(statement: T, num_1: U, num_2: U) {
    println!(&quot;{}! Is {} greater than {}? {}&quot;, statement, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compare_and_display(&quot;Listen up!&quot;, 9, 8);
}
</code></pre></pre>
<p>這就打印出了<code>Listen up!! Is 9 greater than 8? true</code>。</p>
<p>所以<code>fn compare_and_display&lt;T: Display, U: Display + PartialOrd&gt;(statement: T, num_1: U, num_2: U)</code>說。</p>
<ul>
<li>函數名稱是<code>compare_and_display</code>,</li>
<li>第一個類型是T，它是通用的。它必須是一個可以用{}打印的類型。</li>
<li>下一個類型是U，它是通用的。它必須是一個可以用{}打印的類型。另外，它必須是一個可以比較的類型(使用 <code>&gt;</code>、<code>&lt;</code> 和 <code>==</code>)。</li>
</ul>
<p>現在我們可以給<code>compare_and_display</code>不同的類型。<code>statement</code>可以是一個<code>String</code>，一個<code>&amp;str</code>，任何有Display的類型。</p>
<p>為了讓通用函數更容易讀懂，我們也可以這樣寫，在代碼塊之前就寫上<code>where</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::cmp::PartialOrd;
use std::fmt::Display;

fn compare_and_display&lt;T, U&gt;(statement: T, num_1: U, num_2: U)
where
    T: Display,
    U: Display + PartialOrd,
{
    println!(&quot;{}! Is {} greater than {}? {}&quot;, statement, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compare_and_display(&quot;Listen up!&quot;, 9, 8);
}
</code></pre></pre>
<p>當你有很多通用類型時，使用<code>where</code>是一個好主意。</p>
<p>還要注意。</p>
<ul>
<li>如果你有一個類型T和另一個類型T，它們必須是相同的。</li>
<li>如果你有一個類型T和另一個類型U，它們可以是不同的。但它們也可以是相同的。</li>
</ul>
<p>比如說</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn say_two&lt;T: Display, U: Display&gt;(statement_1: T, statement_2: U) { // Type T needs Display, type U needs Display
    println!(&quot;I have two things to say: {} and {}&quot;, statement_1, statement_2);
}

fn main() {

    say_two(&quot;Hello there!&quot;, String::from(&quot;I hate sand.&quot;)); // Type T is a &amp;str, but type U is a String.
    say_two(String::from(&quot;Where is Padme?&quot;), String::from(&quot;Is she all right?&quot;)); // Both types are String.
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">I have two things to say: Hello there! and I hate sand.
I have two things to say: Where is Padme? and Is she all right?
</code></pre>
<h2 id="option和result"><a class="header" href="#option和result">Option和Result</a></h2>
<p>我們現在理解了枚舉和泛型，所以我們可以理解<code>Option</code>和<code>Result</code>。Rust使用這兩個枚舉來使代碼更安全。</p>
<p>我們將從<code>Option</code>開始。</p>
<h3 id="option-1"><a class="header" href="#option-1">Option</a></h3>
<p>當你有一個可能存在，也可能不存在的值時，你就用<code>Option</code>。當一個值存在的時候就是<code>Some(value)</code>，不存在的時候就是<code>None</code>，下面是一個壞代碼的例子，可以用<code>Option</code>來改進。</p>
<pre><pre class="playground"><code class="language-rust">    // ⚠️
fn take_fifth(value: Vec&lt;i32&gt;) -&gt; i32 {
    value[4]
}

fn main() {
    let new_vec = vec![1, 2];
    let index = take_fifth(new_vec);
}
</code></pre></pre>
<p>當我們運行這段代碼時，它崩潰。以下是信息。</p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 2 but the index is 4', src\main.rs:34:5
</code></pre>
<p>崩潰的意思是，程序在問題發生之前就停止了。Rust看到函數想要做一些不可能的事情，就會停止。它 &quot;解開堆棧&quot;(從堆棧中取值)，並告訴你 &quot;對不起，我不能這樣做&quot;。</p>
<p>所以現在我們將返回類型從<code>i32</code>改為<code>Option&lt;i32&gt;</code>。這意味著 &quot;如果有的話給我一個<code>Some(i32)</code>，如果沒有的話給我一個<code>None</code>&quot;。我們說<code>i32</code>是 &quot;包&quot;在一個<code>Option</code>裡面，也就是說它在一個<code>Option</code>裡面。你必須做一些事情才能把這個值弄出來。</p>
<pre><pre class="playground"><code class="language-rust">fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 { // .len() gives the length of the vec.
                         // It must be at least 5.
        None
    } else {
        Some(value[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!(&quot;{:?}, {:?}&quot;, take_fifth(new_vec), take_fifth(bigger_vec));
}
</code></pre></pre>
<p>這個打印的是<code>None, Some(5)</code>。這下好了，因為現在我們再也不崩潰了。但是我們如何得到5的值呢？</p>
<p>我們可以用 <code>.unwrap()</code> 在一個Option中獲取值，但要小心 <code>.unwrap()</code>。這就像拆禮物一樣:也許裡面有好東西，也許裡面有一條憤怒的蛇。只有在你確定的情況下，你才會想要<code>.unwrap()</code>。如果你拆開一個<code>None</code>的值，程序就會崩潰。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 {
        None
    } else {
        Some(value[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!(&quot;{:?}, {:?}&quot;,
        take_fifth(new_vec).unwrap(), // this one is None. .unwrap() will panic!
        take_fifth(bigger_vec).unwrap()
    );
}
</code></pre></pre>
<p>消息是: </p>
<pre><code class="language-text">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src\main.rs:14:9
</code></pre>
<p>但我們不需要使用<code>.unwrap()</code>。我們可以使用<code>match</code>。那麼我們就可以把我們有<code>Some</code>的值打印出來，如果有<code>None</code>的值就不要碰。比如說</p>
<pre><pre class="playground"><code class="language-rust">fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 {
        None
    } else {
        Some(value[4])
    }
}

fn handle_option(my_option: Vec&lt;Option&lt;i32&gt;&gt;) {
  for item in my_option {
    match item {
      Some(number) =&gt; println!(&quot;Found a {}!&quot;, number),
      None =&gt; println!(&quot;Found a None!&quot;),
    }
  }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let mut option_vec = Vec::new(); // Make a new vec to hold our options
                                     // The vec is type: Vec&lt;Option&lt;i32&gt;&gt;. That means a vec of Option&lt;i32&gt;.

    option_vec.push(take_fifth(new_vec)); // This pushes &quot;None&quot; into the vec
    option_vec.push(take_fifth(bigger_vec)); // This pushes &quot;Some(5)&quot; into the vec

    handle_option(option_vec); // handle_option looks at every option in the vec.
                               // It prints the value if it is Some. It doesn't touch it if it is None.
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Found a None!
Found a 5!
</code></pre>
<p>因為我們知道泛型，所以我們能夠讀懂<code>Option</code>的代碼。它看起來是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

fn main() {}
</code></pre></pre>
<p>要記住的重要一點是:有了<code>Some</code>，你就有了一個類型為<code>T</code>的值(任何類型)。還要注意的是，<code>enum</code>名字後面的角括號圍繞著<code>T</code>是告訴編譯器它是通用的。它沒有<code>Display</code>這樣的trait或任何東西來限制它，所以它可以是任何東西。但是對於<code>None</code>，你什麼都沒有。</p>
<p>所以在<code>match</code>語句中，對於Option，你不能說。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
Some(value) =&gt; println!(&quot;The value is {}&quot;, value),
None(value) =&gt; println!(&quot;The value is {}&quot;, value),
<span class="boring">}
</span></code></pre></pre>
<p>因為<code>None</code>只是<code>None</code>。</p>
<p>當然，還有更簡單的方法來使用Option。在這段代碼中，我們將使用一個叫做 <code>.is_some()</code> 的方法來告訴我們是否是 <code>Some</code>。(是的，還有一個叫做<code>.is_none()</code>的方法。)在這個更簡單的方法中，我們不需要<code>handle_option()</code>了。我們也不需要Option的vec了。</p>
<pre><pre class="playground"><code class="language-rust">fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 {
        None
    } else {
        Some(value[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let vec_of_vecs = vec![new_vec, bigger_vec];
    for vec in vec_of_vecs {
        let inside_number = take_fifth(vec);
        if inside_number.is_some() {
            // .is_some() returns true if we get Some, false if we get None
            println!(&quot;We got: {}&quot;, inside_number.unwrap()); // now it is safe to use .unwrap() because we already checked
        } else {
            println!(&quot;We got nothing.&quot;);
        }
    }
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">We got nothing.
We got: 5
</code></pre>
<h3 id="result-1"><a class="header" href="#result-1">Result</a></h3>
<p>Result和Option類似，但這裡的區別是。</p>
<ul>
<li>Option大約是<code>Some</code>或<code>None</code>(有值或無值)。</li>
<li>Result大約是<code>Ok</code>或<code>Err</code>(還好的結果，或錯誤的結果)。</li>
</ul>
<p>所以，<code>Option</code>是如果你在想:&quot;也許會有，也許不會有。&quot;也許會有一些東西，也許不會有。&quot; 但<code>Result</code>是如果你在想: &quot;也許會失敗&quot;</p>
<p>比較一下，這裡是Option和Result的簽名。</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn main() {}
</code></pre></pre>
<p>所以Result在 &quot;Ok &quot;裡面有一個值，在 &quot;Err &quot;裡面有一個值。這是因為錯誤通常包含描述錯誤的信息。</p>
<p><code>Result&lt;T, E&gt;</code>的意思是你要想好<code>Ok</code>要返回什麼，<code>Err</code>要返回什麼。其實，你可以決定任何事情。甚至這個也可以。</p>
<pre><pre class="playground"><code class="language-rust">fn check_error() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    check_error();
}
</code></pre></pre>
<p><code>check_error</code>說 &quot;如果得到<code>Ok</code>就返回<code>()</code>，如果得到<code>Err</code>就返回<code>()</code>&quot;。然後我們用<code>()</code>返回<code>Ok</code>。</p>
<p>編譯器給了我們一個有趣的警告。</p>
<pre><code class="language-text">warning: unused `std::result::Result` that must be used
 --&gt; src\main.rs:6:5
  |
6 |     check_error();
  |     ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>這是真的:我們只返回了<code>Result</code>，但它可能是一個<code>Err</code>。所以讓我們稍微處理一下這個錯誤，儘管我們仍然沒有真正做任何事情。</p>
<pre><pre class="playground"><code class="language-rust">fn give_result(input: i32) -&gt; Result&lt;(), ()&gt; {
    if input % 2 == 0 {
        return Ok(())
    } else {
        return Err(())
    }
}

fn main() {
    if give_result(5).is_ok() {
        println!(&quot;It's okay, guys&quot;)
    } else {
        println!(&quot;It's an error, guys&quot;)
    }
}
</code></pre></pre>
<p>打印出<code>It's an error, guys</code>。所以我們只是處理了第一個錯誤。</p>
<p>記住，輕鬆檢查的四種方法是<code>.is_some()</code>、<code>is_none()</code>、<code>is_ok()</code>和<code>is_err()</code>。</p>
<p>有時，一個帶有Result的函數會用<code>String</code>來表示<code>Err</code>的值。這不是最好的方法，但比我們目前所做的要好一些。</p>
<pre><pre class="playground"><code class="language-rust">fn check_if_five(number: i32) -&gt; Result&lt;i32, String&gt; {
    match number {
        5 =&gt; Ok(number),
        _ =&gt; Err(&quot;Sorry, the number wasn't five.&quot;.to_string()), // This is our error message
    }
}

fn main() {
    let mut result_vec = Vec::new(); // Create a new vec for the results

    for number in 2..7 {
        result_vec.push(check_if_five(number)); // push each result into the vec
    }

    println!(&quot;{:?}&quot;, result_vec);
}
</code></pre></pre>
<p>我們的Vec打印:</p>
<pre><code class="language-text">[Err(&quot;Sorry, the number wasn\'t five.&quot;), Err(&quot;Sorry, the number wasn\'t five.&quot;), Err(&quot;Sorry, the number wasn\'t five.&quot;), Ok(5),
Err(&quot;Sorry, the number wasn\'t five.&quot;)]
</code></pre>
<p>就像Option一樣，在<code>Err</code>上用<code>.unwrap()</code>就會崩潰。</p>
<pre><pre class="playground"><code class="language-rust">    // ⚠️
fn main() {
    let error_value: Result&lt;i32, &amp;str&gt; = Err(&quot;There was an error&quot;); // Create a Result that is already an Err
    println!(&quot;{}&quot;, error_value.unwrap()); // Unwrap it
}
</code></pre></pre>
<p>程序崩潰，打印。</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;There was an error&quot;', src\main.rs:30:20
</code></pre>
<p>這些信息可以幫助你修正你的代碼。<code>src\main.rs:30:20</code>的意思是 &quot;在目錄src的main.rs內，第30行和第20列&quot;。所以你可以去那裡查看你的代碼並修復問題。</p>
<p>你也可以創建自己的錯誤類型，標準庫中的Result函數和其他人的代碼通常都會這樣做。例如，標準庫中的這個函數。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>這個函數接收一個字節向量(<code>u8</code>)，並嘗試創建一個<code>String</code>，所以Result的成功情況是<code>String</code>，錯誤情況是<code>FromUtf8Error</code>。你可以給你的錯誤類型起任何你想要的名字。</p>
<p>使用 <code>match</code> 與 <code>Option</code> 和 <code>Result</code> 有時需要很多代碼。例如，<code>.get()</code> 方法在 <code>Vec</code> 上返回 <code>Option</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];
    let get_one = my_vec.get(0); // 0 to get the first number
    let get_two = my_vec.get(10); // Returns None
    println!(&quot;{:?}&quot;, get_one);
    println!(&quot;{:?}&quot;, get_two);
}
</code></pre></pre>
<p>此打印</p>
<pre><code class="language-text">Some(2)
None
</code></pre>
<p>所以現在我們可以匹配得到數值。讓我們使用0到10的範圍，看看是否符合<code>my_vec</code>中的數字。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      match my_vec.get(index) {
        Some(number) =&gt; println!(&quot;The number is: {}&quot;, number),
        None =&gt; {}
      }
    }
}
</code></pre></pre>
<p>這是好的，但是我們對<code>None</code>不做任何處理，因為我們不關心。這裡我們可以用<code>if let</code>把代碼變小。<code>if let</code>的意思是 &quot;符合就做，不符合就不做&quot;。<code>if let</code>是在你不要求對所有的東西都匹配的時候使用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      if let Some(number) = my_vec.get(index) {
        println!(&quot;The number is: {}&quot;, number);
      }
    }
}
</code></pre></pre>
<p><strong>重要的是要記住</strong>。<code>if let Some(number) = my_vec.get(index)</code>的意思是 &quot;如果你從<code>my_vec.get(index)</code>得到<code>Some(number)</code>&quot;。</p>
<p>另外注意:它使用的是一個<code>=</code>。它不是一個布爾值。</p>
<p><code>while let</code>就像<code>if let</code>的一個while循環。想象一下，我們有這樣的氣象站數據。</p>
<pre><code class="language-text">[&quot;Berlin&quot;, &quot;cloudy&quot;, &quot;5&quot;, &quot;-7&quot;, &quot;78&quot;]
[&quot;Athens&quot;, &quot;sunny&quot;, &quot;not humid&quot;, &quot;20&quot;, &quot;10&quot;, &quot;50&quot;]
</code></pre>
<p>我們想得到數字，但不想得到文字。對於數字，我們可以使用一個叫做 <code>parse::&lt;i32&gt;()</code> 的方法。<code>parse()</code>是方法，<code>::&lt;i32&gt;</code>是類型。它將嘗試把 <code>&amp;str</code> 變成 <code>i32</code>，如果可以的話就把它給我們。它返回一個 <code>Result</code>，因為它可能無法工作(比如你想讓它解析 &quot;Billybrobby&quot;--那不是一個數字)。</p>
<p>我們還將使用 <code>.pop()</code>。這將從向量中取出最後一項。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let weather_vec = vec![
        vec![&quot;Berlin&quot;, &quot;cloudy&quot;, &quot;5&quot;, &quot;-7&quot;, &quot;78&quot;],
        vec![&quot;Athens&quot;, &quot;sunny&quot;, &quot;not humid&quot;, &quot;20&quot;, &quot;10&quot;, &quot;50&quot;],
    ];
    for mut city in weather_vec {
        println!(&quot;For the city of {}:&quot;, city[0]); // In our data, every first item is the city name
        while let Some(information) = city.pop() {
            // This means: keep going until you can't pop anymore
            // When the vector reaches 0 items, it will return None
            // and it will stop.
            if let Ok(number) = information.parse::&lt;i32&gt;() {
                // Try to parse the variable we called information
                // This returns a result. If it's Ok(number), it will print it
                println!(&quot;The number is: {}&quot;, number);
            }  // We don't write anything here because we do nothing if we get an error. Throw them all away
        }
    }
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">For the city of Berlin:
The number is: 78
The number is: -7
The number is: 5
For the city of Athens:
The number is: 50
The number is: 10
The number is: 20
</code></pre>
<h2 id="其他集合類型"><a class="header" href="#其他集合類型">其他集合類型</a></h2>
<p>Rust還有很多集合類型。你可以在標準庫中的 https://doc.rust-lang.org/beta/std/collections/ 看到它們。那個頁面對為什麼要使用一種類型有很好的解釋，所以如果你不知道你想要什麼類型，就去那裡。這些集合都在標準庫的<code>std::collections</code>裡面。使用它們的最好方法是使用 <code>use</code> 語句。
就像我們的<code>enums</code>一樣。我們將從<code>HashMap</code>開始，這是很常見的。</p>
<h3 id="hashmap和btreemap"><a class="header" href="#hashmap和btreemap">HashMap和BTreeMap</a></h3>
<p>HashMap是由<em>keys</em>和<em>values</em>組成的集合。你使用鍵來查找與鍵匹配的值。你可以只用<code>HashMap::new()</code>創建一個新的<code>HashMap</code>，並使用<code>.insert(key, value)</code>來插入元素。</p>
<p><code>HashMap</code>是沒有順序的，所以如果你把<code>HashMap</code>中的每一個鍵都打印在一起，可能會打印出不同的結果。我們可以在一個例子中看到這一點。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap; // This is so we can just write HashMap instead of std::collections::HashMap every time

struct City {
    name: String,
    population: HashMap&lt;u32, u32&gt;, // This will have the year and the population for the year
}

fn main() {

    let mut tallinn = City {
        name: &quot;Tallinn&quot;.to_string(),
        population: HashMap::new(), // So far the HashMap is empty
    };

    tallinn.population.insert(1372, 3_250); // insert three dates
    tallinn.population.insert(1851, 24_000);
    tallinn.population.insert(2020, 437_619);


    for (year, population) in tallinn.population { // The HashMap is HashMap&lt;u32, u32&gt; so it returns a two items each time
        println!(&quot;In the year {} the city of {} had a population of {}.&quot;, year, tallinn.name, population);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">In the year 1372 the city of Tallinn had a population of 3250.
In the year 2020 the city of Tallinn had a population of 437619.
In the year 1851 the city of Tallinn had a population of 24000.
</code></pre>
<p>或者可能會打印。</p>
<pre><code class="language-text">In the year 1851 the city of Tallinn had a population of 24000.
In the year 2020 the city of Tallinn had a population of 437619.
In the year 1372 the city of Tallinn had a population of 3250.
</code></pre>
<p>你可以看到，它不按順序排列。</p>
<p>如果你想要一個可以排序的<code>HashMap</code>，你可以用<code>BTreeMap</code>。其實它們之間是非常相似的，所以我們可以快速的把我們的<code>HashMap</code>改成<code>BTreeMap</code>來看看。大家可以看到，這幾乎是一樣的代碼。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeMap; // Just change HashMap to BTreeMap

struct City {
    name: String,
    population: BTreeMap&lt;u32, u32&gt;, // Just change HashMap to BTreeMap
}

fn main() {

    let mut tallinn = City {
        name: &quot;Tallinn&quot;.to_string(),
        population: BTreeMap::new(), // Just change HashMap to BTreeMap
    };

    tallinn.population.insert(1372, 3_250);
    tallinn.population.insert(1851, 24_000);
    tallinn.population.insert(2020, 437_619);

    for (year, population) in tallinn.population {
        println!(&quot;In the year {} the city of {} had a population of {}.&quot;, year, tallinn.name, population);
    }
}
</code></pre></pre>
<p>現在會一直打印。</p>
<pre><code class="language-text">In the year 1372 the city of Tallinn had a population of 3250.
In the year 1851 the city of Tallinn had a population of 24000.
In the year 2020 the city of Tallinn had a population of 437619.
</code></pre>
<p>現在我們再來看看<code>HashMap</code>。</p>
<p>只要把鍵放在<code>[]</code>的方括號裡，就可以得到<code>HashMap</code>的值。在接下來的這個例子中，我們將帶出<code>Bielefeld</code>這個鍵的值，也就是<code>Germany</code>。但是要注意，因為如果沒有鍵，程序會崩潰。比如你寫了<code>println!(&quot;{:?}&quot;, city_hashmap[&quot;Bielefeldd&quot;]);</code>，那麼就會崩潰，因為<code>Bielefeldd</code>不存在。</p>
<p>如果你不確定會有一個鍵，你可以使用<code>.get()</code>，它返回一個<code>Option</code>。如果它存在，將是<code>Some(value)</code>，如果不存在，你將得到<code>None</code>，而不是使程序崩潰。這就是為什麼 <code>.get()</code> 是從 <code>HashMap</code> 中獲取一個值的比較安全的方法。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let canadian_cities = vec![&quot;Calgary&quot;, &quot;Vancouver&quot;, &quot;Gimli&quot;];
    let german_cities = vec![&quot;Karlsruhe&quot;, &quot;Bad Doberan&quot;, &quot;Bielefeld&quot;];

    let mut city_hashmap = HashMap::new();

    for city in canadian_cities {
        city_hashmap.insert(city, &quot;Canada&quot;);
    }
    for city in german_cities {
        city_hashmap.insert(city, &quot;Germany&quot;);
    }

    println!(&quot;{:?}&quot;, city_hashmap[&quot;Bielefeld&quot;]);
    println!(&quot;{:?}&quot;, city_hashmap.get(&quot;Bielefeld&quot;));
    println!(&quot;{:?}&quot;, city_hashmap.get(&quot;Bielefeldd&quot;));
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">&quot;Germany&quot;
Some(&quot;Germany&quot;)
None
</code></pre>
<p>這是因為<em>Bielefeld</em>存在，但<em>Bielefeldd</em>不存在。</p>
<p>如果<code>HashMap</code>已經有一個鍵，當你試圖把它放進去時，它將覆蓋它的值。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, &quot;L'Allemagne Moderne&quot;);
    book_hashmap.insert(1, &quot;Le Petit Prince&quot;);
    book_hashmap.insert(1, &quot;섀도우 오브 유어 스마일&quot;);
    book_hashmap.insert(1, &quot;Eye of the World&quot;);

    println!(&quot;{:?}&quot;, book_hashmap.get(&amp;1));
}
</code></pre></pre>
<p>這將打印出 <code>Some(&quot;Eye of the World&quot;)</code>，因為它是你最後使用 <code>.insert()</code> 的條目。</p>
<p>檢查一個條目是否存在是很容易的，因為你可以用 <code>.get()</code> 檢查，它給出了 <code>Option</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, &quot;L'Allemagne Moderne&quot;);

    if book_hashmap.get(&amp;1).is_none() { // is_none() returns a bool: true if it's None, false if it's Some
        book_hashmap.insert(1, &quot;Le Petit Prince&quot;);
    }

    println!(&quot;{:?}&quot;, book_hashmap.get(&amp;1));
}
</code></pre></pre>
<p>這個打印<code>Some(&quot;L\'Allemagne Moderne&quot;)</code>是因為已經有了key為<code>1</code>的，所以我們沒有插入<code>Le Petit Prince</code>。</p>
<p><code>HashMap</code>有一個非常有趣的方法，叫做<code>.entry()</code>，你一定要試試。有了它，你可以在沒有鍵的情況下，用如<code>.or_insert()</code>這類方法來插入值。有趣的是，它還給出了一個可變引用，所以如果你想的話，你可以改變它。首先是一個例子，我們只是在每次插入書名到<code>HashMap</code>時插入一個<code>true</code>。</p>
<p>讓我們假設我們有一個圖書館，並希望跟蹤我們的書籍。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec![&quot;L'Allemagne Moderne&quot;, &quot;Le Petit Prince&quot;, &quot;Eye of the World&quot;, &quot;Eye of the World&quot;]; // Eye of the World appears twice

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        book_hashmap.entry(book).or_insert(true);
    }
    for (book, true_or_false) in book_hashmap {
        println!(&quot;Do we have {}? {}&quot;, book, true_or_false);
    }
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">Do we have Eye of the World? true
Do we have Le Petit Prince? true
Do we have L'Allemagne Moderne? true
</code></pre>
<p>但這並不是我們想要的。也許最好是數一下書的數量，這樣我們就知道<em>世界之眼</em> 有兩本。首先讓我們看看<code>.entry()</code>做了什麼，以及<code>.or_insert()</code>做了什麼。<code>.entry()</code>其實是返回了一個名為<code>Entry</code>的<code>enum</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn entry(&amp;mut self, key: K) -&gt; Entry&lt;K, V&gt; // 🚧
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">Entry文檔頁</a>。下面是其代碼的簡單版本。<code>K</code>表示key，<code>V</code>表示value。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
use std::collections::hash_map::*;

enum Entry&lt;K, V&gt; {
    Occupied(OccupiedEntry&lt;K, V&gt;),
    Vacant(VacantEntry&lt;K, V&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>然後當我們調用<code>.or_insert()</code>時，它就會查看枚舉，並決定該怎麼做。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn or_insert(self, default: V) -&gt; &amp;mut V { // 🚧
    match self {
        Occupied(entry) =&gt; entry.into_mut(),
        Vacant(entry) =&gt; entry.insert(default),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>有趣的是，它返回一個<code>mut</code>的引用。<code>&amp;mut V</code>. 這意味著你可以使用<code>let</code>將其附加到一個變量上，並改變變量來改變<code>HashMap</code>中的值。所以對於每本書，如果沒有條目，我們就會插入一個0。而如果有的話，我們將在引用上使用<code>+= 1</code>來增加數字。現在它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec![&quot;L'Allemagne Moderne&quot;, &quot;Le Petit Prince&quot;, &quot;Eye of the World&quot;, &quot;Eye of the World&quot;];

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        let return_value = book_hashmap.entry(book).or_insert(0); // return_value is a mutable reference. If nothing is there, it will be 0
        *return_value +=1; // Now return_value is at least 1. And if there was another book, it will go up by 1
    }

    for (book, number) in book_hashmap {
        println!(&quot;{}, {}&quot;, book, number);
    }
}
</code></pre></pre>
<p>重要的部分是<code>let return_value = book_hashmap.entry(book).or_insert(0);</code>。如果去掉 <code>let</code>，你會得到 <code>book_hashmap.entry(book).or_insert(0)</code>。如果沒有<code>let</code>，它什麼也不做:它插入了0，沒有獲取指向0的可變引用。所以我們把它綁定到<code>return_value</code>上，這樣我們就可以保留0。然後我們把值增加1，這樣<code>HashMap</code>中的每本書都至少有1。然後當<code>.entry()</code>再看<em>世界之眼</em>時，它不會插入任何東西，但它給我們一個可變的1。然後我們把它增加到2，所以它才會打印出這樣的結果。</p>
<pre><code class="language-text">L'Allemagne Moderne, 1
Le Petit Prince, 1
Eye of the World, 2
</code></pre>
<p>你也可以用<code>.or_insert()</code>做一些事情，比如插入一個vec，然後推入數據。讓我們假設我們問街上的男人和女人他們對一個政治家的看法。他們給出的評分從0到10。然後我們要把這些數字放在一起，看看這個政治家是更受男人歡迎還是女人歡迎。它可以是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let data = vec![ // This is the raw data
        (&quot;male&quot;, 9),
        (&quot;female&quot;, 5),
        (&quot;male&quot;, 0),
        (&quot;female&quot;, 6),
        (&quot;female&quot;, 5),
        (&quot;male&quot;, 10),
    ];

    let mut survey_hash = HashMap::new();

    for item in data { // This gives a tuple of (&amp;str, i32)
        survey_hash.entry(item.0).or_insert(Vec::new()).push(item.1); // This pushes the number into the Vec inside
    }

    for (male_or_female, numbers) in survey_hash {
        println!(&quot;{:?}: {:?}&quot;, male_or_female, numbers);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">&quot;female&quot;, [5, 6, 5]
&quot;male&quot;, [9, 0, 10]
</code></pre>
<p>重要的一行是:<code>survey_hash.entry(item.0).or_insert(Vec::new()).push(item.1);</code>，所以如果它看到 &quot;女&quot;，就會檢查<code>HashMap</code>中是否已經有 &quot;女&quot;。如果沒有，它就會插入一個<code>Vec::new()</code>，然後把數字推入。如果它看到 &quot;女性&quot;已經在<code>HashMap</code>中，它將不會插入一個新的Vec，而只是將數字推入其中。</p>
<h3 id="hashset和btreeset"><a class="header" href="#hashset和btreeset">HashSet和BTreeSet</a></h3>
<p><code>HashSet</code>實際上是一個只有key的<code>HashMap</code>。在<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">HashSet的頁面</a>上面有解釋。</p>
<p><code>A hash set implemented as a HashMap where the value is ().</code> 所以這是一個<code>HashMap</code>，有鍵，沒有值。</p>
<p>如果你只是想知道一個鍵是否存在，或者不存在，你經常會使用<code>HashSet</code>。</p>
<p>想象一下，你有100個隨機數，每個數字在1和100之間。如果你這樣做，有些數字會出現不止一次，而有些數字根本不會出現。如果你把它們放到<code>HashSet</code>中，那麼你就會有一個所有出現的數字的列表。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let many_numbers = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut number_hashset = HashSet::new();

    for number in many_numbers {
        number_hashset.insert(number);
    }

    let hashset_length = number_hashset.len(); // The length tells us how many numbers are in it
    println!(&quot;There are {} unique numbers, so we are missing {}.&quot;, hashset_length, 100 - hashset_length);

    // Let's see what numbers we are missing
    let mut missing_vec = vec![];
    for number in 0..100 {
        if number_hashset.get(&amp;number).is_none() { // If .get() returns None,
            missing_vec.push(number);
        }
    }

    print!(&quot;It does not contain: &quot;);
    for number in missing_vec {
        print!(&quot;{} &quot;, number);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">There are 66 unique numbers, so we are missing 34.
It does not contain: 1 2 4 6 7 9 12 21 23 27 30 31 39 40 45 47 48 50 52 53 62 65 69 70 72 75 77 78 83 85 88 97 98 99
</code></pre>
<p><code>BTreeSet</code>與<code>HashSet</code>相似，就像<code>BTreeMap</code>與<code>HashMap</code>相似一樣。如果我們把<code>HashSet</code>中的每一項都打印出來，就不知道順序是什麼了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in number_hashset { // 🚧
    print!(&quot;{} &quot;, entry);
}
<span class="boring">}
</span></code></pre></pre>
<p>也許它能打印出這個。<code>67 28 42 25 95 59 87 11 5 81 64 34 8 15 13 86 10 89 63 93 49 41 46 57 60 29 17 22 74 43 32 38 36 76 71 18 14 84 61 16 35 90 56 54 91 19 94 44 3 0 68 80 51 92 24 20 82 26 58 33 55 96 37 66 79 73</code>. 但它幾乎不會再以同樣的方式打印。</p>
<p>在這裡也一樣，如果你決定需要訂購的話，很容易把你的<code>HashSet</code>改成<code>BTreeSet</code>。在我們的代碼中，我們只需要做兩處改動，就可以從<code>HashSet</code>切換到<code>BTreeSet</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeSet; // Change HashSet to BTreeSet

fn main() {
    let many_numbers = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut number_btreeset = BTreeSet::new(); // Change HashSet to BTreeSet

    for number in many_numbers {
        number_btreeset.insert(number);
    }
    for entry in number_btreeset {
        print!(&quot;{} &quot;, entry);
    }
}
</code></pre></pre>
<p>現在會按順序打印。<code>0 3 5 8 10 11 13 14 15 16 17 18 19 20 22 24 25 26 28 29 32 33 34 35 36 37 38 41 42 43 44 46 49 51 54 55 56 57 58 59 60 61 63 64 66 67 68 71 73 74 76 79 80 81 82 84 86 87 89 90 91 92 93 94 95 96</code>.</p>
<h3 id="二叉堆"><a class="header" href="#二叉堆">二叉堆</a></h3>
<p><code>BinaryHeap</code>是一種有趣的集合類型，因為它大部分是無序的，但也有一點秩序。它把最大的元素放在前面，但其他元素是按任何順序排列的。</p>
<p>我們將用另一個元素列表來舉例，但這次數據少些。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn show_remainder(input: &amp;BinaryHeap&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { // This function shows the remainder in the BinaryHeap. Actually an iterator would be
                                                         // faster than a function - we will learn them later.
    let mut remainder_vec = vec![];
    for number in input {
        remainder_vec.push(*number)
    }
    remainder_vec
}

fn main() {
    let many_numbers = vec![0, 5, 10, 15, 20, 25, 30]; // These numbers are in order

    let mut my_heap = BinaryHeap::new();

    for number in many_numbers {
        my_heap.push(number);
    }

    while let Some(number) = my_heap.pop() { // .pop() returns Some(number) if a number is there, None if not. It pops from the front
        println!(&quot;Popped off {}. Remaining numbers are: {:?}&quot;, number, show_remainder(&amp;my_heap));
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Popped off 30. Remaining numbers are: [25, 15, 20, 0, 10, 5]
Popped off 25. Remaining numbers are: [20, 15, 5, 0, 10]
Popped off 20. Remaining numbers are: [15, 10, 5, 0]
Popped off 15. Remaining numbers are: [10, 0, 5]
Popped off 10. Remaining numbers are: [5, 0]
Popped off 5. Remaining numbers are: [0]
Popped off 0. Remaining numbers are: []
</code></pre>
<p>你可以看到，0指數的數字總是最大的。25, 20, 15, 10, 5, 然後是0.</p>
<p>使用<code>BinaryHeap&lt;(u8, &amp;str)&gt;</code>的一個好方法是用於一個事情的集合。這裡我們創建一個<code>BinaryHeap&lt;(u8, &amp;str)&gt;</code>，其中<code>u8</code>是任務重要性的數字。<code>&amp;str</code>是對要做的事情的描述。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn main() {
    let mut jobs = BinaryHeap::new();

    // Add jobs to do throughout the day
    jobs.push((100, &quot;Write back to email from the CEO&quot;));
    jobs.push((80, &quot;Finish the report today&quot;));
    jobs.push((5, &quot;Watch some YouTube&quot;));
    jobs.push((70, &quot;Tell your team members thanks for always working hard&quot;));
    jobs.push((30, &quot;Plan who to hire next for the team&quot;));

    while let Some(job) = jobs.pop() {
        println!(&quot;You need to: {}&quot;, job.1);
    }
}
</code></pre></pre>
<p>這將一直打印:</p>
<pre><code class="language-text">You need to: Write back to email from the CEO
You need to: Finish the report today
You need to: Tell your team members thanks for always working hard
You need to: Plan who to hire next for the team
You need to: Watch some YouTube
</code></pre>
<h3 id="vecdeque"><a class="header" href="#vecdeque">VecDeque</a></h3>
<p><code>VecDeque</code>就是一個<code>Vec</code>，既能從前面彈出item，又能從後面彈出item。Rust有<code>VecDeque</code>是因為<code>Vec</code>很適合從後面(最後一個元素)彈出，但從前面彈出就不那麼好了。當你在<code>Vec</code>上使用<code>.pop()</code>的時候，它只是把右邊最後一個item取下來，其他的都不會動。但是如果你把它從其他部分取下來，右邊的所有元素都會向左移動一個位置。你可以在<code>.remove()</code>的描述中看到這一點。</p>
<pre><code class="language-text">Removes and returns the element at position index within the vector, shifting all elements after it to the left.
</code></pre>
<p>所以如果你這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![9, 8, 7, 6, 5];
    my_vec.remove(0);
}
</code></pre></pre>
<p>它將刪除 <code>9</code>。索引1中的<code>8</code>將移到索引0，索引2中的<code>7</code>將移到索引1，以此類推。想象一下，一個大停車場，每當有一輛車離開時，右邊所有的車都要移過來。</p>
<p>比如說，這對計算機來說是一個<em>很大</em>的工作量。事實上，如果你在playground上運行它，它可能會因為工作太多而直接放棄。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![0; 600_000];
    for i in 0..600000 {
        my_vec.remove(0);
    }
}
</code></pre></pre>
<p>這是60萬個零的<code>Vec</code>。每次你用<code>remove(0)</code>，它就會把每個零向左移動一個空格。然後它就會做60萬次。</p>
<p>用<code>VecDeque</code>就不用擔心這個問題了。它通常比<code>Vec</code>慢一點，但如果你要在兩端都做事情，那麼它就快多了。你可以直接用<code>VecDeque::from</code>與<code>Vec</code>來創建一個。那麼我們上面的代碼就是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn main() {
    let mut my_vec = VecDeque::from(vec![0; 600000]);
    for i in 0..600000 {
        my_vec.pop_front(); // pop_front is like .pop but for the front
    }
}
</code></pre></pre>
<p>現在速度快了很多，在playground上，它在一秒內完成，而不是放棄。</p>
<p>在接下來的這個例子中，我們在一個<code>Vec</code>上做一些事。我們創建一個<code>VecDeque</code>，用<code>.push_front()</code>把它們放在前面，所以我們添加的第一個元素會在右邊。但是我們推送的每一個元素都是一個<code>(&amp;str, bool)</code>:<code>&amp;str</code>是描述, <code>false</code>表示還沒有完成。我們用<code>done()</code>函數從後面彈出一個元素，但是我們不想刪除它。相反，我們把<code>false</code>改成<code>true</code>，然後把它推到前面，這樣我們就可以保留它。</p>
<p>它看起來是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn check_remaining(input: &amp;VecDeque&lt;(&amp;str, bool)&gt;) { // Each item is a (&amp;str, bool)
    for item in input {
        if item.1 == false {
            println!(&quot;You must: {}&quot;, item.0);
        }
    }
}

fn done(input: &amp;mut VecDeque&lt;(&amp;str, bool)&gt;) {
    let mut task_done = input.pop_back().unwrap(); // pop off the back
    task_done.1 = true;                            // now it's done - mark as true
    input.push_front(task_done);                   // put it at the front now
}

fn main() {
    let mut my_vecdeque = VecDeque::new();
    let things_to_do = vec![&quot;send email to customer&quot;, &quot;add new product to list&quot;, &quot;phone Loki back&quot;];

    for thing in things_to_do {
        my_vecdeque.push_front((thing, false));
    }

    done(&amp;mut my_vecdeque);
    done(&amp;mut my_vecdeque);

    check_remaining(&amp;my_vecdeque);

    for task in my_vecdeque {
        print!(&quot;{:?} &quot;, task);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">You must: phone Loki back
(&quot;add new product to list&quot;, true) (&quot;send email to customer&quot;, true) (&quot;phone Loki back&quot;, false)
</code></pre>
<h2 id="操作符"><a class="header" href="#操作符">?操作符</a></h2>
<p>有一種更短的方法來處理<code>Result</code>(和<code>Option</code>)，它比<code>match</code>和<code>if let</code>更短。它叫做 &quot;問號運算符&quot;，就是<code>?</code>。在返回結果的函數後，可以加上<code>?</code>。這樣就會:</p>
<ul>
<li>如果是<code>Ok</code>，返回<code>Result</code>裡面的內容。</li>
<li>如果是<code>Err</code>，則將錯誤傳回。</li>
</ul>
<p>換句話說，它幾乎為你做了所有的事情。</p>
<p>我們可以用 <code>.parse()</code> 再試一次。我們將編寫一個名為 <code>parse_str</code> 的函數，試圖將 <code>&amp;str</code> 變成 <code>i32</code>。它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?; // Here is the question mark
    Ok(parsed_number)
}

fn main() {}
</code></pre></pre>
<p>這個函數接收一個 <code>&amp;str</code>。如果是 <code>Ok</code>，則給出一個 <code>i32</code>，包裹在 <code>Ok</code> 中。如果是 <code>Err</code>，則返回 <code>ParseIntError</code>。然後我們嘗試解析這個數字，並加上<code>?</code>。也就是 &quot;檢查是否錯誤，如果沒問題就給出Result裡面的內容&quot;。如果有問題，就會返回錯誤並結束。但如果沒問題，就會進入下一行。下一行是<code>Ok()</code>裡面的數字。我們需要用<code>Ok</code>來包裝，因為返回的是<code>Result&lt;i32, ParseIntError&gt;</code>，而不是<code>i32</code>。</p>
<p>現在，我們可以試試我們的函數。讓我們看看它對<code>&amp;str</code>的vec有什麼作用。</p>
<pre><pre class="playground"><code class="language-rust">fn parse_str(input: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?;
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec![&quot;Seven&quot;, &quot;8&quot;, &quot;9.0&quot;, &quot;nice&quot;, &quot;6060&quot;];
    for item in str_vec {
        let parsed = parse_str(item);
        println!(&quot;{:?}&quot;, parsed);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Err(ParseIntError { kind: InvalidDigit })
Ok(8)
Err(ParseIntError { kind: InvalidDigit })
Err(ParseIntError { kind: InvalidDigit })
Ok(6060)
</code></pre>
<p>我們是怎麼找到<code>std::num::ParseIntError</code>的呢？一個簡單的方法就是再 &quot;問&quot;一下編譯器。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let failure = &quot;Not a number&quot;.parse::&lt;i32&gt;();
    failure.rbrbrb(); // ⚠️ Compiler: &quot;What is rbrbrb()???&quot;
}
</code></pre></pre>
<p>編譯器不懂，說。</p>
<pre><code class="language-text">error[E0599]: no method named `rbrbrb` found for enum `std::result::Result&lt;i32, std::num::ParseIntError&gt;` in the current scope
 --&gt; src\main.rs:3:13
  |
3 |     failure.rbrbrb();
  |             ^^^^^^ method not found in `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>所以<code>std::result::Result&lt;i32, std::num::ParseIntError&gt;</code>就是我們需要的簽名。</p>
<p>我們不需要寫 <code>std::result::Result</code>，因為 <code>Result</code> 總是 &quot;在範圍內&quot;(在範圍內 = 準備好使用)。Rust對我們經常使用的所有類型都是這樣做的，所以我們不必寫<code>std::result::Result</code>、<code>std::collections::Vec</code>等。</p>
<p>我們現在還沒有處理文件這樣的東西，所以?操作符看起來還不是太有用。但這裡有一個無用但快速的例子，說明你如何在單行上使用它。與其用 <code>.parse()</code> 創建一個 <code>i32</code>，不如做更多。我們將創建一個 <code>u16</code>，然後把它變成 <code>String</code>，再變成 <code>u32</code>，然後再變成 <code>String</code>，最後變成 <code>i32</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;u16&gt;()?.to_string().parse::&lt;u32&gt;()?.to_string().parse::&lt;i32&gt;()?; // Add a ? each time to check and pass it on
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec![&quot;Seven&quot;, &quot;8&quot;, &quot;9.0&quot;, &quot;nice&quot;, &quot;6060&quot;];
    for item in str_vec {
        let parsed = parse_str(item);
        println!(&quot;{:?}&quot;, parsed);
    }
}
</code></pre></pre>
<p>這打印出同樣的東西，但這次我們在一行中處理了三個<code>Result</code>。稍後我們將對文件進行處理，因為它們總是返回<code>Result</code>，因為很多事情都可能出錯。</p>
<p>想象一下:你想打開一個文件，向它寫入，然後關閉它。首先你需要成功找到這個文件(這就是一個<code>Result</code>)。然後你需要成功地寫入它(那是一個<code>Result</code>)。對於<code>?</code>，你可以在一行上完成。</p>
<h3 id="when-panic-and-unwrap-are-good"><a class="header" href="#when-panic-and-unwrap-are-good">When panic and unwrap are good</a></h3>
<p>Rust有一個<code>panic!</code>的宏，你可以用它來讓程序崩潰。它使用起來很方便。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!(&quot;Time to panic!&quot;);
}
</code></pre></pre>
<p>運行程序時，會顯示信息<code>&quot;Time to panic!&quot;</code>。<code>thread 'main' panicked at 'Time to panic!', src\main.rs:2:3</code></p>
<p>你會記得<code>src\main.rs</code>是目錄和文件名，<code>2:3</code>是行名和列名。有了這些信息，你就可以找到代碼並修復它。</p>
<p><code>panic!</code>是一個很好用的宏，以確保你知道什麼時候有變化。例如，這個叫做<code>prints_three_things</code>的函數總是從一個向量中打印出索引[0]、[1]和[2]。這沒關係，因為我們總是給它一個有三個元素的向量。</p>
<pre><pre class="playground"><code class="language-rust">fn prints_three_things(vector: Vec&lt;i32&gt;) {
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    prints_three_things(my_vec);
}
</code></pre></pre>
<p>它打印出<code>8, 9, 10</code>，一切正常。</p>
<p>但試想一下，後來我們寫的代碼越來越多，忘記了<code>my_vec</code>只能有三個元素。現在<code>my_vec</code>在這部分有六個元素。</p>
<pre><pre class="playground"><code class="language-rust">fn prints_three_things(vector: Vec&lt;i32&gt;) {
  println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
  let my_vec = vec![8, 9, 10, 10, 55, 99]; // Now my_vec has six things
  prints_three_things(my_vec);
}
</code></pre></pre>
<p>不會發生錯誤，因為[0]和[1]和[2]都在這個較長的<code>Vec</code>裡面。但如果只能有三個元素呢？我們就不會知道有問題了，因為程序不會崩潰。我們應該這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn prints_three_things(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!(&quot;my_vec must always have three items&quot;) // will panic if the length is not 3
    }
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    prints_three_things(my_vec);
}
</code></pre></pre>
<p>現在我們知道，如果向量有6個元素，它應該要崩潰:</p>
<pre><pre class="playground"><code class="language-rust">    // ⚠️
fn prints_three_things(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!(&quot;my_vec must always have three items&quot;)
    }
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10, 10, 55, 99];
    prints_three_things(my_vec);
}
</code></pre></pre>
<p>這樣我們就得到了<code>thread 'main' panicked at 'my_vec must always have three items', src\main.rs:8:9</code>。多虧了<code>panic!</code>，我們現在記得<code>my_vec</code>應該只有三個元素。所以<code>panic!</code>是一個很好的宏，可以在你的代碼中創建提醒。</p>
<p>還有三個與<code>panic!</code>類似的宏，你在測試中經常使用。它們分別是 <code>assert!</code>, <code>assert_eq!</code>, 和 <code>assert_ne!</code>.</p>
<p>下面是它們的意思。</p>
<ul>
<li><code>assert!()</code>: 如果<code>()</code>裡面的部分不是真的, 程序就會崩潰.</li>
<li><code>assert_eq!()</code>:<code>()</code>裡面的兩個元素必須相等。</li>
<li><code>assert_ne!()</code>:<code>()</code>裡面的兩個元素必須不相等。(<em>ne</em>表示不相等)</li>
</ul>
<p>一些例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Loki Laufeyson&quot;;

    assert!(my_name == &quot;Loki Laufeyson&quot;);
    assert_eq!(my_name, &quot;Loki Laufeyson&quot;);
    assert_ne!(my_name, &quot;Mithridates&quot;);
}
</code></pre></pre>
<p>這不會有任何作用，因為三個斷言宏都沒有問題。(這就是我們想要的)</p>
<p>如果你願意，還可以加個提示信息。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Loki Laufeyson&quot;;

    assert!(
        my_name == &quot;Loki Laufeyson&quot;,
        &quot;{} should be Loki Laufeyson&quot;,
        my_name
    );
    assert_eq!(
        my_name, &quot;Loki Laufeyson&quot;,
        &quot;{} and Loki Laufeyson should be equal&quot;,
        my_name
    );
    assert_ne!(
        my_name, &quot;Mithridates&quot;,
        &quot;You entered {}. Input must not equal Mithridates&quot;,
        my_name
    );
}
</code></pre></pre>
<p>這些信息只有在程序崩潰時才會顯示。所以如果你運行這個。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Mithridates&quot;;

    assert_ne!(
        my_name, &quot;Mithridates&quot;,
        &quot;You enter {}. Input must not equal Mithridates&quot;,
        my_name
    );
}
</code></pre></pre>
<p>它將顯示:</p>
<pre><code class="language-text">thread 'main' panicked at 'assertion failed: `(left != right)`
  left: `&quot;Mithridates&quot;`,
 right: `&quot;Mithridates&quot;`: You entered Mithridates. Input must not equal Mithridates', src\main.rs:4:5
</code></pre>
<p>所以它說 &quot;你說左!=右，但左==右&quot;。而且它顯示我們的信息說<code>You entered Mithridates. Input must not equal Mithridates</code>。</p>
<p>當你在寫程序的時候，想讓它在出現問題的時候崩潰，<code>unwrap</code>是個好注意。當你的代碼寫完後，把<code>unwrap</code>改成其他不會崩潰的東西就好了。</p>
<p>你也可以用<code>expect</code>，它和<code>unwrap</code>一樣，但是更好一些，因為它支持用戶自定義信息。教科書通常會給出這樣的建議:&quot;如果你經常使用<code>.unwrap()</code>, 至少也要用<code>.expect()</code>來獲得更好的錯誤信息.&quot;</p>
<p>這樣會崩潰的:</p>
<pre><pre class="playground"><code class="language-rust">   // ⚠️
fn get_fourth(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let fourth = input.get(3).unwrap();
    *fourth
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let fourth = get_fourth(&amp;my_vec);
}
</code></pre></pre>
<p>錯誤信息是<code>thread 'main' panicked at 'called Option::unwrap() on a None value', src\main.rs:7:18</code>。</p>
<p>現在我們用<code>expect</code>來寫自己的信息。</p>
<pre><pre class="playground"><code class="language-rust">   // ⚠️
fn get_fourth(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let fourth = input.get(3).expect(&quot;Input vector needs at least 4 items&quot;);
    *fourth
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let fourth = get_fourth(&amp;my_vec);
}
</code></pre></pre>
<p>又崩潰了，但錯誤比較多。<code>thread 'main' panicked at 'Input vector needs at least 4 items', src\main.rs:7:18</code>. <code>.expect()</code>因為這個原因比<code>.unwrap()</code>要好一點，但是在<code>None</code>上還是會崩潰。現在這裡有一個錯誤的案例，一個函數試圖unwrap兩次。它需要一個<code>Vec&lt;Option&lt;i32&gt;&gt;</code>，所以可能每個部分都會有一個<code>Some&lt;i32&gt;</code>，也可能是一個<code>None</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn try_two_unwraps(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!(&quot;Index 0 is: {}&quot;, input[0].unwrap());
    println!(&quot;Index 1 is: {}&quot;, input[1].unwrap());
}

fn main() {
    let vector = vec![None, Some(1000)]; // This vector has a None, so it will panic
    try_two_unwraps(vector);
}
</code></pre></pre>
<p>消息是:<code>thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src\main.rs:2:32</code>。我們不檢查行號，就不知道是第一個<code>.unwrap()</code>還是第二個<code>.unwrap()</code>。最好是檢查一下長度，也不要unwrap。不過有了<code>.expect()</code>至少會好<em>一點</em>。下面是<code>.expect()</code>的情況：</p>
<pre><pre class="playground"><code class="language-rust">fn try_two_unwraps(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!(&quot;Index 0 is: {}&quot;, input[0].expect(&quot;The first unwrap had a None!&quot;));
    println!(&quot;Index 1 is: {}&quot;, input[1].expect(&quot;The second unwrap had a None!&quot;));
}

fn main() {
    let vector = vec![None, Some(1000)];
    try_two_unwraps(vector);
}
</code></pre></pre>
<p>所以，這是好一點的。<code>thread 'main' panicked at 'The first unwrap had a None!', src\main.rs:2:32</code>. 我們也有行號，所以我們可以找到它。</p>
<p>如果你想一直有一個你想選擇的值，也可以用<code>unwrap_or</code>。如果你這樣做，它永遠不會崩潰。就是這樣的。</p>
<ul>
<li>1)好，因為你的程序不會崩潰，但</li>
<li>2)如果你想讓程序在出現問題時崩潰，也許不好。</li>
</ul>
<p>但通常我們都不希望自己的程序崩潰，所以<code>unwrap_or</code>是個不錯的方法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or(&amp;0); // If .get doesn't work, we will make the value &amp;0.
                                              // .get returns a reference, so we need &amp;0 and not 0
                                              // You can write &quot;let *fourth&quot; with a * if you want fourth to be
                                              // a 0 and not a &amp;0, but here we just print so it doesn't matter

    println!(&quot;{}&quot;, fourth);
}
</code></pre></pre>
<p>這將打印出 <code>0</code>，因為 <code>.unwrap_or(&amp;0)</code> 給出了一個 0，即使它是 <code>None</code>。</p>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<p>我們以前見過trait:<code>Debug</code>、<code>Copy</code>、<code>Clone</code>都是trait。要給一個類型一個trait，就必須實現它。因為<code>Debug</code>和其他的trait都很常見，所以我們有自動實現的屬性。這就是當你寫下<code>#[derive(Debug)]</code>所發生的事情:你自動實現了<code>Debug</code>。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyStruct {
    number: usize,
}

fn main() {}
</code></pre></pre>
<p>但是其他的特性就比較困難了，所以需要用<code>impl</code>手動實現。例如，<code>Add</code>(在<code>std::ops::Add</code>處找到)是用來累加兩個東西的。但是Rust並不知道你到底要怎麼累加，所以你必須告訴它。</p>
<pre><pre class="playground"><code class="language-rust">struct ThingsToAdd {
    first_thing: u32,
    second_thing: f32,
}

fn main() {}
</code></pre></pre>
<p>我們可以累加<code>first_thing</code>和<code>second_thing</code>，但我們需要提供更多信息。也許我們想要一個<code>f32</code>，所以像這樣:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let result = self.second_thing + self.first_thing as f32
<span class="boring">}
</span></code></pre></pre>
<p>但也許我們想要一個整數，所以像這樣:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let result = self.second_thing as u32 + self.first_thing
<span class="boring">}
</span></code></pre></pre>
<p>或者我們想把<code>self.first_thing</code>放在<code>self.second_thing</code>旁邊，這樣加。所以如果我們把55加到33.4，我們要看到的是5533.4，而不是88.4。</p>
<p>所以首先我們看一下如何創建一個trait。關於<code>trait</code>，要記住的重要一點是，它們是關於行為的。要創建一個trait，寫下單詞<code>trait</code>，然後創建一些函數。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // A simple struct - an Animal only has a name
    name: String,
}

trait Dog { // The dog trait gives some functionality
    fn bark(&amp;self) { // It can bark
        println!(&quot;Woof woof!&quot;);
    }
    fn run(&amp;self) { // and it can run
        println!(&quot;The dog is running!&quot;);
    }
}

impl Dog for Animal {} // Now Animal has the trait Dog

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark(); // Now Animal can use bark()
    rover.run();  // and it can use run()
}
</code></pre></pre>
<p>這個是可以的，但是我們不想打印 &quot;狗在跑&quot;。如果你想的話，你可以改變<code>trait</code>給你的方法，但你必須有相同的簽名。這意味著它需要接受同樣的東西，並返回同樣的東西。例如，我們可以改變 <code>.run()</code> 的方法，但我們必須遵循簽名。簽名說</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
fn run(&amp;self) {
    println!(&quot;The dog is running!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fn run(&amp;self)</code>的意思是 &quot;fn <code>run()</code>以<code>&amp;self</code>為參數，不返回任何內容&quot;。所以你不能這樣做:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;self) -&gt; i32 { // ⚠️
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust會說。</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>但我們可以做到這一點。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // A simple struct - an Animal only has a name
    name: String,
}

trait Dog { // The dog trait gives some functionality
    fn bark(&amp;self) { // It can bark
        println!(&quot;Woof woof!&quot;);
    }
    fn run(&amp;self) { // and it can run
        println!(&quot;The dog is running!&quot;);
    }
}

impl Dog for Animal {
    fn run(&amp;self) {
        println!(&quot;{} is running!&quot;, self.name);
    }
}

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark(); // Now Animal can use bark()
    rover.run();  // and it can use run()
}
</code></pre></pre>
<p>現在它打印的是 <code>Rover is running!</code>。這是好的，因為我們返回的是 <code>()</code>，或者說什麼都沒有，這就是trait所說的。</p>
<p>當你寫一個trait的時候，你可以直接寫函數簽名，但如果你這樣做，用戶將不得不寫函數實現。我們來試試。現在我們把<code>bark()</code>和<code>run()</code>改成只說<code>fn bark(&amp;self);</code>和<code>fn run(&amp;self);</code>。這不是一個完整的函數實現，所以必須由用戶來寫。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    name: String,
}

trait Dog {
    fn bark(&amp;self); // bark() says it needs a &amp;self and returns nothing
    fn run(&amp;self); // run() says it needs a &amp;self and returns nothing.
                   // So now we have to write them ourselves.
}

impl Dog for Animal {
    fn bark(&amp;self) {
        println!(&quot;{}, stop barking!!&quot;, self.name);
    }
    fn run(&amp;self) {
        println!(&quot;{} is running!&quot;, self.name);
    }
}

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark();
    rover.run();
}
</code></pre></pre>
<p>所以，當你創建一個trait時，你必須思考:&quot;我應該寫哪些功能？而用戶應該寫哪些函數？&quot; 如果你認為用戶每次使用函數的方式應該是一樣的，那麼就把函數寫出來。如果你認為用戶會以不同的方式使用，那就寫出函數簽名即可。</p>
<p>所以，讓我們嘗試為我們的struct實現Display特性。首先我們將創建一個簡單的結構體:</p>
<pre><pre class="playground"><code class="language-rust">struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };
}
</code></pre></pre>
<p>現在我們要打印<code>mr_mantle</code>。調試很容易得出。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    println!(&quot;Mr. Mantle is a {:?}&quot;, mr_mantle);
}
</code></pre></pre>
<p>但Debug打印不是最漂亮的方式，因為它看起來是這樣的:</p>
<pre><code class="language-text">Mr. Mantle is a Cat { name: &quot;Reggie Mantle&quot;, age: 4 }
</code></pre>
<p>因此，如果我們想要更好的打印，就需要實現<code>Display</code>為<code>Cat</code>。在<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a>上我們可以看到Display的信息，還有一個例子。它說</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.longitude, self.latitude)
    }
}

fn main() {}
</code></pre></pre>
<p>有些部分我們還不明白，比如<code>&lt;'_&gt;</code>和<code>f</code>在做什麼。但我們理解<code>Position</code>結構體:它只是兩個<code>f32</code>。我們也明白，<code>self.longitude</code>和<code>self.latitude</code>是結構體中的字段。所以，也許我們的結構體就可以用這個代碼，用<code>self.name</code>和<code>self.age</code>。另外，<code>write!</code>看起來很像<code>println!</code>，所以很熟悉。所以我們這樣寫。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
    }
}

fn main() {}
</code></pre></pre>
<p>讓我們添加一個<code>fn main()</code>。現在我們的代碼是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
      write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
  }
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    println!(&quot;{}&quot;, mr_mantle);
}
</code></pre></pre>
<p>成功了! 現在，當我們使用<code>{}</code>打印時，我們得到<code>Reggie Mantle is a cat who is 4 years old.</code>。這看起來好多了。</p>
<p>順便說一下，如果你實現了<code>Display</code>，那麼你就可以免費得到<code>ToString</code>的特性。這是因為你使用<code>format!</code>宏來實現<code>.fmt()</code>函數，這讓你可以用<code>.to_string()</code>來創建一個<code>String</code>。所以我們可以做這樣的事情，我們把<code>reggie_mantle</code>傳給一個想要<code>String</code>的函數，或者其他任何東西。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
    }
}

fn print_cats(pet: String) {
    println!(&quot;{}&quot;, pet);
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    print_cats(mr_mantle.to_string()); // Turn him into a String here
    println!(&quot;Mr. Mantle's String is {} letters long.&quot;, mr_mantle.to_string().chars().count()); // Turn him into chars and count them
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Reggie Mantle is a cat who is 4 years old.
Mr. Mantle's String is 42 letters long.
</code></pre>
<p>關於trait，要記住的是，它們是關於某些東西的行為。你的<code>struct</code>是如何行動的？它能做什麼？這就是trait的作用。如果你想想我們到目前為止所看到的一些trait，它們都是關於行為的:<code>Copy</code>是一個類型可以做的事情。<code>Display</code>也是一個類型能做的事情。<code>ToString</code>是另一個trait，它也是一個類型可以做的事情:它可以變化成一個<code>String</code>。在我們的 <code>Dog</code> trait中，<em>Dog</em>這個詞並不意味著你能做的事情，但它給出了一些讓它做事情的方法。
你也可以為 <code>struct Poodle</code> 或 <code>struct Beagle</code> 實現它，它們都會得到 <code>Dog</code> 方法。</p>
<p>讓我們再看一個與單純行為聯繫更緊密的例子。我們將想象一個有一些簡單角色的幻想遊戲。一個是<code>Monster</code>，另外兩個是<code>Wizard</code>和<code>Ranger</code>。<code>Monster</code>只是有<code>health</code>，所以我們可以攻擊它，其他兩個還沒有什麼。但是我們做了兩個trait。一個叫<code>FightClose</code>，讓你近身作戰。另一個是<code>FightFromDistance</code>，讓你在遠處戰鬥。只有<code>Ranger</code>可以使用<code>FightFromDistance</code>。下面是它的樣子:</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

struct Wizard {}
struct Ranger {}

trait FightClose {
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            &quot;You attack with your sword. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            &quot;You attack with your hand. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance {
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                &quot;You attack with your bow. Your opponent now has {} health left.&quot;,
                opponent.health
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            &quot;You attack with your rock. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard {};
    let aragorn = Ranger {};

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left.
You attack with your bow. Your opponent now has 20 health left.
</code></pre>
<p>我們在trait裡面一直傳遞<code>self</code>，但是我們現在不能用它做什麼。那是因為 Rust 不知道什麼類型會使用它。它可能是一個 <code>Wizard</code>，也可能是一個 <code>Ranger</code>，也可能是一個叫做 <code>Toefocfgetobjtnode</code> 的新結構，或者其他任何東西。為了讓<code>self</code>具有一定的功能，我們可以在trait中添加必要的trait。比如說，如果我們想用<code>{:?}</code>打印，那麼我們就需要<code>Debug</code>。你只要把它寫在<code>:</code>(冒號)後面，就可以把它添加到trait中。現在我們的代碼是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

#[derive(Debug)] // Now Wizard has Debug
struct Wizard {
    health: i32, // Now Wizard has health
}
#[derive(Debug)] // So does Ranger
struct Ranger {
    health: i32, // So does Ranger
}

trait FightClose: std::fmt::Debug { // Now a type needs Debug to use FightClose
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            &quot;You attack with your sword. Your opponent now has {} health left. You are now at: {:?}&quot;, // We can now print self with {:?} because we have Debug
            opponent.health, &amp;self
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            &quot;You attack with your hand. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, &amp;self
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance: std::fmt::Debug { // We could also do trait FightFromDistance: FightClose because FightClose needs Debug
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                &quot;You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}&quot;,
                opponent.health, self
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            &quot;You attack with your rock. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, self
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>現在這個打印:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
</code></pre>
<p>在真實的遊戲中，可能最好為每個類型重寫這個，因為<code>You are now at: Wizard { health: 60 }</code>看起來有點可笑。這也是為什麼trait裡面的方法通常很簡單，因為你不知道什麼類型會使用它。例如，你不能寫出 <code>self.0 += 10</code> 這樣的東西。但是這個例子表明，我們可以在我們正在寫的trait裡面使用其他的trait。當我們這樣做的時候，我們會得到一些我們可以使用的方法。</p>
<p>另外一種使用trait的方式是使用所謂的<code>trait bounds</code>。意思是 &quot;通過一個trait進行限制&quot;。trait限制很簡單，因為一個trait實際上不需要任何方法，或者說根本不需要任何東西。讓我們用類似但不同的東西重寫我們的代碼。這次我們的trait沒有任何方法，但我們有其他需要trait使用的函數。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // So we don't have to write std::fmt::Debug every time now

struct Monster {
    health: i32,
}

#[derive(Debug)]
struct Wizard {
    health: i32,
}
#[derive(Debug)]
struct Ranger {
    health: i32,
}

trait Magic{} // No methods for any of these traits. They are just trait bounds
trait FightClose {}
trait FightFromDistance {}

impl FightClose for Ranger{} // Each type gets FightClose,
impl FightClose for Wizard {}
impl FightFromDistance for Ranger{} // but only Ranger gets FightFromDistance
impl Magic for Wizard{}  // and only Wizard gets Magic

fn attack_with_bow&lt;T: FightFromDistance + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 10 {
        opponent.health -= 10;
        println!(
            &quot;You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, character
        );
    }
}

fn attack_with_sword&lt;T: FightClose + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster) {
    opponent.health -= 10;
    println!(
        &quot;You attack with your sword. Your opponent now has {} health left. You are now at: {:?}&quot;,
        opponent.health, character
    );
}

fn fireball&lt;T: Magic + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 15 {
        opponent.health -= 20;
        println!(&quot;You raise your hands and cast a fireball! Your opponent now has {} health left. You are now at: {:?}&quot;,
    opponent.health, character);
    }
}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    attack_with_sword(&amp;radagast, &amp;mut uruk_hai);
    attack_with_bow(&amp;aragorn, &amp;mut uruk_hai, 8);
    fireball(&amp;radagast, &amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>這個打印出來的東西幾乎是一樣的。</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
You raise your hands and cast a fireball! Your opponent now has 0 health left. You are now at: Wizard { health: 60 }
</code></pre>
<p>所以你可以看到，當你使用traits時，有很多方法可以做同樣的事情。這一切都取決於什麼對你正在編寫的程序最有意義。</p>
<p>現在讓我們來看看如何實現一些在Rust中使用的主要trait。</p>
<h3 id="from-trait"><a class="header" href="#from-trait">From trait</a></h3>
<p><em>From</em>是一個非常方便的trait，你知道這一點，因為你已經看到了很多。使用<em>From</em>，你可以從一個<code>&amp;str</code>創建一個<code>String</code>，你也可以用許多其他類型創建多種類型。例如，Vec使用<em>From</em>來創建以下類型:</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>這裡有很多<code>Vec::from()</code>我們還沒有用過。我們來做幾個，看看會怎麼樣:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // We will make a generic function to print them so we want Display

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // Take any Vec&lt;T&gt; if type T has Display
    for item in input {
        print!(&quot;{} &quot;, item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // Try from an array
    print_vec(&amp;array_vec);

    let str_vec = Vec::from(&quot;What kind of vec will I be?&quot;); // An array from a &amp;str? This will be interesting
    print_vec(&amp;str_vec);

    let string_vec = Vec::from(&quot;What kind of vec will a String be?&quot;.to_string()); // Also from a String
    print_vec(&amp;string_vec);
}
</code></pre></pre>
<p>它打印的內容如下。</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>如果從類型上看，第二個和第三個向量是<code>Vec&lt;u8&gt;</code>，也就是<code>&amp;str</code>和<code>String</code>的字節。所以你可以看到<code>From</code>是非常靈活的，用的也很多。我們用自己的類型來試試。</p>
<p>我們將創建兩個結構體，然後為其中一個結構體實現<code>From</code>。一個結構體將是<code>City</code>，另一個結構體將是<code>Country</code>。我們希望能夠做到這一點。<code>let country_name = Country::from(vector_of_cities)</code>.</p>
<p>它看起來是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // So we can print City
struct City {
    name: String,
    population: u32,
}

impl City {
    fn new(name: &amp;str, population: u32) -&gt; Self { // just a new function
        Self {
            name: name.to_string(),
            population,
        }
    }
}
#[derive(Debug)] // Country also needs to be printed
struct Country {
    cities: Vec&lt;City&gt;, // Our cities go in here
}

impl From&lt;Vec&lt;City&gt;&gt; for Country { // Note: we don't have to write From&lt;City&gt;, we can also do
                                   // From&lt;Vec&lt;City&gt;&gt;. So we can also implement on a type that
                                   // we didn't create
    fn from(cities: Vec&lt;City&gt;) -&gt; Self {
        Self { cities }
    }
}

impl Country {
    fn print_cities(&amp;self) { // function to print the cities in Country
        for city in &amp;self.cities {
            // &amp; because Vec&lt;City&gt; isn't Copy
            println!(&quot;{:?} has a population of {:?}.&quot;, city.name, city.population);
        }
    }
}

fn main() {
    let helsinki = City::new(&quot;Helsinki&quot;, 631_695);
    let turku = City::new(&quot;Turku&quot;, 186_756);

    let finland_cities = vec![helsinki, turku]; // This is the Vec&lt;City&gt;
    let finland = Country::from(finland_cities); // So now we can use From

    finland.print_cities();
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">&quot;Helsinki&quot; has a population of 631695.
&quot;Turku&quot; has a population of 186756.
</code></pre>
<p>你可以看到，<code>From</code>很容易從你沒有創建的類型中實現，比如<code>Vec</code>、<code>i32</code>等等。這裡還有一個例子，我們創建一個有兩個向量的向量。第一個向量存放偶數，第二個向量存放奇數。對於<code>From</code>，你可以給它一個<code>i32</code>的向量，它會把它變成<code>Vec&lt;Vec&lt;i32&gt;&gt;</code>:一個容納<code>i32</code>的向量。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct EvenOddVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for EvenOddVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut even_odd_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // A vec with two empty vecs inside
                                                                    // This is the return value but first we must fill it
        for item in input {
            if item % 2 == 0 {
                even_odd_vec[0].push(item);
            } else {
                even_odd_vec[1].push(item);
            }
        }
        Self(even_odd_vec) // Now it is done so we return it as Self (Self = EvenOddVec)
    }
}

fn main() {
    let bunch_of_numbers = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = EvenOddVec::from(bunch_of_numbers);

    println!(&quot;Even numbers: {:?}\nOdd numbers: {:?}&quot;, new_vec.0[0], new_vec.0[1]);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Even numbers: [8, 222, 0, 8]
Odd numbers: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>像 <code>EvenOddVec</code> 這樣的類型可能最好是通用 <code>T</code>，這樣我們就可以使用許多數字類型。如果你想練習的話，你可以試著把這個例子做成通用的。</p>
<h3 id="在函數中使用字符串和str"><a class="header" href="#在函數中使用字符串和str">在函數中使用字符串和&amp;str</a></h3>
<p>有時你想讓一個函數可以同時接受 <code>String</code> 和 <code>&amp;str</code>。你可以通過泛型和 <code>AsRef</code> 特性來實現這一點。<code>AsRef</code> 用於從一個類型向另一個類型提供引用。如果你看看 <code>String</code> 的文檔，你可以看到它對許多類型都有 <code>AsRef</code>。</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>下面是它們的一些函數簽名。</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}
</span></code></pre></pre>
<p>你可以看到，它需要<code>&amp;self</code>，並給出另一個類型的引用。這意味著，如果你有一個通用類型T，你可以說它需要<code>AsRef&lt;str&gt;</code>。如果你這樣做，它將能夠使用一個<code>&amp;str</code>和一個<code>String</code>。</p>
<p>我們先說說泛型函數。這個還不能用。</p>
<pre><pre class="playground"><code class="language-rust">fn print_it&lt;T&gt;(input: T) {
    println!(&quot;{}&quot;, input) // ⚠️
}

fn main() {
    print_it(&quot;Please print me&quot;);
}
</code></pre></pre>
<p>Rust說<code>error[E0277]: T doesn't implement std::fmt::Display</code>。所以我們會要求T實現Display。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
}
</code></pre></pre>
<p>現在可以用了，打印出<code>Please print me</code>。這是好的，但T仍然可以是多種類型。
可以是<code>i8</code>，也可以是<code>f32</code>，或者其他任何實現了<code>Display</code>的類型。我們加上<code>AsRef&lt;str&gt;</code>，現在T需要<code>AsRef&lt;str&gt;</code>和<code>Display</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
    print_it(&quot;Also, please print me&quot;.to_string());
    // print_it(7); &lt;- This will not print
}
</code></pre></pre>
<p>現在，它不會接受<code>i8</code>這樣的類型。</p>
<p>不要忘了，當函數變長時，你可以用<code>where</code>來寫不同的函數。如果我們加上Debug，那麼就會變成<code>fn print_it&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code>，這一行就很長了。所以我們可以這樣寫。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // add Debug

fn print_it&lt;T&gt;(input: T) // Now this line is easy to read
where
    T: AsRef&lt;str&gt; + Debug + Display, // and these traits are easy to read
{
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
    print_it(&quot;Also, please print me&quot;.to_string());
}
</code></pre></pre>
<h2 id="鏈式方法"><a class="header" href="#鏈式方法">鏈式方法</a></h2>
<p>Rust是一種系統編程語言，就像C和C++一樣，它的代碼可以寫成獨立的命令，單獨成行，但它也有函數式風格。兩種風格都可以，但函數式通常比較短。下面以非函數式(稱為 &quot;命令式&quot;)為例，讓<code>Vec</code>從1到10。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut new_vec = Vec::new();
    let mut counter = 1;

    while counter &lt; 11 {
        new_vec.push(counter);
        counter += 1;
    }

    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>這個打印<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>。</p>
<p>而這裡是函數式風格的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = (1..=10).collect::&lt;Vec&lt;i32&gt;&gt;();
    // Or you can write it like this:
    // let new_vec: Vec&lt;i32&gt; = (1..=10).collect();
    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p><code>.collect()</code>可以為很多類型做集合，所以我們要告訴它類型。</p>
<p>用函數式可以鏈接方法。&quot;鏈接方法&quot;的意思是把很多方法放在一個語句中。下面是一個很多方法鏈在一起的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let new_vec = my_vec.into_iter().skip(3).take(4).collect::&lt;Vec&lt;i32&gt;&gt;();

    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>這樣就創建了一個<code>[3, 4, 5, 6]</code>的Vec。這一行的信息量很大，所以把每個方法放在新的一行上會有幫助。讓我們這樣做，以使其更容易閱讀。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let new_vec = my_vec
        .into_iter() // &quot;iterate&quot; over the items (iterate = work with each item inside it). into_iter() gives us owned values, not references
        .skip(3) // skip over three items: 0, 1, and 2
        .take(4) // take the next four: 3, 4, 5, and 6
        .collect::&lt;Vec&lt;i32&gt;&gt;(); // put them in a new Vec&lt;i32&gt;

    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>當你瞭解閉包和迭代器時，你可以最好地使用這種函數式。所以我們接下來將學習它們。</p>
<h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<p>迭代器是一個構造，它可以給你集合中的元素，一次一個。實際上，我們已經使用了很多迭代器:<code>for</code>循環給你一個迭代器。當你想在其他時候使用迭代器時，你必須選擇什麼樣的迭代器:</p>
<ul>
<li><code>.iter()</code> 引用的迭代器</li>
<li><code>.iter_mut()</code> 可變引用的迭代器</li>
<li><code>.into_iter()</code> 值的迭代器(不是引用)</li>
</ul>
<p><code>for</code>循環其實只是一個擁有值的迭代器。這就是為什麼可以讓它變得可變，然後你可以在使用的時候改變值。</p>
<p>我們可以這樣使用迭代器。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vector1 = vec![1, 2, 3]; // we will use .iter() and .into_iter() on this one
    let vector1_a = vector1.iter().map(|x| x + 1).collect::&lt;Vec&lt;i32&gt;&gt;();
    let vector1_b = vector1.into_iter().map(|x| x * 10).collect::&lt;Vec&lt;i32&gt;&gt;();

    let mut vector2 = vec![10, 20, 30]; // we will use .iter_mut() on this one
    vector2.iter_mut().for_each(|x| *x +=100);

    println!(&quot;{:?}&quot;, vector1_a);
    println!(&quot;{:?}&quot;, vector2);
    println!(&quot;{:?}&quot;, vector1_b);
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">[2, 3, 4]
[110, 120, 130]
[10, 20, 30]
</code></pre>
<p>前兩個我們用了一個叫<code>.map()</code>的方法。這個方法可以讓你對每一個元素做一些事情，然後把它傳遞下去。最後我們用的是一個叫<code>.for_each()</code>的方法。這個方法只是讓你對每一個元素做一些事情。<code>.iter_mut()</code>加上<code>for_each()</code>基本上就是一個<code>for</code>的循環。在每一個方法裡面，我們可以給每一個元素起一個名字(我們剛才叫它 <code>x</code>)，然後用它來改變它。這些被稱為閉包，我們將在下一節學習它們。</p>
<p>讓我們再來看看它們，一次一個。</p>
<p>首先我們用<code>.iter()</code>對<code>vector1</code>進行引用。我們給每個元素都加了1，並使其成為一個新的Vec。<code>vector1</code>還活著，因為我們只用了引用:我們沒有按值取。現在我們有 <code>vector1</code>，還有一個新的 Vec 叫 <code>vector1_a</code>。因為<code>.map()</code>只是傳遞了它，所以我們需要使用<code>.collect()</code>把它變成一個<code>Vec</code>。</p>
<p>然後我們用<code>into_iter</code>從<code>vector1</code>中按值得到一個迭代器。這樣就破壞了<code>vector1</code>，因為這就是<code>into_iter()</code>的作用。所以我們做了<code>vector1_b</code>之後，就不能再使用<code>vector1</code>了。</p>
<p>最後我們在<code>vector2</code>上使用<code>.iter_mut()</code>。它是可變的，所以我們不需要使用<code>.collect()</code>來創建一個新的Vec。相反，我們用可變引用改變同一Vec中的值。所以<code>vector2</code>仍然存在。因為我們不需要一個新的Vec，我們使用<code>for_each</code>:它就像一個<code>for</code>循環。</p>
<h3 id="迭代器如何工作"><a class="header" href="#迭代器如何工作">迭代器如何工作</a></h3>
<p>迭代器的工作原理是使用一個叫做 <code>.next()</code> 的方法，它給出一個 <code>Option</code>。當你使用迭代器時，Rust會一遍又一遍地調用<code>next()</code>。如果得到 <code>Some</code>，它就會繼續前進。如果得到 <code>None</code>，它就停止。</p>
<p>你還記得 <code>assert_eq!</code> 宏嗎？在文檔中，你經常看到它。這裡它展示了迭代器的工作原理。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec!['a', 'b', '거', '柳']; // Just a regular Vec

    let mut my_vec_iter = my_vec.iter(); // This is an Iterator type now, but we haven't called it yet

    assert_eq!(my_vec_iter.next(), Some(&amp;'a'));  // Call the first item with .next()
    assert_eq!(my_vec_iter.next(), Some(&amp;'b'));  // Call the next
    assert_eq!(my_vec_iter.next(), Some(&amp;'거')); // Again
    assert_eq!(my_vec_iter.next(), Some(&amp;'柳')); // Again
    assert_eq!(my_vec_iter.next(), None);        // Nothing is left: just None
    assert_eq!(my_vec_iter.next(), None);        // You can keep calling .next() but it will always be None
}
</code></pre></pre>
<p>為自己的struct或enum實現<code>Iterator</code>並不難。首先我們創建一個書庫，想一想。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // we want to print it with {:?}
struct Library {
    library_type: LibraryType, // this is our enum
    books: Vec&lt;String&gt;, // list of books
}

#[derive(Debug)]
enum LibraryType { // libraries can be city libraries or country libraries
    City,
    Country,
}

impl Library {
    fn add_book(&amp;mut self, book: &amp;str) { // we use add_book to add new books
        self.books.push(book.to_string()); // we take a &amp;str and turn it into a String, then add it to the Vec
    }

    fn new() -&gt; Self { // this creates a new Library
        Self {
            library_type: LibraryType::City, // most are in the city so we'll choose City
                                             // most of the time
            books: Vec::new(),
        }
    }
}

fn main() {
    let mut my_library = Library::new(); // make a new library
    my_library.add_book(&quot;The Doom of the Darksword&quot;); // add some books
    my_library.add_book(&quot;Demian - die Geschichte einer Jugend&quot;);
    my_library.add_book(&quot;구운몽&quot;);
    my_library.add_book(&quot;吾輩は貓である&quot;);

    println!(&quot;{:?}&quot;, my_library.books); // we can print our list of books
}
</code></pre></pre>
<p>這很好用。現在我們想為庫實現<code>Iterator</code>，這樣我們就可以在<code>for</code>循環中使用它。現在如果我們嘗試 <code>for</code> 循環，它就無法工作。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in my_library {
    println!(&quot;{}&quot;, item); // ⚠️
}
<span class="boring">}
</span></code></pre></pre>
<p>它說:</p>
<pre><code class="language-text">error[E0277]: `Library` is not an iterator
  --&gt; src\main.rs:47:16
   |
47 |    for item in my_library {
   |                ^^^^^^^^^^ `Library` is not an iterator
   |
   = help: the trait `std::iter::Iterator` is not implemented for `Library`
   = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>但是我們可以用<code>impl Iterator for Library</code>把庫做成迭代器。<code>Iterator</code>trait的信息在標準庫中。<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a></p>
<p>在頁面的左上方寫著:<code>Associated Types: Item</code>和<code>Required Methods: next</code>。&quot;關聯類型&quot;的意思是 &quot;一起使用的類型&quot;。我們的關聯類型將是<code>String</code>，因為我們希望迭代器給我們提供String。</p>
<p>在頁面中，它有一個看起來像這樣的例子。</p>
<pre><pre class="playground"><code class="language-rust">// an iterator which alternates between Some and None
struct Alternate {
    state: i32,
}

impl Iterator for Alternate {
    type Item = i32;

    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let val = self.state;
        self.state = self.state + 1;

        // if it's even, Some(i32), else None
        if val % 2 == 0 {
            Some(val)
        } else {
            None
        }
    }
}

fn main() {}
</code></pre></pre>
<p>你可以看到<code>impl Iterator for Alternate</code>下面寫著<code>type Item = i32</code>。這就是關聯類型。我們的迭代器將針對我們的書籍列表，這是一個<code>Vec&lt;String&gt;</code>。當我們調用next的時候。
它將給我們一個<code>String</code>。所以我們就寫<code>type Item = String;</code>。這就是關聯項。</p>
<p>為了實現 <code>Iterator</code>，你需要寫 <code>fn next()</code> 函數。這是你決定迭代器應該做什麼的地方。對於我們的 <code>Library</code>，我們首先希望它給我們最後一本書。所以我們將<code>match</code>與<code>.pop()</code>一起，如果是<code>Some</code>的話，就把最後一項去掉。我們還想為每個元素打印 &quot;is found!&quot;。現在它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Clone)]
struct Library {
    library_type: LibraryType,
    books: Vec&lt;String&gt;,
}

#[derive(Debug, Clone)]
enum LibraryType {
    City,
    Country,
}

impl Library {
    fn add_book(&amp;mut self, book: &amp;str) {
        self.books.push(book.to_string());
    }

    fn new() -&gt; Self {
        Self {
            library_type: LibraryType::City,
            // most of the time
            books: Vec::new(),
        }
    }
}

impl Iterator for Library {
    type Item = String;

    fn next(&amp;mut self) -&gt; Option&lt;String&gt; {
        match self.books.pop() {
            Some(book) =&gt; Some(book + &quot; is found!&quot;), // Rust allows String + &amp;str
            None =&gt; None,
        }
    }
}

fn main() {
    let mut my_library = Library::new();
    my_library.add_book(&quot;The Doom of the Darksword&quot;);
    my_library.add_book(&quot;Demian - die Geschichte einer Jugend&quot;);
    my_library.add_book(&quot;구운몽&quot;);
    my_library.add_book(&quot;吾輩は貓である&quot;);

    for item in my_library.clone() { // we can use a for loop now. Give it a clone so Library won't be destroyed
        println!(&quot;{}&quot;, item);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">吾輩は貓である is found!
구운몽 is found!
Demian - die Geschichte einer Jugend is found!
The Doom of the Darksword is found!
</code></pre>
<h2 id="閉包-1"><a class="header" href="#閉包-1">閉包</a></h2>
<p>閉包就像快速函數，不需要名字。有時它們被稱為lambda。Closures很容易辨識，因為它們使用<code>||</code>而不是<code>()</code>。它們在 Rust 中非常常見，一旦你學會了使用它們，你就會愛不釋手。</p>
<p>你可以將一個閉包綁定到一個變量上，然後當你使用它時，它看起來就像一個函數一樣。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || println!(&quot;This is a closure&quot;);
    my_closure();
}
</code></pre></pre>
<p>所以這個閉包什麼都不需要:<code>||</code>，並打印一條信息。<code>This is a closure</code>.</p>
<p>在<code>||</code>之間我們可以添加輸入變量和類型，就像在<code>()</code>裡面添加函數一樣。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = |x: i32| println!(&quot;{}&quot;, x);

    my_closure(5);
    my_closure(5+5);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">5
10
</code></pre>
<p>當閉包變得更復雜時，你可以添加一個代碼塊。那就可以隨心所欲的長。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || {
        let number = 7;
        let other_number = 10;
        println!(&quot;The two numbers are {} and {}.&quot;, number, other_number);
          // This closure can be as long as we want, just like a function.
    };

    my_closure();
}
</code></pre></pre>
<p>但是閉包是特殊的，因為它可以接受閉包之外的變量，即使你只寫<code>||</code>。所以你可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = || println!(&quot;{}&quot;, number_one + number_two);
    my_closure();
}
</code></pre></pre>
<p>所以這就打印出了<code>16</code>。你不需要在 <code>||</code> 中放入任何東西，因為它可以直接取 <code>number_one</code> 和 <code>number_two</code> 並添加它們。</p>
<p>順便說一下，這就是<strong>closure</strong>這個名字的由來，因為它們會取變量並將它們 &quot;包圍&quot;在裡面。如果你想很正確的說。</p>
<ul>
<li>一個<code>||</code>如果不把變量從外面包圍起來 那就是一個 &quot;匿名函數&quot;. 匿名的意思是 &quot;沒有名字&quot;。它的工作原理更像一個普通函數。</li>
<li><code>||</code> 從外部包圍變量的函數是 &quot;closure&quot;。它把周圍的變量 &quot;封閉&quot;起來使用。</li>
</ul>
<p>但是人們經常會把所有的<code>||</code>函數都叫做閉包，所以你不用擔心名字的問題。我們只對任何帶有<code>||</code>的函數說 &quot;closure&quot;，但請記住，它可能意味著一個 &quot;匿名函數&quot;。</p>
<p>為什麼要知道這兩者的區別呢？因為匿名函數其實和有名字的函數做的機器代碼是一樣的。它們給人的感覺是 &quot;高層抽象&quot;，所以有時候大家會覺得機器代碼會很複雜。但是Rust用它生成的機器碼和普通函數一樣快。</p>
<p>所以我們再來看看閉包能做的一些事情。你也可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = |x: i32| println!(&quot;{}&quot;, number_one + number_two + x);
    my_closure(5);
}
</code></pre></pre>
<p>這個閉包取<code>number_one</code>和<code>number_two</code>。我們還給了它一個新的變量 <code>x</code>，並說 <code>x</code> 是 5.然後它把這三個加在一起打印 <code>21</code>。</p>
<p>通常在Rust中，你會在一個方法裡面看到閉包，因為裡面有一個閉包是非常方便的。我們在上一節的 <code>.map()</code> 和 <code>.for_each()</code> 中看到了閉包。在那一節中，我們寫了 <code>|x|</code> 來引入迭代器中的下一個元素，這就是一個閉包。</p>
<p>下面再舉一個例子:我們知道，如果<code>unwrap</code>不起作用，可以用<code>unwrap_or</code>方法給出一個值。之前我們寫的是:<code>let fourth = my_vec.get(3).unwrap_or(&amp;0);</code>。但是還有一個<code>unwrap_or_else</code>方法，裡面有一個閉包。所以你可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or_else(|| { // try to unwrap. If it doesn't work,
        if my_vec.get(0).is_some() {               // see if my_vec has something at index [0]
            &amp;my_vec[0]                             // Give the number at index 0 if there is something
        } else {
            &amp;0 // otherwise give a &amp;0
        }
    });

    println!(&quot;{}&quot;, fourth);
}
</code></pre></pre>
<p>當然，閉包也可以很簡單。例如，你可以只寫<code>let fourth = my_vec.get(3).unwrap_or_else(|| &amp;0);</code>。你不需要總是因為有一個閉包就使用<code>{}</code>並寫出複雜的代碼。只要你把<code>||</code>放進去，編譯器就知道你放了你需要的閉包。</p>
<p>最常用的閉包方法可能是<code>.map()</code>。我們再來看看它。下面是一種使用方法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec        // take num_vec
        .iter()                     // iterate over it
        .map(|number| number * 2)   // for each item, multiply by two
        .collect::&lt;Vec&lt;i32&gt;&gt;();     // then make a new Vec from this
    println!(&quot;{:?}&quot;, double_vec);
}
</code></pre></pre>
<p>另一個很好的例子是在<code>.enumerate()</code>之後使用<code>.for_each()</code>。<code>.enumerate()</code>方法給出一個帶有索引號和元素的迭代器。例如:<code>[10, 9, 8]</code>變成<code>(0, 10), (1, 9), (2, 8)</code>。這裡每個項的類型是<code>(usize, i32)</code>。所以你可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()      // iterate over num_vec
        .enumerate() // get (index, number)
        .for_each(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number)); // do something for each one
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">Index number 0 has number 10
Index number 1 has number 9
Index number 2 has number 8
</code></pre>
<p>在這種情況下，我們用<code>for_each</code>代替<code>map</code>。<code>map</code>是用於對<strong>每個元素做一些事情，並將其傳遞出去，而<code>for_each</code>是當你看到每個元素</strong>時做一些事情。另外，<code>map</code>不做任何事情，除非你使用<code>collect</code>這樣的方法。</p>
<p>其實，這就是迭代器的有趣之處。如果你嘗試<code>map</code>而不使用<code>collect</code>這樣的方法，編譯器會告訴你，它什麼也不做。它不會崩潰，但編譯器會告訴你，你什麼都沒做。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()
        .enumerate()
        .map(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number));

}
</code></pre></pre>
<p>它說:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` that must be used
 --&gt; src\main.rs:4:5
  |
4 | /     num_vec
5 | |         .iter()
6 | |         .enumerate()
7 | |         .map(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number));
  | |_________________________________________________________________________________________^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
</code></pre>
<p>這是一個<strong>警告</strong>，所以這不是一個錯誤:程序運行正常。但是為什麼num_vec沒有任何作用呢？我們可以看看類型就知道了。</p>
<ul>
<li>
<p><code>let num_vec = vec![10, 9, 8];</code> 現在是一個<code>Vec&lt;i32&gt;</code>。</p>
</li>
<li>
<p><code>.iter()</code> 現在是一個 <code>Iter&lt;i32&gt;</code>。所以它是一個迭代器，其元素為 <code>i32</code>。</p>
</li>
<li>
<p><code>.enumerate()</code>現在是一個<code>Enumerate&lt;Iter&lt;i32&gt;&gt;</code>型。所以它是<code>Enumerate</code>型的<code>Iter</code>型的<code>i32</code>。</p>
</li>
<li>
<p><code>.map()</code>現在是一個<code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>的類型。所以它是一個類型<code>Map</code>的類型<code>Enumerate</code>的類型<code>Iter</code>的類型<code>i32</code>。</p>
</li>
</ul>
<p>我們所做的只是做了一個越來越複雜的結構。所以這個<code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>是一個準備好了的結構，但只有當我們告訴它要做什麼的時候，它才會去做。Rust這樣做是因為它需要保證足夠快。它不想這樣做:</p>
<ul>
<li>遍歷Vec中所有的<code>i32</code></li>
<li>然後從迭代器中枚舉出所有的<code>i32</code></li>
<li>然後將所有列舉的<code>i32</code>映射過來</li>
</ul>
<p>Rust 只想做一次計算，所以它創建結構並等待。然後，如果我們說<code>.collect::&lt;Vec&lt;i32&gt;&gt;()</code>，它知道該怎麼做，並開始移動。這就是<code>iterators are lazy and do nothing unless consumed</code>的意思。迭代器在你 &quot;消耗&quot;它們(用完它們)之前不會做任何事情。</p>
<p>你甚至可以用<code>.collect()</code>創建像<code>HashMap</code>這樣複雜的東西，所以它非常強大。下面是一個如何將兩個向量放入<code>HashMap</code>的例子。首先我們把兩個向量創建出來，然後我們會對它們使用<code>.into_iter()</code>來得到一個值的迭代器。然後我們使用<code>.zip()</code>方法。這個方法將兩個迭代器連接在一起，就像拉鍊一樣。最後，我們使用<code>.collect()</code>來創建<code>HashMap</code>。</p>
<p>下面是代碼。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // a Vec&lt;i32&gt;
    let some_words = vec![&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]; // a Vec&lt;&amp;str&gt;

    let number_word_hashmap = some_numbers
        .into_iter()                 // now it is an iter
        .zip(some_words.into_iter()) // inside .zip() we put in the other iter. Now they are together.
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();

    println!(&quot;For key {} we get {}.&quot;, 2, number_word_hashmap.get(&amp;2).unwrap());
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">For key 2 we get two.
</code></pre>
<p>你可以看到，我們寫了 <code>&lt;HashMap&lt;_, _&gt;&gt;</code>，因為這足以讓 Rust 決定 <code>HashMap&lt;i32, &amp;str&gt;</code> 的類型。如果你想寫 <code>.collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();</code>也行，也可以這樣寫:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // a Vec&lt;i32&gt;
    let some_words = vec![&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]; // a Vec&lt;&amp;str&gt;
    let number_word_hashmap: HashMap&lt;_, _&gt; = some_numbers  // Because we tell it the type here...
        .into_iter()
        .zip(some_words.into_iter())
        .collect(); // we don't have to tell it here
}
</code></pre></pre>
<p>還有一種方法，就像<code>.enumerate()</code>的<code>char</code>。<code>char_indices()</code>. (Indices的意思是 &quot;索引&quot;)。你用它的方法是一樣的。假設我們有一個由3位數組成的大字符串。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers_together = &quot;140399923481800622623218009598281&quot;;

    for (index, number) in numbers_together.char_indices() {
        match (index % 3, number) {
            (0..=1, number) =&gt; print!(&quot;{}&quot;, number), // just print the number if there is a remainder
            _ =&gt; print!(&quot;{}\t&quot;, number), // otherwise print the number with a tab space
        }
    }
}
</code></pre></pre>
<p>打印<code>140     399     923     481     800     622     623     218     009     598    281</code>。</p>
<h3 id="閉包中的_"><a class="header" href="#閉包中的_">閉包中的|_|</a></h3>
<p>有時你會在一個閉包中看到 <code>|_|</code>。這意味著這個閉包需要一個參數(比如 <code>x</code>)，但你不想使用它。所以 <code>|_|</code> 意味著 &quot;好吧，這個閉包需要一個參數，但我不會給它一個名字，因為我不關心它&quot;。</p>
<p>下面是一個錯誤的例子，當你不這樣做的時候。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    println!(&quot;{:?}&quot;, my_vec.iter().for_each(|| println!(&quot;We didn't use the variables at all&quot;))); // ⚠️
}
</code></pre></pre>
<p>Rust說</p>
<pre><code class="language-text">error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments
  --&gt; src\main.rs:28:36
   |
28 |     println!(&quot;{:?}&quot;, my_vec.iter().for_each(|| println!(&quot;We didn't use the variables at all&quot;)));
   |                                    ^^^^^^^^ -- takes 0 arguments
   |                                    |
   |                                    expected closure that takes 1 argument
</code></pre>
<p>編譯器其實給你一些幫助。</p>
<pre><code class="language-text">help: consider changing the closure to take and ignore the expected argument
   |
28 |     println!(&quot;{:?}&quot;, my_vec.iter().for_each(|_| println!(&quot;We didn't use the variables at all&quot;)));
</code></pre>
<p>這是很好的建議。如果你把<code>||</code>改成<code>|_|</code>就可以了。</p>
<h3 id="閉包和迭代器的有用方法"><a class="header" href="#閉包和迭代器的有用方法">閉包和迭代器的有用方法</a></h3>
<p>一旦你熟悉了閉包，Rust就會成為一種非常有趣的語言。有了閉包，你可以將方法互相<em>鏈接</em>起來，用很少的代碼做很多事情。下面是一些我們還沒有見過的閉包和使用閉包的方法。</p>
<p><code>.filter()</code>: 這可以讓你在迭代器中保留你想保留的元素。讓我們過濾一年中的月份。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let months = vec![&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];

    let filtered_months = months
        .into_iter()                         // make an iter
        .filter(|month| month.len() &lt; 5)     // We don't want months more than 5 bytes in length.
                                             // We know that each letter is one byte so .len() is fine
        .filter(|month| month.contains(&quot;u&quot;)) // Also we only like months with the letter u
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

    println!(&quot;{:?}&quot;, filtered_months);
}
</code></pre></pre>
<p>這個打印<code>[&quot;June&quot;, &quot;July&quot;]</code>。</p>
<p><code>.filter_map()</code>. 這個叫做<code>filter_map()</code>，因為它做了<code>.filter()</code>和<code>.map()</code>。閉包必須返回一個 <code>Option&lt;T&gt;</code>，然後對每個<code>Option</code>, 如果是 <code>Some</code>, <code>filter_map()</code>將取出它的值。所以比如說你<code>.filter_map()</code>一個<code>vec![Some(2), None, Some(3)]</code>，它就會返回<code>[2, 3]</code>。</p>
<p>我們將用一個<code>Company</code>結構體來寫一個例子。每個公司都有一個<code>name</code>，所以這個字段是<code>String</code>，但是CEO可能最近已經辭職了。所以<code>ceo</code>字段是<code>Option&lt;String&gt;</code>。我們會<code>.filter_map()</code>過一些公司，只保留CEO名字。</p>
<pre><pre class="playground"><code class="language-rust">struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            name =&gt; Some(name.to_string()),
        }; // ceo is decided, so now we return Self
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone() // Just returns a clone of the CEO (struct is not Copy)
    }
}

fn main() {
    let company_vec = vec![
        Company::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Company::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Company::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Company::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let all_the_ceos = company_vec
        .into_iter()
        .filter_map(|company| company.get_ceo()) // filter_map needs Option&lt;T&gt;
        .collect::&lt;Vec&lt;String&gt;&gt;();

    println!(&quot;{:?}&quot;, all_the_ceos);
}
</code></pre></pre>
<p>這就打印出了<code>[&quot;Unknown&quot;, &quot;Doug Suttles&quot;]</code>。</p>
<p>既然 <code>.filter_map()</code> 需要 <code>Option</code>，那麼 <code>Result</code> 呢？沒問題:有一個叫做 <code>.ok()</code> 的方法，可以把 <code>Result</code> 變成 <code>Option</code>。之所以叫<code>.ok()</code>，是因為它能發送的只是<code>Ok</code>的結果(<code>Err</code>的信息沒有了)。你記得<code>Option</code>是<code>Option&lt;T&gt;</code>，而<code>Result</code>是<code>Result&lt;T, E&gt;</code>，同時有<code>Ok</code>和<code>Err</code>的信息。所以當你使用<code>.ok()</code>時，任何<code>Err</code>的信息都會丟失，變成<code>None</code>。</p>
<p>使用 <code>.parse()</code> 是一個很簡單的例子，我們嘗試解析一些用戶輸入。<code>.parse()</code>在這裡接受一個<code>&amp;str</code>，並試圖把它變成一個<code>f32</code>。它返回一個 <code>Result</code>，但我們使用的是 <code>filter_map()</code>，所以我們只需拋出錯誤。<code>Err</code>的任何內容都會變成<code>None</code>，並被<code>.filter_map()</code>過濾掉。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let user_input = vec![&quot;8.9&quot;, &quot;Nine point nine five&quot;, &quot;8.0&quot;, &quot;7.6&quot;, &quot;eleventy-twelve&quot;];

    let actual_numbers = user_input
        .into_iter()
        .filter_map(|input| input.parse::&lt;f32&gt;().ok())
        .collect::&lt;Vec&lt;f32&gt;&gt;();

    println!(&quot;{:?}&quot;, actual_numbers);
}
</code></pre></pre>
<p>將打印: <code>[8.9, 8.0, 7.6]</code>。</p>
<p>與<code>.ok()</code>相對的是<code>.ok_or()</code>和<code>ok_or_else()</code>。這樣就把<code>Option</code>變成了<code>Result</code>。之所以叫<code>.ok_or()</code>，是因為<code>Result</code>給出了一個<code>Ok</code><strong>或</strong><code>Err</code>，所以你必須讓它知道<code>Err</code>的值是多少。這是因為<code>None</code>中的<code>Option</code>沒有任何信息。另外，你現在可以看到，這些方法名稱中的<em>else</em>部分意味著它有一個閉包。</p>
<p>我們可以把我們的<code>Option</code>從<code>Company</code>結構中取出來，然後這樣把它變成一個<code>Result</code>。對於長期的錯誤處理，最好是創建自己的錯誤類型。
但是現在我們只是給它一個錯誤信息，所以它就變成了<code>Result&lt;String, &amp;str&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">// Everything before main() is exactly the same
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Company::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Company::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Company::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let mut results_vec = vec![]; // Pretend we need to gather error results too

    company_vec
        .iter()
        .for_each(|company| results_vec.push(company.get_ceo().ok_or(&quot;No CEO found&quot;)));

    for item in results_vec {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>這行是最大的變化:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
.for_each(|company| results_vec.push(company.get_ceo().ok_or(&quot;No CEO found&quot;)));
<span class="boring">}
</span></code></pre></pre>
<p>它的意思是:&quot;每家公司，用<code>get_ceo()</code>. 如果你得到了，那就把<code>Ok</code>裡面的數值傳給你。如果沒有，就在<code>Err</code>裡面傳遞 &quot;沒有找到CEO&quot;。然後把這個推到vec裡。&quot;</p>
<p>所以當我們打印<code>results_vec</code>的時候，就會得到這樣的結果。</p>
<pre><code class="language-text">Ok(&quot;Unknown&quot;)
Ok(&quot;Doug Suttles&quot;)
Err(&quot;No CEO found&quot;)
Err(&quot;No CEO found&quot;)
</code></pre>
<p>所以現在我們有了所有四個條目。現在讓我們使用 <code>.ok_or_else()</code>，這樣我們就可以使用一個閉包，並得到一個更好的錯誤信息。現在我們有空間使用<code>format!</code>來創建一個<code>String</code>，並將公司名稱放在其中。然後我們返回<code>String</code>。</p>
<pre><pre class="playground"><code class="language-rust">// Everything before main() is exactly the same
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Company::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Company::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Company::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let mut results_vec = vec![];

    company_vec.iter().for_each(|company| {
        results_vec.push(company.get_ceo().ok_or_else(|| {
            let err_message = format!(&quot;No CEO found for {}&quot;, company.name);
            err_message
        }))
    });

    for item in results_vec {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>這樣一來，我們就有了。</p>
<pre><code class="language-text">Ok(&quot;Unknown&quot;)
Ok(&quot;Doug Suttles&quot;)
Err(&quot;No CEO found for The Red-Headed League&quot;)
Err(&quot;No CEO found for Stark Enterprises&quot;)
</code></pre>
<p><code>.and_then()</code>是一個有用的方法，它接收一個<code>Option</code>，然後讓你對它的值做一些事情，並把它傳遞出去。所以它的輸入是一個 <code>Option</code>，輸出也是一個 <code>Option</code>。這有點像一個安全的 &quot;解包，然後做一些事情，然後再包&quot;。</p>
<p>一個簡單的例子是，我們使用 <code>.get()</code> 從一個 vec 中得到一個數字，因為它返回一個 <code>Option</code>。現在我們可以把它傳給 <code>and_then()</code>，如果它是 <code>Some</code>，我們可以對它做一些數學運算。如果是<code>None</code>，那麼<code>None</code>就會被傳遞過去。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 0]; // just a vec with numbers

    let number_to_add = 5;       // use this in the math later
    let mut empty_vec = vec![];  // results go in here


    for index in 0..5 {
        empty_vec.push(
            new_vec
               .get(index)
                .and_then(|number| Some(number + 1))
                .and_then(|number| Some(number + number_to_add))
        );
    }
    println!(&quot;{:?}&quot;, empty_vec);
}
</code></pre></pre>
<p>這就打印出了<code>[Some(14), Some(15), Some(6), None, None]</code>。你可以看到<code>None</code>並沒有被過濾掉，只是傳遞了。</p>
<p><code>.and()</code>有點像<code>Option</code>的<code>bool</code>。你可以匹配很多個<code>Option</code>，如果它們都是<code>Some</code>，那麼它會給出最後一個。而如果其中一個是<code>None</code>，那麼就會給出<code>None</code>。</p>
<p>首先這裡有一個<code>bool</code>的例子來幫助想象。你可以看到，如果你用的是<code>&amp;&amp;</code>(和)，哪怕是一個<code>false</code>，也會讓一切<code>false</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let one = true;
    let two = false;
    let three = true;
    let four = true;

    println!(&quot;{}&quot;, one &amp;&amp; three); // prints true
    println!(&quot;{}&quot;, one &amp;&amp; two &amp;&amp; three &amp;&amp; four); // prints false
}
</code></pre></pre>
<p>現在這裡的<code>.and()</code>也是一樣的。想象一下，我們做了五次操作，並把結果放在一個Vec&lt;Option&lt;&amp;str&gt;&gt;中。如果我們得到一個值，我們就把<code>Some(&quot;success!&quot;)</code>推到Vec中。然後我們再做兩次這樣的操作。之後我們用<code>.and()</code>每次只顯示得到<code>Some</code>的索引。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_try = vec![Some(&quot;success!&quot;), None, Some(&quot;success!&quot;), Some(&quot;success!&quot;), None];
    let second_try = vec![None, Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;)];
    let third_try = vec![Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;), None];

    for i in 0..first_try.len() {
        println!(&quot;{:?}&quot;, first_try[i].and(second_try[i]).and(third_try[i]));
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">None
None
Some(&quot;success!&quot;)
Some(&quot;success!&quot;)
None
</code></pre>
<p>第一個(索引0)是<code>None</code>，因為在<code>second_try</code>中有一個<code>None</code>為索引0。第二個是<code>None</code>，因為在<code>first_try</code>中有一個<code>None</code>。其次是<code>Some(&quot;success!&quot;)</code>，因為<code>first_try</code>、<code>second try</code>、<code>third_try</code>中沒有<code>None</code>。</p>
<p><code>.any()</code>和<code>.all()</code>在迭代器中非常容易使用。它們根據你的輸入返回一個<code>bool</code>。在這個例子中，我們做了一個非常大的vec(大約20000個元素)，包含了從<code>'a'</code>到<code>'働'</code>的所有字符。然後我們創建一個函數來檢查是否有字符在其中。</p>
<p>接下來我們創建一個更小的vec，問它是否都是字母(用<code>.is_alphabetic()</code>方法)。然後我們問它是不是所有的字符都小於韓文字符<code>'행'</code>。</p>
<p>還要注意放一個參照物，因為<code>.iter()</code>給了一個參照物，你需要一個<code>&amp;</code>和另一個<code>&amp;</code>進行比較。</p>
<pre><pre class="playground"><code class="language-rust">fn in_char_vec(char_vec: &amp;Vec&lt;char&gt;, check: char) {
    println!(&quot;Is {} inside? {}&quot;, check, char_vec.iter().any(|&amp;char| char == check));
}

fn main() {
    let char_vec = ('a'..'働').collect::&lt;Vec&lt;char&gt;&gt;();
    in_char_vec(&amp;char_vec, 'i');
    in_char_vec(&amp;char_vec, '뷁');
    in_char_vec(&amp;char_vec, '鑿');

    let smaller_vec = ('A'..'z').collect::&lt;Vec&lt;char&gt;&gt;();
    println!(&quot;All alphabetic? {}&quot;, smaller_vec.iter().all(|&amp;x| x.is_alphabetic()));
    println!(&quot;All less than the character 행? {}&quot;, smaller_vec.iter().all(|&amp;x| x &lt; '행'));
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Is i inside? true
Is 뷁 inside? false
Is 鑿 inside? false
All alphabetic? false
All less than the character 행? true
</code></pre>
<p>順便說一下，<code>.any()</code>只檢查到一個匹配的元素，然後就停止了。如果它已經找到了一個匹配項，它不會檢查所有的元素。如果您要在 <code>Vec</code> 上使用 <code>.any()</code>，最好把可能匹配的元素推到前面。或者你可以在 <code>.iter()</code> 之後使用 <code>.rev()</code> 來反向迭代。這裡有一個這樣的vec。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);
}
</code></pre></pre>
<p>所以這個<code>Vec</code>有1000個<code>6</code>，後面還有一個<code>5</code>。我們假設我們要用<code>.any()</code>來看看它是否包含5。首先讓我們確定<code>.rev()</code>是有效的。記住，一個<code>Iterator</code>總是有<code>.next()</code>，讓你每次都檢查它的工作。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut iterator = big_vec.iter().rev();
    println!(&quot;{:?}&quot;, iterator.next());
    println!(&quot;{:?}&quot;, iterator.next());
}
</code></pre></pre>
<p>它的打印。</p>
<pre><code class="language-text">Some(5)
Some(6)
</code></pre>
<p>我們是對的:有一個<code>Some(5)</code>，然後1000個<code>Some(6)</code>開始。所以我們可以這樣寫。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    println!(&quot;{:?}&quot;, big_vec.iter().rev().any(|&amp;number| number == 5));
}
</code></pre></pre>
<p>而且因為是<code>.rev()</code>，所以它只調用<code>.next()</code>一次就停止了。如果我們不用<code>.rev()</code>，那麼它將調用<code>.next()</code> 1001次才停止。這段代碼顯示了它。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut counter = 0; // Start counting
    let mut big_iter = big_vec.into_iter(); // Make it an Iterator

    loop {
        counter +=1;
        if big_iter.next() == Some(5) { // Keep calling .next() until we get Some(5)
            break;
        }
    }
    println!(&quot;Final counter is: {}&quot;, counter);
}
</code></pre></pre>
<p>這將打印出 <code>Final counter is: 1001</code>，所以我們知道它必須調用 <code>.next()</code> 1001 次才能找到 5。</p>
<p><code>.find()</code> 告訴你一個迭代器是否有東西，而 <code>.position()</code> 告訴你它在哪裡。<code>.find()</code>與<code>.any()</code>不同，因為它返回一個<code>Option</code>，裡面有值(或<code>None</code>)。同時，<code>.position()</code>也是一個帶有位置號的<code>Option</code>，或<code>None</code>。換句話說</p>
<ul>
<li><code>.find()</code>: &quot;我儘量幫你拿&quot;</li>
<li><code>.position()</code>:&quot;我幫你找找看在哪裡&quot;</li>
</ul>
<p>下面是一個簡單的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    println!(&quot;{:?}&quot;, num_vec.iter().find(|&amp;number| number % 3 == 0)); // find takes a reference, so we give it &amp;number
    println!(&quot;{:?}&quot;, num_vec.iter().find(|&amp;number| number * 2 == 30));

    println!(&quot;{:?}&quot;, num_vec.iter().position(|&amp;number| number % 3 == 0));
    println!(&quot;{:?}&quot;, num_vec.iter().position(|&amp;number| number * 2 == 30));

}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Some(30) // This is the number itself
None // No number inside times 2 == 30
Some(2) // This is the position
None
</code></pre>
<p>使用 <code>.cycle()</code> 你可以創建一個永遠循環的迭代器。這種類型的迭代器與 <code>.zip()</code> 很好地結合在一起，可以創建新的東西，就像這個例子，它創建了一個 <code>Vec&lt;(i32, &amp;str)&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let even_odd = vec![&quot;even&quot;, &quot;odd&quot;];

    let even_odd_vec = (0..6)
        .zip(even_odd.into_iter().cycle())
        .collect::&lt;Vec&lt;(i32, &amp;str)&gt;&gt;();
    println!(&quot;{:?}&quot;, even_odd_vec);
}
</code></pre></pre>
<p>所以，即使<code>.cycle()</code>可能永遠不會結束，但當把它們壓縮在一起時，另一個迭代器只運行了6次。
也就是說，<code>.cycle()</code>所做的迭代器不會再被<code>.next()</code>調用，所以六次之後就完成了。輸出的結果是</p>
<pre><code>[(0, &quot;even&quot;), (1, &quot;odd&quot;), (2, &quot;even&quot;), (3, &quot;odd&quot;), (4, &quot;even&quot;), (5, &quot;odd&quot;)]
</code></pre>
<p>類似的事情也可以用一個沒有結尾的範圍來完成。如果你寫<code>0..</code>，那麼你就創建了一個永不停止的範圍。你可以很容易地使用這個方法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ten_chars = ('a'..).take(10).collect::&lt;Vec&lt;char&gt;&gt;();
    let skip_then_ten_chars = ('a'..).skip(1300).take(10).collect::&lt;Vec&lt;char&gt;&gt;();

    println!(&quot;{:?}&quot;, ten_chars);
    println!(&quot;{:?}&quot;, skip_then_ten_chars);
}
</code></pre></pre>
<p>兩者都是打印十個字符，但第二個跳過1300位，打印的是亞美尼亞語的十個字母。</p>
<pre><code>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
['յ', 'ն', 'շ', 'ո', 'չ', 'պ', 'ջ', 'ռ', 'ս', 'վ']
</code></pre>
<p>另一種流行的方法叫做<code>.fold()</code>。這個方法經常用於將迭代器中的元素加在一起，但你也可以做更多的事情。它與<code>.for_each()</code>有些類似。在 <code>.fold()</code> 中，你首先添加一個起始值 (如果你是把元素加在一起，那麼就是 0)，然後是一個逗號，然後是閉包。結尾給你兩個元素:到目前為止的總數，和下一個元素。首先這裡有一個簡單的例子，顯示<code>.fold()</code>將元素加在一起。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_numbers = vec![9, 6, 9, 10, 11];

    println!(&quot;{}&quot;, some_numbers
        .iter()
        .fold(0, |total_so_far, next_number| total_so_far + next_number)
    );
}
</code></pre></pre>
<p>所以，在第1步中，它從0開始，再加上下一個數字:9。</p>
<ul>
<li>第1步，從0開始，加上下一個數字9</li>
<li>然後把9加上6: 15。</li>
<li>然後把15加上9: 24。</li>
<li>然後取24，再加上10: 34。</li>
<li>最後取34，再加上11: 45。所以它的打印結果是<code>45</code>.</li>
</ul>
<p>但是你不需要只用它來添加東西。下面是一個例子，我們在每一個字符上加一個'-'，就會變成<code>String</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a_string = &quot;I don't have any dashes in me.&quot;;

    println!(
        &quot;{}&quot;,
        a_string
            .chars() // Now it's an iterator
            .fold(&quot;-&quot;.to_string(), |mut string_so_far, next_char| { // Start with a String &quot;-&quot;. Bring it in as mutable each time along with the next char
                string_so_far.push(next_char); // Push the char on, then '-'
                string_so_far.push('-');
                string_so_far} // Don't forget to pass it on to the next loop
            ));
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">-I- -d-o-n-'-t- -h-a-v-e- -a-n-y- -d-a-s-h-e-s- -i-n- -m-e-.-
</code></pre>
<p>還有很多其他方便的方法，比如</p>
<ul>
<li><code>.take_while()</code>，只要得到<code>true</code>，就會帶入一個迭代器(例如<code>take while x &gt; 5</code>)</li>
<li><code>.cloned()</code>，它在迭代器內做了一個克隆。這將一個引用變成了一個值。</li>
<li><code>.by_ref()</code>，它使迭代器取一個引用。這很好的保證了你使用<code>Vec</code>或類似的方法來創建迭代器後可以使用它。</li>
<li>許多其他的<code>_while</code>方法:<code>.skip_while()</code>、<code>.map_while()</code>等等。</li>
<li><code>.sum()</code>:就是把所有的東西加在一起。</li>
</ul>
<p><code>.chunks()</code>和<code>.windows()</code>是將矢量切割成你想要的尺寸的兩種方法。你把你想要的尺寸放在括號裡。比如說你有一個有10個元素的矢量，你想要一個3的尺寸，它的工作原理是這樣的。</p>
<ul>
<li>
<p><code>.chunks()</code>會給你4個切片: [0, 1, 2], 然後是[3, 4, 5], 然後是[6, 7, 8], 最後是[9]. 所以它會嘗試用三個元素創建一個切片，但如果它沒有三個元素，那麼它就不會崩潰。它只會給你剩下的東西。</p>
</li>
<li>
<p><code>.windows()</code>會先給你一個[0, 1, 2]的切片。然後它將移過一片，給你[1, 2, 3]。它將一直這樣做，直到最後到達3的最後一片，然後停止。</p>
</li>
</ul>
<p>所以讓我們在一個簡單的數字向量上使用它們。它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

    for chunk in num_vec.chunks(3) {
        println!(&quot;{:?}&quot;, chunk);
    }
    println!();
    for window in num_vec.windows(3) {
        println!(&quot;{:?}&quot;, window);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[0]

[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 0]
</code></pre>
<p>順便說一下，如果你什麼都不給它，<code>.chunks()</code>會崩潰。你可以為一個只有一項的向量寫<code>.chunks(1000)</code>，但你不能為任何長度為0的東西寫<code>.chunks()</code>。 如果你點擊[src]，你可以在函數中看到這一點，因為它說<code>assert!(chunk_size != 0);</code>。</p>
<p><code>.match_indices()</code> 讓你把 <code>String</code> 或 <code>&amp;str</code> 裡面所有符合你的輸入的東西都提取出來，並給你索引。它與 <code>.enumerate()</code> 類似，因為它返回一個包含兩個元素的元組。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rules = &quot;Rule number 1: No fighting. Rule number 2: Go to bed at 8 pm. Rule number 3: Wake up at 6 am.&quot;;
    let rule_locations = rules.match_indices(&quot;Rule&quot;).collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // This is Vec&lt;usize, &amp;str&gt; but we just tell Rust to do it
    println!(&quot;{:?}&quot;, rule_locations);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">[(0, &quot;Rule&quot;), (28, &quot;Rule&quot;), (62, &quot;Rule&quot;)]
</code></pre>
<p><code>.peekable()</code> 讓你創建一個迭代器，在那裡你可以看到 (窺視) 下一個元素。它就像調用 <code>.next()</code> (它給出了一個 <code>Option</code>)，除了迭代器不會移動，所以你可以隨意使用它。實際上，你可以把peekable看成是 &quot;可停止&quot;的，因為你可以想停多久就停多久。下面是一個例子，我們對每個元素都使用<code>.peek()</code>三次。我們可以永遠使用<code>.peek()</code>，直到我們使用<code>.next()</code>移動到下一個元素。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let just_numbers = vec![1, 5, 100];
    let mut number_iter = just_numbers.iter().peekable(); // This actually creates a type of iterator called Peekable

    for _ in 0..3 {
        println!(&quot;I love the number {}&quot;, number_iter.peek().unwrap());
        println!(&quot;I really love the number {}&quot;, number_iter.peek().unwrap());
        println!(&quot;{} is such a nice number&quot;, number_iter.peek().unwrap());
        number_iter.next();
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">I love the number 1
I really love the number 1
1 is such a nice number
I love the number 5
I really love the number 5
5 is such a nice number
I love the number 100
I really love the number 100
100 is such a nice number
</code></pre>
<p>下面是另一個例子，我們使用<code>.peek()</code>對一個元素進行匹配。使用完後，我們調用<code>.next()</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let locations = vec![
        (&quot;Nevis&quot;, 25),
        (&quot;Taber&quot;, 8428),
        (&quot;Markerville&quot;, 45),
        (&quot;Cardston&quot;, 3585),
    ];
    let mut location_iter = locations.iter().peekable();
    while location_iter.peek().is_some() {
        match location_iter.peek() {
            Some((name, number)) if *number &lt; 100 =&gt; { // .peek() gives us a reference so we need *
                println!(&quot;Found a hamlet: {} with {} people&quot;, name, number)
            }
            Some((name, number)) =&gt; println!(&quot;Found a town: {} with {} people&quot;, name, number),
            None =&gt; break,
        }
        location_iter.next();
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Found a hamlet: Nevis with 25 people
Found a town: Taber with 8428 people
Found a hamlet: Markerville with 45 people
Found a town: Cardston with 3585 people
</code></pre>
<p>最後，這裡有一個例子，我們也使用<code>.match_indices()</code>。在這個例子中，我們根據<code>&amp;str</code>中的空格數，將名字放入<code>struct</code>中。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Names {
    one_word: Vec&lt;String&gt;,
    two_words: Vec&lt;String&gt;,
    three_words: Vec&lt;String&gt;,
}

fn main() {
    let vec_of_names = vec![
        &quot;Caesar&quot;,
        &quot;Frodo Baggins&quot;,
        &quot;Bilbo Baggins&quot;,
        &quot;Jean-Luc Picard&quot;,
        &quot;Data&quot;,
        &quot;Rand Al'Thor&quot;,
        &quot;Paul Atreides&quot;,
        &quot;Barack Hussein Obama&quot;,
        &quot;Bill Jefferson Clinton&quot;,
    ];

    let mut iter_of_names = vec_of_names.iter().peekable();

    let mut all_names = Names { // start an empty Names struct
        one_word: vec![],
        two_words: vec![],
        three_words: vec![],
    };

    while iter_of_names.peek().is_some() {
        let next_item = iter_of_names.next().unwrap(); // We can use .unwrap() because we know it is Some
        match next_item.match_indices(' ').collect::&lt;Vec&lt;_&gt;&gt;().len() { // Create a quick vec using .match_indices and check the length
            0 =&gt; all_names.one_word.push(next_item.to_string()),
            1 =&gt; all_names.two_words.push(next_item.to_string()),
            _ =&gt; all_names.three_words.push(next_item.to_string()),
        }
    }

    println!(&quot;{:?}&quot;, all_names);
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">Names { one_word: [&quot;Caesar&quot;, &quot;Data&quot;], two_words: [&quot;Frodo Baggins&quot;, &quot;Bilbo Baggins&quot;, &quot;Jean-Luc Picard&quot;, &quot;Rand Al\'Thor&quot;, &quot;Paul Atreides&quot;], three_words:
[&quot;Barack Hussein Obama&quot;, &quot;Bill Jefferson Clinton&quot;] }
</code></pre>
<h2 id="dbg-宏和inspect"><a class="header" href="#dbg-宏和inspect">dbg! 宏和.inspect</a></h2>
<p><code>dbg!</code>是一個非常有用的宏，可以快速打印信息。它是 <code>println!</code> 的一個很好的替代品，因為它的輸入速度更快，提供的信息更多。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    dbg!(my_number);
}
</code></pre></pre>
<p>這樣就可以打印出<code>[src\main.rs:4] my_number = 8</code>。</p>
<p>但實際上，你可以把<code>dbg!</code>放在其他很多地方，甚至可以把代碼包在裡面。比如看這段代碼。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 9;
    my_number += 10;

    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>這段代碼創建了一個新的可變數字，並改變了它。然後創建一個vec，並使用<code>iter</code>和<code>map</code>以及<code>collect</code>創建一個新的vec。在這段代碼中，我們幾乎可以把<code>dbg!</code>放在任何地方。<code>dbg!</code>問編譯器：&quot;此刻你在做什麼？&quot;，然後告訴你:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = dbg!(9);
    dbg!(my_number += 10);

    let new_vec = dbg!(vec![8, 9, 10]);

    let double_vec = dbg!(new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());

    dbg!(double_vec);
}
</code></pre></pre>
<p>所以這個打印:</p>
<pre><code class="language-text">[src\main.rs:3] 9 = 9
</code></pre>
<p>和：</p>
<pre><code class="language-text">[src\main.rs:4] my_number += 10 = ()
</code></pre>
<p>和：</p>
<pre><code class="language-text">[src\main.rs:6] vec![8, 9, 10] = [
    8,
    9,
    10,
]
</code></pre>
<p>而這個，甚至可以顯示出表達式的值。</p>
<pre><code class="language-text">[src\main.rs:8] new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;() = [
    16,
    18,
    20,
]
</code></pre>
<p>和：</p>
<pre><code class="language-text">[src\main.rs:10] double_vec = [
    16,
    18,
    20,
]
</code></pre>
<p><code>.inspect</code> 與 <code>dbg!</code> 有點類似，就像在迭代器中使用<code>map</code>一樣使用它。它給了你迭代項，你可以打印它或者做任何你想做的事情。例如，我們再看看我們的 <code>double_vec</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .map(|x| x * 2)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>我們想知道更多關於代碼的信息。所以我們在兩個地方添加<code>inspect()</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .inspect(|first_item| println!(&quot;The item is: {}&quot;, first_item))
        .map(|x| x * 2)
        .inspect(|next_item| println!(&quot;Then it is: {}&quot;, next_item))
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">The item is: 8
Then it is: 16
The item is: 9
Then it is: 18
The item is: 10
Then it is: 20
</code></pre>
<p>而且因為<code>.inspect</code>採取的是封閉式，所以我們可以隨意寫。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .inspect(|first_item| {
            println!(&quot;The item is: {}&quot;, first_item);
            match **first_item % 2 { // first item is a &amp;&amp;i32 so we use **
                0 =&gt; println!(&quot;It is even.&quot;),
                _ =&gt; println!(&quot;It is odd.&quot;),
            }
            println!(&quot;In binary it is {:b}.&quot;, first_item);
        })
        .map(|x| x * 2)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">The item is: 8
It is even.
In binary it is 1000.
The item is: 9
It is odd.
In binary it is 1001.
The item is: 10
It is even.
In binary it is 1010.
</code></pre>
<h2 id="str的類型"><a class="header" href="#str的類型">&amp;str的類型</a></h2>
<p><code>&amp;str</code>的類型不止一種。我們有。</p>
<ul>
<li>字符串： 當你寫<code>let my_str = &quot;I am a &amp;str&quot;</code>的時候，你就會產生這些字符。它們在整個程序中持續存在，因為它們是直接寫進二進制中的，它們的類型是 <code>&amp;'static str</code>。<code>'</code>的意思是它的生命期，字符串字元有一個叫<code>static</code>的生命期。</li>
<li>借用str：這是常規的 <code>&amp;str</code> 形式，沒有 <code>static</code> 生命期。如果你創建了一個<code>String</code>，並得到了它的引用，當你需要它時，Rust會把它轉換為<code>&amp;str</code>。比如說</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_str(my_str: &amp;str) { // it can use &amp;String like a &amp;str
    println!(&quot;{}&quot;, my_str);
}

fn main() {
    let my_string = String::from(&quot;I am a string&quot;);
    prints_str(&amp;my_string); // we give prints_str a &amp;String
}
</code></pre></pre>
<p>那麼什麼是lifetime呢？我們現在就來瞭解一下。</p>
<h2 id="生命期"><a class="header" href="#生命期">生命期</a></h2>
<p>生命期的意思是 &quot;變量的生命期有多長&quot;。你只需要考慮引用的生命期。這是因為引用的生命期不能比它們來自的對象更長。例如，這個函數就不能用。</p>
<pre><pre class="playground"><code class="language-rust">fn returns_reference() -&gt; &amp;str {
    let my_string = String::from(&quot;I am a string&quot;);
    &amp;my_string // ⚠️
}

fn main() {}
</code></pre></pre>
<p>問題是<code>my_string</code>只存在於<code>returns_reference</code>中。我們試圖返回 <code>&amp;my_string</code>，但是 <code>&amp;my_string</code> 不能沒有 <code>my_string</code>。所以編譯器說不行。</p>
<p>這個代碼也不行。</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;str {
    let my_string = String::from(&quot;I am a string&quot;);
    &quot;I am a str&quot; // ⚠️
}

fn main() {
    let my_str = returns_str();
    println!(&quot;{}&quot;, my_str);
}
</code></pre></pre>
<p>但幾乎是成功的。編譯器說:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:6:21
  |
6 | fn returns_str() -&gt; &amp;str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
6 | fn returns_str() -&gt; &amp;'static str {
  |                     ^^^^^^^^
</code></pre>
<p><code>missing lifetime specifier</code>的意思是，我們需要加一個<code>'</code>的生命期。然後說它<code>contains a borrowed value, but there is no value for it to be borrowed from</code>。也就是說，<code>I am a str</code>不是借來的。它寫<code>&amp;'static str</code>就說<code>consider using the 'static lifetime</code>。所以它認為我們應該嘗試說這是一個字符串的文字。</p>
<p>現在它工作了。</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;'static str {
    let my_string = String::from(&quot;I am a string&quot;);
    &quot;I am a str&quot;
}

fn main() {
    let my_str = returns_str();
    println!(&quot;{}&quot;, my_str);
}
</code></pre></pre>
<p>這是因為我們返回了一個 <code>&amp;str</code>，生命期為 <code>static</code>。同時，<code>my_string</code>只能以<code>String</code>的形式返回:我們不能返回對它的引用，因為它將在下一行死亡。</p>
<p>所以現在<code>fn returns_str() -&gt; &amp;'static str</code>告訴Rust， &quot;別擔心，我們只會返回一個字符串字面量&quot;. 字符串字面量在整個程序中都是有效的，所以Rust很高興。你會注意到，這與泛型類似。當我們告訴編譯器類似 <code>&lt;T: Display&gt;</code> 的東西時，我們承諾我們將只使用實現了 <code>Display</code> 的輸入。生命期也類似:我們並沒有改變任何變量的生命期。我們只是告訴編譯器輸入的生命期是多少。</p>
<p>但是<code>'static</code>並不是唯一的生命期。實際上，每個變量都有一個生命期，但通常我們不必寫出來。編譯器很聰明，一般都能自己算出來。只有在編譯器不知道的時候，我們才需要寫出生命期。</p>
<p>下面是另一個生命期的例子。想象一下，我們想創建一個<code>City</code>結構，並給它一個<code>&amp;str</code>的名字。我們可能想這樣做，因為這樣做的性能比用<code>String</code>快。所以我們這樣寫，但還不能用。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: &amp;str, // ⚠️
    date_founded: u32,
}

fn main() {
    let my_city = City {
        name: &quot;Ichinomiya&quot;,
        date_founded: 1921,
    };
}
</code></pre></pre>
<p>編譯器說:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:3:11
  |
3 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 | struct City&lt;'a&gt; {
3 |     name: &amp;'a str,
  |
</code></pre>
<p>Rust 需要 <code>&amp;str</code> 的生命期，因為 <code>&amp;str</code> 是一個引用。如果<code>name</code>指向的值被丟棄了會怎樣？那就不安全了。</p>
<p><code>'static</code>呢，能用嗎？我們以前用過。我們試試吧。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: &amp;'static str, // change &amp;str to &amp;'static str
    date_founded: u32,
}

fn main() {
    let my_city = City {
        name: &quot;Ichinomiya&quot;,
        date_founded: 1921,
    };

    println!(&quot;{} was founded in {}&quot;, my_city.name, my_city.date_founded);
}
</code></pre></pre>
<p>好的，這就可以了。也許這就是你想要的結構。但是，請注意，我們只能接受 &quot;字符串字面量&quot;，所以不能接受對其他東西的引用。所以這將無法工作。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: &amp;'static str, // must live for the whole program
    date_founded: u32,
}

fn main() {
    let city_names = vec![&quot;Ichinomiya&quot;.to_string(), &quot;Kurume&quot;.to_string()]; // city_names does not live for the whole program

    let my_city = City {
        name: &amp;city_names[0], // ⚠️ This is a &amp;str, but not a &amp;'static str. It is a reference to a value inside city_names
        date_founded: 1921,
    };

    println!(&quot;{} was founded in {}&quot;, my_city.name, my_city.date_founded);
}
</code></pre></pre>
<p>編譯器說:</p>
<pre><code class="language-text">error[E0597]: `city_names` does not live long enough
  --&gt; src\main.rs:12:16
   |
12 |         name: &amp;city_names[0],
   |                ^^^^^^^^^^
   |                |
   |                borrowed value does not live long enough
   |                requires that `city_names` is borrowed for `'static`
...
18 | }
   | - `city_names` dropped here while still borrowed
</code></pre>
<p>這一點很重要，因為我們給它的引用其實已經夠長壽了。但是我們承諾只給它一個<code>&amp;'static str</code>，這就是問題所在。</p>
<p>所以現在我們就試試之前編譯器的建議。它說嘗試寫<code>struct City&lt;'a&gt;</code>和<code>name: &amp;'a str</code>。這就意味著，只有當<code>name</code>活到<code>City</code>一樣壽命的情況下，它才會接受<code>name</code>的引用。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'a&gt; { // City has lifetime 'a
    name: &amp;'a str, // and name also has lifetime 'a.
    date_founded: u32,
}

fn main() {
    let city_names = vec![&quot;Ichinomiya&quot;.to_string(), &quot;Kurume&quot;.to_string()];

    let my_city = City {
        name: &amp;city_names[0],
        date_founded: 1921,
    };

    println!(&quot;{} was founded in {}&quot;, my_city.name, my_city.date_founded);
}
</code></pre></pre>
<p>另外記住，如果你願意，你可以寫任何東西來代替<code>'a</code>。這也和泛型類似，我們寫<code>T</code>和<code>U</code>，但實際上可以寫任何東西。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'city&gt; { // The lifetime is now called 'city
    name: &amp;'city str, // and name has the 'city lifetime
    date_founded: u32,
}

fn main() {}
</code></pre></pre>
<p>所以一般都會寫<code>'a, 'b, 'c</code>等，因為這樣寫起來比較快，也是常用的寫法。但如果你想的話，你可以隨時更改。有一個很好的建議是，如果代碼非常複雜，把生命期改成一個 &quot;人類可讀&quot;的名字可以幫助你閱讀代碼。</p>
<p>我們再來看看與trait的比較，對於泛型。比如說</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn prints&lt;T: Display&gt;(input: T) {
    println!(&quot;T is {}&quot;, input);
}

fn main() {}
</code></pre></pre>
<p>當你寫<code>T: Display</code>的時候，它的意思是 &quot;只有當T有Display時，才取T&quot;。
而不是說: &quot;我把Display給T&quot;.</p>
<p>對於生命期也是如此。當你在這裡寫 'a:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'a&gt; {
    name: &amp;'a str,
    date_founded: u32,
}

fn main() {}
</code></pre></pre>
<p>意思是 &quot;如果<code>name</code>的生命期至少與<code>City</code>一樣長，才接受<code>name</code>的輸入&quot;。
它的意思不是說: &quot;我會讓<code>name</code>的輸入與<code>City</code>一樣長壽&quot;。</p>
<p>現在我們可以瞭解一下之前看到的<code>&lt;'_&gt;</code>。這被稱為 &quot;匿名生命期&quot;，是使用引用的一個指標。例如，當你在實現結構時，Rust會向你建議使用。這裡有一個幾乎可以工作的結構體，但還不能工作：</p>
<pre><pre class="playground"><code class="language-rust">    // ⚠️
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

fn main() {}
</code></pre></pre>
<p>所以我們對<code>struct</code>做了我們需要做的事情:首先我們說<code>name</code>來自於一個<code>&amp;str</code>。這就意味著我們需要lifetime，所以我們給了它<code>&lt;'a&gt;</code>。然後我們必須對<code>struct</code>做同樣的處理，以證明它們至少和這個生命期一樣長。但是Rust卻告訴我們要這樣做:</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>它想讓我們加上那個匿名的生命期，以表明有一個引用被使用。所以如果我們這樣寫，它就會很高興。</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

fn main() {}
</code></pre></pre>
<p>這個生命期是為了讓你不必總是寫諸如<code>impl&lt;'a&gt; Adventurer&lt;'a&gt;</code>這樣的東西，因為結構已經顯示了生命期。</p>
<p>在Rust中，生命期是很困難的，但這裡有一些技巧可以避免對它們太過緊張。</p>
<ul>
<li>你可以繼續使用自有類型，使用克隆等，如果你想暫時避免它們。</li>
<li>很多時候，當編譯器想要lifetime的時候，你只要在這裡和那裡寫上&lt;'a&gt;就可以了。這只是一種 &quot;別擔心，我不會給你任何不夠長壽的東西&quot;的說法。</li>
<li>你可以每次只探索一下生命期。寫一些擁有值的代碼，然後把一個代碼變成一個引用。編譯器會開始抱怨，但也會給出一些建議。如果它變得太複雜，你可以撤銷它，下次再試。</li>
</ul>
<p>讓我們用我們的代碼來做這個，看看編譯器怎麼說。首先我們回去把生命期拿出來，同時實現<code>Display</code>。<code>Display</code>就打印<code>Adventurer</code>的名字。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
struct Adventurer {
    name: &amp;str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {}
</code></pre></pre>
<p>第一個抱怨就是這個:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:2:11
  |
2 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Adventurer&lt;'a&gt; {
2 |     name: &amp;'a str,
  |
</code></pre>
<p>它建議怎麼做:在Adventurer後面加上<code>&lt;'a&gt;</code>，以及<code>&amp;'a str</code>。所以我們就這麼做。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {}
</code></pre></pre>
<p>現在它對這些部分很滿意，但對<code>impl</code>塊感到奇怪。它希望我們提到它在使用引用。</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`

error[E0726]: implicit elided lifetime not allowed here
  --&gt; src\main.rs:12:28
   |
12 | impl std::fmt::Display for Adventurer {
   |                            ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>好了，我們將這些寫進去......現在它工作了！現在我們可以創建一個<code>Adventurer</code>，然後用它做一些事情:</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer&lt;'_&gt; {

        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {
    let mut billy = Adventurer {
        name: &quot;Billy&quot;,
        hit_points: 100_000,
    };
    println!(&quot;{}&quot;, billy);
    billy.take_damage();
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">Billy has 100000 hit points.
Billy has 99980 hit points left!
</code></pre>
<p>所以你可以看到，lifetimes往往只是編譯器想要確定。而且它通常很聰明，幾乎可以猜到你想要的生命期，只需要你告訴它，它就可以確定了。</p>
<h2 id="內部可變性"><a class="header" href="#內部可變性">內部可變性</a></h2>
<h3 id="cell"><a class="header" href="#cell">Cell</a></h3>
<p><strong>內部可變性</strong>的意思是在內部有一點可變性。還記得在Rust中，你需要用<code>mut</code>來改變一個變量嗎？也有一些方法可以不用<code>mut</code>這個詞來改變它們。這是因為Rust有一些方法可以讓你安全地在一個不可變的結構裡面改變值。每一種方法都遵循一些規則，確保改變值仍然是安全的。</p>
<p>首先，讓我們看一個簡單的例子，我們會想要這樣做:想象一下，一個叫<code>PhoneModel</code>的結構體有很多字段:</p>
<pre><pre class="playground"><code class="language-rust">struct PhoneModel {
    company_name: String,
    model_name: String,
    screen_size: f32,
    memory: usize,
    date_issued: u32,
    on_sale: bool,
}

fn main() {
    let super_phone_3000 = PhoneModel {
        company_name: &quot;YY Electronics&quot;.to_string(),
        model_name: &quot;Super Phone 3000&quot;.to_string(),
        screen_size: 7.5,
        memory: 4_000_000,
        date_issued: 2020,
        on_sale: true,
    };

}
</code></pre></pre>
<p><code>PhoneModel</code>中的字段最好是不可變的，因為我們不希望數據改變。比如說<code>date_issued</code>和<code>screen_size</code>永遠不會變。</p>
<p>但是裡面有一個字段叫<code>on_sale</code>。一個手機型號先是會有銷售(<code>true</code>)，但是後來公司會停止銷售。我們能不能只讓這一個字段可變？因為我們不想寫<code>let mut super_phone_3000</code>。如果我們這樣做，那麼每個字段都會變得可變。</p>
<p>Rust有很多方法可以讓一些不可變的東西里面有一些安全的可變性，最簡單的方法叫做<code>Cell</code>。首先我們使用<code>use std::cell::Cell</code>，這樣我們就可以每次只寫<code>Cell</code>而不是<code>std::cell::Cell</code>。</p>
<p>然後我們把<code>on_sale: bool</code>改成<code>on_sale: Cell&lt;bool&gt;</code>。現在它不是一個bool:它是一個<code>Cell</code>，容納了一個<code>bool</code>。</p>
<p><code>Cell</code>有一個叫做<code>.set()</code>的方法，在這裡你可以改變值。我們用<code>.set()</code>把<code>on_sale: true</code>改為<code>on_sale: Cell::new(true)</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::Cell;

struct PhoneModel {
    company_name: String,
    model_name: String,
    screen_size: f32,
    memory: usize,
    date_issued: u32,
    on_sale: Cell&lt;bool&gt;,
}

fn main() {
    let super_phone_3000 = PhoneModel {
        company_name: &quot;YY Electronics&quot;.to_string(),
        model_name: &quot;Super Phone 3000&quot;.to_string(),
        screen_size: 7.5,
        memory: 4_000_000,
        date_issued: 2020,
        on_sale: Cell::new(true),
    };

    // 10 years later, super_phone_3000 is not on sale anymore
    super_phone_3000.on_sale.set(false);
}
</code></pre></pre>
<p><code>Cell</code> 適用於所有類型，但對簡單的 Copy 類型效果最好，因為它給出的是值，而不是引用。<code>Cell</code>有一個叫做<code>get()</code>的方法，它只對Copy類型有效。</p>
<p>另一個可以使用的類型是 <code>RefCell</code>。</p>
<h3 id="refcell"><a class="header" href="#refcell">RefCell</a></h3>
<p><code>RefCell</code>是另一種無需聲明<code>mut</code>而改變值的方法。它的意思是 &quot;引用單元格&quot;，就像 <code>Cell</code>，但使用引用而不是副本。</p>
<p>我們將創建一個 <code>User</code> 結構。到目前為止，你可以看到它與 <code>Cell</code> 類似。</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct User {
    id: u32,
    year_registered: u32,
    username: String,
    active: RefCell&lt;bool&gt;,
    // Many other fields
}

fn main() {
    let user_1 = User {
        id: 1,
        year_registered: 2020,
        username: &quot;User 1&quot;.to_string(),
        active: RefCell::new(true),
    };

    println!(&quot;{:?}&quot;, user_1.active);
}
</code></pre></pre>
<p>這樣就可以打印出<code>RefCell { value: true }</code>。</p>
<p><code>RefCell</code>的方法有很多。其中兩種是<code>.borrow()</code>和<code>.borrow_mut()</code>。使用這些方法，你可以做與<code>&amp;</code>和<code>&amp;mut</code>相同的事情。規則都是一樣的:</p>
<ul>
<li>多個不可變借用可以</li>
<li>一個可變的借用可以</li>
<li>但可變和不可變借用在一起是不行的</li>
</ul>
<p>所以改變<code>RefCell</code>中的值是非常容易的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
user_1.active.replace(false);
println!(&quot;{:?}&quot;, user_1.active);
<span class="boring">}
</span></code></pre></pre>
<p>而且還有很多其他的方法，比如<code>replace_with</code>使用的是閉包。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let date = 2020;

user_1
    .active
    .replace_with(|_| if date &lt; 2000 { true } else { false });
println!(&quot;{:?}&quot;, user_1.active);
<span class="boring">}
</span></code></pre></pre>
<p>但是你要小心使用<code>RefCell</code>，因為它是在運行時而不是編譯時檢查借用。運行時是指程序實際運行的時候(編譯後)。所以這將會被編譯，即使它是錯誤的。</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct User {
    id: u32,
    year_registered: u32,
    username: String,
    active: RefCell&lt;bool&gt;,
    // Many other fields
}

fn main() {
    let user_1 = User {
        id: 1,
        year_registered: 2020,
        username: &quot;User 1&quot;.to_string(),
        active: RefCell::new(true),
    };

    let borrow_one = user_1.active.borrow_mut(); // first mutable borrow - okay
    let borrow_two = user_1.active.borrow_mut(); // second mutable borrow - not okay
}
</code></pre></pre>
<p>但如果你運行它，它就會立即崩潰。</p>
<pre><code class="language-text">thread 'main' panicked at 'already borrowed: BorrowMutError', C:\Users\mithr\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\src\libcore\cell.rs:877:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\rust_book.exe` (exit code: 101)
</code></pre>
<p><code>already borrowed: BorrowMutError</code>是重要的部分。所以當你使用<code>RefCell</code>時，好編譯<strong>並</strong>運行檢查。</p>
<h3 id="mutex"><a class="header" href="#mutex">Mutex</a></h3>
<p><code>Mutex</code>是另一種改變數值的方法，不需要聲明<code>mut</code>。Mutex的意思是<code>mutual exclusion</code>，也就是 &quot;一次只能改一個&quot;。這就是為什麼<code>Mutex</code>是安全的，因為它每次只讓一個進程改變它。為了做到這一點，它使用了<code>.lock()</code>。<code>Lock</code>就像從裡面鎖上一扇門。你進入一個房間，鎖上門，現在你可以在房間裡面改變東西。別人不能進來阻止你，因為你把門鎖上了。</p>
<p><code>Mutex</code>通過例子更容易理解:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5); // A new Mutex&lt;i32&gt;. We don't need to say mut
    let mut mutex_changer = my_mutex.lock().unwrap(); // mutex_changer is a MutexGuard
                                                     // It has to be mut because we will change it
                                                     // Now it has access to the Mutex
                                                     // Let's print my_mutex to see:

    println!(&quot;{:?}&quot;, my_mutex); // This prints &quot;Mutex { data: &lt;locked&gt; }&quot;
                                // So we can't access the data with my_mutex now,
                                // only with mutex_changer

    println!(&quot;{:?}&quot;, mutex_changer); // This prints 5. Let's change it to 6.

    *mutex_changer = 6; // mutex_changer is a MutexGuard&lt;i32&gt; so we use * to change the i32

    println!(&quot;{:?}&quot;, mutex_changer); // Now it says 6
}
</code></pre></pre>
<p>但是<code>mutex_changer</code>做完後還是有鎖。我們該如何阻止它呢？<code>Mutex</code>在<code>MutexGuard</code>超出範圍時就會被解鎖。&quot;超出範圍&quot;表示該代碼塊已經完成。比如說:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    {
        let mut mutex_changer = my_mutex.lock().unwrap();
        *mutex_changer = 6;
    } // mutex_changer goes out of scope - now it is gone. It is not locked anymore

    println!(&quot;{:?}&quot;, my_mutex); // Now it says: Mutex { data: 6 }
}
</code></pre></pre>
<p>如果你不想使用不同的<code>{}</code>代碼塊，你可以使用<code>std::mem::drop(mutex_changer)</code>。<code>std::mem::drop</code>的意思是 &quot;讓這個超出範圍&quot;。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap();
    *mutex_changer = 6;
    std::mem::drop(mutex_changer); // drop mutex_changer - it is gone now
                                   // and my_mutex is unlocked

    println!(&quot;{:?}&quot;, my_mutex); // Now it says: Mutex { data: 6 }
}
</code></pre></pre>
<p>你必須小心使用 <code>Mutex</code>，因為如果另一個變量試圖 <code>lock</code>它，它會等待。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap(); // mutex_changer has the lock
    let mut other_mutex_changer = my_mutex.lock().unwrap(); // other_mutex_changer wants the lock
                                                            // the program is waiting
                                                            // and waiting
                                                            // and will wait forever.

    println!(&quot;This will never print...&quot;);
}
</code></pre></pre>
<p>還有一種方法是<code>try_lock()</code>。然後它會試一次，如果沒能鎖上就會放棄。<code>try_lock().unwrap()</code>就不要做了，因為如果不成功它就會崩潰。<code>if let</code>或<code>match</code>比較好。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap();
    let mut other_mutex_changer = my_mutex.try_lock(); // try to get the lock

    if let Ok(value) = other_mutex_changer {
        println!(&quot;The MutexGuard has: {}&quot;, value)
    } else {
        println!(&quot;Didn't get the lock&quot;)
    }
}
</code></pre></pre>
<p>另外，你不需要創建一個變量來改變<code>Mutex</code>。你可以直接這樣做:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);

    *my_mutex.lock().unwrap() = 6;

    println!(&quot;{:?}&quot;, my_mutex);
}
</code></pre></pre>
<p><code>*my_mutex.lock().unwrap() = 6;</code>的意思是 &quot;解鎖my_mutex並使其成為6&quot;。沒有任何變量來保存它，所以你不需要調用 <code>std::mem::drop</code>。如果你願意，你可以做100次--這並不重要。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);

    for _ in 0..100 {
        *my_mutex.lock().unwrap() += 1; // locks and unlocks 100 times
    }

    println!(&quot;{:?}&quot;, my_mutex);
}
</code></pre></pre>
<h3 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h3>
<p><code>RwLock</code>的意思是 &quot;讀寫鎖&quot;。它像<code>Mutex</code>，但也像<code>RefCell</code>。你用<code>.write().unwrap()</code>代替<code>.lock().unwrap()</code>來改變它。但你也可以用<code>.read().unwrap()</code>來獲得讀權限。它和<code>RefCell</code>一樣，遵循這些規則:</p>
<ul>
<li>很多<code>.read()</code>變量可以</li>
<li>一個<code>.write()</code>變量可以</li>
<li>但多個<code>.write()</code>或<code>.read()</code>與<code>.write()</code>一起是不行的</li>
</ul>
<p>如果在無法訪問的情況下嘗試<code>.write()</code>，程序將永遠運行。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap(); // one .read() is fine
    let read2 = my_rwlock.read().unwrap(); // two .read()s is also fine

    println!(&quot;{:?}, {:?}&quot;, read1, read2);

    let write1 = my_rwlock.write().unwrap(); // uh oh, now the program will wait forever
}
</code></pre></pre>
<p>所以我們用<code>std::mem::drop</code>，就像用<code>Mutex</code>一樣。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;
use std::mem::drop; // We will use drop() many times

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap();
    let read2 = my_rwlock.read().unwrap();

    println!(&quot;{:?}, {:?}&quot;, read1, read2);

    drop(read1);
    drop(read2); // we dropped both, so we can use .write() now

    let mut write1 = my_rwlock.write().unwrap();
    *write1 = 6;
    drop(write1);
    println!(&quot;{:?}&quot;, my_rwlock);
}
</code></pre></pre>
<p>而且你也可以使用<code>try_read()</code>和<code>try_write()</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap();
    let read2 = my_rwlock.read().unwrap();

    if let Ok(mut number) = my_rwlock.try_write() {
        *number += 10;
        println!(&quot;Now the number is {}&quot;, number);
    } else {
        println!(&quot;Couldn't get write access, sorry!&quot;)
    };
}
</code></pre></pre>
<h2 id="cow"><a class="header" href="#cow">Cow</a></h2>
<p>Cow是一個非常方便的枚舉。它的意思是 &quot;寫時克隆&quot;，如果你不需要<code>String</code>，可以返回一個<code>&amp;str</code>，如果你需要，可以返回一個<code>String</code>。(它也可以對數組與Vec等做同樣的處理)。</p>
<p>為了理解它，我們看一下簽名。它說</p>
<pre><pre class="playground"><code class="language-rust">pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
 {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}

fn main() {}
</code></pre></pre>
<p>你馬上就知道，<code>'a</code>意味著它可以和引用一起工作。<code>ToOwned</code>的特性意味著它是一個可以變成擁有類型的類型。例如，<code>str</code>通常是一個引用(<code>&amp;str</code>)，你可以把它變成一個擁有的<code>String</code>。</p>
<p>接下來是<code>?Sized</code>。這意味著 &quot;也許是Sized，但也許不是&quot;。Rust中幾乎每個類型都是Sized的，但像<code>str</code>這樣的類型卻不是。這就是為什麼我們需要一個 <code>&amp;</code> 來代替 <code>str</code>，因為編譯器不知道大小。所以，如果你想要一個可以使用 <code>str</code> 這樣的trait，你可以添加 <code>?Sized.</code></p>
<p>接下來是<code>enum</code>的變種。它們是 <code>Borrowed</code> 和 <code>Owned</code>。</p>
<p>想象一下，你有一個返回 <code>Cow&lt;'static, str&gt;</code> 的函數。如果你告訴函數返回<code>&quot;My message&quot;.into()</code>，它就會查看類型:&quot;My message&quot;是<code>str</code>. 這是一個<code>Borrowed</code>的類型，所以它選擇<code>Borrowed(&amp;'a B)</code>。所以它就變成了<code>Cow::Borrowed(&amp;'static str)</code>。</p>
<p>而如果你給它一個<code>format!(&quot;{}&quot;, &quot;My message&quot;).into()</code>，那麼它就會查看類型。這次是一個<code>String</code>，因為<code>format!</code>創建了<code>String</code>。所以這次會選擇 &quot;Owned&quot;。</p>
<p>下面是一個測試<code>Cow</code>的例子。我們將把一個數字放入一個函數中，返回一個<code>Cow&lt;'static, str&gt;</code>。根據這個數字，它會創建一個<code>&amp;str</code>或<code>String</code>。然後它使用<code>.into()</code>將其變成<code>Cow</code>。這樣做的時候，它就會選擇<code>Cow::Borrowed</code>或者<code>Cow::Owned</code>。那我們就匹配一下，看看它選的是哪一個。</p>
<pre><pre class="playground"><code class="language-rust">use std::borrow::Cow;

fn modulo_3(input: u8) -&gt; Cow&lt;'static, str&gt; {
    match input % 3 {
        0 =&gt; &quot;Remainder is 0&quot;.into(),
        1 =&gt; &quot;Remainder is 1&quot;.into(),
        remainder =&gt; format!(&quot;Remainder is {}&quot;, remainder).into(),
    }
}

fn main() {
    for number in 1..=6 {
        match modulo_3(number) {
            Cow::Borrowed(message) =&gt; println!(&quot;{} went in. The Cow is borrowed with this message: {}&quot;, number, message),
            Cow::Owned(message) =&gt; println!(&quot;{} went in. The Cow is owned with this message: {}&quot;, number, message),
        }
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">1 went in. The Cow is borrowed with this message: Remainder is 1
2 went in. The Cow is owned with this message: Remainder is 2
3 went in. The Cow is borrowed with this message: Remainder is 0
4 went in. The Cow is borrowed with this message: Remainder is 1
5 went in. The Cow is owned with this message: Remainder is 2
6 went in. The Cow is borrowed with this message: Remainder is 0
</code></pre>
<p><code>Cow</code>還有一些其他的方法，比如<code>into_owned</code> 或者 <code>into_borrowed</code>，這樣如果你需要的話，你可以改變它。</p>
<h2 id="類型別名"><a class="header" href="#類型別名">類型別名</a></h2>
<p>類型別名的意思是 &quot;給某個類型一個新的名字&quot;。類型別名非常簡單。通常，當您有一個很長的類型，而又不想每次都寫它時，您就會使用它們。當您想給一個類型起一個更好的名字，便於記憶時，也可以使用它。下面是兩個類型別名的例子。</p>
<p>這裡是一個不難的類型，但是你想讓你的代碼更容易被其他人(或者你)理解。</p>
<pre><pre class="playground"><code class="language-rust">type CharacterVec = Vec&lt;char&gt;;

fn main() {}
</code></pre></pre>
<p>這是一種非常難讀的類型:</p>
<pre><pre class="playground"><code class="language-rust">// this return type is extremely long
fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; std::iter::Take&lt;std::iter::Skip&lt;std::slice::Iter&lt;'a, char&gt;&gt;&gt; {
    input.iter().skip(4).take(5)
}

fn main() {}
</code></pre></pre>
<p>所以你可以改成這樣。</p>
<pre><pre class="playground"><code class="language-rust">type SkipFourTakeFive&lt;'a&gt; = std::iter::Take&lt;std::iter::Skip&lt;std::slice::Iter&lt;'a, char&gt;&gt;&gt;;

fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; SkipFourTakeFive {
    input.iter().skip(4).take(5)
}

fn main() {}
</code></pre></pre>
<p>當然，你也可以導入元素，讓類型更短:</p>
<pre><pre class="playground"><code class="language-rust">use std::iter::{Take, Skip};
use std::slice::Iter;

fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; Take&lt;Skip&lt;Iter&lt;'a, char&gt;&gt;&gt; {
    input.iter().skip(4).take(5)
}

fn main() {}
</code></pre></pre>
<p>所以你可以根據自己的喜好來決定在你的代碼中什麼是最好看的。</p>
<p>請注意，這並沒有創建一個實際的新類型。它只是一個代替現有類型的名稱。所以如果你寫了 <code>type File = String;</code>，編譯器只會看到 <code>String</code>。所以這將打印出 <code>true</code>。</p>
<pre><pre class="playground"><code class="language-rust">type File = String;

fn main() {
    let my_file = File::from(&quot;I am file contents&quot;);
    let my_string = String::from(&quot;I am file contents&quot;);
    println!(&quot;{}&quot;, my_file == my_string);
}
</code></pre></pre>
<p>那麼如果你想要一個實際的新類型呢？</p>
<p>如果你想要一個新的文件類型，而編譯器看到的是<code>File</code>，你可以把它放在一個結構中。</p>
<pre><pre class="playground"><code class="language-rust">struct File(String); // File is a wrapper around String

fn main() {
    let my_file = File(String::from(&quot;I am file contents&quot;));
    let my_string = String::from(&quot;I am file contents&quot;);
}
</code></pre></pre>
<p>現在這樣就不行了，因為它們是兩種不同的類型。</p>
<pre><pre class="playground"><code class="language-rust">struct File(String); // File is a wrapper around String

fn main() {
    let my_file = File(String::from(&quot;I am file contents&quot;));
    let my_string = String::from(&quot;I am file contents&quot;);
    println!(&quot;{}&quot;, my_file == my_string);  // ⚠️ cannot compare File with String
}
</code></pre></pre>
<p>如果你想比較裡面的String，可以用my_file.0:</p>
<pre><pre class="playground"><code class="language-rust">struct File(String);

fn main() {
    let my_file = File(String::from(&quot;I am file contents&quot;));
    let my_string = String::from(&quot;I am file contents&quot;);
    println!(&quot;{}&quot;, my_file.0 == my_string); // my_file.0 is a String, so this prints true
}
</code></pre></pre>
<h3 id="在函數中導入和重命名"><a class="header" href="#在函數中導入和重命名">在函數中導入和重命名</a></h3>
<p>通常你會在程序的頂部寫上<code>use</code>，像這樣。</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::{Cell, RefCell};

fn main() {}
</code></pre></pre>
<p>但我們看到，你可以在任何地方這樣做，特別是在函數中使用名稱較長的enum。下面是一個例子:</p>
<pre><pre class="playground"><code class="language-rust">enum MapDirection {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

fn main() {}

fn give_direction(direction: &amp;MapDirection) {
    match direction {
        MapDirection::North =&gt; println!(&quot;You are heading north.&quot;),
        MapDirection::NorthEast =&gt; println!(&quot;You are heading northeast.&quot;),
        // So much more left to type...
        // ⚠️ because we didn't write every possible variant
    }
}
</code></pre></pre>
<p>所以現在我們要在函數裡面導入MapDirection。也就是說，在函數裡面你可以直接寫<code>North</code>等。</p>
<pre><pre class="playground"><code class="language-rust">enum MapDirection {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

fn main() {}

fn give_direction(direction: &amp;MapDirection) {
    use MapDirection::*; // Import everything in MapDirection
    let m = &quot;You are heading&quot;;

    match direction {
        North =&gt; println!(&quot;{} north.&quot;, m),
        NorthEast =&gt; println!(&quot;{} northeast.&quot;, m),
        // This is a bit better
        // ⚠️
    }
}
</code></pre></pre>
<p>我們已經看到<code>::*</code>的意思是 &quot;導入::之後的所有內容&quot;。在我們的例子中，這意味著<code>North</code>，<code>NorthEast</code>......一直到<code>NorthWest</code>。當你導入別人的代碼時，你也可以這樣做，但如果代碼非常大，你可能會有問題。如果它有一些元素和你的代碼是一樣的呢？所以一般情況下最好不要一直使用<code>::*</code>，除非你有把握。很多時候你在別人的代碼裡看到一個叫<code>prelude</code>的部分，裡面有你可能需要的所有主要元素。那麼你通常會這樣使用:<code>name::prelude::*</code>。 我們將在 <code>modules</code> 和 <code>crates</code> 的章節中更多地討論這個問題。</p>
<p>您也可以使用 <code>as</code> 來更改名稱。例如，也許你正在使用別人的代碼，而你不能改變枚舉中的名稱。</p>
<pre><pre class="playground"><code class="language-rust">enum FileState {
    CannotAccessFile,
    FileOpenedAndReady,
    NoSuchFileExists,
    SimilarFileNameInNextDirectory,
}

fn main() {}
</code></pre></pre>
<p>那麼你就可以</p>
<ol>
<li>導入所有的東西</li>
<li>更改名稱</li>
</ol>
<pre><pre class="playground"><code class="language-rust">enum FileState {
    CannotAccessFile,
    FileOpenedAndReady,
    NoSuchFileExists,
    SimilarFileNameInNextDirectory,
}

fn give_filestate(input: &amp;FileState) {
    use FileState::{
        CannotAccessFile as NoAccess,
        FileOpenedAndReady as Good,
        NoSuchFileExists as NoFile,
        SimilarFileNameInNextDirectory as OtherDirectory
    };
    match input {
        NoAccess =&gt; println!(&quot;Can't access file.&quot;),
        Good =&gt; println!(&quot;Here is your file&quot;),
        NoFile =&gt; println!(&quot;Sorry, there is no file by that name.&quot;),
        OtherDirectory =&gt; println!(&quot;Please check the other directory.&quot;),
    }
}

fn main() {}
</code></pre></pre>
<p>所以現在你可以寫<code>OtherDirectory</code>而不是<code>FileState::SimilarFileNameInNextDirectory</code>。</p>
<h2 id="todo宏"><a class="header" href="#todo宏">todo!宏</a></h2>
<p>有時你想粗略寫點寫代碼幫助你想象你的項目。例如，想象一個簡單的項目，用書籍做一些事情。下面是你寫的時候的想法:</p>
<pre><pre class="playground"><code class="language-rust">struct Book {} // Okay, first I need a book struct.
               // Nothing in there yet - will add later

enum BookType { // A book can be hardcover or softcover, so add an enum
    HardCover,
    SoftCover,
}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {} // ⚠️ get_book should take a &amp;Book and return an Option&lt;String&gt;

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {} // delete_book should take a Book and return a Result...
                                                    // TODO: impl block and make these functions methods...
fn check_book_type(book_type: &amp;BookType) { // Let's make sure the match statement works
    match book_type {
        BookType::HardCover =&gt; println!(&quot;It's hardcover&quot;),
        BookType::SoftCover =&gt; println!(&quot;It's softcover&quot;),
    }
}

fn main() {
    let book_type = BookType::HardCover;
    check_book_type(&amp;book_type); // Okay, let's check this function!
}
</code></pre></pre>
<p>但Rust對<code>get_book</code>和<code>delete_book</code>不滿意。它說</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src\main.rs:32:29
   |
32 | fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {}
   |    --------                 ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::option::Option&lt;std::string::String&gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&gt; src\main.rs:34:31
   |
34 | fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {}
   |    -----------                ^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::result::Result&lt;(), std::string::String&gt;`
           found unit type `()`
</code></pre>
<p>但是你現在不關心<code>get_book</code>和<code>delete_book</code>。這時你可以使用<code>todo!()</code>。如果你把這個加到函數中，Rust不會抱怨，而且會編譯。</p>
<pre><pre class="playground"><code class="language-rust">struct Book {}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {
    todo!() // todo means &quot;I will do it later, please be quiet&quot;
}

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {
    todo!()
}

fn main() {}
</code></pre></pre>
<p>所以現在代碼編譯，你可以看到<code>check_book_type</code>的結果:<code>It's hardcover</code>。</p>
<p>但是要小心，因為它只是編譯--你不能使用函數。如果你調用裡面有<code>todo!()</code>的函數，它就會崩潰。</p>
<p>另外，<code>todo!()</code>函數仍然需要真實的輸入和輸出類型。如果你只寫這個，它將無法編譯。</p>
<pre><pre class="playground"><code class="language-rust">struct Book {}

fn get_book(book: &amp;Book) -&gt; WorldsBestType { // ⚠️
    todo!()
}

fn main() {}
</code></pre></pre>
<p>它會說</p>
<pre><code class="language-text">error[E0412]: cannot find type `WorldsBestType` in this scope
  --&gt; src\main.rs:32:29
   |
32 | fn get_book(book: &amp;Book) -&gt; WorldsBestType {
   |                             ^^^^^^^^^^^^^^ not found in this scope
</code></pre>
<p><code>todo!()</code>其實和另一個宏一樣：<code>unimplemented!()</code>。程序員們經常使用 <code>unimplemented!()</code>，但打字時太長了，所以他們創建了 <code>todo!()</code>，它比較短。</p>
<h2 id="rc-1"><a class="header" href="#rc-1">Rc</a></h2>
<p>Rc的意思是 &quot;reference counter&quot;(引用計數器)。你知道在Rust中，每個變量只能有一個所有者。這就是為什麼這個不能工作的原因:</p>
<pre><pre class="playground"><code class="language-rust">fn takes_a_string(input: String) {
    println!(&quot;It is: {}&quot;, input)
}

fn also_takes_a_string(input: String) {
    println!(&quot;It is: {}&quot;, input)
}

fn main() {
    let user_name = String::from(&quot;User MacUserson&quot;);

    takes_a_string(user_name);
    also_takes_a_string(user_name); // ⚠️
}
</code></pre></pre>
<p><code>takes_a_string</code>取了<code>user_name</code>之後，你就不能再使用了。這裡沒有問題:你可以直接給它<code>user_name.clone()</code>。但有時一個變量是一個結構的一部分，也許你不能克隆這個結構；或者<code>String</code>真的很長，你不想克隆它。這些都是<code>Rc</code>的一些原因，它讓你擁有多個所有者。<code>Rc</code>就像一個優秀的辦公人員。<code>Rc</code>寫下誰擁有所有權，以及有多少個。然後一旦所有者的數量下降到0，這個變量就可以消失了。</p>
<p>下面是如何使用<code>Rc</code>。首先想象兩個結構:一個叫 <code>City</code>，另一個叫 <code>CityData</code>。<code>City</code>有一個城市的信息，而<code>CityData</code>把所有的城市都放在<code>Vec</code>中。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: String,
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;String&gt;,
}

fn main() {
    let calgary = City {
        name: &quot;Calgary&quot;.to_string(),
        population: 1_200_000,
           // Pretend that this string is very very long
        city_history: &quot;Calgary began as a fort called Fort Calgary that...&quot;.to_string(),
    };

    let canada_cities = CityData {
        names: vec![calgary.name], // This is using calgary.name, which is short
        histories: vec![calgary.city_history], // But this String is very long
    };

    println!(&quot;Calgary's history is: {}&quot;, calgary.city_history);  // ⚠️
}
</code></pre></pre>
<p>當然，這是不可能的，因為<code>canada_cities</code>現在擁有數據，而<code>calgary</code>沒有。它說:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `calgary.city_history`
  --&gt; src\main.rs:27:42
   |
24 |         histories: vec![calgary.city_history], // But this String is very long
   |                         -------------------- value moved here
...
27 |     println!(&quot;Calgary's history is: {}&quot;, calgary.city_history);  // ⚠️
   |                                          ^^^^^^^^^^^^^^^^^^^^ value borrowed here after move
   |
   = note: move occurs because `calgary.city_history` has type `std::string::String`, which does not implement the `Copy` trait
</code></pre>
<p>我們可以克隆名稱:<code>names: vec![calgary.name.clone()]</code>，但是我們不想克隆<code>city_history</code>，因為它很長。所以我們可以用一個<code>Rc</code>。</p>
<p>增加<code>use</code>的聲明。</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {}
</code></pre></pre>
<p>然後用<code>Rc</code>把<code>String</code>包圍起來:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: Rc&lt;String&gt;,
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;Rc&lt;String&gt;&gt;,
}

fn main() {}
</code></pre></pre>
<p>要添加一個新的引用，你必須<code>clone</code> <code>Rc</code>。但是等一下，我們不是想避免使用<code>.clone()</code>嗎？不完全是:我們不想克隆整個String。但是一個<code>Rc</code>的克隆只是克隆了指針--它基本上是沒有開銷的。這就像在一盒書上貼上一個名字貼紙，以表明有兩個人擁有它，而不是做一盒全新的書。</p>
<p>你可以用<code>item.clone()</code>或者用<code>Rc::clone(&amp;item)</code>來克隆一個叫<code>item</code>的<code>Rc</code>。所以calgary.city_history有兩個所有者。
我們可以用<code>Rc::strong_count(&amp;item)</code>查詢擁有者數量。另外我們再增加一個新的所有者。現在我們的代碼是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: Rc&lt;String&gt;, // String inside an Rc
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;Rc&lt;String&gt;&gt;, // A Vec of Strings inside Rcs
}

fn main() {
    let calgary = City {
        name: &quot;Calgary&quot;.to_string(),
        population: 1_200_000,
           // Pretend that this string is very very long
        city_history: Rc::new(&quot;Calgary began as a fort called Fort Calgary that...&quot;.to_string()), // Rc::new() to make the Rc
    };

    let canada_cities = CityData {
        names: vec![calgary.name],
        histories: vec![calgary.city_history.clone()], // .clone() to increase the count
    };

    println!(&quot;Calgary's history is: {}&quot;, calgary.city_history);
    println!(&quot;{}&quot;, Rc::strong_count(&amp;calgary.city_history));
    let new_owner = calgary.city_history.clone();
}
</code></pre></pre>
<p>這就打印出了<code>2</code>。而<code>new_owner</code>現在是<code>Rc&lt;String&gt;</code>。現在如果我們用<code>println!(&quot;{}&quot;, Rc::strong_count(&amp;calgary.city_history));</code>，我們得到<code>3</code>。</p>
<p>那麼，如果有強指針，是否有弱指針呢？是的，有。弱指針是有用的，因為如果兩個<code>Rc</code>互相指向對方，它們就不會死。這就是所謂的 &quot;引用循環&quot;。如果第1項對第2項有一個Rc，而第2項對第1項有一個Rc，它們不能到0，在這種情況下，要使用弱引用。那麼<code>Rc</code>就會對引用進行計數，但如果只有弱引用，那麼它就會死掉。你使用<code>Rc::downgrade(&amp;item)</code>而不是<code>Rc::clone(&amp;item)</code>來創建弱引用。另外，需要用<code>Rc::weak_count(&amp;item)</code>來查看弱引用數。</p>
<h2 id="多線程"><a class="header" href="#多線程">多線程</a></h2>
<p>如果你使用多個線程，你可以同時做很多事情。現代計算機有一個以上的核心，所以它們可以同時做多件事情，Rust讓你使用它們。Rust使用的線程被稱為 &quot;OS線程&quot;。OS線程意味著操作系統在不同的核上創建線程。(其他一些語言使用 &quot;green threads&quot;，功能較少)</p>
<p>你用<code>std::thread::spawn</code>創建線程，然後用一個閉包來告訴它該怎麼做。線程很有趣，因為它們同時運行，你可以測試它，看看會發生什麼。下面是一個簡單的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    std::thread::spawn(|| {
        println!(&quot;I am printing something&quot;);
    });
}
</code></pre></pre>
<p>如果你運行這個，每次都會不一樣。有時會打印，有時不會打印(這也取決於你的電腦速度)。這是因為有時<code>main()</code>在線程完成之前就完成了。而當<code>main()</code>完成後，程序就結束了。這在<code>for</code>循環中更容易看到。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 { // set up ten threads
        std::thread::spawn(|| {
            println!(&quot;I am printing something&quot;);
        });
    }   // Now the threads start.
}       // How many can finish before main() ends here?
</code></pre></pre>
<p>通常在<code>main</code>結束之前，大約會打印出四條線程，但總是不一樣。如果你的電腦速度比較快，那麼可能就不會打印了。另外，有時線程會崩潰。</p>
<pre><code class="language-text">thread 'thread 'I am printing something
thread '&lt;unnamed&gt;&lt;unnamed&gt;thread '' panicked at '&lt;unnamed&gt;I am printing something
' panicked at 'thread '&lt;unnamed&gt;cannot access stdout during shutdown' panicked at '&lt;unnamed&gt;thread 'cannot access stdout during
shutdown
</code></pre>
<p>這是在程序關閉時，線程試圖做一些正確的事情時出現的錯誤。</p>
<p>你可以給電腦做一些事情，這樣它就不會馬上關閉了。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        std::thread::spawn(|| {
            println!(&quot;I am printing something&quot;);
        });
    }
    for _ in 0..1_000_000 { // make the program declare &quot;let x = 9&quot; one million times
                            // It has to finish this before it can exit the main function
        let _x = 9;
    }
}
</code></pre></pre>
<p>但這是一個讓線程有時間完成的愚蠢方法。更好的方法是將線程綁定到一個變量上。如果你加上 <code>let</code>，你就能創建一個 <code>JoinHandle</code>。你可以在<code>spawn</code>的簽名中看到這一點:</p>
<pre><code class="language-text">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre>
<p>(<code>f</code>是閉包--我們將在後面學習如何將閉包放入我們的函數中)</p>
<p>所以現在我們每次都有<code>JoinHandle</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        let handle = std::thread::spawn(|| {
            println!(&quot;I am printing something&quot;);
        });

    }
}
</code></pre></pre>
<p><code>handle</code>現在是<code>JoinHandle</code>。我們怎麼處理它呢？我們使用一個叫做 <code>.join()</code> 的方法。這個方法的意思是 &quot;等待所有線程完成&quot;(它等待線程加入它)。所以現在只要寫<code>handle.join()</code>，它就會等待每個線程完成。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        let handle = std::thread::spawn(|| {
            println!(&quot;I am printing something&quot;);
        });

        handle.join(); // Wait for the threads to finish
    }
}
</code></pre></pre>
<p>現在我們就來瞭解一下三種類型的閉包。這三種類型是</p>
<ul>
<li><code>FnOnce</code>: 取整個值</li>
<li><code>FnMut</code>: 取一個可變引用</li>
<li><code>Fn</code>: 取一個普通引用</li>
</ul>
<p>如果可以的話，閉包會盡量使用<code>Fn</code>。但如果它需要改變值，它將使用 <code>FnMut</code>，而如果它需要取整個值，它將使用 <code>FnOnce</code>。<code>FnOnce</code>是個好名字，因為它解釋了它的作用:它取一次值，然後就不能再取了。</p>
<p>下面是一個例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = String::from(&quot;I will go into the closure&quot;);
    let my_closure = || println!(&quot;{}&quot;, my_string);
    my_closure();
    my_closure();
}
</code></pre></pre>
<p><code>String</code>沒有實現<code>Copy</code>，所以<code>my_closure()</code>是<code>Fn</code>: 它拿到一個引用</p>
<p>如果我們改變<code>my_string</code>，它變成<code>FnMut</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;I will go into the closure&quot;);
    let mut my_closure = || {
        my_string.push_str(&quot; now&quot;);
        println!(&quot;{}&quot;, my_string);
    };
    my_closure();
    my_closure();
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">I will go into the closure now
I will go into the closure now now
</code></pre>
<p>而如果按值獲取，則是<code>FnOnce</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;i32&gt; = vec![8, 9, 10];
    let my_closure = || {
        my_vec
            .into_iter() // into_iter takes ownership
            .map(|x| x as u8) // turn it into u8
            .map(|x| x * 2) // multiply by 2
            .collect::&lt;Vec&lt;u8&gt;&gt;() // collect into a Vec
    };
    let new_vec = my_closure();
    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>我們是按值取的，所以我們不能多跑<code>my_closure()</code>次。這就是名字的由來。</p>
<p>那麼現在回到線程。讓我們試著從外部引入一個值:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(|| {
        println!(&quot;{}&quot;, my_string); // ⚠️
    });

    handle.join();
}
</code></pre></pre>
<p>編譯器說這個不行。</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `my_string`, which is owned by the current function
  --&gt; src\main.rs:28:37
   |
28 |     let handle = std::thread::spawn(|| {
   |                                     ^^ may outlive borrowed value `my_string`
29 |         println!(&quot;{}&quot;, my_string);
   |                        --------- `my_string` is borrowed here
   |
note: function requires argument type to outlive `'static`
  --&gt; src\main.rs:28:18
   |
28 |       let handle = std::thread::spawn(|| {
   |  __________________^
29 | |         println!(&quot;{}&quot;, my_string);
30 | |     });
   | |______^
help: to force the closure to take ownership of `my_string` (and any other referenced variables), use the `move` keyword
   |
28 |     let handle = std::thread::spawn(move || {
   |                                     ^^^^^^^
</code></pre>
<p>這條信息很長，但很有用:它說到<code>use the `move` keyword</code>。問題是我們可以在線程使用<code>my_string</code>時對它做任何事情，但線程並不擁有它。這將是不安全的。</p>
<p>讓我們試試其他行不通的東西。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(|| {
        println!(&quot;{}&quot;, my_string); // now my_string is being used as a reference
    });

    std::mem::drop(my_string);  // ⚠️ We try to drop it here. But the thread still needs it.

    handle.join();
}
</code></pre></pre>
<p>所以你要用<code>move</code>來取值，現在安全了:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(move|| {
        println!(&quot;{}&quot;, my_string);
    });

    std::mem::drop(my_string);  // ⚠️ we can't drop, because handle has it. So this won't work

    handle.join();
}
</code></pre></pre>
<p>所以我們把<code>std::mem::drop</code>刪掉，現在就可以了。<code>handle</code>取<code>my_string</code>，我們的代碼就安全了。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(move|| {
        println!(&quot;{}&quot;, my_string);
    });

    handle.join();
}
</code></pre></pre>
<p>所以只要記住:如果你在線程中需要一個來自線程外的值，你需要使用<code>move</code>。</p>
<h2 id="函數中的閉包"><a class="header" href="#函數中的閉包">函數中的閉包</a></h2>
<p>閉包是偉大的。那麼我們如何把它們放到自己的函數中呢？</p>
<p>你可以創建自己的函數來接受閉包，但是在函數裡面就不那麼自由了，你必須決定類型。在函數外部，一個閉包可以在<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>之間自行決定，但在函數內部你必須選擇一個。最好的理解方式是看幾個函數簽名。
這裡是<code>.all()</code>的那個。我們記得，它檢查一個迭代器，看看所有的東西是否是<code>true</code>(取決於你決定是<code>true</code>還是<code>false</code>)。它的部分簽名是這樣說的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool    // 🚧
    where
        F: FnMut(Self::Item) -&gt; bool,
<span class="boring">}
</span></code></pre></pre>
<p><code>fn all&lt;F&gt;</code>:這告訴你有一個通用類型<code>F</code>。一個閉包總是泛型，因為每次都是不同的類型。</p>
<p><code>(&amp;mut self, f: F)</code>:<code>&amp;mut self</code>告訴你這是一個方法。<code>f: F</code>通常你看到的是一個閉包:這是變量名和類型。 當然，<code>f</code>和<code>F</code>並沒有什麼特別之處，它們可以是不同的名字。如果你願意，你可以寫<code>my_closure: Closure</code>--這並不重要。但在簽名中，你幾乎總是看到<code>f: F</code>。</p>
<p>接下來是關於閉包的部分:<code>F: FnMut(Self::Item) -&gt; bool</code>。在這裡，它決定了閉包是 <code>FnMut</code>，所以它可以改變值。它改變了<code>Self::Item</code>的值，這是它所取的迭代器。而且它必須返回 <code>true</code> 或 <code>false</code>。</p>
<p>這裡是一個更簡單的簽名，有一個閉包。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something&lt;F&gt;(f: F)    // 🚧
where
    F: FnOnce(),
{
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>這只是說它接受一個閉包，取值(<code>FnOnce</code>=取值)，而不返回任何東西。所以現在我們可以調用這個什麼都不取的閉包，做我們喜歡做的事情。我們將創建一個 <code>Vec</code>，然後對它進行迭代，只是為了展示我們現在可以做什麼。</p>
<pre><pre class="playground"><code class="language-rust">fn do_something&lt;F&gt;(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let some_vec = vec![9, 8, 10];
    do_something(|| {
        some_vec
            .into_iter()
            .for_each(|x| println!(&quot;The number is: {}&quot;, x));
    })
}
</code></pre></pre>
<p>一個更真實的例子，我們將再次創建一個 <code>City</code> 結構體。這次 <code>City</code> 結構體有更多關於年份和人口的數據。它有一個 <code>Vec&lt;u32&gt;</code> 來表示所有的年份，還有一個 <code>Vec&lt;u32&gt;</code> 來表示所有的人口。</p>
<p><code>City</code>有兩個方法:<code>new()</code>用於創建一個新的<code>City</code>, <code>.city_data()</code>有個閉包參數。當我們使用 <code>.city_data()</code> 時，它給我們提供了年份和人口以及一個閉包，所以我們可以對數據做我們想做的事情。閉包類型是 <code>FnMut</code>，所以我們可以改變數據。它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    years: Vec&lt;u32&gt;,
    populations: Vec&lt;u32&gt;,
}

impl City {
    fn new(name: &amp;str, years: Vec&lt;u32&gt;, populations: Vec&lt;u32&gt;) -&gt; Self {

        Self {
            name: name.to_string(),
            years,
            populations,
        }
    }

    fn city_data&lt;F&gt;(&amp;mut self, mut f: F) // We bring in self, but only f is generic F. f is the closure

    where
        F: FnMut(&amp;mut Vec&lt;u32&gt;, &amp;mut Vec&lt;u32&gt;), // The closure takes mutable vectors of u32
                                                // which are the year and population data
    {
        f(&amp;mut self.years, &amp;mut self.populations) // Finally this is the actual function. It says
                                                  // &quot;use a closure on self.years and self.populations&quot;
                                                  // We can do whatever we want with the closure
    }
}

fn main() {
    let years = vec![
        1372, 1834, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020,
    ];
    let populations = vec![
        3_250, 15_300, 24_000, 45_900, 58_800, 119_800, 283_071, 478_974, 400_378, 401_694,
        406_703, 437_619,
    ];
    // Now we can create our city
    let mut tallinn = City::new(&quot;Tallinn&quot;, years, populations);

    // Now we have a .city_data() method that has a closure. We can do anything we want.

    // First let's put the data for 5 years together and print it.
    tallinn.city_data(|city_years, city_populations| { // We can call the input anything we want
        let new_vec = city_years
            .into_iter()
            .zip(city_populations.into_iter()) // Zip the two together
            .take(5)                           // but only take the first 5
            .collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // Tell Rust to decide the type inside the tuple
        println!(&quot;{:?}&quot;, new_vec);
    });

    // Now let's add some data for the year 2030
    tallinn.city_data(|x, y| { // This time we just call the input x and y
        x.push(2030);
        y.push(500_000);
    });

    // We don't want the 1834 data anymore
    tallinn.city_data(|x, y| {
        let position_option = x.iter().position(|x| *x == 1834);
        if let Some(position) = position_option {
            println!(
                &quot;Going to delete {} at position {:?} now.&quot;,
                x[position], position
            ); // Confirm that we delete the right item
            x.remove(position);
            y.remove(position);
        }
    });

    println!(
        &quot;Years left are {:?}\nPopulations left are {:?}&quot;,
        tallinn.years, tallinn.populations
    );
}
</code></pre></pre>
<p>這將打印出我們調用<code>.city_data().</code>的所有時間的結果:</p>
<pre><code class="language-text">[(1372, 3250), (1834, 15300), (1851, 24000), (1881, 45900), (1897, 58800)]
Going to delete 1834 at position 1 now.
Years left are [1372, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020, 2030]
Populations left are [3250, 24000, 45900, 58800, 119800, 283071, 478974, 400378, 401694, 406703, 437619, 500000]
</code></pre>
<h2 id="impl-trait-1"><a class="header" href="#impl-trait-1">impl Trait</a></h2>
<p><code>impl Trait</code>與泛型類似。你還記得，泛型使用一個類型 <code>T</code>(或任何其他名稱)，然後在程序編譯時決定。首先我們來看一個具體的類型:</p>
<pre><pre class="playground"><code class="language-rust">fn gives_higher_i32(one: i32, two: i32) {
    let higher = if one &gt; two { one } else { two };
    println!(&quot;{} is higher.&quot;, higher);
}

fn main() {
    gives_higher_i32(8, 10);
}
</code></pre></pre>
<p>這個打印:<code>10 is higher.</code>.</p>
<p>但是這個只接受<code>i32</code>，所以現在我們要把它做成通用的。我們需要比較，我們需要用<code>{}</code>打印，所以我們的類型T需要<code>PartialOrd</code>和<code>Display</code>。記住，這意味著 &quot;只接受已經實現<code>PartialOrd</code>和<code>Display</code>的類型&quot;。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn gives_higher_i32&lt;T: PartialOrd + Display&gt;(one: T, two: T) {
    let higher = if one &gt; two { one } else { two };
    println!(&quot;{} is higher.&quot;, higher);
}

fn main() {
    gives_higher_i32(8, 10);
}
</code></pre></pre>
<p>現在我們來看看<code>impl Trait</code>，它也是類似的。我們可以引入一個類型 <code>impl Trait</code>，而不是 <code>T</code>。然後它將帶入一個實現該特性的類型。這幾乎是一樣的。</p>
<pre><pre class="playground"><code class="language-rust">fn prints_it(input: impl Into&lt;String&gt; + std::fmt::Display) { // Takes anything that can turn into a String and has Display
    println!(&quot;You can print many things, including {}&quot;, input);
}

fn main() {
    let name = &quot;Tuon&quot;;
    let string_name = String::from(&quot;Tuon&quot;);
    prints_it(name);
    prints_it(string_name);
}
</code></pre></pre>
<p>然而，更有趣的是，我們可以返回 <code>impl Trait</code>，這讓我們可以返回閉包，因為它們的函數簽名是trait。你可以在有它們的方法的簽名中看到這一點。例如，這是 <code>.map()</code> 的簽名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;     // 🚧
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B,
    {
        Map::new(self, f)
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>fn map&lt;B, F&gt;(self, f: F)</code>的意思是，它需要兩個通用類型。<code>F</code>是指從實現<code>.map()</code>的容器中取一個元素的函數，<code>B</code>是該函數的返回類型。然後在<code>where</code>之後，我們看到的是trait bound。(&quot;trait bound&quot;的意思是 &quot;它必須有這個trait&quot;。)一個是<code>Sized</code>，接下來是閉包簽名。它必須是一個 <code>FnMut</code>，並在 <code>Self::Item</code> 上做閉包，也就是你給它的迭代器。然後它返回<code>B</code>。</p>
<p>所以我們可以用同樣的方法來返回一個閉包。要返回一個閉包，使用 <code>impl</code>，然後是閉包簽名。一旦你返回它，你就可以像使用一個函數一樣使用它。下面是一個函數的小例子，它根據你輸入的文本給出一個閉包。如果你輸入 &quot;double &quot;或 &quot;triple&quot;，那麼它就會把它乘以2或3，否則就會返給你相同的數字。因為它是一個閉包，我們可以做任何我們想做的事情，所以我們也打印一條信息。</p>
<pre><pre class="playground"><code class="language-rust">fn returns_a_closure(input: &amp;str) -&gt; impl FnMut(i32) -&gt; i32 {
    match input {
        &quot;double&quot; =&gt; |mut number| {
            number *= 2;
            println!(&quot;Doubling number. Now it is {}&quot;, number);
            number
        },
        &quot;triple&quot; =&gt; |mut number| {
            number *= 40;
            println!(&quot;Tripling number. Now it is {}&quot;, number);
            number
        },
        _ =&gt; |number| {
            println!(&quot;Sorry, it's the same: {}.&quot;, number);
            number
        },
    }
}

fn main() {
    let my_number = 10;

    // Make three closures
    let mut doubles = returns_a_closure(&quot;double&quot;);
    let mut triples = returns_a_closure(&quot;triple&quot;);
    let mut quadruples = returns_a_closure(&quot;quadruple&quot;);

    doubles(my_number);
    triples(my_number);
    quadruples(my_number);
}
</code></pre></pre>
<p>下面是一個比較長的例子。讓我們想象一下，在一個遊戲中，你的角色面對的是晚上比較強的怪物。我們可以創建一個叫<code>TimeOfDay</code>的枚舉來記錄一天的情況。你的角色叫西蒙，有一個叫<code>character_fear</code>的數字，也就是<code>f64</code>。它晚上上升，白天下降。我們將創建一個<code>change_fear</code>函數，改變他的恐懼，但也做其他事情，如寫消息。它大概是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">enum TimeOfDay { // just a simple enum
    Dawn,
    Day,
    Sunset,
    Night,
}

fn change_fear(input: TimeOfDay) -&gt; impl FnMut(f64) -&gt; f64 { // The function takes a TimeOfDay. It returns a closure.
                                                             // We use impl FnMut(64) -&gt; f64 to say that it needs to
                                                             // change the value, and also gives the same type back.
    use TimeOfDay::*; // So we only have to write Dawn, Day, Sunset, Night
                      // Instead of TimeOfDay::Dawn, TimeOfDay::Day, etc.
    match input {
        Dawn =&gt; |x| { // This is the variable character_fear that we give it later
            println!(&quot;The morning sun has vanquished the horrible night. You no longer feel afraid.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 0.5);
            x * 0.5
        },
        Day =&gt; |x| {
            println!(&quot;What a nice day. Maybe put your feet up and rest a bit.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 0.2);
            x * 0.2
        },
        Sunset =&gt; |x| {
            println!(&quot;The sun is almost down! This is no good.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 1.4);
            x * 1.4
        },
        Night =&gt; |x| {
            println!(&quot;What a horrible night to have a curse.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 5.0);
            x * 5.0
        },
    }
}

fn main() {
    use TimeOfDay::*;
    let mut character_fear = 10.0; // Start Simon with 10

    let mut daytime = change_fear(Day); // Make four closures here to call every time we want to change Simon's fear.
    let mut sunset = change_fear(Sunset);
    let mut night = change_fear(Night);
    let mut morning = change_fear(Dawn);

    character_fear = daytime(character_fear); // Call the closures on Simon's fear. They give a message and change the fear number.
                                              // In real life we would have a Character struct and use it as a method instead,
                                              // like this: character_fear.daytime()
    character_fear = sunset(character_fear);
    character_fear = night(character_fear);
    character_fear = morning(character_fear);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">What a nice day. Maybe put your feet up and rest a bit.
Your fear is now 2
The sun is almost down! This is no good.
Your fear is now 2.8
What a horrible night to have a curse.
Your fear is now 14
The morning sun has vanquished the horrible night. You no longer feel afraid.
Your fear is now 7
</code></pre>
<h2 id="arc-1"><a class="header" href="#arc-1">Arc</a></h2>
<p>你還記得我們用<code>Rc</code>來給一個變量一個以上的所有者。如果我們在線程中做同樣的事情，我們需要一個 <code>Arc</code>。<code>Arc</code>的意思是 &quot;atomic reference counter&quot;(原子引用計數器)。原子的意思是它使用計算機的處理器，所以每次只寫一次數據。這一點很重要，因為如果兩個線程同時寫入數據，你會得到錯誤的結果。例如，想象一下，如果你能在Rust中做到這一點。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let mut x = 10;

for i in 0..10 { // Thread 1
    x += 1
}
for i in 0..10 { // Thread 2
    x += 1
}
<span class="boring">}
</span></code></pre></pre>
<p>如果線程1和線程2一起啟動，也許就會出現這種情況。</p>
<ul>
<li>線程1看到10，寫下11，然後線程2看到11，寫下12 然後線程2看到11，寫入12。到目前為止沒有問題。</li>
<li>線程1看到12。同時，線程2看到12。線程一看到13，寫下13 線程2也寫了13 現在我們有13個，但應該是14個 Now we have 13, but it should be 14. 這是個大問題。</li>
</ul>
<p><code>Arc</code>使用處理器來確保這種情況不會發生，所以當你有線程時必須使用這種方法。不過不建議單線程上用<code>Arc</code>，因為<code>Rc</code>更快一些。</p>
<p>不過你不能只用一個<code>Arc</code>來改變數據。所以你用一個<code>Mutex</code>把數據包起來，然後用一個<code>Arc</code>把<code>Mutex</code>包起來。</p>
<p>所以我們用一個<code>Mutex</code>在一個<code>Arc</code>裡面來改變一個數字的值。首先我們設置一個線程。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        println!(&quot;The thread is working!&quot;) // Just testing the thread
    });

    handle.join().unwrap(); // Make the thread wait here until it is done
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>到目前為止，這個只打印:</p>
<pre><code class="language-text">The thread is working!
Exiting the program
</code></pre>
<p>很好，現在讓我們把它放在<code>for</code>的循環中，進行<code>0..5</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;The thread is working!&quot;)
        }
    });

    handle.join().unwrap();
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>這也是可行的。我們得到以下結果:</p>
<pre><code class="language-text">The thread is working!
The thread is working!
The thread is working!
The thread is working!
The thread is working!
Exiting the program
</code></pre>
<p>現在我們再加一個線程。每個線程都會做同樣的事情。你可以看到，這些線程是在同一時間工作的。有時會先打印<code>Thread 1 is working!</code>，但其他時候<code>Thread 2 is working!</code>先打印。這就是所謂的<strong>併發</strong>，也就是 &quot;一起運行&quot;的意思。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let thread1 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;Thread 1 is working!&quot;)
        }
    });

    let thread2 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;Thread 2 is working!&quot;)
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Exiting the program
</code></pre>
<p>現在我們要改變<code>my_number</code>的數值。現在它是一個<code>i32</code>。我們將把它改為 <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>:一個可以改變的 <code>i32</code>，由 <code>Arc</code> 保護。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let my_number = Arc::new(Mutex::new(0));
<span class="boring">}
</span></code></pre></pre>
<p>現在我們有了這個，我們可以克隆它。每個克隆可以進入不同的線程。我們有兩個線程，所以我們將做兩個克隆。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let my_number = Arc::new(Mutex::new(0));

let my_number1 = Arc::clone(&amp;my_number); // This clone goes into Thread 1
let my_number2 = Arc::clone(&amp;my_number); // This clone goes into Thread 2
<span class="boring">}
</span></code></pre></pre>
<p>現在，我們已經將安全克隆連接到<code>my_number</code>，我們可以將它們<code>move</code>到其他線程中，沒有問題。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));

    let my_number1 = Arc::clone(&amp;my_number);
    let my_number2 = Arc::clone(&amp;my_number);

    let thread1 = std::thread::spawn(move || { // Only the clone goes into Thread 1
        for _ in 0..10 {
            *my_number1.lock().unwrap() +=1; // Lock the Mutex, change the value
        }
    });

    let thread2 = std::thread::spawn(move || { // Only the clone goes into Thread 2
        for _ in 0..10 {
            *my_number2.lock().unwrap() += 1;
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!(&quot;Value is: {:?}&quot;, my_number);
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>程序打印:</p>
<pre><code class="language-text">Value is: Mutex { data: 20 }
Exiting the program
</code></pre>
<p>所以這是一個成功的案例。</p>
<p>然後我們可以將兩個線程連接在一起，形成一個<code>for</code>循環，並使代碼更短。</p>
<p>我們需要保存句柄，這樣我們就可以在循環外對每個線程調用<code>.join()</code>。如果我們在循環內這樣做，它將等待第一個線程完成後再啟動新的線程。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));
    let mut handle_vec = vec![]; // JoinHandles will go in here

    for _ in 0..2 { // do this twice
        let my_number_clone = Arc::clone(&amp;my_number); // Make the clone before starting the thread
        let handle = std::thread::spawn(move || { // Put the clone in
            for _ in 0..10 {
                *my_number_clone.lock().unwrap() += 1;
            }
        });
        handle_vec.push(handle); // save the handle so we can call join on it outside of the loop
                                 // If we don't push it in the vec, it will just die here
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // call join on all handles
    println!(&quot;{:?}&quot;, my_number);
}
</code></pre></pre>
<p>最後這個打印<code>Mutex { data: 20 }</code>。</p>
<p>這看起來很複雜，但<code>Arc&lt;Mutex&lt;SomeType&gt;&gt;&gt;</code>在Rust中使用的頻率很高，所以它變得很自然。另外，你也可以隨時寫你的代碼，讓它更乾淨。這裡是同樣的代碼，多了一條<code>use</code>語句和兩個函數。這些函數並沒有做任何新的事情，但是它們把一些代碼從<code>main()</code>中移出。如果你很難讀懂的話，可以嘗試重寫這樣的代碼。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread::spawn; // Now we just write spawn

fn make_arc(number: i32) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // Just a function to make a Mutex in an Arc
    Arc::new(Mutex::new(number))
}

fn new_clone(input: &amp;Arc&lt;Mutex&lt;i32&gt;&gt;) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // Just a function so we can write new_clone
    Arc::clone(&amp;input)
}

// Now main() is easier to read
fn main() {
    let mut handle_vec = vec![]; // each handle will go in here
    let my_number = make_arc(0);

    for _ in 0..2 {
        let my_number_clone = new_clone(&amp;my_number);
        let handle = spawn(move || {
            for _ in 0..10 {
                let mut value_inside = my_number_clone.lock().unwrap();
                *value_inside += 1;
            }
        });
        handle_vec.push(handle);    // the handle is done, so put it in the vector
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // Make each one wait

    println!(&quot;{:?}&quot;, my_number);
}
</code></pre></pre>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>A channel is an easy way to use many threads that send to one place.它們相當流行，因為它們很容易組合在一起。你可以在Rust中用<code>std::sync::mpsc</code>創建一個channel。<code>mpsc</code>的意思是 &quot;多個生產者，單個消費者&quot;，所以 &quot;many threads sending to one place&quot;。要啟動一個通道，你可以使用 <code>channel()</code>。這將創建一個 <code>Sender</code> 和一個 <code>Receiver</code>，它們被綁在一起。你可以在函數簽名中看到這一點。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn channel&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;)
<span class="boring">}
</span></code></pre></pre>
<p>所以你要選擇一個發送者的名字和一個接收者的名字。通常你會看到像<code>let (sender, receiver) = channel();</code>這樣的開頭。因為它是泛型函數，如果你只寫這個，Rust不會知道類型。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel(); // ⚠️
}
</code></pre></pre>
<p>編譯器說:</p>
<pre><code class="language-text">error[E0282]: type annotations needed for `(std::sync::mpsc::Sender&lt;T&gt;, std::sync::mpsc::Receiver&lt;T&gt;)`
  --&gt; src\main.rs:30:30
   |
30 |     let (sender, receiver) = channel();
   |         ------------------   ^^^^^^^ cannot infer type for type parameter `T` declared on the function `channel`
   |         |
   |         consider giving this pattern the explicit type `(std::sync::mpsc::Sender&lt;T&gt;, std::sync::mpsc::Receiver&lt;T&gt;)`, where
the type parameter `T` is specified
</code></pre>
<p>它建議為<code>Sender</code>和<code>Receiver</code>添加一個類型。如果你願意的話，可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{channel, Sender, Receiver}; // Added Sender and Receiver here

fn main() {
    let (sender, receiver): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = channel();
}
</code></pre></pre>
<p>但你不必這樣做: 一旦你開始使用<code>Sender</code>和<code>Receiver</code>，Rust就能猜到類型。</p>
<p>所以我們來看一下最簡單的使用通道的方法。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();

    sender.send(5);
    receiver.recv(); // recv = receive, not &quot;rec v&quot;
}
</code></pre></pre>
<p>現在編譯器知道類型了。<code>sender</code>是<code>Result&lt;(), SendError&lt;i32&gt;&gt;</code>，<code>receiver</code>是<code>Result&lt;i32, RecvError&gt;</code>。所以你可以用<code>.unwrap()</code>來看看發送是否有效，或者使用更好的錯誤處理。我們加上<code>.unwrap()</code>，也加上<code>println!</code>，看看得到什麼。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();

    sender.send(5).unwrap();
    println!(&quot;{}&quot;, receiver.recv().unwrap());
}
</code></pre></pre>
<p>這樣就可以打印出<code>5</code>。</p>
<p><code>channel</code>就像<code>Arc</code>一樣，因為你可以克隆它，並將克隆的內容發送到其他線程中。讓我們創建兩個線程，並將值發送到<code>receiver</code>。這段代碼可以工作，但它並不完全是我們想要的。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();

    std::thread::spawn(move|| { // move sender in
        sender.send(&quot;Send a &amp;str this time&quot;).unwrap();
    });

    std::thread::spawn(move|| { // move sender_clone in
        sender_clone.send(&quot;And here is another &amp;str&quot;).unwrap();
    });

    println!(&quot;{}&quot;, receiver.recv().unwrap());
}
</code></pre></pre>
<p>兩個線程開始發送，然後我們<code>println!</code>。它可能會打印 <code>Send a &amp;str this time</code> 或 <code>And here is another &amp;str</code>，這取決於哪個線程先完成。讓我們創建一個join句柄來等待它們完成。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![]; // Put our handles in here

    handle_vec.push(std::thread::spawn(move|| {  // push this into the vec
        sender.send(&quot;Send a &amp;str this time&quot;).unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {  // and push this into the vec
        sender_clone.send(&quot;And here is another &amp;str&quot;).unwrap();
    }));

    for _ in handle_vec { // now handle_vec has 2 items. Let's print them
        println!(&quot;{:?}&quot;, receiver.recv().unwrap());
    }
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">&quot;Send a &amp;str this time&quot;
&quot;And here is another &amp;str&quot;
</code></pre>
<p>現在我們不打印，我們創建一個<code>results_vec</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![];
    let mut results_vec = vec![];

    handle_vec.push(std::thread::spawn(move|| {
        sender.send(&quot;Send a &amp;str this time&quot;).unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {
        sender_clone.send(&quot;And here is another &amp;str&quot;).unwrap();
    }));

    for _ in handle_vec {
        results_vec.push(receiver.recv().unwrap());
    }

    println!(&quot;{:?}&quot;, results_vec);
}
</code></pre></pre>
<p>現在結果在我們的vec中:<code>[&quot;Send a &amp;str this time&quot;, &quot;And here is another &amp;str&quot;]</code>。</p>
<p>現在讓我們假設我們有很多工作要做，並且想要使用線程。我們有一個大的VEC，裡面有1百萬個元素，都是0，我們想把每個0都變成1，我們將使用10個線程，每個線程將做十分之一的工作。我們將創建一個新的VEC，並使用<code>.extend()</code>來收集結果。</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;
use std::thread::spawn;

fn main() {
    let (sender, receiver) = channel();
    let hugevec = vec![0; 1_000_000];
    let mut newvec = vec![];
    let mut handle_vec = vec![];

    for i in 0..10 {
        let sender_clone = sender.clone();
        let mut work: Vec&lt;u8&gt; = Vec::with_capacity(hugevec.len() / 10); // new vec to put the work in. 1/10th the size
        work.extend(&amp;hugevec[i*100_000..(i+1)*100_000]); // first part gets 0..100_000, next gets 100_000..200_000, etc.
        let handle =spawn(move || { // make a handle

            for number in work.iter_mut() { // do the actual work
                *number += 1;
            };
            sender_clone.send(work).unwrap(); // use the sender_clone to send the work to the receiver
        });
        handle_vec.push(handle);
    }

    for handle in handle_vec { // stop until the threads are done
        handle.join().unwrap();
    }

    while let Ok(results) = receiver.try_recv() {
        newvec.push(results); // push the results from receiver.recv() into the vec
    }

    // Now we have a Vec&lt;Vec&lt;u8&gt;&gt;. To put it together we can use .flatten()
    let newvec = newvec.into_iter().flatten().collect::&lt;Vec&lt;u8&gt;&gt;(); // Now it's one vec of 1_000_000 u8 numbers

    println!(&quot;{:?}, {:?}, total length: {}&quot;, // Let's print out some numbers to make sure they are all 1
        &amp;newvec[0..10], &amp;newvec[newvec.len()-10..newvec.len()], newvec.len() // And show that the length is 1_000_000 items
    );

    for number in newvec { // And let's tell Rust that it can panic if even one number is not 1
        if number != 1 {
            panic!();
        }
    }
}
</code></pre></pre>
<h2 id="閱讀rust文檔"><a class="header" href="#閱讀rust文檔">閱讀Rust文檔</a></h2>
<p>知道如何閱讀Rust中的文檔是很重要的，這樣你就可以理解其他人寫的東西。這裡有一些Rust文檔中需要知道的事情。</p>
<h3 id="assert_eq"><a class="header" href="#assert_eq">assert_eq!</a></h3>
<p>你在做測試的時候看到<code>assert_eq!</code>是用的。你把兩個元素放在函數裡面，如果它們不相等，程序就會崩潰。下面是一個簡單的例子，我們需要一個偶數。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    prints_number(56);
}

fn prints_number(input: i32) {
    assert_eq!(input % 2, 0); // number must be equal.
                              // If number % 2 is not 0, it panics
    println!(&quot;The number is not odd. It is {}&quot;, input);
}
</code></pre></pre>
<p>也許你沒有任何計劃在你的代碼中使用<code>assert_eq!</code>，但它在Rust文檔中隨處可見。這是因為在一個文檔中，你需要很大的空間來<code>println!</code>一切。另外，你會需要<code>Display</code>或<code>Debug</code>來打印你想打印的東西。這就是為什麼文檔中到處都有<code>assert_eq!</code>的原因。下面是這裡的一個例子<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a>，展示瞭如何使用Vec。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2);
    assert_eq!(vec[0], 1);

    assert_eq!(vec.pop(), Some(2));
    assert_eq!(vec.len(), 1);

    vec[0] = 7;
    assert_eq!(vec[0], 7);

    vec.extend([1, 2, 3].iter().copied());

    for x in &amp;vec {
        println!(&quot;{}&quot;, x);
    }
    assert_eq!(vec, [7, 1, 2, 3]);
}
</code></pre></pre>
<p>在這些例子中，你可以只把<code>assert_eq!(a, b)</code>看成是在說 &quot;a是b&quot;。現在看看右邊帶有註釋的同一個例子。註釋顯示了它的實際含義。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2); // &quot;The vec length is 2&quot;
    assert_eq!(vec[0], 1); // &quot;vec[0] is 1&quot;

    assert_eq!(vec.pop(), Some(2)); // &quot;When you use .pop(), you get Some()&quot;
    assert_eq!(vec.len(), 1); // &quot;The vec length is now 1&quot;

    vec[0] = 7;
    assert_eq!(vec[0], 7); // &quot;Vec[0] is 7&quot;

    vec.extend([1, 2, 3].iter().copied());

    for x in &amp;vec {
        println!(&quot;{}&quot;, x);
    }
    assert_eq!(vec, [7, 1, 2, 3]); // &quot;The vec now has [7, 1, 2, 3]&quot;
}
</code></pre></pre>
<h3 id="搜索"><a class="header" href="#搜索">搜索</a></h3>
<p>Rust 文檔的頂部欄是搜索欄。它在你輸入時顯示結果。當你往下翻時，你不能再看到搜索欄，但如果你按鍵盤上的<strong>s</strong>鍵，你可以再次搜索。所以在任何地方按<strong>s</strong>鍵可以讓你馬上搜索。</p>
<h3 id="src-按鈕"><a class="header" href="#src-按鈕">[src] 按鈕</a></h3>
<p>通常一個方法、結構體等的代碼不會是完整的。這是因為你通常不需要看到完整的源碼就能知道它是如何工作的，而完整的代碼可能會讓人困惑。但如果你想知道更多，你可以點擊[src]就可以看到所有的內容。例如，在<code>String</code>的頁面上，你可以看到<code>.with_capacity()</code>的這個簽名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn with_capacity(capacity: usize) -&gt; String
<span class="boring">}
</span></code></pre></pre>
<p>好了，你輸入一個數字，它給你一個<code>String</code>。這很簡單，但也許我們很好奇，想看更多。如果你點擊[src]你可以看到這個。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn with_capacity(capacity: usize) -&gt; String {
    String { vec: Vec::with_capacity(capacity) }
}
<span class="boring">}
</span></code></pre></pre>
<p>有趣的是，現在你可以看到，字符串是<code>Vec</code>的一種。而實際上一個<code>String</code>是一個<code>u8</code>字節的向量，這很有意思。你不需要知道，就可以使用<code>with_capacity</code>的方法，你只有點擊[src]才能看到。所以如果文檔沒有太多細節，而你又想知道更多的話，點擊[src]是個好主意。</p>
<h3 id="trait信息"><a class="header" href="#trait信息">trait信息</a></h3>
<p>trait文檔的重要部分是左邊的 &quot;Required Methods&quot;。如果你看到 &quot;Required Methods&quot;，可能意味著你必須自己編寫方法。例如，對於 <code>Iterator</code>，你需要寫 <code>.next()</code> 方法。而對於<code>From</code>，你需要寫<code>.from()</code>方法。但是有些trait只需要一個<strong>屬性</strong>就可以實現，比如我們在<code>#[derive(Debug)]</code>中看到的。<code>Debug</code>需要<code>.fmt()</code>方法，但通常你只需要使用<code>#[derive(Debug)]</code>，除非你想自己做。這就是為什麼在<code>std::fmt::Debug</code>的頁面上說 &quot;一般來說，你應該直接派生出一個Debug實現&quot;。</p>
<h2 id="屬性"><a class="header" href="#屬性">屬性</a></h2>
<p>你以前見過<code>#[derive(Debug)]</code>這樣的代碼:這種類型的代碼叫做<em>屬性</em>。這些屬性是給編譯器提供信息的小段代碼。它們不容易創建，但使用起來非常方便。如果你只用<code>#</code>寫一個屬性，那麼它將影響下一行的代碼。但如果你用<code>#!</code>來寫，那麼它將影響自己空間裡的一切。</p>
<p>下面是一些你會經常看到的屬性。</p>
<p><code>#[allow(dead_code)]</code> 和 <code>#[allow(unused_variables)]</code>。 如果你寫了不用的代碼，Rust仍然會編譯，但會讓你知道。例如，這裡有一個結構體，裡面什麼都沒有，只有一個變量。我們不使用它們中的任何一個。</p>
<pre><pre class="playground"><code class="language-rust">struct JustAStruct {}

fn main() {
    let some_char = 'ん';
}
</code></pre></pre>
<p>如果你這樣寫，Rust會提醒你，你沒有使用它們。</p>
<pre><code class="language-text">warning: unused variable: `some_char`
 --&gt; src\main.rs:4:9
  |
4 |     let some_char = 'ん';
  |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_some_char`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: struct is never constructed: `JustAStruct`
 --&gt; src\main.rs:1:8
  |
1 | struct JustAStruct {}
  |        ^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default
</code></pre>
<p>我們知道，可以在名字前寫一個<code>_</code>，讓編譯器安靜下來。</p>
<pre><pre class="playground"><code class="language-rust">struct _JustAStruct {}

fn main() {
    let _some_char = 'ん';
}
</code></pre></pre>
<p>但你也可以使用屬性。你會注意到在消息中，它使用了<code>#[warn(unused_variables)]</code>和<code>#[warn(dead_code)]</code>。在我們的代碼中，<code>JustAStruct</code>是死代碼，而<code>some_char</code>是一個未使用的變量。<code>warn</code>的反義詞是<code>allow</code>，所以我們可以這樣寫，它不會說什麼。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)]
#![allow(unused_variables)]

struct Struct1 {} // Create five structs
struct Struct2 {}
struct Struct3 {}
struct Struct4 {}
struct Struct5 {}

fn main() {
    let char1 = 'ん'; // and four variables. We don't use any of them but the compiler is quiet
    let char2 = ';';
    let some_str = &quot;I'm just a regular &amp;str&quot;;
    let some_vec = vec![&quot;I&quot;, &quot;am&quot;, &quot;just&quot;, &quot;a&quot;, &quot;vec&quot;];
}
</code></pre></pre>
<p>當然，處理死代碼和未使用的變量是很重要的。但有時你希望編譯器安靜一段時間。或者您可能需要展示一些代碼或教人們Rust，但又不想用編譯器的信息來迷惑他們。</p>
<p><code>#[derive(TraitName)]</code>讓你可以為你創建的結構和枚舉派生一些trait。這適用於許多可以自動派生的常見trait。有些像 <code>Display</code> 這樣的特性不能自動衍生，因為對於 <code>Display</code>，你必須選擇如何顯示。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
#[derive(Display)]
struct HoldsAString {
    the_string: String,
}

fn main() {
    let my_string = HoldsAString {
        the_string: &quot;Here I am!&quot;.to_string(),
    };
}
</code></pre></pre>
<p>錯誤信息會告訴你:</p>
<pre><code class="language-text">error: cannot find derive macro `Display` in this scope
 --&gt; src\main.rs:2:10
  |
2 | #[derive(Display)]
  |
</code></pre>
<p>但是對於可以自動推導出的trait，你可以隨心所欲的放進去。讓我們給<code>HoldsAString</code>在一行中加入七個trait，只是為了好玩，儘管它只需要一個。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, PartialEq, Eq, Ord, PartialOrd, Hash, Clone)]
struct HoldsAString {
    the_string: String,
}

fn main() {
    let my_string = HoldsAString {
        the_string: &quot;Here I am!&quot;.to_string(),
    };
    println!(&quot;{:?}&quot;, my_string);
}
</code></pre></pre>
<p>另外，如果(也只有在)它的字段都實現了<code>Copy</code>的情況下，你才可以創建一個<code>Copy</code>結構。<code>HoldsAString</code>包含<code>String</code>，它沒有實現<code>Copy</code>，所以你不能對它使用<code>#[derive(Copy)]</code>。但是對下面這個結構你可以:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // You also need Clone to use Copy
struct NumberAndBool {
    number: i32, // i32 is Copy
    true_or_false: bool // bool is also Copy. So no problem
}

fn does_nothing(input: NumberAndBool) {

}

fn main() {
    let number_and_bool = NumberAndBool {
        number: 8,
        true_or_false: true
    };

    does_nothing(number_and_bool);
    does_nothing(number_and_bool); // If it didn't have copy, this would make an error
}
</code></pre></pre>
<p><code>#[cfg()]</code>的意思是配置，告訴編譯器是否運行代碼。它通常是這樣的:<code>#[cfg(test)]</code>。你在寫測試函數的時候用這個，這樣它就知道除非你在測試，否則不要運行它們。那麼你可以在你的代碼附近寫測試，但編譯器不會運行它們，除非你告訴編譯器。</p>
<p>還有一個使用<code>cfg</code>的例子是<code>#[cfg(target_os = &quot;windows&quot;)]</code>。有了它，你可以告訴編譯器只在Windows，Linux或其他平臺則不能運行代碼。</p>
<p><code>#![no_std]</code>是一個有趣的屬性，它告訴Rust不要引入標準庫。這意味著你沒有<code>Vec</code>，<code>String</code>，以及標準庫中的其他任何東西。你會在那些沒有多少內存或空間的小型設備的代碼中看到這個。</p>
<p>你可以在<a href="https://doc.rust-lang.org/reference/attributes.html">這裡</a>看到更多的屬性。</p>
<h2 id="box-1"><a class="header" href="#box-1">Box</a></h2>
<p><code>Box</code> 是 Rust 中一個非常方便的類型。當你使用<code>Box</code>時，你可以把一個類型放在堆上而不是棧上。要創建一個新的 <code>Box</code>，只需使用 <code>Box::new()</code> 並將元素放在裡面即可。</p>
<pre><pre class="playground"><code class="language-rust">fn just_takes_a_variable&lt;T&gt;(item: T) {} // Takes anything and drops it.

fn main() {
    let my_number = 1; // This is an i32
    just_takes_a_variable(my_number);
    just_takes_a_variable(my_number); // Using this function twice is no problem, because it's Copy

    let my_box = Box::new(1); // This is a Box&lt;i32&gt;
    just_takes_a_variable(my_box.clone()); // Without .clone() the second function would make an error
    just_takes_a_variable(my_box); // because Box is not Copy
}
</code></pre></pre>
<p>一開始很難想象在哪裡使用它，但你在Rust中經常使用它。你記得<code>&amp;</code>是用於<code>str</code>的，因為編譯器不知道<code>str</code>的大小:它可以是任何長度。但是<code>&amp;</code>的引用總是相同的長度，所以編譯器可以使用它。<code>Box</code>也是類似的。另外，你也可以在<code>Box</code>上使用<code>*</code>來獲取值，就像使用<code>&amp;</code>一樣。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_box = Box::new(1); // This is a Box&lt;i32&gt;
    let an_integer = *my_box; // This is an i32
    println!(&quot;{:?}&quot;, my_box);
    println!(&quot;{:?}&quot;, an_integer);
}
</code></pre></pre>
<p>這就是為什麼Box被稱為 &quot;智能指針&quot;的原因，因為它就像<code>&amp;</code>的引用(指針的一種)，但可以做更多的事情。</p>
<p>你也可以使用Box來創建裡面有相同結構的結構體。這些結構被稱為<em>遞歸</em>，這意味著在Struct A裡面也許是另一個Struct A，有時你可以使用Box來創建鏈表，儘管這在Rust中並不十分流行。但如果你想創建一個遞歸結構，你可以使用<code>Box</code>。如果你試著不用 <code>Box</code> 會發生什麼:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct List {
    item: Option&lt;List&gt;, // ⚠️
}
<span class="boring">}
</span></code></pre></pre>
<p>這個簡單的<code>List</code>有一項，可能是<code>Some&lt;List&gt;</code>(另一個列表)，也可能是<code>None</code>。因為你可以選擇<code>None</code>，所以它不會永遠遞歸。但是編譯器還是不知道大小。</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
  --&gt; src\main.rs:16:1
   |
16 | struct List {
   | ^^^^^^^^^^^ recursive type has infinite size
17 |     item: Option&lt;List&gt;,
   |     ------------------ recursive without indirection
   |
   = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<p>你可以看到，它甚至建議嘗試<code>Box</code>。所以我們用<code>Box</code>把List包裹起來。</p>
<pre><pre class="playground"><code class="language-rust">struct List {
    item: Option&lt;Box&lt;List&gt;&gt;,
}
fn main() {}
</code></pre></pre>
<p>現在編譯器用<code>List</code>就可以了，因為所有的東西都在<code>Box</code>後面，而且它知道<code>Box</code>的大小。那麼一個非常簡單的列表可能是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">struct List {
    item: Option&lt;Box&lt;List&gt;&gt;,
}

impl List {
    fn new() -&gt; List {
        List {
            item: Some(Box::new(List { item: None })),
        }
    }
}

fn main() {
    let mut my_list = List::new();
}
</code></pre></pre>
<p>即使沒有數據也有點複雜，Rust並不怎麼使用這種類型的模式。這是因為Rust對借用和所有權有嚴格的規定，你知道的。但如果你想啟動一個這樣的列表(鏈表)，<code>Box</code>可以幫助你。</p>
<p><code>Box</code>還可以讓你在上面使用<code>std::mem::drop</code>，因為它在堆上。這有時會很方便。</p>
<h2 id="用box包裹trait"><a class="header" href="#用box包裹trait">用Box包裹trait</a></h2>
<p><code>Box</code>對於返回trait非常有用。你可以像這個例子一樣用泛型函數寫trait:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

struct DoesntImplementDisplay {}

fn displays_it&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input);
}

fn main() {}
</code></pre></pre>
<p>這個只能接受<code>Display</code>的東西，所以它不能接受我們的<code>DoesntImplementDisplay</code>結構。但是它可以接受很多其他的東西，比如<code>String</code>。</p>
<p>你也看到了，我們可以使用 <code>impl Trait</code> 來返回其他的trait，或者閉包。<code>Box</code>也可以用類似的方式使用。你可以使用 <code>Box</code>，否則編譯器將不知道值的大小。這個例子表明，trait可以用在任何大小的東西上:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)] // Tell the compiler to be quiet
use std::mem::size_of; // This gives the size of a type

trait JustATrait {} // We will implement this on everything

enum EnumOfNumbers {
    I8(i8),
    AnotherI8(i8),
    OneMoreI8(i8),
}
impl JustATrait for EnumOfNumbers {}

struct StructOfNumbers {
    an_i8: i8,
    another_i8: i8,
    one_more_i8: i8,
}
impl JustATrait for StructOfNumbers {}

enum EnumOfOtherTypes {
    I8(i8),
    AnotherI8(i8),
    Collection(Vec&lt;String&gt;),
}
impl JustATrait for EnumOfOtherTypes {}

struct StructOfOtherTypes {
    an_i8: i8,
    another_i8: i8,
    a_collection: Vec&lt;String&gt;,
}
impl JustATrait for StructOfOtherTypes {}

struct ArrayAndI8 {
    array: [i8; 1000], // This one will be very large
    an_i8: i8,
    in_u8: u8,
}
impl JustATrait for ArrayAndI8 {}

fn main() {
    println!(
        &quot;{}, {}, {}, {}, {}&quot;,
        size_of::&lt;EnumOfNumbers&gt;(),
        size_of::&lt;StructOfNumbers&gt;(),
        size_of::&lt;EnumOfOtherTypes&gt;(),
        size_of::&lt;StructOfOtherTypes&gt;(),
        size_of::&lt;ArrayAndI8&gt;(),
    );
}
</code></pre></pre>
<p>當我們打印這些東西的size的時候，我們得到<code>2, 3, 32, 32, 1002</code>。所以如果你像下面這樣做的話，會得到一個錯誤：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ⚠️
fn returns_just_a_trait() -&gt; JustATrait {
    let some_enum = EnumOfNumbers::I8(8);
    some_enum
}
<span class="boring">}
</span></code></pre></pre>
<p>它說：</p>
<pre><code class="language-text">error[E0746]: return type cannot have an unboxed trait object
  --&gt; src\main.rs:53:30
   |
53 | fn returns_just_a_trait() -&gt; JustATrait {
   |                              ^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>而這是真的，因為size可以是2，3，32，1002，或者其他任何東西。所以我們把它放在一個<code>Box</code>中。在這裡我們還要加上<code>dyn</code>這個關鍵詞。<code>dyn</code>這個詞告訴你，你說的是一個trait，而不是一個結構體或其他任何東西。</p>
<p>所以你可以把函數改成這樣。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
fn returns_just_a_trait() -&gt; Box&lt;dyn JustATrait&gt; {
    let some_enum = EnumOfNumbers::I8(8);
    Box::new(some_enum)
}
<span class="boring">}
</span></code></pre></pre>
<p>現在它工作了，因為在棧上只是一個<code>Box</code>，我們知道<code>Box</code>的大小。</p>
<p>你會經常看到<code>Box&lt;dyn Error&gt;</code>這種形式，因為有時你可能會有多個可能的錯誤。</p>
<p>我們可以快速創建兩個錯誤類型來顯示這一點。要創建一個正式的錯誤類型，你必須為它實現<code>std::error::Error</code>。這部分很容易:只要寫出 <code>impl std::error::Error {}</code>。但錯誤還需要<code>Debug</code>和<code>Display</code>，這樣才能給出問題的信息。<code>Debug</code>只要加上<code>#[derive(Debug)]</code>就行，很容易，但<code>Display</code>需要<code>.fmt()</code>方法。我們之前做過一次。</p>
<p>代碼是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct ErrorOne;

impl Error for ErrorOne {} // Now it is an error type with Debug. Time for Display:

impl fmt::Display for ErrorOne {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;You got the first error!&quot;) // All it does is write this message
    }
}


#[derive(Debug)] // Do the same thing with ErrorTwo
struct ErrorTwo;

impl Error for ErrorTwo {}

impl fmt::Display for ErrorTwo {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;You got the second error!&quot;)
    }
}

// Make a function that just returns a String or an error
fn returns_errors(input: u8) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; { // With Box&lt;dyn Error&gt; you can return anything that has the Error trait

    match input {
        0 =&gt; Err(Box::new(ErrorOne)), // Don't forget to put it in a box
        1 =&gt; Err(Box::new(ErrorTwo)),
        _ =&gt; Ok(&quot;Looks fine to me&quot;.to_string()), // This is the success type
    }

}

fn main() {

    let vec_of_u8s = vec![0_u8, 1, 80]; // Three numbers to try out

    for number in vec_of_u8s {
        match returns_errors(number) {
            Ok(input) =&gt; println!(&quot;{}&quot;, input),
            Err(message) =&gt; println!(&quot;{}&quot;, message),
        }
    }
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">You got the first error!
You got the second error!
Looks fine to me
</code></pre>
<p>如果我們沒有<code>Box&lt;dyn Error&gt;</code>，寫了這個，我們就有問題了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ⚠️
fn returns_errors(input: u8) -&gt; Result&lt;String, Error&gt; {
    match input {
        0 =&gt; Err(ErrorOne),
        1 =&gt; Err(ErrorTwo),
        _ =&gt; Ok(&quot;Looks fine to me&quot;.to_string()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它會告訴你。</p>
<pre><code class="language-text">21  | fn returns_errors(input: u8) -&gt; Result&lt;String, Error&gt; {
    |                                 ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>這並不奇怪，因為我們知道，一個trait可以作用於很多東西，而且它們各自有不同的大小。</p>
<h2 id="默認值和建造者模式"><a class="header" href="#默認值和建造者模式">默認值和建造者模式</a></h2>
<p>你可以實現 <code>Default</code> trait，給你認為最常見的 <code>struct</code> 或 <code>enum</code> 賦值。建造者模式可以很好地與之配合，讓用戶在需要時輕鬆地進行修改。首先我們來看看<code>Default</code>。實際上，Rust中的大多數通用類型已經有<code>Default</code>。它們並不奇怪。0, &quot;&quot;(空字符串), <code>false</code>, 等等。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let default_i8: i8 = Default::default();
    let default_str: String = Default::default();
    let default_bool: bool = Default::default();

    println!(&quot;'{}', '{}', '{}'&quot;, default_i8, default_str, default_bool);
}
</code></pre></pre>
<p>這將打印<code>'0', '', 'false'</code>。</p>
<p>所以<code>Default</code>就像<code>new</code>函數一樣，除了你不需要輸入任何東西。首先我們要創建一個<code>struct</code>，它還沒有實現<code>Default</code>。它有一個<code>new</code>函數，我們用它來創建一個名為Billy的角色，並提供一些統計信息。</p>
<pre><pre class="playground"><code class="language-rust">struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive { LifeState::Alive } else { LifeState::Dead },
        }
    }
}

fn main() {
    let character_1 = Character::new(&quot;Billy&quot;.to_string(), 15, 170, 70, true);
}
</code></pre></pre>
<p>但也許在我們的世界裡，我們希望大部分角色都叫比利，年齡15歲，身高170，體重70，還活著。我們可以實現<code>Default</code>，這樣我們就可以直接寫<code>Character::default()</code>。它看起來是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive {
                LifeState::Alive
            } else {
                LifeState::Dead
            },
        }
    }
}

impl Default for Character {
    fn default() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
}

fn main() {
    let character_1 = Character::default();

    println!(
        &quot;The character {:?} is {:?} years old.&quot;,
        character_1.name, character_1.age
    );
}
</code></pre></pre>
<p>打印出<code>The character &quot;Billy&quot; is 15 years old.</code>，簡單多了!</p>
<p>現在我們來看建造者模式。我們會有很多Billy，所以我們會保留默認的。但是很多其他角色只會有一點不同。建造者模式讓我們可以把小方法鏈接起來，每次改變一個值。這裡是一個<code>Character</code>的方法:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn height(mut self, height: u32) -&gt; Self {    // 🚧
    self.height = height;
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>一定要注意，它取的是<code>mut self</code>。我們之前看到過一次，它不是一個可變引用(<code>&amp;mut self</code>)。它佔用了<code>Self</code>的所有權，有了<code>mut</code>，它將是可變的，即使它之前不是可變的。這是因為<code>.height()</code>擁有完全的所有權，別人不能碰它，所以它是安全的，可變。它只是改變<code>self.height</code>，然後返回<code>Self</code>(就是<code>Character</code>)。</p>
<p>所以我們有三個這樣的構建方法。它們幾乎是一樣的:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn height(mut self, height: u32) -&gt; Self {     // 🚧
    self.height = height;
    self
}

fn weight(mut self, weight: u32) -&gt; Self {
    self.weight = weight;
    self
}

fn name(mut self, name: &amp;str) -&gt; Self {
    self.name = name.to_string();
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>每一個都會改變一個變量，並回饋給<code>Self</code>:這就是你在建造者模式中看到的。所以現在我們類似這樣寫來創建一個角色:<code>let character_1 = Character::default().height(180).weight(60).name(&quot;Bobby&quot;);</code>。如果你正在構建一個庫給別人使用，這可以讓他們很容易用起來。對最終用戶來說很容易，因為它幾乎看起來像自然的英語。&quot;給我一個默認角色，身高為180，體重為60，名字為Bobby.&quot; 到目前為止，我們的代碼看起來是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive {
                LifeState::Alive
            } else {
                LifeState::Dead
            },
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self
    }
}

impl Default for Character {
    fn default() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
}

fn main() {
    let character_1 = Character::default().height(180).weight(60).name(&quot;Bobby&quot;);

    println!(&quot;{:?}&quot;, character_1);
}
</code></pre></pre>
<p>最後一個要添加的方法通常叫<code>.build()</code>。這個方法是一種最終檢查。當你給用戶提供一個像<code>.height()</code>這樣的方法時，你可以確保他們只輸入一個<code>u32()</code>，但是如果他們輸入5000的身高怎麼辦？這在你正在做的遊戲中可能就不對了。我們最後將使用一個名為<code>.build()</code>的方法，返回一個<code>Result</code>。在它裡面我們將檢查用戶輸入是否正常，如果正常，我們將返回一個 <code>Ok(Self)</code>。</p>
<p>不過首先我們要改變<code>.new()</code>方法。我們不希望用戶再自由創建任何一種角色。所以我們將把<code>impl Default</code>的值移到<code>.new()</code>。而現在<code>.new()</code>不接受任何輸入。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new() -&gt; Self {    // 🚧
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>這意味著我們不再需要<code>impl Default</code>了，因為<code>.new()</code>有所有的默認值。所以我們可以刪除<code>impl Default</code>。</p>
<p>現在我們的代碼是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self
    }
}

fn main() {
    let character_1 = Character::new().height(180).weight(60).name(&quot;Bobby&quot;);

    println!(&quot;{:?}&quot;, character_1);
}
</code></pre></pre>
<p>這樣打印出來的結果是一樣的:<code>Character { name: &quot;Bobby&quot;, age: 15, height: 180, weight: 60, lifestate: Alive }</code>。</p>
<p>我們幾乎已經準備好寫<code>.build()</code>方法了，但是有一個問題:如何讓用戶使用它？現在用戶可以寫<code>let x = Character::new().height(76767);</code>，然後得到一個<code>Character</code>。有很多方法可以做到這一點，也許你能想出自己的方法。但是我們會在<code>Character</code>中增加一個<code>can_use: bool</code>的值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]       // 🚧
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
    can_use: bool, // Set whether the user can use the character
}

\\ Cut other code

    fn new() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
            can_use: true, // .new() always gives a good character, so it's true
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>而對於其他的方法，比如<code>.height()</code>，我們會將<code>can_use</code>設置為<code>false</code>。只有<code>.build()</code>會再次設置為<code>true</code>，所以現在用戶要用<code>.build()</code>做最後的檢查。我們要確保<code>height</code>不高於200，<code>weight</code>不高於300。另外，在我們的遊戲中，有一個不好的字叫<code>smurf</code>，我們不希望任何角色使用它。</p>
<p>我們的<code>.build()</code>方法是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build(mut self) -&gt; Result&lt;Character, String&gt; {      // 🚧
    if self.height &lt; 200 &amp;&amp; self.weight &lt; 300 &amp;&amp; !self.name.to_lowercase().contains(&quot;smurf&quot;) {
        self.can_use = true;
        Ok(self)
    } else {
        Err(&quot;Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)&quot;
            .to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>!self.name.to_lowercase().contains(&quot;smurf&quot;)</code> 確保用戶不會寫出類似 &quot;SMURF&quot;或 &quot;IamSmurf&quot;的字樣。它讓整個 <code>String</code> 都變成小寫(小字母)，並檢查 <code>.contains()</code> 而不是 <code>==</code>。而前面的<code>!</code>表示 &quot;不是&quot;。</p>
<p>如果一切正常，我們就把<code>can_use</code>設置為<code>true</code>，然後把<code>Ok</code>裡面的字符給用戶。</p>
<p>現在我們的代碼已經完成了，我們將創建三個不工作的角色，和一個工作的角色。最後的代碼是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
    can_use: bool, // Here is the new value
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
            can_use: true,  // .new() makes a fine character, so it is true
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self.can_use = false; // Now the user can't use the character
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self.can_use = false;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self.can_use = false;
        self
    }

    fn build(mut self) -&gt; Result&lt;Character, String&gt; {
        if self.height &lt; 200 &amp;&amp; self.weight &lt; 300 &amp;&amp; !self.name.to_lowercase().contains(&quot;smurf&quot;) {
            self.can_use = true;   // Everything is okay, so set to true
            Ok(self)               // and return the character
        } else {
            Err(&quot;Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)&quot;
                .to_string())
        }
    }
}

fn main() {
    let character_with_smurf = Character::new().name(&quot;Lol I am Smurf!!&quot;).build(); // This one contains &quot;smurf&quot; - not okay
    let character_too_tall = Character::new().height(400).build(); // Too tall - not okay
    let character_too_heavy = Character::new().weight(500).build(); // Too heavy - not okay
    let okay_character = Character::new()
        .name(&quot;Billybrobby&quot;)
        .height(180)
        .weight(100)
        .build();   // This character is okay. Name is fine, height and weight are fine

    // Now they are not Character, they are Result&lt;Character, String&gt;. So let's put them in a Vec so we can see them:
    let character_vec = vec![character_with_smurf, character_too_tall, character_too_heavy, okay_character];

    for character in character_vec { // Now we will print the character if it's Ok, and print the error if it's Err
        match character {
            Ok(character_info) =&gt; println!(&quot;{:?}&quot;, character_info),
            Err(err_info) =&gt; println!(&quot;{}&quot;, err_info),
        }
        println!(); // Then add one more line
    }
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Character { name: &quot;Billybrobby&quot;, age: 15, height: 180, weight: 100, lifestate: Alive, can_use: true }
</code></pre>
<h2 id="deref和derefmut"><a class="header" href="#deref和derefmut">Deref和DerefMut</a></h2>
<p><code>Deref</code>是讓你用<code>*</code>來解引用某些東西的trait。我們知道，一個引用和一個值是不一樣的。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
fn main() {
    let value = 7; // This is an i32
    let reference = &amp;7; // This is a &amp;i32
    println!(&quot;{}&quot;, value == reference);
}
</code></pre></pre>
<p>而Rust連<code>false</code>都不給，因為它甚至不會比較兩者。</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src\main.rs:4:26
  |
4 |     println!(&quot;{}&quot;, value == reference);
  |                          ^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>當然，這裡的解法是使用<code>*</code>。所以這將打印出<code>true</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let value = 7;
    let reference = &amp;7;
    println!(&quot;{}&quot;, value == *reference);
}
</code></pre></pre>
<p>現在讓我們想象一下一個簡單的類型，它只是容納一個數字。它就像一個<code>Box</code>，我們有一些想法為它提供一些額外的功能。但如果我們只是給它一個數字，
它就不能做那麼多了。</p>
<p>我們不能像使用<code>Box</code>那樣使用<code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
struct HoldsANumber(u8);

fn main() {
    let my_number = HoldsANumber(20);
    println!(&quot;{}&quot;, *my_number + 20);
}
</code></pre></pre>
<p>錯誤信息是:</p>
<pre><code class="language-text">error[E0614]: type `HoldsANumber` cannot be dereferenced
  --&gt; src\main.rs:24:22
   |
24 |     println!(&quot;{:?}&quot;, *my_number + 20);
</code></pre>
<p>我們當然可以做到這一點。<code>println!(&quot;{:?}&quot;, my_number.0 + 20);</code>. 但是這樣的話，我們就是在20的基礎上再單獨加一個<code>u8</code>。如果我們能把它們加在一起就更好了。<code>cannot be dereferenced</code>這個消息給了我們一個線索:我們需要實現<code>Deref</code>。實現<code>Deref</code>的簡單東西有時被稱為 &quot;智能指針&quot;。一個智能指針可以指向它的元素，有它的信息，並且可以使用它的方法。因為現在我們可以添加<code>my_number.0</code>，這是一個<code>u8</code>，但我們不能用<code>HoldsANumber</code>做其他的事情:到目前為止，它只有<code>Debug</code>。</p>
<p>有趣的是:<code>String</code>其實是<code>&amp;str</code>的智能指針，<code>Vec</code>是數組(或其他類型)的智能指針。所以我們其實從一開始就在使用智能指針。</p>
<p>實現<code>Deref</code>並不難，標準庫中的例子也很簡單。<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">下面是標準庫中的示例代碼</a>。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct DerefExample&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

fn main() {
    let x = DerefExample { value: 'a' };
    assert_eq!('a', *x);
}
</code></pre></pre>
<p>所以我們按照這個來，現在我們的<code>Deref</code>是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl Deref for HoldsANumber {
    type Target = u8; // Remember, this is the &quot;associated type&quot;: the type that goes together.
                      // You have to use the right type Target = (the type you want to return)

    fn deref(&amp;self) -&gt; &amp;Self::Target { // Rust calls .deref() when you use *. We just defined Target as a u8 so this is easy to understand
        &amp;self.0   // We chose &amp;self.0 because it's a tuple struct. In a named struct it would be something like &quot;&amp;self.number&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>所以現在我們可以用<code>*</code>來做:</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;
#[derive(Debug)]
struct HoldsANumber(u8);

impl Deref for HoldsANumber {
    type Target = u8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

fn main() {
    let my_number = HoldsANumber(20);
    println!(&quot;{:?}&quot;, *my_number + 20);
}
</code></pre></pre>
<p>所以，這樣就可以打印出<code>40</code>，我們不需要寫<code>my_number.0</code>。這意味著我們得到了 <code>u8</code> 的方法，我們可以為 <code>HoldsANumber</code> 寫出我們自己的方法。我們將添加自己的簡單方法，並使用我們從<code>u8</code>中得到的另一個方法，稱為<code>.checked_sub()</code>。<code>.checked_sub()</code>方法是一個安全的減法，它能返回一個<code>Option</code>。如果它能做減法，那麼它就會在<code>Some</code>裡面給你，如果它不能做減法，那麼它就會給出一個<code>None</code>。記住，<code>u8</code>不能是負數，所以還是<code>.checked_sub()</code>比較安全，這樣就不會崩潰了。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct HoldsANumber(u8);

impl HoldsANumber {
    fn prints_the_number_times_two(&amp;self) {
        println!(&quot;{}&quot;, self.0 * 2);
    }
}

impl Deref for HoldsANumber {
    type Target = u8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

fn main() {
    let my_number = HoldsANumber(20);
    println!(&quot;{:?}&quot;, my_number.checked_sub(100)); // This method comes from u8
    my_number.prints_the_number_times_two(); // This is our own method
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">None
40
</code></pre>
<p>我們也可以實現<code>DerefMut</code>，這樣我們就可以通過<code>*</code>來改變數值。它看起來幾乎是一樣的。在實現<code>DerefMut</code>之前，你需要先實現<code>Deref</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::{Deref, DerefMut};

struct HoldsANumber(u8);

impl HoldsANumber {
    fn prints_the_number_times_two(&amp;self) {
        println!(&quot;{}&quot;, self.0 * 2);
    }
}

impl Deref for HoldsANumber {
    type Target = u8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for HoldsANumber { // You don't need type Target = u8; here because it already knows thanks to Deref
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target { // Everything else is the same except it says mut everywhere
        &amp;mut self.0
    }
}

fn main() {
    let mut my_number = HoldsANumber(20);
    *my_number = 30; // DerefMut lets us do this
    println!(&quot;{:?}&quot;, my_number.checked_sub(100));
    my_number.prints_the_number_times_two();
}
</code></pre></pre>
<p>所以你可以看到，<code>Deref</code>給你的類型提供了強大的力量。</p>
<p>這也是為什麼標準庫說:<code>Deref should only be implemented for smart pointers to avoid confusion</code>。這是因為對於一個複雜的類型，你可以用 <code>Deref</code> 做一些奇怪的事情。讓我們想象一個非常混亂的例子來理解它們的含義。我們將從一個遊戲的 <code>Character</code> 結構開始。一個新的<code>Character</code>需要一些數據，比如智力和力量。所以這裡是我們的第一個角色。</p>
<pre><pre class="playground"><code class="language-rust">struct Character {
    name: String,
    strength: u8,
    dexterity: u8,
    health: u8,
    intelligence: u8,
    wisdom: u8,
    charm: u8,
    hit_points: i8,
    alignment: Alignment,
}

impl Character {
    fn new(
        name: String,
        strength: u8,
        dexterity: u8,
        health: u8,
        intelligence: u8,
        wisdom: u8,
        charm: u8,
        hit_points: i8,
        alignment: Alignment,
    ) -&gt; Self {
        Self {
            name,
            strength,
            dexterity,
            health,
            intelligence,
            wisdom,
            charm,
            hit_points,
            alignment,
        }
    }
}

enum Alignment {
    Good,
    Neutral,
    Evil,
}

fn main() {
    let billy = Character::new(&quot;Billy&quot;.to_string(), 9, 8, 7, 10, 19, 19, 5, Alignment::Good);
}
</code></pre></pre>
<p>現在讓我們想象一下，我們要把人物的hit points放在一個大的vec裡。也許我們會把怪物數據也放進去，把它放在一起。由於 <code>hit_points</code> 是一個 <code>i8</code>，我們實現了 <code>Deref</code>，所以我們可以對它進行各種計算。但是看看現在我們的<code>main()</code>函數中，它看起來多麼奇怪。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

// All the other code is the same until after the enum Alignment
struct Character {
    name: String,
    strength: u8,
    dexterity: u8,
    health: u8,
    intelligence: u8,
    wisdom: u8,
    charm: u8,
    hit_points: i8,
    alignment: Alignment,
}

impl Character {
    fn new(
        name: String,
        strength: u8,
        dexterity: u8,
        health: u8,
        intelligence: u8,
        wisdom: u8,
        charm: u8,
        hit_points: i8,
        alignment: Alignment,
    ) -&gt; Self {
        Self {
            name,
            strength,
            dexterity,
            health,
            intelligence,
            wisdom,
            charm,
            hit_points,
            alignment,
        }
    }
}

enum Alignment {
    Good,
    Neutral,
    Evil,
}

impl Deref for Character { // impl Deref for Character. Now we can do any integer math we want!
    type Target = i8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.hit_points
    }
}



fn main() {
    let billy = Character::new(&quot;Billy&quot;.to_string(), 9, 8, 7, 10, 19, 19, 5, Alignment::Good); // Create two characters, billy and brandy
    let brandy = Character::new(&quot;Brandy&quot;.to_string(), 9, 8, 7, 10, 19, 19, 5, Alignment::Good);

    let mut hit_points_vec = vec![]; // Put our hit points data in here
    hit_points_vec.push(*billy);     // Push *billy?
    hit_points_vec.push(*brandy);    // Push *brandy?

    println!(&quot;{:?}&quot;, hit_points_vec);
}
</code></pre></pre>
<p>這隻打印了<code>[5, 5]</code>。我們的代碼現在讓人讀起來感覺非常奇怪。我們可以在<code>main()</code>上面看到<code>Deref</code>，然後弄清楚<code>*billy</code>的意思是<code>i8</code>，但是如果有很多代碼呢？可能我們的代碼有2000行，突然要弄清楚為什麼要<code>.push()</code> <code>*billy</code>。<code>Character</code>當然不僅僅是<code>i8</code>的智能指針。</p>
<p>當然，寫<code>hit_points_vec.push(*billy)</code>並不違法，但這讓代碼看起來非常奇怪。也許一個簡單的<code>.get_hp()</code>方法會好得多，或者另一個存放角色的結構體。然後你可以迭代並推送每個角色的 <code>hit_points</code>。<code>Deref</code>提供了很多功能，但最好確保代碼的邏輯性。</p>
<h2 id="crate和模塊"><a class="header" href="#crate和模塊">Crate和模塊</a></h2>
<p>每次你在 Rust 中寫代碼時，你都是在 <code>crate</code> 中寫的。<code>crate</code>是一個或多個文件，一起為你的代碼服務。在你寫的文件裡面，你也可以創建一個<code>mod</code>。<code>mod</code>是存放函數、結構體等的空間，因為這些原因被使用:</p>
<ul>
<li>構建你的代碼:它可以幫助你思考代碼的總體結構。當你的代碼越來越大時，這一點可能很重要。</li>
<li>閱讀你的代碼:人們可以更容易理解你的代碼。例如，<code>std::collections::HashMap</code>這個名字告訴你，它在<code>std</code>的模塊<code>collections</code>裡面。這給了你一個提示，也許<code>collections</code>裡面還有更多的集合類型，你可以嘗試一下。</li>
<li>私密性:所有的東西一開始都是私有的。這樣可以讓你不讓用戶直接使用函數。</li>
</ul>
<p>要創建一個<code>mod</code>，只需要寫<code>mod</code>，然後用<code>{}</code>開始一個代碼塊。我們將創建一個名為<code>print_things</code>的mod，它有一些打印相關的功能。</p>
<pre><pre class="playground"><code class="language-rust">mod print_things {
    use std::fmt::Display;

    fn prints_one_thing&lt;T: Display&gt;(input: T) { // Print anything that implements Display
        println!(&quot;{}&quot;, input)
    }
}

fn main() {}
</code></pre></pre>
<p>你可以看到，我們把<code>use std::fmt::Display;</code>寫在<code>print_things</code>裡面，因為它是一個獨立的空間。如果你把<code>use std::fmt::Display;</code>寫在<code>main()</code>裡面，那沒用。而且，我們現在也不能從<code>main()</code>裡面調用。如果在<code>fn</code>前面沒有<code>pub</code>這個關鍵字，它就會保持私密性。讓我們試著在沒有<code>pub</code>的情況下調用它。這裡有一種寫法。</p>
<pre><pre class="playground"><code class="language-rust">// 🚧
fn main() {
    crate::print_things::prints_one_thing(6);
}
</code></pre></pre>
<p><code>crate</code>的意思是 &quot;在這個項目裡&quot;，但對於我們簡單的例子來說，它和 &quot;在這個文件裡面&quot;是一樣的。接著是<code>print_things</code>這個mod，最後是<code>prints_one_thing()</code>函數。你可以每次都寫這個，也可以寫<code>use</code>來導入。現在我們可以看到說它是私有的錯誤:</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
mod print_things {
    use std::fmt::Display;

    fn prints_one_thing&lt;T: Display&gt;(input: T) {
        println!(&quot;{}&quot;, input)
    }
}

fn main() {
    use crate::print_things::prints_one_thing;

    prints_one_thing(6);
    prints_one_thing(&quot;Trying to print a string...&quot;.to_string());
}
</code></pre></pre>
<p>這是錯誤的。</p>
<pre><code class="language-text">error[E0603]: function `prints_one_thing` is private
  --&gt; src\main.rs:10:30
   |
10 |     use crate::print_things::prints_one_thing;
   |                              ^^^^^^^^^^^^^^^^ private function
   |
note: the function `prints_one_thing` is defined here
  --&gt; src\main.rs:4:5
   |
4  |     fn prints_one_thing&lt;T: Display&gt;(input: T) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>很容易理解，函數<code>print_one_thing</code>是私有的。它還用<code>src\main.rs:4:5</code>告訴我們在哪裡可以找到這個函數。這很有幫助，因為你不僅可以在一個文件中寫<code>mod</code>，還可以在很多文件中寫<code>mod</code>。</p>
<p>現在我們只需要寫<code>pub fn</code>而不是<code>fn</code>，一切就都可以了。</p>
<pre><pre class="playground"><code class="language-rust">mod print_things {
    use std::fmt::Display;

    pub fn prints_one_thing&lt;T: Display&gt;(input: T) {
        println!(&quot;{}&quot;, input)
    }
}

fn main() {
    use crate::print_things::prints_one_thing;

    prints_one_thing(6);
    prints_one_thing(&quot;Trying to print a string...&quot;.to_string());
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">6
Trying to print a string...
</code></pre>
<p><code>pub</code>對結構體、枚舉、trait或模塊有什麼作用？<code>pub</code>對它們來說是這樣的:</p>
<ul>
<li><code>pub</code>對於一個結構：它使結構公開，但成員不是公開的。要想讓一個成員公開，你也要為每個成員寫<code>pub</code>。</li>
<li><code>pub</code> 對於一個枚舉或trait：所有的東西都變成了公共的。這是有意義的，因為traits是給事物賦予相同的行為。而枚舉是值之間的選擇，你需要看到所有的枚舉值才能做選擇。</li>
<li><code>pub</code>對於一個模塊來說：一個頂層的模塊會是<code>pub</code>，因為如果它不是pub，那麼根本沒有人可以使用裡面的任何東西。但是模塊裡面的模塊需要使用<code>pub</code>才能成為公共的。</li>
</ul>
<p>我們在<code>print_things</code>裡面放一個名為<code>Billy</code>的結構體。這個結構體幾乎都會是public的，但也不盡然。這個結構是公共的，所以它這樣寫：<code>pub struct Billy</code>。裡面會有一個 <code>name</code> 和 <code>times_to_print</code>。<code>name</code>不會是公共的，因為我們只想讓用戶創建名為<code>&quot;Billy&quot;.to_string()</code>的結構。但是用戶可以選擇打印的次數，所以這將是公開的。它的是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">mod print_things {
    use std::fmt::{Display, Debug};

    #[derive(Debug)]
    pub struct Billy { // Billy is public
        name: String, // but name is private.
        pub times_to_print: u32,
    }

    impl Billy {
        pub fn new(times_to_print: u32) -&gt; Self { // That means the user needs to use new to create a Billy. The user can only change the number of times_to_print
            Self {
                name: &quot;Billy&quot;.to_string(), // We choose the name - the user can't
                times_to_print,
            }
        }

        pub fn print_billy(&amp;self) { // This function prints a Billy
            for _ in 0..self.times_to_print {
                println!(&quot;{:?}&quot;, self.name);
            }
        }
    }

    pub fn prints_one_thing&lt;T: Display&gt;(input: T) {
        println!(&quot;{}&quot;, input)
    }
}

fn main() {
    use crate::print_things::*; // Now we use *. This imports everything from print_things

    let my_billy = Billy::new(3);
    my_billy.print_billy();
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">&quot;Billy&quot;
&quot;Billy&quot;
&quot;Billy&quot;
</code></pre>
<p>對了，導入一切的<code>*</code>叫做 &quot;glob運算符&quot;。Glob的意思是 &quot;全局&quot;，所以它意味著一切。</p>
<p>在<code>mod</code>裡面你可以創建其他mod。一個子 mod(mod裡的mod)總是可以使用父 mod 內部的任何東西。你可以在下一個例子中看到這一點，我們在 <code>mod province</code> 裡面有一個 <code>mod city</code>，而<code>mod province</code>在 <code>mod country</code> 裡面。</p>
<p>你可以這樣想:即使你在一個國家，你可能不在一個省。而即使你在一個省，你也可能不在一個市。但如果你在一個城市，你就在這個城市的省份和它的國家。</p>
<pre><pre class="playground"><code class="language-rust">mod country { // The main mod doesn't need pub
    fn print_country(country: &amp;str) { // Note: this function isn't public
        println!(&quot;We are in the country of {}&quot;, country);
    }
    pub mod province { // Make this mod public

        fn print_province(province: &amp;str) { // Note: this function isn't public
            println!(&quot;in the province of {}&quot;, province);
        }

        pub mod city { // Make this mod public
            pub fn print_city(country: &amp;str, province: &amp;str, city: &amp;str) {  // This function is public though
                crate::country::print_country(country);
                crate::country::province::print_province(province);
                println!(&quot;in the city of {}&quot;, city);
            }
        }
    }
}

fn main() {
    crate::country::province::city::print_city(&quot;Canada&quot;, &quot;New Brunswick&quot;, &quot;Moncton&quot;);
}
</code></pre></pre>
<p>有趣的是，<code>print_city</code>可以訪問<code>print_province</code>和<code>print_country</code>。這是因為<code>mod city</code>在其他mod裡面。它不需要在<code>print_province</code>前面添加<code>pub</code>之後才能使用。這也是有道理的:一個城市不需要做什麼，它本來就在一個省裡，在一個國家裡。</p>
<p>你可能注意到，<code>crate::country::province::print_province(province);</code>非常長。當我們在一個模塊裡面的時候，我們可以用<code>super</code>從上面引入元素。其實super這個詞本身就是&quot;上面&quot;的意思，比如 &quot;上級&quot;。在我們的例子中，我們只用了一次函數，但是如果你用的比較多的話，那麼最好是導入。如果它能讓你的代碼更容易閱讀，那也是個好主意，即使你只用了一次函數。現在的代碼幾乎是一樣的，但更容易閱讀一些。</p>
<pre><pre class="playground"><code class="language-rust">mod country {
    fn print_country(country: &amp;str) {
        println!(&quot;We are in the country of {}&quot;, country);
    }
    pub mod province {
        fn print_province(province: &amp;str) {
            println!(&quot;in the province of {}&quot;, province);
        }

        pub mod city {
            use super::super::*; // use everything in &quot;above above&quot;: that means mod country
            use super::*;        // use everything in &quot;above&quot;: that means mod province

            pub fn print_city(country: &amp;str, province: &amp;str, city: &amp;str) {
                print_country(country);
                print_province(province);
                println!(&quot;in the city of {}&quot;, city);
            }
        }
    }
}

fn main() {
    use crate::country::province::city::print_city; // bring in the function

    print_city(&quot;Canada&quot;, &quot;New Brunswick&quot;, &quot;Moncton&quot;);
    print_city(&quot;Korea&quot;, &quot;Gyeonggi-do&quot;, &quot;Gwangju&quot;); // Now it's less work to use it again
}
</code></pre></pre>
<h2 id="測試"><a class="header" href="#測試">測試</a></h2>
<p>現在我們已經瞭解了模塊,就可以談談測試了。在Rust中測試你的代碼是非常容易的，因為你可以在你的代碼旁邊寫測試。</p>
<p>開始測試的最簡單的方法是在一個函數上面添加<code>#[test]</code>。下面是一個簡單的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn two_is_two() {
    assert_eq!(2, 2);
}
<span class="boring">}
</span></code></pre></pre>
<p>但如果你試圖在playground中運行它，它給出了一個錯誤。<code>error[E0601]: `main` function not found in crate `playground</code>. 這是因為你不使用 <em>Run</em> 來進行測試，你使用 <em>Test</em> 。另外，你不使用 <code>main()</code> 函數進行測試 - 它們在外面運行。要在Playground中運行這個，點擊 <em>RUN</em> 旁邊的<code>···</code>，然後把它改為 <em>Test</em> 。現在如果你點擊它，它將運行測試。(如果你已經安裝了 Rust，你將輸入 <code>cargo test</code> 來做這個測試)</p>
<p>這裡是輸出:</p>
<pre><code class="language-text">running 1 test
test two_is_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>讓我們把<code>assert_eq!(2, 2)</code>改成<code>assert_eq!(2, 3)</code>，看看會有什麼結果。當測試失敗時，你會得到更多的信息。</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>assert_eq!(left, right)</code>是Rust中測試一個函數的主要方法。如果它不工作，它將顯示不同的值:左邊有2，但右邊有3。</p>
<p><code>RUST_BACKTRACE=1</code>是什麼意思？這是計算機上的一個設置，可以提供更多關於錯誤的信息。幸好playground也有:點擊<code>STABLE</code>旁邊的<code>···</code>，然後設置回溯為<code>ENABLED</code>。如果你這樣做，它會給你<em>很多</em>的信息。</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: 2 == 3', src/lib.rs:3:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:78
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:59
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1076
   5: std::io::Write::write_fmt
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/io/mod.rs:1537
   6: std::io::impls::&lt;impl std::io::Write for alloc::boxed::Box&lt;W&gt;&gt;::write_fmt
             at src/libstd/io/impls.rs:176
   7: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:62
   8: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   9: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:198
  10: std::panicking::default_hook
             at src/libstd/panicking.rs:215
  11: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:486
  12: std::panicking::begin_panic
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:410
  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
  15: core::ops::function::FnOnce::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libcore/ops/function.rs:232
  16: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::FnOnce&lt;A&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/liballoc/boxed.rs:1076
  17: &lt;std::panic::AssertUnwindSafe&lt;F&gt; as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:318
  18: std::panicking::try::do_call
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:297
  19: std::panicking::try
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:274
  20: std::panic::catch_unwind
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:394
  21: test::run_test_in_process
             at src/libtest/lib.rs:541
  22: test::run_test::run_test_inner::{{closure}}
             at src/libtest/lib.rs:450
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>除非你真的找不到問題所在，否則你不需要使用回溯。但幸運的是你也不需要全部理解。 如果你繼續閱讀，你最終會看到第13行，那裡寫著<code>playground</code>--那是它提到的你的代碼的位置。其他的都是關於Rust為了運行你的程序,在其他庫中所做的事情。但是這兩行告訴你，它看的是playground的第2行和第3行，這是一個提示，要檢查那裡。這裡是那個部分:</p>
<pre><code class="language-text">  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
</code></pre>
<p>編輯：Rust在2021年初改進了其回溯信息，只顯示最有意義的信息。現在它更容易閱讀。</p>
<pre><code class="language-text">failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: playground::two_is_two
             at ./src/lib.rs:3:5
   3: playground::two_is_two::{{closure}}
             at ./src/lib.rs:2:1
   4: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
</code></pre>
<p>現在我們再把回溯關閉，回到常規測試。現在我們要寫一些其他函數，並使用測試函數來測試它們。這裡有幾個:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
<span class="boring">[test]
</span>fn it_returns_two() {
    assert_eq!(return_two(), 2);
}

fn return_six() -&gt; i8 {
    4 + return_two()
}
<span class="boring">[test]
</span>fn it_returns_six() {
    assert_eq!(return_six(), 6)
}
<span class="boring">}
</span></code></pre></pre>
<p>現在，都能運行:</p>
<pre><code class="language-text">running 2 tests
test it_returns_two ... ok
test it_returns_six ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>這不是太難。</p>
<p>通常你會想把你的測試放在自己的模塊中。要做到這一點，請使用相同的 <code>mod</code> 關鍵字，並在其上方添加 <code>#[cfg(test)]</code>(記住:<code>cfg</code> 的意思是 &quot;配置&quot;)。你還要在每個測試上面繼續寫<code>#[test]</code>。這是因為以後當你安裝Rust時，你可以做更復雜的測試。你將可以運行一個測試，或者所有的測試，或者運行幾個測試。另外別忘了寫<code>use super::*;</code>，因為測試模塊需要使用上面的函數。現在它看起來會是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
fn return_six() -&gt; i8 {
    4 + return_two()
}

<span class="boring">[cfg(test)]
</span>mod tests {
    use super::*;

    #[test]
    fn it_returns_six() {
        assert_eq!(return_six(), 6)
    }
    #[test]
    fn it_returns_two() {
        assert_eq!(return_two(), 2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="測試驅動的開發"><a class="header" href="#測試驅動的開發">測試驅動的開發</a></h3>
<p>在閱讀Rust或其他語言時，你可能會看到 &quot;測試驅動開發&quot;這個詞。這是編寫程序的一種方式，有些人喜歡它，而有些人則喜歡其他的方式。&quot;測試驅動開發&quot;的意思是 &quot;先寫測試，再寫代碼&quot;。當你這樣做的時候，你會有很多關於你想要你的代碼做的所有事情的測試代碼。然後你開始寫代碼，並運行測試，看看你是否做對了。然後，當你添加和重寫代碼時，如果有什麼地方出了問題，測試代碼會一直在那裡向你展示。這在Rust中是非常容易的，因為編譯器給出了很多待修復內容的信息。讓我們寫一個測試驅動開發的小例子，看看它是什麼樣子的。</p>
<p>讓我們想象一個接受用戶輸入的計算器。它可以加(+)，也可以減(-)。如果用戶寫 &quot;5+6&quot;，它應該返回11，如果用戶寫 &quot;5+6-7&quot;，它應該返回4，以此類推。所以我們先從測試函數開始。你也可以看到，測試中的函數名通常都相當長。這是因為你可能會運行很多測試，你想了解哪些測試失敗了。</p>
<p>我們想象一下，一個名為<code>math()</code>的函數就可以完成所有的工作。它將返回一個 <code>i32</code>(我們不會使用浮點數)。因為它需要返回一些東西，所以我們每次都只返回 <code>6</code>。然後我們將寫三個測試函數。當然，它們都會失敗。現在的代碼是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn math(input: &amp;str) -&gt; i32 {
    6
}

<span class="boring">[cfg(test)]
</span>mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它給了我們這個信息。</p>
<pre><code class="language-text">running 3 tests
test tests::one_minus_minus_one_is_two ... FAILED
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>以及<code>thread 'tests::one_plus_one_is_two' panicked at 'assertion failed: `(left == right)` </code>的所有信息。我們不需要在這裡全部打印出來。</p>
<p>現在要考慮如何創建計算器。我們將接受任何數字，以及符號<code>+-</code>。我們將允許空格，但不允許其他任何東西。所以，讓我們從包含所有數值的<code>const</code>開始。然後我們將使用 <code>.chars()</code> 按字符進行迭代，並使用 <code>.all()</code> 確保它們都在裡面。</p>
<p>然後，我們將添加一個會崩潰的測試。要做到這一點，添加 <code>#[should_panic]</code> 屬性:現在如果它崩潰，測試將成功。</p>
<p>現在代碼看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;; // Don't forget the space at the end

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }
    6 // we still return a 6 for now
}

<span class="boring">[cfg(test)]
</span>mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }

    #[test]
    #[should_panic]  // Here is our new test - it should panic
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>現在，當我們運行測試時，我們得到這樣的結果。</p>
<pre><code class="language-text">running 4 tests
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_minus_minus_one_is_two ... FAILED
test tests::panics_when_characters_not_right ... ok
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>一個成功了! 我們的<code>math()</code>函數現在只能接受好的輸入了。</p>
<p>下一步是編寫實際的計算器。這就是先有測試的有趣之處:實際的代碼要晚很多。首先，我們將把計算器的邏輯放在一起。我們要做到以下幾點。</p>
<ul>
<li>所有的空位都應該被刪除。這在<code>.filter()</code>中很容易實現。</li>
<li>所有輸入應該變成一個<code>Vec</code>。<code>+</code>不需要成為輸入，但是當程序看到<code>+</code>時，應該知道這個數字已經完成了。例如，輸入<code>+</code>應該這樣做:
<ol>
<li>看到<code>1</code>，把它推到一個空字符串中。</li>
<li>看到另一個1，把它推入字符串中(現在是 &quot;11&quot;)。</li>
<li>看到一個<code>+</code>，知道這個數字已經結束。它會把字符串推入vec中，然後清空字符串。</li>
</ol>
</li>
<li>程序必須計算出<code>-</code>的數量。奇數(1，3，5...)表示減法，偶數(2，4，6...)表示加法。所以 &quot;1--9&quot;應該是10，而不是-8。</li>
<li>程序應該刪除最後一個數字後面的任何東西。<code>5+5+++++----</code>是由<code>OKAY_CHARACTERS</code>中的所有字符組成的，但它應該變成<code>5+5</code>。<code>.trim_end_matches()</code>就很簡單了，你把<code>&amp;str</code>末尾符合的東西都去掉。</li>
</ul>
<p>順便說一下，<code>.trim_end_matches()</code>和<code>.trim_start_matches()</code>曾經是<code>trim_right_matches()</code>和<code>trim_left_matches()</code>。但後來人們注意到有些語言是從右到左(波斯語、希伯來語等)，所以左右都是錯的。你可能還能在一些代碼中看到舊的名字，但它們是一樣的)。)</p>
<p>首先我們只想通過所有的測試。通過測試後，我們就可以 &quot;重構&quot;了。重構的意思是讓代碼變得更好，通常是通過結構、枚舉和方法等方式。下面是我們使測試通過的代碼。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric())
    {
        panic!(&quot;Please only input numbers, +-, or spaces.&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;(); // Remove + and - at the end, and all spaces
    let mut result_vec = vec![]; // Results go in here
    let mut push_string = String::new(); // This is the string we push in every time. We will keep reusing it in the loop.
    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !push_string.is_empty() { // If the string is empty, we don't want to push &quot;&quot; into result_vec
                    result_vec.push(push_string.clone()); // But if it's not empty, it will be a number. Push it into the vec
                    push_string.clear(); // Then clear the string
                }
            },
            '-' =&gt; { // If we get a -,
                if push_string.contains('-') || push_string.is_empty() { // check to see if it's empty or has a -
                    push_string.push(character) // if so, then push it in
                } else { // otherwise, it will contain a number
                result_vec.push(push_string.clone()); // so push the number into result_vec, clear it and then push -
                push_string.clear();
                push_string.push(character);
                }
            },
            number =&gt; { // number here means &quot;anything else that matches&quot;. We selected the name here
                if push_string.contains('-') { // We might have some - characters to push in first
                    result_vec.push(push_string.clone());
                    push_string.clear();
                    push_string.push(number);
                } else { // But if we don't, that means we can push the number in
                    push_string.push(number);
                }
            },
        }
    }
    result_vec.push(push_string); // Push one last time after the loop is over. Don't need to .clone() because we don't use it anymore

    let mut total = 0; // Now it's time to do math. Start with a total
    let mut adds = true; // true = add, false = subtract
    let mut math_iter = result_vec.into_iter();
    while let Some(entry) = math_iter.next() { // Iter through the items
        if entry.contains('-') { // If it has a - character, check if it's even or odd
            if entry.chars().count() % 2 == 1 {
                adds = match adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue; // Go to the next item
            } else {
                continue;
            }
        }
        if adds == true {
            total += entry.parse::&lt;i32&gt;().unwrap(); // If there is no '-', it must be a number. So we are safe to unwrap
        } else {
            total -= entry.parse::&lt;i32&gt;().unwrap();
            adds = true;  // After subtracting, reset adds to true.
        }
    }
    total // Finally, return the total
}
   /// We'll add a few more tests just to make sure

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0); // This is a new test
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8); // This is a new test
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>現在測試通過了!</p>
<pre><code class="language-text">running 6 tests
test tests::one_minus_minus_one_is_two ... ok
test tests::nine_plus_nine_minus_nine_minus_nine_is_zero ... ok
test tests::one_minus_two_is_minus_one ... ok
test tests::eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end ... ok
test tests::one_plus_one_is_two ... ok
test tests::panics_when_characters_not_right ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>你可以看到，在測試驅動的開發中，有一個來回的過程。它是這樣的。</p>
<ul>
<li>首先你要寫出所有你能想到的測試</li>
<li>然後你開始寫代碼。</li>
<li>當你寫代碼的時候，你會有其他測試的想法。</li>
<li>你添加測試，你的測試隨著你的發展而增長。你的測試越多，你的代碼被檢查的次數就越多。</li>
</ul>
<p>當然，測試並不能檢查所有的東西，認為 &quot;通過所有測試=代碼是完美的&quot;是錯誤的。但是，測試對於你修改代碼的時候是非常好的。如果你以後修改了代碼，然後運行測試，如果其中一個測試不成功，你就會知道該怎麼修復。</p>
<p>現在我們可以重寫(重構)一下代碼。一個好的方法是用clippy開始。如果你安裝了Rust，那麼你可以輸入<code>cargo clippy</code>，如果你使用的是Playground，那麼點擊<code>TOOLS</code>，選擇Clippy。Clippy會查看你的代碼，並給你提示，讓你的代碼更簡單。我們的代碼沒有任何錯誤，但它可以更好。</p>
<p>Clippy會告訴我們兩件事。</p>
<pre><code class="language-text">warning: this loop could be written as a `for` loop
  --&gt; src/lib.rs:44:5
   |
44 |     while let Some(entry) = math_iter.next() { // Iter through the items
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for entry in math_iter`
   |
   = note: `#[warn(clippy::while_let_on_iterator)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator

warning: equality checks against true are unnecessary
  --&gt; src/lib.rs:53:12
   |
53 |         if adds == true {
   |            ^^^^^^^^^^^^ help: try simplifying it as shown: `adds`
   |
   = note: `#[warn(clippy::bool_comparison)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison
</code></pre>
<p>這是真的:<code>for entry in math_iter</code>比<code>while let Some(entry) = math_iter.next()</code>簡單得多。而<code>for</code>循環實際上是一個迭代器，所以我們沒有任何理由寫<code>.iter()</code>。謝謝你，clippy! 而且我們也不需要做<code>math_iter</code>:我們可以直接寫<code>for entry in result_vec</code>。</p>
<p>現在我們將開始一些真正的重構。我們將創建一個 <code>Calculator</code> 結構體，而不是單獨的變量。這將擁有我們使用的所有變量。我們將改變兩個名字以使其更加清晰。<code>result_vec</code>將變成<code>results</code>，<code>push_string</code>將變成<code>current_input</code>(current的意思是 &quot;現在&quot;)。而到目前為止，它只有一種方法:new。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>現在我們的代碼其實比較長，但更容易讀懂。比如，<code>if adds</code>現在是<code>if calculator.adds</code>，這就跟讀英文完全一樣。它的樣子是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.current_input.push(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.current_input.clear();
                calculator.current_input.push(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                    calculator.current_input.push(number);
                } else {
                    calculator.current_input.push(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最後我們增加兩個新方法。一個叫做 <code>.clear()</code>，清除 <code>current_input()</code>。另一個叫做 <code>push_char()</code>，把輸入推到 <code>current_input()</code> 上。這是我們重構後的代碼。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }

    fn clear(&amp;mut self) {
        self.current_input.clear();
    }

    fn push_char(&amp;mut self, character: char) {
        self.current_input.push(character);
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.push_char(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.clear();
                calculator.push_char(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                    calculator.push_char(number);
                } else {
                    calculator.push_char(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>現在大概已經夠好了。我們可以寫更多的方法，但是像<code>calculator.results.push(calculator.current_input.clone());</code>這樣的行已經很清楚了。重構最好是在你完成後還能輕鬆閱讀代碼的時候。你不希望只是為了讓代碼變短而重構:例如，<code>clc.clr()</code>就比<code>calculator.clear()</code>差很多。</p>
<h2 id="外部crate"><a class="header" href="#外部crate">外部crate</a></h2>
<p>外部crate的意思是 &quot;別人的crate&quot;。</p>
<p>在本節中，你<em>差不多</em>需要安裝Rust，但我們仍然可以只使用Playground。現在我們要學習如何導入別人寫的crate。這在Rust中很重要，原因有二。</p>
<ul>
<li>導入其他的crate很容易，並且...</li>
<li>Rust標準庫是相當小的。</li>
</ul>
<p>這意味著，在Rust中，很多基本功能都需要用到外部Crate，這很正常。我們的想法是，如果使用外部Crate很方便，那麼你可以選擇最好的一個。也許一個人會為一個功能創建一個crate，然後其他人會創建一個更好的crate。</p>
<p>在本書中，我們只看最流行的crate，也就是每個使用Rust的人都知道的crate。</p>
<p>要開始學習外部Crate，我們將從最常見的Crate開始。<code>rand</code>.</p>
<h3 id="rand"><a class="header" href="#rand">rand</a></h3>
<p>你有沒有注意到，我們還沒有使用任何隨機數？那是因為隨機數不在標準庫中。但是有很多crate &quot;幾乎是標準庫&quot;，因為大家都在使用它們。在任何情況下，帶入一個 crate 是非常容易的。如果你的電腦上有Rust，有一個叫<code>Cargo.toml</code>的文件，裡面有這些信息。<code>Cargo.toml</code>文件在你啟動時是這樣的。</p>
<pre><code class="language-text">[package]
name = &quot;rust_book&quot;
version = &quot;0.1.0&quot;
authors = [&quot;David MacLeod&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>現在，如果你想添加<code>rand</code> crate，在<code>crates.io</code>上搜索它，這是所有crate的去處。這將帶你到<code>https://crates.io/crates/rand</code>。當你點擊那個，你可以看到一個屏幕，上面寫著<code>Cargo.toml   rand = &quot;0.7.3&quot;</code>。你所要做的就是在[dependencies]下添加這樣的內容:</p>
<pre><code class="language-text">[package]
name = &quot;rust_book&quot;
version = &quot;0.1.0&quot;
authors = [&quot;David MacLeod&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<p>然後Cargo會幫你完成剩下的工作。然後你就可以在<code>rand</code>文檔網站上開始編寫像<a href="https://docs.rs/rand/0.7.3/rand/">本例代碼</a>這樣的代碼。要想進入文檔，你可以點擊<a href="https://crates.io/crates/rand">crates.io上的頁面</a>中的<code>docs</code>按鈕。</p>
<p>關於Cargo的介紹就到這裡了:我們現在使用的還只是playground。幸運的是，playground已經安裝了前100個crate。所以你還不需要寫進<code>Cargo.toml</code>。在playground上，你可以想象，它有一個這樣的長長的列表，有100個crate。</p>
<pre><code class="language-text">[dependencies]
rand = &quot;0.7.3&quot;
some_other_crate = &quot;0.1.0&quot;
another_nice_crate = &quot;1.7&quot;
</code></pre>
<p>也就是說，如果要使用<code>rand</code>，你可以直接這樣做:</p>
<pre><pre class="playground"><code class="language-rust">use rand; // This means the whole crate rand
          // On your computer you can't just write this;
          // you need to write in the Cargo.toml file first

fn main() {
    for _ in 0..5 {
        let random_u16 = rand::random::&lt;u16&gt;();
        print!(&quot;{} &quot;, random_u16);
    }
}
</code></pre></pre>
<p>每次都會打印不同的<code>u16</code>號碼，比如<code>42266 52873 56528 46927 6867</code>。</p>
<p><code>rand</code>中的主要功能是<code>random</code>和<code>thread_rng</code>(rng的意思是 &quot;隨機數發生器&quot;)。而實際上如果你看<code>random</code>，它說:&quot;這只是<code>thread_rng().gen()</code>的一個快捷方式&quot;。所以其實是<code>thread_rng</code>基本做完了一切。</p>
<p>下面是一個簡單的例子，從1到10的數字。為了得到這些數字，我們在1到11之間使用<code>.gen_range()</code>。</p>
<pre><pre class="playground"><code class="language-rust">use rand::{thread_rng, Rng}; // Or just use rand::*; if we are lazy

fn main() {
    let mut number_maker = thread_rng();
    for _ in 0..5 {
        print!(&quot;{} &quot;, number_maker.gen_range(1, 11));
    }
}
</code></pre></pre>
<p>這將打印出<code>7 2 4 8 6</code>這樣的東西。</p>
<p>用隨機數我們可以做一些有趣的事情，比如為遊戲創建角色。我們將使用<code>rand</code>和其他一些我們知道的東西來創建它們。在這個遊戲中，我們的角色有六種狀態，用一個d6來表示他們。d6是一個立方體，當你投擲它時，它能給出1、2、3、4、5或6。每個角色都會擲三次d6，所以每個統計都在3到18之間。</p>
<p>但是有時候如果你的角色有一些低的東西，比如3或4，那就不公平了。比如說你的力量是3，你就不能拿東西。所以還有一種方法是用d6四次。你擲四次，然後扔掉最低的數字。所以如果你擲3，3，1，6，那麼你保留3，3，6=12。我們也會把這個方法做出來，所以遊戲的主人可以決定。</p>
<p>這是我們簡單的角色創建器。我們為數據統計創建了一個<code>Character</code>結構，甚至還實現了<code>Display</code>來按照我們想要的方式打印。</p>
<pre><pre class="playground"><code class="language-rust">use rand::{thread_rng, Rng}; // Or just use rand::*; if we are lazy
use std::fmt; // Going to impl Display for our character


struct Character {
    strength: u8,
    dexterity: u8,    // This means &quot;body quickness&quot;
    constitution: u8, // This means &quot;health&quot;
    intelligence: u8,
    wisdom: u8,
    charisma: u8, // This means &quot;popularity with people&quot;
}

fn three_die_six() -&gt; u8 { // A &quot;die&quot; is the thing you throw to get the number
    let mut generator = thread_rng(); // Create our random number generator
    let mut stat = 0; // This is the total
    for _ in 0..3 {
        stat += generator.gen_range(1..=6); // Add each time
    }
    stat // Return the total
}

fn four_die_six() -&gt; u8 {
    let mut generator = thread_rng();
    let mut results = vec![]; // First put the numbers in a vec
    for _ in 0..4 {
        results.push(generator.gen_range(1..=6));
    }
    results.sort(); // Now a result like [4, 3, 2, 6] becomes [2, 3, 4, 6]
    results.remove(0); // Now it would be [3, 4, 6]
    results.iter().sum() // Return this result
}

enum Dice {
    Three,
    Four
}

impl Character {
    fn new(dice: Dice) -&gt; Self { // true for three dice, false for four
        match dice {
            Dice::Three =&gt; Self {
                strength: three_die_six(),
                dexterity: three_die_six(),
                constitution: three_die_six(),
                intelligence: three_die_six(),
                wisdom: three_die_six(),
                charisma: three_die_six(),
            },
            Dice::Four =&gt; Self {
                strength: four_die_six(),
                dexterity: four_die_six(),
                constitution: four_die_six(),
                intelligence: four_die_six(),
                wisdom: four_die_six(),
                charisma: four_die_six(),
            },
        }
    }
    fn display(&amp;self) { // We can do this because we implemented Display below
        println!(&quot;{}&quot;, self);
        println!();
    }
}

impl fmt::Display for Character { // Just follow the code for in https://doc.rust-lang.org/std/fmt/trait.Display.html and change it a bit
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;Your character has these stats:
strength: {}
dexterity: {}
constitution: {}
intelligence: {}
wisdom: {}
charisma: {}&quot;,
            self.strength,
            self.dexterity,
            self.constitution,
            self.intelligence,
            self.wisdom,
            self.charisma
        )
    }
}



fn main() {
    let weak_billy = Character::new(Dice::Three);
    let strong_billy = Character::new(Dice::Four);
    weak_billy.display();
    strong_billy.display();
}
</code></pre></pre>
<p>它會打印出這樣的東西。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Your character has these stats:
strength: 9
dexterity: 15
constitution: 15
intelligence: 8
wisdom: 11
charisma: 9

Your character has these stats:
strength: 9
dexterity: 13
constitution: 14
intelligence: 16
wisdom: 16
charisma: 10
<span class="boring">}
</span></code></pre></pre>
<p>有四個骰子的角色通常在大多數事情上都會好一點。</p>
<h3 id="rayon"><a class="header" href="#rayon">rayon</a></h3>
<p><code>rayon</code> 是一個流行的crate，它可以讓你加快 Rust 代碼的速度。它之所以受歡迎，是因為它無需像 <code>thread::spawn</code> 這樣的東西就能創建線程。換句話說，它之所以受歡迎是因為它既有效又容易編寫。比如說</p>
<ul>
<li><code>.iter()</code>, <code>.iter_mut()</code>, <code>into_iter()</code>在rayon中是這樣寫的:</li>
<li><code>.par_iter()</code>, <code>.par_iter_mut()</code>, <code>par_into_iter()</code>. 所以你只要加上<code>par_</code>，你的代碼就會變得快很多。(par的意思是 &quot;並行&quot;)</li>
</ul>
<p>其他方法也一樣:<code>.chars()</code>就是<code>.par_chars()</code>，以此類推。</p>
<p>這裡舉個例子，一段簡單的代碼，卻讓計算機做了很多工作。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![0; 200_000];
    my_vec.iter_mut().enumerate().for_each(|(index, number)| *number+=index+1);
    println!(&quot;{:?}&quot;, &amp;my_vec[5000..5005]);
}
</code></pre></pre>
<p>它創建了一個有20萬項的向量:每一項都是0，然後調用<code>.enumerate()</code>來獲取每個數字的索引，並將0改為索引號。它的打印時間太長，所以我們只打印5000到5004項。這在Rust中還是非常快的，但如果你願意，你可以用Rayon讓它更快。代碼幾乎是一樣的。</p>
<pre><pre class="playground"><code class="language-rust">use rayon::prelude::*; // Import rayon

fn main() {
    let mut my_vec = vec![0; 200_000];
    my_vec.par_iter_mut().enumerate().for_each(|(index, number)| *number+=index+1); // add par_ to iter_mut
    println!(&quot;{:?}&quot;, &amp;my_vec[5000..5005]);
}
</code></pre></pre>
<p>就這樣了。<code>rayon</code>還有很多其他的方法來定製你想做的事情，但最簡單的就是 &quot;添加<code>_par</code>，讓你的程序更快&quot;。</p>
<h3 id="serde"><a class="header" href="#serde">serde</a></h3>
<p><code>serde</code>是一個流行的crate，它可以在JSON、YAML等格式間相互轉換。最常見的使用方法是通過創建一個<code>struct</code>，上面有兩個屬性。<a href="https://serde.rs/">它看起來是這樣的</a>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Serialize</code>和<code>Deserialize</code>trait是使轉換變得簡單的原因。(這也是<code>serde</code>這個名字的由來)如果你的結構體上有這兩個trait，那麼你只需要調用一個方法就可以把它轉化為JSON或其他任何東西。</p>
<h3 id="regex"><a class="header" href="#regex">regex</a></h3>
<p><a href="https://crates.io/crates/regex">regex</a> crate 可以讓你使用 <a href="https://en.wikipedia.org/wiki/Regular_expression">正則表達式</a> 搜索文本。有了它，你可以通過一次搜索得到諸如 <code>colour</code>, <code>color</code>, <code>colours</code> 和 <code>colors</code> 的匹配信息。正則表達式是另一門語言，如果你想使用它們，也必須學會。</p>
<h3 id="chrono"><a class="header" href="#chrono">chrono</a></h3>
<p><a href="https://crates.io/crates/chrono">chrono</a>是為那些需要更多時間功能的人準備的主要crate。我們現在來看一下標準庫，它有時間的功能，但是如果你需要更多的功能，那麼這個crate是一個不錯的選擇。</p>
<h2 id="標準庫之旅"><a class="header" href="#標準庫之旅">標準庫之旅</a></h2>
<p>現在你已經知道了很多Rust的知識，你將能夠理解標準庫裡面的大部分東西。它裡面的代碼已經不是那麼可怕了。讓我們來看看它裡面一些我們還沒有學過的部分。本篇遊記將介紹標準庫的大部分部分，你不需要安裝Rust。我們將重溫很多我們已經知道的內容，這樣我們就可以更深入地學習它們。</p>
<h3 id="數組-2"><a class="header" href="#數組-2">數組</a></h3>
<p>關於數組需要注意的一點是，它們沒有實現<code>Iterator.</code>。這意味著，如果你有一個數組，你不能使用<code>for</code>。但是你可以對它們使用 <code>.iter()</code> 這樣的方法。或者你可以使用<code>&amp;</code>來得到一個切片。實際上，如果你嘗試使用<code>for</code>，編譯器會準確地告訴你。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ⚠️
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];

    for city in my_cities {
        println!(&quot;{}&quot;, city);
    }
}
</code></pre></pre>
<p>消息是:</p>
<pre><code class="language-text">error[E0277]: `[&amp;str; 3]` is not an iterator
 --&gt; src\main.rs:5:17
  |
  |                 ^^^^^^^^^ borrow the array with `&amp;` or call `.iter()` on it to iterate over it
</code></pre>
<p>所以讓我們試試這兩種方法。它們的結果是一樣的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];

    for city in &amp;my_cities {
        println!(&quot;{}&quot;, city);
    }
    for city in my_cities.iter() {
        println!(&quot;{}&quot;, city);
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
</code></pre>
<p>如果你想從一個數組中獲取變量，你可以把它們的名字放在 <code>[]</code> 中來解構它。這與在 <code>match</code> 語句中使用元組或從結構體中獲取變量是一樣的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];
    let [city1, city2, city3] = my_cities;
    println!(&quot;{}&quot;, city1);
}
</code></pre></pre>
<p>打印出<code>Beirut</code>.</p>
<h3 id="char"><a class="header" href="#char">char</a></h3>
<p>您可以使用<code>.escape_unicode()</code>的方法來獲取<code>char</code>的Unicode號碼。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let korean_word = &quot;청춘예찬&quot;;
    for character in korean_word.chars() {
        print!(&quot;{} &quot;, character.escape_unicode());
    }
}
</code></pre></pre>
<p>這將打印出 <code>u{ccad} u{cd98} u{c608} u{cc2c}</code>。</p>
<p>你可以使用 <code>From</code> trait從 <code>u8</code> 中得到一個字符，但對於 <code>u32</code>，你使用 <code>TryFrom</code>，因為它可能無法工作。<code>u32</code>中的數字比Unicode中的字符多很多。我們可以通過一個簡單的演示來瞭解。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom; // You need to bring TryFrom in to use it
use rand::prelude::*;      // We will use random numbers too

fn main() {
    let some_character = char::from(99); // This one is easy - no need for TryFrom
    println!(&quot;{}&quot;, some_character);

    let mut random_generator = rand::thread_rng();
    // This will try 40,000 times to make a char from a u32.
    // The range is 0 (std::u32::MIN) to u32's highest number (std::u32::MAX). If it doesn't work, we will give it '-'.
    for _ in 0..40_000 {
        let bigger_character = char::try_from(random_generator.gen_range(std::u32::MIN..std::u32::MAX)).unwrap_or('-');
        print!(&quot;{}&quot;, bigger_character)
    }
}
</code></pre></pre>
<p>幾乎每次都會生成一個<code>-</code>。這是你會看到的那種輸出的一部分。</p>
<pre><code class="language-text">------------------------------------------------------------------------𤒰---------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------춗--------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
------------򇍜----------------------------------------------------
</code></pre>
<p>所以，你要用<code>TryFrom</code>是件好事。</p>
<p>另外，從2020年8月底開始，你現在可以從<code>char</code>中得到一個<code>String</code>。(<code>String</code>實現了<code>From&lt;char&gt;</code>)只要寫<code>String::from()</code>，然後在裡面放一個<code>char</code>。</p>
<h3 id="整數"><a class="header" href="#整數">整數</a></h3>
<p>這些類型的數學方法有很多，另外還有一些其他的方法。下面是一些最有用的。</p>
<p><code>.checked_add()</code>, <code>.checked_sub()</code>, <code>.checked_mul()</code>, <code>.checked_div()</code>. 如果你認為你可能會得到一個不適合類型的數字，這些都是不錯的方法。它們會返回一個 <code>Option</code>，這樣你就可以安全地檢查你的數學計算是否正常，而不會讓程序崩潰。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 200_u8;
    let other_number = 200_u8;

    println!(&quot;{:?}&quot;, some_number.checked_add(other_number));
    println!(&quot;{:?}&quot;, some_number.checked_add(1));
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">None
Some(201)
</code></pre>
<p>你會注意到，在整數的頁面上，經常說<code>rhs</code>。這意味著 &quot;右邊&quot;，也就是你做一些數學運算時的右操作數。比如在<code>5 + 6</code>中，<code>5</code>在左邊，<code>6</code>在右邊，所以<code>6</code>就是<code>rhs</code>。這個不是關鍵詞，但是你會經常看到，所以知道就好。</p>
<p>說到這裡，我們來學習一下如何實現<code>Add</code>。在你實現了<code>Add</code>之後，你可以在你創建的類型上使用<code>+</code>。你需要自己實現<code>Add</code>，因為add可以表達很多意思。這是標準庫頁面中的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add; // first bring in Add

#[derive(Debug, Copy, Clone, PartialEq)] // PartialEq is probably the most important part here. You want to be able to compare numbers
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self; // Remember, this is called an &quot;associated type&quot;: a &quot;type that goes together&quot;.
                        // In this case it's just another Point

    fn add(self, other: Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>現在讓我們為自己的類型實現<code>Add</code>。讓我們想象一下，我們想把兩個國家加在一起，這樣我們就可以比較它們的經濟。它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
use std::ops::Add;

#[derive(Clone)]
struct Country {
    name: String,
    population: u32,
    gdp: u32, // This is the size of the economy
}

impl Country {
    fn new(name: &amp;str, population: u32, gdp: u32) -&gt; Self {
        Self {
            name: name.to_string(),
            population,
            gdp,
        }
    }
}

impl Add for Country {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            name: format!(&quot;{} and {}&quot;, self.name, other.name), // We will add the names together,
            population: self.population + other.population, // and the population,
            gdp: self.gdp + other.gdp,   // and the GDP
        }
    }
}

impl fmt::Display for Country {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;In {} are {} people and a GDP of ${}&quot;, // Then we can print them all with just {}
            self.name, self.population, self.gdp
        )
    }
}

fn main() {
    let nauru = Country::new(&quot;Nauru&quot;, 10_670, 160_000_000);
    let vanuatu = Country::new(&quot;Vanuatu&quot;, 307_815, 820_000_000);
    let micronesia = Country::new(&quot;Micronesia&quot;, 104_468, 367_000_000);

    // We could have given Country a &amp;str instead of a String for the name. But we would have to write lifetimes everywhere
    // and that would be too much for a small example. Better to just clone them when we call println!.
    println!(&quot;{}&quot;, nauru.clone());
    println!(&quot;{}&quot;, nauru.clone() + vanuatu.clone());
    println!(&quot;{}&quot;, nauru + vanuatu + micronesia);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">In Nauru are 10670 people and a GDP of $160000000
In Nauru and Vanuatu are 318485 people and a GDP of $980000000
In Nauru and Vanuatu and Micronesia are 422953 people and a GDP of $1347000000
</code></pre>
<p>以後在這段代碼中，我們可以把<code>.fmt()</code>改成更容易閱讀的數字顯示。</p>
<p>另外三個叫<code>Sub</code>、<code>Mul</code>和<code>Div</code>，實現起來基本一樣。<code>+=</code>、<code>-=</code>、<code>*=</code>和<code>/=</code>，只要加上<code>Assign</code>:<code>AddAssign</code>、<code>SubAssign</code>、<code>MulAssign</code>和<code>DivAssign</code>即可。你可以看到完整的列表<a href="https://doc.rust-lang.org/std/ops/index.html#structs">這裡</a>，因為還有很多。例如 <code>%</code> 被稱為 <code>Rem</code>, <code>-</code> 被稱為 <code>Neg</code>, 等等。</p>
<h3 id="浮點數-1"><a class="header" href="#浮點數-1">浮點數</a></h3>
<p><code>f32</code>和<code>f64</code>有非常多的方法，你在做數學計算的時候會用到。我們不看這些，但這裡有一些你可能會用到的方法。它們分別是 <code>.floor()</code>, <code>.ceil()</code>, <code>.round()</code>, 和 <code>.trunc()</code>. 所有這些方法都返回一個 <code>f32</code> 或 <code>f64</code>，它像一個整數，小數點後面是 <code>0</code>。它們是這樣做的。</p>
<ul>
<li><code>.floor()</code>: 給你下一個最低的整數.</li>
<li><code>.ceil()</code>: 給你下一個最高的整數。</li>
<li><code>.round()</code>: 如果小數部分大於等於0.5，返回數值加1;如果小數部分小於0.5，返回相同數值。這就是所謂的四捨五入，因為它給你一個 &quot;舍入&quot;的數字(一個數字的簡短形式)。</li>
<li><code>.trunc()</code>:只是把小數點號後的部分截掉。Truncate是 &quot;截斷&quot;的意思。</li>
</ul>
<p>這裡有一個簡單的函數來打印它們。</p>
<pre><pre class="playground"><code class="language-rust">fn four_operations(input: f64) {
    println!(
&quot;For the number {}:
floor: {}
ceiling: {}
rounded: {}
truncated: {}\n&quot;,
        input,
        input.floor(),
        input.ceil(),
        input.round(),
        input.trunc()
    );
}

fn main() {
    four_operations(9.1);
    four_operations(100.7);
    four_operations(-1.1);
    four_operations(-19.9);
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">For the number 9.1:
floor: 9
ceiling: 10
rounded: 9 // because less than 9.5
truncated: 9

For the number 100.7:
floor: 100
ceiling: 101
rounded: 101 // because more than 100.5
truncated: 100

For the number -1.1:
floor: -2
ceiling: -1
rounded: -1
truncated: -1

For the number -19.9:
floor: -20
ceiling: -19
rounded: -20
truncated: -19
</code></pre>
<p><code>f32</code> 和 <code>f64</code> 有一個叫做 <code>.max()</code> 和 <code>.min()</code> 的方法，可以得到兩個數字中較大或較小的數字。(對於其他類型，你可以直接使用<code>std::cmp::max</code>和<code>std::cmp::min</code>。)下面是用<code>.fold()</code>來得到最高或最低數的方法。你又可以看到，<code>.fold()</code>不僅僅是用來加數字的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8.0_f64, 7.6, 9.4, 10.0, 22.0, 77.345, 10.22, 3.2, -7.77, -10.0];
    let maximum = my_vec.iter().fold(f64::MIN, |current_number, next_number| current_number.max(*next_number)); // Note: start with the lowest possible number for an f64.
    let minimum = my_vec.iter().fold(f64::MAX, |current_number, next_number| current_number.min(*next_number)); // And here start with the highest possible number
    println!(&quot;{}, {}&quot;, maximum, minimum);
}
</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">bool</a></h3>
<p>在 Rust 中，如果你願意，你可以把 <code>bool</code> 變成一個整數，因為這樣做是安全的。但你不能反過來做。如你所見，<code>true</code>變成了1，<code>false</code>變成了0。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false = (true, false);
    println!(&quot;{} {}&quot;, true_false.0 as u8, true_false.1 as i32);
}
</code></pre></pre>
<p>這將打印出<code>1 0</code>。如果你告訴編譯器類型，也可以使用 <code>.into()</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false: (i128, u16) = (true.into(), false.into());
    println!(&quot;{} {}&quot;, true_false.0, true_false.1);
}
</code></pre></pre>
<p>這打印的是一樣的東西。</p>
<p>從Rust 1.50(2021年2月發佈)開始，有一個叫做 <code>then()</code>的方法，它將一個 <code>bool</code>變成一個 <code>Option</code>。使用<code>then()</code>時需要一個閉包，如果item是<code>true</code>，閉包就會被調用。同時，無論從閉包中返回什麼，都會進入<code>Option</code>中。下面是一個小例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let (tru, fals) = (true.then(|| 8), false.then(|| 8));
    println!(&quot;{:?}, {:?}&quot;, tru, fals);
}
</code></pre></pre>
<p>這個打印 <code>Some(8), None</code>。</p>
<p>下面是一個較長的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let bool_vec = vec![true, false, true, false, false];

    let option_vec = bool_vec
        .iter()
        .map(|item| {
            item.then(|| { // Put this inside of map so we can pass it on
                println!(&quot;Got a {}!&quot;, item);
                &quot;It's true, you know&quot; // This goes inside Some if it's true
                                      // Otherwise it just passes on None
            })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;Now we have: {:?}&quot;, option_vec);

    // That printed out the Nones too. Let's filter map them out in a new Vec.
    let filtered_vec = option_vec.into_iter().filter_map(|c| c).collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;And without the Nones: {:?}&quot;, filtered_vec);
}
</code></pre></pre>
<p>將打印:</p>
<pre><code class="language-text">Got a true!
Got a true!
Now we have: [Some(&quot;It\'s true, you know&quot;), None, Some(&quot;It\'s true, you know&quot;), None, None]
And without the Nones: [&quot;It\'s true, you know&quot;, &quot;It\'s true, you know&quot;]
</code></pre>
<h3 id="vec-1"><a class="header" href="#vec-1">Vec</a></h3>
<p>Vec有很多方法我們還沒有看。先說說<code>.sort()</code>。<code>.sort()</code>一點都不奇怪。它使用<code>&amp;mut self</code>來對一個向量進行排序。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![100, 90, 80, 0, 0, 0, 0, 0];
    my_vec.sort();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>這樣打印出來的是<code>[0, 0, 0, 0, 0, 80, 90, 100]</code>。但還有一種更有趣的排序方式叫<code>.sort_unstable()</code>，它通常更快。它之所以更快，是因為它不在乎排序前後相同數字的先後順序。在常規的<code>.sort()</code>中，你知道最後的<code>0, 0, 0, 0, 0</code>會在<code>.sort()</code>之後的順序相同。但是<code>.sort_unstable()</code>可能會把最後一個0移到索引0，然後把第三個最後的0移到索引2，等等。</p>
<p><code>.dedup()</code>的意思是 &quot;去重複&quot;。它將刪除一個向量中相同的元素，但只有當它們彼此相鄰時才會刪除。接下來這段代碼不會只打印<code>&quot;sun&quot;, &quot;moon&quot;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![&quot;sun&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;];
    my_vec.dedup();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>它只是把另一個 &quot;sun&quot;旁邊的 &quot;sun&quot;去掉，然後把一個 &quot;moon&quot;旁邊的 &quot;moon&quot;去掉，再把另一個 &quot;moon&quot;旁邊的 &quot;moon&quot;去掉。結果是 <code>[&quot;sun&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;]</code>.</p>
<p>如果你想把每個重複的東西都去掉，就先<code>.sort()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![&quot;sun&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;];
    my_vec.sort();
    my_vec.dedup();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>結果:<code>[&quot;moon&quot;, &quot;sun&quot;]</code>.</p>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<p>你會記得，<code>String</code>有點像<code>Vec</code>。它很像<code>Vec</code>，你可以調用很多相同的方法。比如說，你可以用<code>String::with_capacity()</code>創建一個，如果你需要多次用<code>.push()</code>推一個<code>char</code>，或者用<code>.push_str()</code>推一個<code>&amp;str</code>。下面是一個有多次內存分配的<code>String</code>的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::new();
    let mut capacity_counter = 0; // capacity starts at 0
    for _ in 0..100_000 { // Do this 100,000 times
        if push_string.capacity() != capacity_counter { // First check if capacity is different now
            println!(&quot;{}&quot;, push_string.capacity()); // If it is, print it
            capacity_counter = push_string.capacity(); // then update the counter
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;); // and push this in every time
    }
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">35
70
140
280
560
1120
2240
4480
8960
17920
35840
71680
143360
286720
573440
1146880
2293760
4587520
</code></pre>
<p>我們不得不重新分配(把所有東西複製過來)18次。但既然我們知道了最終的容量，我們可以馬上設置容量，不需要重新分配:只設置一次<code>String</code>容量就夠了。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520); // We know the exact number. Some different big number could work too
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!(&quot;{}&quot;, push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;);
    }
}
</code></pre></pre>
<p>而這個打印<code>4587520</code>。完美的! 我們再也不用分配了。</p>
<p>當然，實際長度肯定比這個小。如果你試了100001次，101000次等等，還是會說<code>4587520</code>。這是因為每次的容量都是之前的2倍。不過我們可以用<code>.shrink_to_fit()</code>來縮小它(和<code>Vec</code>一樣)。我們的<code>String</code>已經非常大了，我們不想再給它增加任何東西，所以我們可以把它縮小一點。但是隻有在你有把握的情況下才可以這樣做:下面是原因。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520);
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!(&quot;{}&quot;, push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;);
    }
    push_string.shrink_to_fit();
    println!(&quot;{}&quot;, push_string.capacity());
    push_string.push('a');
    println!(&quot;{}&quot;, push_string.capacity());
    push_string.shrink_to_fit();
    println!(&quot;{}&quot;, push_string.capacity());
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">4587520
3500000
7000000
3500001
</code></pre>
<p>所以首先我們的大小是<code>4587520</code>，但我們沒有全部使用。我們用了<code>.shrink_to_fit()</code>，然後把大小降到了<code>3500000</code>。但是我們忘記了我們需要推上一個 <code>a</code>。當我們這樣做的時候，Rust 看到我們需要更多的空間，給了我們雙倍的空間:現在是 <code>7000000</code>。Whoops! 所以我們又調用了<code>.shrink_to_fit()</code>，現在又回到了<code>3500001</code>。</p>
<p><code>.pop()</code>對<code>String</code>有用，就像對<code>Vec</code>一樣。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;.daer ot drah tib elttil a si gnirts sihT&quot;);
    loop {
        let pop_result = my_string.pop();
        match pop_result {
            Some(character) =&gt; print!(&quot;{}&quot;, character),
            None =&gt; break,
        }
    }
}
</code></pre></pre>
<p>這打印的是<code>This string is a little bit hard to read.</code>，因為它是從最後一個字符開始的。</p>
<p><code>.retain()</code>是一個使用閉包的方法，這對<code>String</code>來說是罕見的。就像在迭代器上的<code>.filter()</code>一樣。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Age: 20 Height: 194 Weight: 80&quot;);
    my_string.retain(|character| character.is_alphabetic() || character == ' '); // Keep if a letter or a space
    dbg!(my_string); // Let's use dbg!() for fun this time instead of println!
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">[src\main.rs:4] my_string = &quot;Age  Height  Weight &quot;
</code></pre>
<h3 id="osstring和cstring"><a class="header" href="#osstring和cstring">OsString和CString</a></h3>
<p><code>std::ffi</code>是<code>std</code>的一部分，它幫助你將Rust與其他語言或操作系統一起使用。它有<code>OsString</code>和<code>CString</code>這樣的類型，它們就像操作系統的<code>String</code>或語言C的<code>String</code>一樣，它們各自也有自己的<code>&amp;str</code>類型:<code>OsStr</code>和<code>CStr</code>。<code>ffi</code>的意思是 &quot;foreign function interface&quot;(外部函數接口)。</p>
<p>當你必須與一個沒有Unicode的操作系統一起工作時，你可以使用<code>OsString</code>。所有的Rust字符串都是unicode，但不是每個操作系統支持。下面是標準庫中關於為什麼我們有<code>OsString</code>的簡單英文解釋。</p>
<ul>
<li>Unix系統(Linux等)上的字符串可能是很多沒有0的字節組合在一起。而且有時你會把它們讀成Unicode UTF-8。</li>
<li>Windows上的字符串可能是由隨機的16位值組成的，沒有0。有時你會把它們讀成Unicode UTF-16。</li>
<li>在Rust中，字符串總是有效的UTF-8，其中可能包含0。</li>
</ul>
<p>所以，<code>OsString</code>被設計為支持它們讀取。</p>
<p>你可以用一個<code>OsString</code>做所有常規的事情，比如<code>OsString::from(&quot;Write something here&quot;)</code>。它還有一個有趣的方法，叫做 <code>.into_string()</code>，試圖把自己變成一個常規的 <code>String</code>。它返回一個 <code>Result</code>，但 <code>Err</code> 部分只是原來的 <code>OsString</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn into_string(self) -&gt; Result&lt;String, OsString&gt;
<span class="boring">}
</span></code></pre></pre>
<p>所以如果不行的話，那你就把它找回來。你不能調用<code>.unwrap()</code>，因為它會崩潰，但是你可以使用<code>match</code>來找回<code>OsString</code>。我們通過調用不存在的方法來測試一下。</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::OsString;

fn main() {
    // ⚠️
    let os_string = OsString::from(&quot;This string works for your OS too.&quot;);
    match os_string.into_string() {
        Ok(valid) =&gt; valid.thth(),           // Compiler: &quot;What's .thth()??&quot;
        Err(not_valid) =&gt; not_valid.occg(),  // Compiler: &quot;What's .occg()??&quot;
    }
}
</code></pre></pre>
<p>然後編譯器準確地告訴我們我們想知道的東西。</p>
<pre><code class="language-text">error[E0599]: no method named `thth` found for struct `std::string::String` in the current scope
 --&gt; src/main.rs:6:28
  |
6 |         Ok(valid) =&gt; valid.thth(),
  |                            ^^^^ method not found in `std::string::String`

error[E0599]: no method named `occg` found for struct `std::ffi::OsString` in the current scope
 --&gt; src/main.rs:7:37
  |
7 |         Err(not_valid) =&gt; not_valid.occg(),
  |                                     ^^^^ method not found in `std::ffi::OsString`
</code></pre>
<p>我們可以看到，<code>valid</code>的類型是<code>String</code>，<code>not_valid</code>的類型是<code>OsString</code>。</p>
<h3 id="mem"><a class="header" href="#mem">Mem</a></h3>
<p><code>std::mem</code>有一些非常有趣的方法。我們已經看到了一些，比如<code>.size_of()</code>、<code>.size_of_val()</code>和<code>.drop()</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    println!(&quot;{}&quot;, mem::size_of::&lt;i32&gt;());
    let my_array = [8; 50];
    println!(&quot;{}&quot;, mem::size_of_val(&amp;my_array));
    let mut some_string = String::from(&quot;You can drop a String because it's on the heap&quot;);
    mem::drop(some_string);
    // some_string.clear();   If we did this it would panic
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">4
200
</code></pre>
<p>下面是<code>mem</code>中的一些其他方法。</p>
<p><code>swap()</code>: 用這個方法你可以交換兩個變量之間的值。你可以通過為每個變量創建一個可變引用來做。當你有兩個東西想交換，而Rust因為借用規則不讓你交換時，這很有幫助。或者只是當你想快速切換兩個東西的時候。</p>
<p>這裡有一個例子。</p>
<pre><pre class="playground"><code class="language-rust">use std::{mem, fmt};

struct Ring { // Create a ring from Lord of the Rings
    owner: String,
    former_owner: String,
    seeker: String, // seeker means &quot;person looking for it&quot;
}

impl Ring {
    fn new(owner: &amp;str, former_owner: &amp;str, seeker: &amp;str) -&gt; Self {
        Self {
            owner: owner.to_string(),
            former_owner: former_owner.to_string(),
            seeker: seeker.to_string(),
        }
    }
}

impl fmt::Display for Ring { // Display to show who has it and who wants it
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, &quot;{} has the ring, {} used to have it, and {} wants it&quot;, self.owner, self.former_owner, self.seeker)
        }
}

fn main() {
    let mut one_ring = Ring::new(&quot;Frodo&quot;, &quot;Gollum&quot;, &quot;Sauron&quot;);
    println!(&quot;{}&quot;, one_ring);
    mem::swap(&amp;mut one_ring.owner, &amp;mut one_ring.former_owner); // Gollum got the ring back for a second
    println!(&quot;{}&quot;, one_ring);
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">Frodo has the ring, Gollum used to have it, and Sauron wants it
Gollum has the ring, Frodo used to have it, and Sauron wants it
</code></pre>
<p><code>replace()</code>:這個就像swap一樣，其實裡面也用了swap，你可以看到。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn replace&lt;T&gt;(dest: &amp;mut T, mut src: T) -&gt; T {
    swap(dest, &amp;mut src);
    src
}
<span class="boring">}
</span></code></pre></pre>
<p>所以它只是做了一個交換，然後返回另一個元素。有了這個，你就用你放進去的其他東西來替換這個值。因為它返回的是舊的值，所以你應該用<code>let</code>來使用它。下面是一個簡單的例子。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct City {
    name: String,
}

impl City {
    fn change_name(&amp;mut self, name: &amp;str) {
        let old_name = mem::replace(&amp;mut self.name, name.to_string());
        println!(
            &quot;The city once called {} is now called {}.&quot;,
            old_name, self.name
        );
    }
}

fn main() {
    let mut capital_city = City {
        name: &quot;Constantinople&quot;.to_string(),
    };
    capital_city.change_name(&quot;Istanbul&quot;);
}
</code></pre></pre>
<p>這樣就會打印出<code>The city once called Constantinople is now called Istanbul.</code>。</p>
<p>有一個函數叫<code>.take()</code>，和<code>.replace()</code>一樣，但它在元素中留下了默認值。
你會記得，默認值通常是0、&quot;&quot;之類的東西。這裡是簽名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn take&lt;T&gt;(dest: &amp;mut T) -&gt; T
where
    T: Default,
<span class="boring">}
</span></code></pre></pre>
<p>所以你可以做這樣的事情。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    let mut number_vec = vec![8, 7, 0, 2, 49, 9999];
    let mut new_vec = vec![];

    number_vec.iter_mut().for_each(|number| {
        let taker = mem::take(number);
        new_vec.push(taker);
    });

    println!(&quot;{:?}\n{:?}&quot;, number_vec, new_vec);
}
</code></pre></pre>
<p>你可以看到，它將所有數字都替換為0:沒有刪除任何索引。</p>
<pre><code class="language-text">[0, 0, 0, 0, 0, 0]
[8, 7, 0, 2, 49, 9999]
</code></pre>
<p>當然，對於你自己的類型，你可以把<code>Default</code>實現成任何你想要的類型。我們來看一個例子，我們有一個<code>Bank</code>和一個<code>Robber</code>。每次他搶了<code>Bank</code>，他就會在桌子上拿到錢。但是辦公桌可以隨時從後面拿錢，所以它永遠有50。我們將為此自制一個類型，所以它將永遠有50。下面是它的工作原理。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
use std::ops::{Deref, DerefMut}; // We will use this to get the power of u32

struct Bank {
    money_inside: u32,
    money_at_desk: DeskMoney, // This is our &quot;smart pointer&quot; type. It has its own default, but it will use u32
}

struct DeskMoney(u32);

impl Default for DeskMoney {
    fn default() -&gt; Self {
        Self(50) // default is always 50, not 0
    }
}

impl Deref for DeskMoney { // With this we can access the u32 using *
    type Target = u32;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for DeskMoney { // And with this we can add, subtract, etc.
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

impl Bank {
    fn check_money(&amp;self) {
        println!(
            &quot;There is ${} in the back and ${} at the desk.\n&quot;,
            self.money_inside, *self.money_at_desk // Use * so we can just print the u32
        );
    }
}

struct Robber {
    money_in_pocket: u32,
}

impl Robber {
    fn check_money(&amp;self) {
        println!(&quot;The robber has ${} right now.\n&quot;, self.money_in_pocket);
    }

    fn rob_bank(&amp;mut self, bank: &amp;mut Bank) {
        let new_money = mem::take(&amp;mut bank.money_at_desk); // Here it takes the money, and leaves 50 because that is the default
        self.money_in_pocket += *new_money; // Use * because we can only add u32. DeskMoney can't add
        bank.money_inside -= *new_money;    // Same here
        println!(&quot;She robbed the bank. She now has ${}!\n&quot;, self.money_in_pocket);
    }
}

fn main() {
    let mut bank_of_klezkavania = Bank { // Set up our bank
        money_inside: 5000,
        money_at_desk: DeskMoney(50),
    };
    bank_of_klezkavania.check_money();

    let mut robber = Robber { // Set up our robber
        money_in_pocket: 50,
    };
    robber.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Rob, then check money
    robber.check_money();
    bank_of_klezkavania.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Do it again
    robber.check_money();
    bank_of_klezkavania.check_money();

}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">There is $5000 in the back and $50 at the desk.

The robber has $50 right now.

She robbed the bank. She now has $100!

The robber has $100 right now.

There is $4950 in the back and $50 at the desk.

She robbed the bank. She now has $150!

The robber has $150 right now.

There is $4900 in the back and $50 at the desk.
</code></pre>
<p>你可以看到桌子上總是有50美元。</p>
<h3 id="prelude"><a class="header" href="#prelude">Prelude</a></h3>
<p>標準庫也有一個prelude，這就是為什麼你不用寫<code>use std::vec::Vec</code>這樣的東西來創建一個<code>Vec</code>。你可以<a href="https://doc.rust-lang.org/std/prelude/index.html#prelude-contents">在這裡</a>看到所有這些元素，並且大致瞭解:</p>
<ul>
<li><code>std::marker::{Copy, Send, Sized, Sync, Unpin}</code>. 你以前沒有見過<code>Unpin</code>，因為幾乎每一種類型都會用到它(比如<code>Sized</code>，也很常見)。&quot;Pin&quot;的意思是不讓東西動。在這種情況下，<code>Pin</code>意味著它在內存中不能移動，但大多數元素都有<code>Unpin</code>，所以你可以移動。這就是為什麼像<code>std::mem::replace</code>這樣的函數能用，因為它們沒有被釘住。</li>
<li><code>std::ops::{Drop, Fn, FnMut, FnOnce}</code>.</li>
<li><code>std::mem::drop</code></li>
<li><code>std::boxed::Box</code>.</li>
<li><code>std::borrow::ToOwned</code>. 你之前用<code>Cow</code>看到過一點，它可以把借來的內容變成自己的。它使用<code>.to_owned()</code>來實現這個功能。你也可以在<code>&amp;str</code>上使用<code>.to_owned()</code>，得到一個<code>String</code>，對於其他借來的值也是一樣。</li>
<li><code>std::clone::Clone</code></li>
<li><code>std::cmp::{PartialEq, PartialOrd, Eq, Ord}</code>.</li>
<li><code>std::convert::{AsRef, AsMut, Into, From}</code>.</li>
<li><code>std::default::Default</code>.</li>
<li><code>std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}</code>. 我們之前用<code>.rev()</code>來做迭代器:這實際上是做了一個<code>DoubleEndedIterator</code>。<code>ExactSizeIterator</code>只是類似於<code>0..10</code>的東西:它已經知道自己的<code>.len()</code>是10。其他迭代器不知道它們的長度是肯定的。</li>
<li><code>std::option::Option::{self, Some, None}</code>.</li>
<li><code>std::result::Result::{self, Ok, Err}</code>.</li>
<li><code>std::string::{String, ToString}</code>.</li>
<li><code>std::vec::Vec</code>.</li>
</ul>
<p>如果你因為某些原因不想要這個prelude怎麼辦？就加屬性<code>#![no_implicit_prelude]</code>。我們來試一試，看編譯器的抱怨。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
#![no_implicit_prelude]
fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from(&quot;This won't work&quot;);
    println!(&quot;{:?}, {}&quot;, my_vec, my_string);
}
</code></pre></pre>
<p>現在Rust根本不知道你想做什麼。</p>
<pre><code class="language-text">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:5:5
  |
5 |     println!(&quot;{:?}, {}&quot;, my_vec, my_string);
  |     ^^^^^^^

error: cannot find macro `vec` in this scope
 --&gt; src/main.rs:3:18
  |
3 |     let my_vec = vec![8, 9, 10];
  |                  ^^^

error[E0433]: failed to resolve: use of undeclared type or module `String`
 --&gt; src/main.rs:4:21
  |
4 |     let my_string = String::from(&quot;This won't work&quot;);
  |                     ^^^^^^ use of undeclared type or module `String`

error: aborting due to 3 previous errors
</code></pre>
<p>因此，對於這個簡單的代碼，你需要告訴Rust使用<code>extern</code>(外部)crate，叫做<code>std</code>，然後是你想要的元素。這裡是我們要做的一切，只是為了創建一個Vec和一個String，並打印它。</p>
<pre><pre class="playground"><code class="language-rust">#![no_implicit_prelude]

extern crate std; // Now you have to tell Rust that you want to use a crate called std
use std::vec; // We need the vec macro
use std::string::String; // and string
use std::convert::From; // and this to convert from a &amp;str to the String
use std::println; // and this to print

fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from(&quot;This won't work&quot;);
    println!(&quot;{:?}, {}&quot;, my_vec, my_string);
}
</code></pre></pre>
<p>現在終於成功了，打印出<code>[8, 9, 10], This won't work</code>。所以你可以明白為什麼Rust要用prelude了。但如果你願意，你不需要使用它。而且你甚至可以使用<code>#![no_std]</code>(我們曾經看到過)，用於你連堆棧內存這種東西都用不上的時候。但大多數時候，你根本不用考慮不用prelude或<code>std</code>。</p>
<p>那麼為什麼之前我們沒有看到<code>extern</code>這個關鍵字呢？是因為你已經不需要它了。以前，當帶入外部crate時，你必須使用它。所以以前要使用<code>rand</code>，你必須要寫成:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate rand;
<span class="boring">}
</span></code></pre></pre>
<p>然後用 <code>use</code> 語句來表示你想使用的修改、trait等。但現在Rust編譯器已經不需要這些幫助了--你只需要使用<code>use</code>，rust就知道在哪裡可以找到它。所以你幾乎再也不需要<code>extern crate</code>了，但在其他人的Rust代碼中，你可能仍然會在頂部看到它。</p>
<h3 id="time"><a class="header" href="#time">Time</a></h3>
<p><code>std::time</code>是你可以找到時間函數的地方。(如果你想要更多的功能，<code>chrono</code>這樣的crate也可以。)最簡單的功能就是用<code>Instant::now()</code>獲取系統時間即可。</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time = Instant::now();
    println!(&quot;{:?}&quot;, time);
}
</code></pre></pre>
<p>如果你打印出來，你會得到這樣的東西。<code>Instant { tv_sec: 2738771, tv_nsec: 685628140 }</code>. 這說的是秒和納秒，但用處不大。比如你看2738771秒(寫於8月)，就是31.70天。這和月份、日子沒有任何關係。但是<code>Instant</code>的頁面告訴我們，它本身不應該有用。它說它是 &quot;不透明的，只有和Duration一起才有用&quot;。Opaque的意思是 &quot;你搞不清楚&quot;，而Duration的意思是 &quot;過了多少時間&quot;。所以它只有在做比較時間這樣的事情時才有用。</p>
<p>如果你看左邊的trait，其中一個是<code>Sub&lt;Instant&gt;</code>。也就是說我們可以用<code>-</code>來減去一個。而當我們點擊[src]看它的作用時，頁面顯示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sub&lt;Instant&gt; for Instant {
    type Output = Duration;

    fn sub(self, other: Instant) -&gt; Duration {
        self.duration_since(other)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>因此，它需要一個<code>Instant</code>，並使用<code>.duration_since()</code>給出一個<code>Duration</code>。讓我們試著打印一下。我們將創建兩個相鄰的 <code>Instant::now()</code>，然後讓程序忙活一會兒，再創建一個 <code>Instant::now()</code>。然後我們再創建一個<code>Instant::now()</code>. 最後，我們來看看用了多長時間。</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = Instant::now();
    let time2 = Instant::now(); // These two are right next to each other

    let mut new_string = String::new();
    loop {
        new_string.push('წ'); // Make Rust push this Georgian letter onto the String
        if new_string.len() &gt; 100_000 { //  until it is 100,000 bytes long
            break;
        }
    }
    let time3 = Instant::now();
    println!(&quot;{:?}&quot;, time2 - time1);
    println!(&quot;{:?}&quot;, time3 - time1);
}
</code></pre></pre>
<p>這將打印出這樣的東西。</p>
<pre><code class="language-text">1.025µs
683.378µs
</code></pre>
<p>所以，這只是1微秒多與683毫秒。我們可以看到，Rust確實花了一些時間來做。</p>
<p>不過我們可以用一個<code>Instant</code>做一件有趣的事情。
我們可以把它變成<code>String</code>與<code>format!(&quot;{:?}&quot;, Instant::now());</code>。它的樣子是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = format!(&quot;{:?}&quot;, Instant::now());
    println!(&quot;{}&quot;, time1);
}
</code></pre></pre>
<p>這樣就會打印出類似<code>Instant { tv_sec: 2740773, tv_nsec: 632821036 }</code>的東西。這是沒有用的，但是如果我們使用 <code>.iter()</code> 和 <code>.rev()</code> 以及 <code>.skip(2)</code>，我們可以跳過最後的 <code>}</code> 和 <code> </code>。我們可以用它來創建一個隨機數發生器。</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn bad_random_number(digits: usize) {
    if digits &gt; 9 {
        panic!(&quot;Random number can only be up to 9 digits&quot;);
    }
    let now = Instant::now();
    let output = format!(&quot;{:?}&quot;, now);

    output
        .chars()
        .rev()
        .skip(2)
        .take(digits)
        .for_each(|character| print!(&quot;{}&quot;, character));
    println!();
}

fn main() {
    bad_random_number(1);
    bad_random_number(1);
    bad_random_number(3);
    bad_random_number(3);
}
</code></pre></pre>
<p>這樣就會打印出類似這樣的內容:</p>
<pre><code class="language-text">6
4
967
180
</code></pre>
<p>這個函數被稱為<code>bad_random_number</code>，因為它不是一個很好的隨機數生成器。Rust有更好的crate，可以用比<code>rand</code>更少的代碼創建隨機數，比如<code>fastrand</code>。但這是一個很好的例子，你可以利用你的想象力用<code>Instant</code>來做一些事情。</p>
<p>當你有一個線程時，你可以使用<code>std::thread::sleep</code>使它停止一段時間。當你這樣做時，你必須給它一個duration。你不必創建多個線程來做這件事，因為每個程序至少在一個線程上。<code>sleep</code>雖然需要一個<code>Duration</code>，所以它可以知道要睡多久。你可以這樣選單位:<code>Duration::from_millis()</code>, <code>Duration::from_secs</code>, 等等。這裡舉一個例子:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use std::thread::sleep;

fn main() {
    let three_seconds = Duration::from_secs(3);
    println!(&quot;I must sleep now.&quot;);
    sleep(three_seconds);
    println!(&quot;Did I miss anything?&quot;);
}
</code></pre></pre>
<p>這將只打印</p>
<pre><code class="language-text">I must sleep now.
Did I miss anything?
</code></pre>
<p>但線程在三秒鐘內什麼也不做。當你有很多線程需要經常嘗試一些事情時，比如連接，你通常會使用<code>.sleep()</code>。你不希望線程在一秒鐘內使用你的處理器嘗試10萬次，而你只是想讓它有時檢查一下。所以，你就可以設置一個<code>Duration</code>，它就會在每次醒來的時候嘗試做它的任務。</p>
<h3 id="其他宏"><a class="header" href="#其他宏">其他宏</a></h3>
<p>我們再來看看其他一些宏。</p>
<p><code>unreachable!()</code></p>
<p>這個宏有點像<code>todo!()</code>，除了它是針對你永遠不會用的代碼。也許你在一個枚舉中有一個<code>match</code>，你知道它永遠不會選擇其中的一個分支，所以代碼永遠無法達到那個分支。如果是這樣，你可以寫<code>unreachable!()</code>，這樣編譯器就知道可以忽略這部分。</p>
<p>例如，假設你有一個程序，當你選擇一個地方居住時，它會寫一些東西。在烏克蘭，除了切爾諾貝利，其他地方都不錯。你的程序不讓任何人選擇切爾諾貝利，因為它現在不是一個好地方。但是這個枚舉是很早以前在別人的代碼裡做的，你無法更改。所以在<code>match</code>的分支中，你可以用這個宏。它是這樣的:</p>
<pre><pre class="playground"><code class="language-rust">enum UkrainePlaces {
    Kiev,
    Kharkiv,
    Chernobyl, // Pretend we can't change the enum - Chernobyl will always be here
    Odesa,
    Dnipro,
}

fn choose_city(place: &amp;UkrainePlaces) {
    use UkrainePlaces::*;
    match place {
        Kiev =&gt; println!(&quot;You will live in Kiev&quot;),
        Kharkiv =&gt; println!(&quot;You will live in Kharkiv&quot;),
        Chernobyl =&gt; unreachable!(),
        Odesa =&gt; println!(&quot;You will live in Odesa&quot;),
        Dnipro =&gt; println!(&quot;You will live in Dnipro&quot;),
    }
}

fn main() {
    let user_input = UkrainePlaces::Kiev; // Pretend the user input is made from some other function. The user can't choose Chernobyl, no matter what
    choose_city(&amp;user_input);
}
</code></pre></pre>
<p>這將打印出 <code>You will live in Kiev</code>。</p>
<p><code>unreachable!()</code>對你來說也很好讀，因為它提醒你代碼的某些部分是不可訪問的。不過你必須確定代碼確實是不可訪問的。如果編譯器調用<code>unreachable!()</code>，程序就會崩潰。</p>
<p>此外，如果你曾經有不可達的代碼，而編譯器知道，它會告訴你。下面是一個簡單的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_or_false = true;

    match true_or_false {
        true =&gt; println!(&quot;It's true&quot;),
        false =&gt; println!(&quot;It's false&quot;),
        true =&gt; println!(&quot;It's true&quot;), // Whoops, we wrote true again
    }
}
</code></pre></pre>
<p>它會說</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; src/main.rs:7:9
  |
7 |         true =&gt; println!(&quot;It's true&quot;),
  |         ^^^^
  |
</code></pre>
<p>但是<code>unreachable!()</code>是用於編譯器無法知道的時候，就像我們另一個例子。</p>
<p><code>column!</code>, <code>line!</code>, <code>file!</code>, <code>module_path!</code></p>
<p>這四個宏有點像<code>dbg!()</code>，因為你只是把它們放進代碼去給你調試信息。但是它們不需要任何變量--你只需要用它們和括號一起使用，而沒有其他的東西。它們放到一起很容易學:</p>
<ul>
<li><code>column!()</code>給你寫的那一列</li>
<li><code>file!()</code>給你寫的文件的名稱</li>
<li><code>line!()</code>給你寫的那行字，然後是</li>
<li><code>module_path!()</code>給你模塊的位置。</li>
</ul>
<p>接下來的代碼在一個簡單的例子中展示了這三者。我們將假裝有更多的代碼(mod裡面的mod)，因為這就是我們要使用這些宏的原因。你可以想象一個大的Rust程序,它有許多mod和文件。</p>
<pre><pre class="playground"><code class="language-rust">pub mod something {
    pub mod third_mod {
        pub fn print_a_country(input: &amp;mut Vec&lt;&amp;str&gt;) {
            println!(
                &quot;The last country is {} inside the module {}&quot;,
                input.pop().unwrap(),
                module_path!()
            );
        }
    }
}

fn main() {
    use something::third_mod::*;
    let mut country_vec = vec![&quot;Portugal&quot;, &quot;Czechia&quot;, &quot;Finland&quot;];

    // do some stuff
    println!(&quot;Hello from file {}&quot;, file!());

    // do some stuff
    println!(
        &quot;On line {} we got the country {}&quot;,
        line!(),
        country_vec.pop().unwrap()
    );

    // do some more stuff

    println!(
        &quot;The next country is {} on line {} and column {}.&quot;,
        country_vec.pop().unwrap(),
        line!(),
        column!(),
    );

    // lots more code

    print_a_country(&amp;mut country_vec);
}
</code></pre></pre>
<p>它打印的是這樣的。</p>
<pre><code class="language-text">Hello from file src/main.rs
On line 23 we got the country Finland
The next country is Czechia on line 32 and column 9.
The last country is Portugal inside the module rust_book::something::third_mod
</code></pre>
<p><code>cfg!</code></p>
<p>我們知道，你可以使用 <code>#[cfg(test)]</code> 和 <code>#[cfg(windows)]</code> 這樣的屬性來告訴編譯器在某些情況下該怎麼做。當你有<code>test</code>時，當你在測試模式下運行Rust時，它會運行代碼(如果是在電腦上，你輸入<code>cargo test</code>)。而當你使用<code>windows</code>時，如果用戶使用的是Windows，它就會運行代碼。但也許你只是想根據不同操作系統對依賴系統的代碼做很小的修改。這時候這個宏就很有用了。它返回一個<code>bool</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let helpful_message = if cfg!(target_os = &quot;windows&quot;) { &quot;backslash&quot; } else { &quot;slash&quot; };

    println!(
        &quot;...then in your hard drive, type the directory name followed by a {}. Then you...&quot;,
        helpful_message
    );
}
</code></pre></pre>
<p>這將以不同的方式打印，取決於你的系統。Rust Playground在Linux上運行，所以會打印:</p>
<pre><code class="language-text">...then in your hard drive, type the directory name followed by a slash. Then you...
</code></pre>
<p><code>cfg!()</code>適用於任何一種配置。下面是一個例子，當你在測試中使用一個函數時，它的運行方式會有所不同。</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)] // cfg! will know to look for the word test
mod testing {
    use super::*;
    #[test]
    fn check_if_five() {
        assert_eq!(bring_number(true), 5); // This bring_number() function should return 5
    }
}

fn bring_number(should_run: bool) -&gt; u32 { // This function takes a bool as to whether it should run
    if cfg!(test) &amp;&amp; should_run { // if it should run and has the configuration test, return 5
        5
    } else if should_run { // if it's not a test but it should run, print something. When you run a test it ignores println! statements
        println!(&quot;Returning 5. This is not a test&quot;);
        5
    } else {
        println!(&quot;This shouldn't run, returning 0.&quot;); // otherwise return 0
        0
    }
}

fn main() {
    bring_number(true);
    bring_number(false);
}
</code></pre></pre>
<p>現在根據配置的不同，它的運行方式也會不同。如果你只是運行程序，它會給你這樣的結果:</p>
<pre><code class="language-text">Returning 5. This is not a test
This shouldn't run, returning 0.
</code></pre>
<p>但如果你在測試模式下運行它(<code>cargo test</code>，用於電腦上的Rust)，它實際上會運行測試。因為在這種情況下，測試總是返回5，所以它會通過。</p>
<pre><code class="language-text">running 1 test
test testing::check_if_five ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="編寫宏"><a class="header" href="#編寫宏">編寫宏</a></h2>
<p>編寫宏是非常複雜的。你可能永遠都不需要寫宏，但有時你可能會想寫，因為它們非常方便。寫宏很有趣，因為它們幾乎是不同的語言。要寫一個宏，你實際上是用另一個叫<code>macro_rules!</code>的宏。然後你添加你的宏名稱，並打開一個<code>{}</code>塊。裡面有點像<code>match</code>語句。</p>
<p>這裡有一個只取<code>()</code>，然後返回6:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! give_six {
    () =&gt; {
        6
    };
}

fn main() {
    let six = give_six!();
    println!(&quot;{}&quot;, six);
}
</code></pre></pre>
<p>但這和<code>match</code>語句是不一樣的，因為宏實際上不會編譯任何東西。它只是接受一個輸入並給出一個輸出。然後編譯器會檢查它是否有意義。這就是為什麼宏就像 &quot;寫代碼的代碼&quot;。你會記得，一個真正的<code>match</code>語句需要給出相同的類型，所以這不會工作:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
// ⚠️
    let my_number = 10;
    match my_number {
        10 =&gt; println!(&quot;You got a ten&quot;),
        _ =&gt; 10,
    }
}
</code></pre></pre>
<p>它會抱怨你在一種情況下要返回<code>()</code>，在另一種情況下要返回<code>i32</code>。</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
 --&gt; src\main.rs:5:14
  |
3 | /     match my_number {
4 | |         10 =&gt; println!(&quot;You got a ten&quot;),
  | |               ------------------------- this is found to be of type `()`
5 | |         _ =&gt; 10,
  | |              ^^ expected `()`, found integer
6 | |     }
  | |_____- `match` arms have incompatible types
</code></pre>
<p>但宏並不關心，因為它只是給出一個輸出。它不是一個編譯器--它是代碼前的代碼。所以你可以這樣做:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! six_or_print {
    (6) =&gt; {
        6
    };
    () =&gt; {
        println!(&quot;You didn't give me 6.&quot;);
    };
}

fn main() {
    let my_number = six_or_print!(6);
    six_or_print!();
}
</code></pre></pre>
<p>這個就好辦了，打印的是<code>You didn't give me 6.</code>。你也可以看到，這不是匹配分支，因為沒有<code>_</code>行。我們只能給它<code>(6)</code>，或者<code>()</code>，其他的都會出錯。而我們給它的<code>6</code>甚至不是<code>i32</code>，只是一個輸入6。其實你可以設置任何東西作為宏的輸入，因為它只是看輸入，看得到什麼。比如說:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    (THis is strange input 하하はは哈哈 but it still works) =&gt; {
        println!(&quot;You guessed the secret message!&quot;)
    };
    () =&gt; {
        println!(&quot;You didn't guess it&quot;);
    };
}

fn main() {
    might_print!(THis is strange input 하하はは哈哈 but it still works);
    might_print!();
}
</code></pre></pre>
<p>所以這個奇怪的宏只響應兩件事。<code>()</code>和<code>(THis is strange input 하하はは哈哈 but it still works)</code>. 沒有其他的東西。它打印的是:</p>
<pre><code class="language-text">You guessed the secret message!
You didn't guess it
</code></pre>
<p>所以宏不完全是Rust語法。但是宏也可以理解你給它的不同類型的輸入。拿這個例子來說。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    ($input:expr) =&gt; {
        println!(&quot;You gave me: {}&quot;, $input);
    }
}

fn main() {
    might_print!(6);
}
</code></pre></pre>
<p>這將打印<code>You gave me: 6</code>。<code>$input:expr</code>部分很重要。它的意思是 &quot;對於一個表達式，給它起一個變量名$input&quot;。在宏中，變量以<code>$</code>開頭。在這個宏中，如果你給它一個表達式，它就會打印出來。我們再來試一試。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    ($input:expr) =&gt; {
        println!(&quot;You gave me: {:?}&quot;, $input); // Now we'll use {:?} because we will give it different kinds of expressions
    }
}

fn main() {
    might_print!(()); // give it a ()
    might_print!(6); // give it a 6
    might_print!(vec![8, 9, 7, 10]); // give it a vec
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">You gave me: ()
You gave me: 6
You gave me: [8, 9, 7, 10]
</code></pre>
<p>另外注意，我們寫了<code>{:?}</code>，但它不會檢查<code>&amp;input</code>是否實現了<code>Debug</code>。它只會寫代碼，並嘗試讓它編譯，如果沒有，那麼它就會給出一個錯誤。</p>
<p>那麼除了<code>expr</code>，宏還能看到什麼呢？它們是 <code>block | expr | ident | item | lifetime | literal  | meta | pat | path | stmt | tt | ty | vis</code>. 這就是複雜的部分。你可以在<a href="https://doc.rust-lang.org/beta/reference/macros-by-example.html">這裡</a>看到它們各自的意思，這裡說:</p>
<pre><code class="language-text">item: an Item
block: a BlockExpression
stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)
pat: a Pattern
expr: an Expression
ty: a Type
ident: an IDENTIFIER_OR_KEYWORD
path: a TypePath style path
tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})
meta: an Attr, the contents of an attribute
lifetime: a LIFETIME_TOKEN
vis: a possibly empty Visibility qualifier
literal: matches -?LiteralExpression
</code></pre>
<p>另外有一個很好的網站叫cheats.rs，在<a href="https://cheats.rs/#macros-attributes">這裡</a>解釋了它們，並且每個都給出了例子。</p>
<p>然而，對於大多數宏，你只會用到 <code>expr</code>、<code>ident</code> 和 <code>tt</code>。<code>ident</code> 表示標識符，用於變量或函數名稱。<code>tt</code>表示token樹，和任何類型的輸入。讓我們嘗試用這兩個詞創建一個簡單的宏。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! check {
    ($input1:ident, $input2:expr) =&gt; {
        println!(
            &quot;Is {:?} equal to {:?}? {:?}&quot;,
            $input1,
            $input2,
            $input1 == $input2
        );
    };
}

fn main() {
    let x = 6;
    let my_vec = vec![7, 8, 9];
    check!(x, 6);
    check!(my_vec, vec![7, 8, 9]);
    check!(x, 10);
}
</code></pre></pre>
<p>所以這將取一個<code>ident</code>(像一個變量名)和一個表達式，看看它們是否相同。它的打印結果是</p>
<pre><code class="language-text">Is 6 equal to 6? true
Is [7, 8, 9] equal to [7, 8, 9]? true
Is 6 equal to 10? false
</code></pre>
<p>而這裡有一個宏，輸入<code>tt</code>，然後把它打印出來。它先用一個叫<code>stringify!</code>的宏創建一個字符串。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! print_anything {
    ($input:tt) =&gt; {
        let output = stringify!($input);
        println!(&quot;{}&quot;, output);
    };
}

fn main() {
    print_anything!(ththdoetd);
    print_anything!(87575oehq75onth);
}
</code></pre></pre>
<p>這個將打印:</p>
<pre><code class="language-text">ththdoetd
87575oehq75onth
</code></pre>
<p>但是如果我們給它一些帶有空格、逗號等的東西，它就不會打印。它會認為我們給了它不止一個元素或額外的信息，所以它會感到困惑。</p>
<p>這就是宏開始變得困難的地方。</p>
<p>要一次給宏提供多個元素，我們必須使用不同的語法。不要用<code>$input</code>，而是<code>$($input1),*</code>。這意味著零或更多(這是 * 的意思)，用逗號分隔。如果你想要一個或多個，請使用 <code>+</code> 而不是 <code>*</code>。</p>
<p>現在我們的宏看起來是這樣的。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! print_anything {
    ($($input1:tt),*) =&gt; {
        let output = stringify!($($input1),*);
        println!(&quot;{}&quot;, output);
    };
}


fn main() {
    print_anything!(ththdoetd, rcofe);
    print_anything!();
    print_anything!(87575oehq75onth, ntohe, 987987o, 097);
}
</code></pre></pre>
<p>所以它接受任何用逗號隔開的token樹，並使用 <code>stringify!</code> 把它變成一個字符串。然後打印出來。它的打印結果是:</p>
<pre><code class="language-text">ththdoetd, rcofe

87575oehq75onth, ntohe, 987987o, 097
</code></pre>
<p>如果我們使用<code>+</code>而不是<code>*</code>，它會給出一個錯誤，因為有一次我們沒有給它輸入。所以<code>*</code>是一個比較安全的選擇。</p>
<p>所以現在我們可以開始看到宏的威力了。在接下來的這個例子中，我們實際上可以創建我們自己的函數:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_a_function {
    ($name:ident, $($input:tt),*) =&gt; { // First you give it one name for the function, then it checks everything else
        fn $name() {
            let output = stringify!($($input),*); // It makes everything else into a string
            println!(&quot;{}&quot;, output);
        }
    };
}


fn main() {
    make_a_function!(print_it, 5, 5, 6, I); // We want a function called print_it() that prints everything else we give it
    print_it();
    make_a_function!(say_its_nice, this, is, really, nice); // Same here but we change the function name
    say_its_nice();
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">5, 5, 6, I
this, is, really, nice
</code></pre>
<p>所以現在我們可以開始瞭解其他的宏了。你可以看到，我們已經使用的一些宏非常簡單。這裡是我們用來寫入文件的<code>write!</code>的那個:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! write {
    ($dst:expr, $($arg:tt)*) =&gt; ($dst.write_fmt($crate::format_args!($($arg)*)))
}
<span class="boring">}
</span></code></pre></pre>
<p>要使用它，你就輸入這個:</p>
<ul>
<li>一個表達式(<code>expr</code>) 得到變量名<code>$dst</code>.</li>
<li>之後的一切。如果它寫的是<code>$arg:tt</code>，那麼它只會取1個，但是因為它寫的是<code>$($arg:tt)*</code>，所以它取0，1，或者任意多個。</li>
</ul>
<p>然後它取<code>$dst</code>，並對它使用了一個叫做<code>write_fmt</code>的方法。在這裡面，它使用了另一個叫做<code>format_args!</code>的宏，它接受所有的<code>$($arg)*</code>，或者我們輸入的所有參數。</p>
<p>現在我們來看一下<code>todo!</code>這個宏。當你想讓程序編譯但還沒有寫出你的代碼時，就會用到這個宏。它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! todo {
    () =&gt; (panic!(&quot;not yet implemented&quot;));
    ($($arg:tt)+) =&gt; (panic!(&quot;not yet implemented: {}&quot;, $crate::format_args!($($arg)+)));
}
<span class="boring">}
</span></code></pre></pre>
<p>這個有兩個選項:你可以輸入<code>()</code>，也可以輸入一些token樹(<code>tt</code>)。</p>
<ul>
<li>如果你輸入<code>()</code>，它只是<code>panic!</code>，並加上一個信息。所以其實你可以直接寫<code>panic!(&quot;not yet implemented&quot;)</code>，而不是<code>todo!</code>，這也是一樣的。</li>
<li>如果你輸入一些參數，它會嘗試打印它們。你可以看到裡面有同樣的<code>format_args!</code>宏，它的工作原理和<code>println!</code>一樣。</li>
</ul>
<p>所以，如果你寫了這個，它也會工作:</p>
<pre><pre class="playground"><code class="language-rust">fn not_done() {
    let time = 8;
    let reason = &quot;lack of time&quot;;
    todo!(&quot;Not done yet because of {}. Check back in {} hours&quot;, reason, time);
}

fn main() {
    not_done();
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">thread 'main' panicked at 'not yet implemented: Not done yet because of lack of time. Check back in 8 hours', src/main.rs:4:5
</code></pre>
<p>在一個宏裡面，你甚至可以調用同一個宏。這裡有一個。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Let's print this.&quot;);
    };
    ($input:expr) =&gt; {
        my_macro!();
    };
    ($($input:expr),*) =&gt; {
        my_macro!();
    }
}

fn main() {
    my_macro!(vec![8, 9, 0]);
    my_macro!(toheteh);
    my_macro!(8, 7, 0, 10);
    my_macro!();
}
</code></pre></pre>
<p>這個可以取<code>()</code>，也可以取一個表達式，也可以取很多表達式。但是不管你放什麼表達式，它都會忽略所有的表達式，只是在<code>()</code>上調用<code>my_macro!</code>。所以輸出的只是<code>Let's print this</code>，四次。</p>
<p>在<code>dbg!</code>宏中也可以看到同樣的情況，也是調用自己。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! dbg {
    () =&gt; {
        $crate::eprintln!(&quot;[{}:{}]&quot;, $crate::file!(), $crate::line!()); //$crate means the crate that it's in.
    };
    ($val:expr) =&gt; {
        // Use of `match` here is intentional because it affects the lifetimes
        // of temporaries - https://stackoverflow.com/a/48732525/1063961
        match $val {
            tmp =&gt; {
                $crate::eprintln!(&quot;[{}:{}] {} = {:#?}&quot;,
                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &amp;tmp);
                tmp
            }
        }
    };
    // Trailing comma with single argument is ignored
    ($val:expr,) =&gt; { $crate::dbg!($val) };
    ($($val:expr),+ $(,)?) =&gt; {
        ($($crate::dbg!($val)),+,)
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>(<code>eprintln!</code>與<code>println!</code>相同，只打印到<code>io::stderr</code>而不是<code>io::stdout</code>。還有<code>eprint!</code>不增加一行)。)</p>
<p>所以我們可以自己去試一試。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dbg!();
}
</code></pre></pre>
<p>這與第一分支相匹配，所以它會用<code>file!</code>和<code>line!</code>宏打印文件名和行名。它打印的是<code>[src/main.rs:2]</code>。</p>
<p>我們用這個來試試。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dbg!(vec![8, 9, 10]);
}
</code></pre></pre>
<p>這將匹配下一個分支，因為它是一個表達式。然後它將調用輸入<code>tmp</code>並使用這個代碼。<code> $crate::eprintln!(&quot;[{}:{}] {} = {:#?}&quot;, $crate::file!(), $crate::line!(), $crate::stringify!($val), &amp;tmp);</code>. 所以它會用<code>file!</code>和<code>line!</code>來打印，然後把<code>$val</code>做成<code>String</code>，用<code>{:#?}</code>來漂亮的打印<code>tmp</code>。所以對於我們的輸入，它會這樣寫。</p>
<pre><code class="language-text">[src/main.rs:2] vec![8, 9, 10] = [
    8,
    9,
    10,
]
</code></pre>
<p>剩下的部分，即使你多加了一個逗號，它也只是自己調用<code>dbg!</code>。</p>
<p>正如你所看到的，宏是非常複雜的！通常你只想讓一個宏自動完成一些簡單函數不能很好完成的事情。學習宏的最好方法是看其他宏的例子。沒有多少人能夠快速寫出宏而不出問題。所以不要認為你需要知道宏的一切，才能知道如何在Rust中寫。但如果你讀了其他宏，並稍加修改，你就可以很容易地借用它們的力量。然後你可能會開始適應寫自己的宏。</p>
<h1 id="第2部分---電腦上的rust"><a class="header" href="#第2部分---電腦上的rust">第2部分 - 電腦上的Rust</a></h1>
<p>你看到了，我們幾乎可以使用Playground學習Rust中的任何東西。但如果你到目前為止已經學了這麼多，現在你可能會想要在你的電腦上使用Rust。總有一些事情是你不能用Playground做的，比如使用文件或代碼在多個文件中。其他如輸入和flags也需要在電腦上安裝Rust。但最重要的是，在你的電腦上有了Rust，你可以使用Crate。我們已經瞭解了crate，但在playground中你只能使用最流行的crate。但在你的電腦上，你可以在程序中使用任何crate。</p>
<h2 id="cargo"><a class="header" href="#cargo">cargo</a></h2>
<p><code>rustc</code>的意思是Rust編譯器，實際的編譯工作由它完成。一個rust文件的結尾是<code>.rs</code>。但大多數人不會寫出類似 <code>rustc main.rs</code> 的東西來編譯。他們使用的是名為 <code>cargo</code> 的東西，它是 Rust 的主包管理器。</p>
<p>關於這個名字的一個說明: 之所以叫<code>cargo</code>，是因為當你把crate放在一起時，你會得到cargo。Crate就是你在船上或卡車上看到的木箱，但你記住，每個Rust項目也叫Crate。那麼當你把它們放在一起時，你就會得到整個cargo。</p>
<p>當你使用cargo來運行一個項目時，你可以看到這一點。讓我們用 <code>rand</code> 試試簡單的東西:我們只是在八個字母之間隨機選擇。</p>
<pre><pre class="playground"><code class="language-rust">use rand::seq::SliceRandom; // Use this for .choose over slices

fn main() {

    let my_letters = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

    let mut rng = rand::thread_rng();
    for _ in 0..6 {
        print!(&quot;{} &quot;, my_letters.choose(&amp;mut rng).unwrap());
    }
}
</code></pre></pre>
<p>這樣就會打印出<code>b c g h e a</code>這樣的東西。但我們想先看看<code>cargo</code>的作用。要使用 <code>cargo</code> 並運行我們的程序，通常我們輸入 <code>cargo run</code>。這樣就可以構建我們的程序，併為我們運行它。當它開始編譯的時候，會做這樣的事情:</p>
<pre><code class="language-text">   Compiling getrandom v0.1.14
   Compiling cfg-if v0.1.10
   Compiling ppv-lite86 v0.2.8
   Compiling rand_core v0.5.1
   Compiling rand_chacha v0.2.2
   Compiling rand v0.7.3
   Compiling rust_book v0.1.0 (C:\Users\mithr\OneDrive\Documents\Rust\rust_book)
    Finished dev [unoptimized + debuginfo] target(s) in 13.13s
     Running `C:\Users\mithr\OneDrive\Documents\Rust\rust_book\target\debug\rust_book.exe`
g f c f h b
</code></pre>
<p>所以看起來不只是引入了<code>rand</code>，還引入了一些其他的crate。這是因為我們的crate需要<code>rand</code>，但<code>rand</code>也有一些代碼也需要其他crate。所以<code>cargo</code>會找到我們需要的所有crate，並把它們放在一起。在我們的案例中，只有7個，但在非常大的項目中，你可能會有200個或更多的crate要引入。</p>
<p>這就是你可以看到Rust的權衡的地方。Rust的速度非常快，因為它提前編譯。它通過查看代碼，看你寫的代碼到底做了什麼。例如，你可能會寫這樣的泛型代碼:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_and_return_thing&lt;T: Display&gt;(input: T) -&gt; T {
    println!(&quot;You gave me {} and now I will give it back.&quot;, input);
    input
}

fn main() {
    let my_name = print_and_return_thing(&quot;Windy&quot;);
    let small_number = print_and_return_thing(9.0);
}
</code></pre></pre>
<p>這個函數可以用任何實現了<code>Display</code>的作為參數，所以我們給它一個<code>&amp;str</code>，接下來給它一個<code>f64</code>，這對我們來說是沒有問題的。但是編譯器不看泛型，因為它不想在運行時做任何事情。它想把一個能運行的程序儘可能快地組裝起來。所以當它看第一部分的<code>&quot;Windy&quot;</code>時，它沒有看到<code>fn print_and_return_thing&lt;T: Display&gt;(input: T) -&gt; T</code>，它看到的是<code>fn print_and_return_thing(input: &amp;str) -&gt; &amp;str</code>這樣的東西。而接下來它看到的是<code>fn print_and_return_thing(input: f64) -&gt; f64</code>。所有關於trait的檢查等等都是在編譯時完成的。這就是為什麼泛型需要更長的時間來編譯，因為它需要弄清楚它們，並使之具體化。</p>
<p>還有一點:Rust 2020正在努力處理編譯時間問題，因為這部分需要的時間最長。每一個版本的Rust在編譯時都會快一點，而且還有一些其他的計劃來加快它的速度。但與此同時，以下是你應該知道的:</p>
<ul>
<li><code>cargo build</code>會構建你的程序，這樣你就可以運行它了。</li>
<li><code>cargo run</code>將建立你的程序並運行它。</li>
<li><code>cargo build --release</code>和<code>cargo run --release</code>發佈模式下有同樣的效果。什麼是發佈模式？當你的代碼最終完成後就可以用發佈模式了。Rust會花更多的時間來編譯，但它這樣做是因為它使用了它所知道的一切，來使編譯出的程序運行更快。Release模式實際上比常規模式<em>快的多</em>，常規模式被稱為debug模式。那是因為它的編譯速度更快，而且有更多的調試信息。常規的<code>cargo build</code>叫做 &quot;debug build&quot;，<code>cargo build --release</code>叫做 &quot;release build&quot;。</li>
<li><code>cargo check</code>是一種檢查代碼的方式。它就像編譯一樣，只不過它不會真正地創建你的程序。這是一個很好的檢查你的代碼的方法，因為它不像<code>build</code>或<code>run</code>那樣需要很長時間。</li>
</ul>
<p>對了，命令中的<code>--release</code>部分叫做<code>flag</code>。這意味著命令中的額外信息。</p>
<p>其他一些你需要知道的事情是:</p>
<ul>
<li><code>cargo new</code>. 這樣做是為了創建一個新的Rust項目。<code>new</code>之後，寫上項目的名稱，<code>cargo</code>將會創建所有你需要的文件和文件夾。</li>
<li><code>cargo clean</code>. 當你把crate添加到<code>Cargo.toml</code>時，電腦會下載所有需要的文件，它們會佔用很多空間。如果你不想再讓它們在你的電腦上，輸入<code>cargo clean</code>。</li>
</ul>
<p>關於編譯器還有一點:只有當你第一次使用<code>cargo build</code>或<code>cargo run</code>時，它才會花費最多的時間。之後它就會記住，它又會快速編譯。但如果你使用 <code>cargo clean</code>，然後運行 <code>cargo build</code>，它將不得不再慢慢地編譯一次。</p>
<h2 id="接受用戶輸入"><a class="header" href="#接受用戶輸入">接受用戶輸入</a></h2>
<p>一個簡單的方法是用<code>std::io::stdin</code>來接受用戶的輸入。這意味著 &quot;標準輸入&quot;，也就是來自鍵盤的輸入。用<code>stdin()</code>可以獲得用戶的輸入，但是接下來你就會想用<code>.read_line()</code>把它放到<code>&amp;mut String</code>中。下面是一個簡單的例子，但它既能工作，也不能工作:</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Please type something, or x to escape:&quot;);
    let mut input_string = String::new();

    while input_string != &quot;x&quot; { // This is the part that doesn't work right
        input_string.clear(); // First clear the String. Otherwise it will keep adding to it
        io::stdin().read_line(&amp;mut input_string).unwrap(); // Get the stdin from the user, and put it in read_string
        println!(&quot;You wrote {}&quot;, input_string);
    }
    println!(&quot;See you later!&quot;);
}
</code></pre></pre>
<p>下面是一個輸出輸出的樣子。</p>
<pre><code class="language-text">Please type something, or x to escape:
something
You wrote something

Something else
You wrote Something else

x
You wrote x

x
You wrote x

x
You wrote x
</code></pre>
<p>它接受我們的輸入，然後把它還給我們，它甚至知道我們輸入了<code>x</code>。但它並沒有退出程序。唯一的辦法是關閉窗口，或者輸入ctrl和c。讓我們把<code>println!</code>中的<code>{}</code>改為<code>{:?}</code>，以獲得更多的信息(如果你喜歡那個宏，也可以使用<code>dbg!(&amp;input_string)</code>)。現在它說</p>
<pre><code class="language-text">Please type something, or x to escape:
something
You wrote &quot;something\r\n&quot;
Something else
You wrote &quot;Something else\r\n&quot;
x
You wrote &quot;x\r\n&quot;
x
You wrote &quot;x\r\n&quot;
</code></pre>
<p>這是因為鍵盤輸入其實不只是<code>something</code>，而是<code>something</code>和<code>Enter</code>鍵。有一個簡單的方法可以解決這個問題，叫做<code>.trim()</code>，它可以把所有的空白都去掉。順便說一下，<a href="https://doc.rust-lang.org/reference/whitespace.html">這些字符</a>都是空白字符。</p>
<pre><code class="language-text">U+0009 (horizontal tab, '\t')
U+000A (line feed, '\n')
U+000B (vertical tab)
U+000C (form feed)
U+000D (carriage return, '\r')
U+0020 (space, ' ')
U+0085 (next line)
U+200E (left-to-right mark)
U+200F (right-to-left mark)
U+2028 (line separator)
U+2029 (paragraph separator)
</code></pre>
<p>這樣就可以把<code>x\r\n</code>變成只剩<code>x</code>了。現在它可以工作了:</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Please type something, or x to escape:&quot;);
    let mut input_string = String::new();

    while input_string.trim() != &quot;x&quot; {
        input_string.clear();
        io::stdin().read_line(&amp;mut input_string).unwrap();
        println!(&quot;You wrote {}&quot;, input_string);
    }
    println!(&quot;See you later!&quot;);
}
</code></pre></pre>
<p>現在可以打印了:</p>
<pre><code class="language-text">Please type something, or x to escape:
something
You wrote something

Something
You wrote Something

x
You wrote x

See you later!
</code></pre>
<p>還有一種用戶輸入叫<code>std::env::Args</code>(env是環境的意思)。<code>Args</code>是用戶啟動程序時輸入的內容。其實在一個程序中總是至少有一個<code>Arg</code>。我們寫一個程序，只用<code>std::env::args()</code>來打印它們，看看它們是什麼。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{:?}&quot;, std::env::args());
}
</code></pre></pre>
<p>如果我們寫<code>cargo run</code>，那麼它的打印結果是這樣的:</p>
<pre><code class="language-text">Args { inner: [&quot;target\\debug\\rust_book.exe&quot;] }
</code></pre>
<p>讓我們給它更多的輸入，看看它的作用。我們輸入 <code>cargo run but with some extra words</code> 。 它給我們:</p>
<pre><code class="language-text">Args { inner: [&quot;target\\debug\\rust_book.exe&quot;, &quot;but&quot;, &quot;with&quot;, &quot;some&quot;, &quot;extra&quot;, &quot;words&quot;] }
</code></pre>
<p>有意思。而當我們查看<a href="https://doc.rust-lang.org/std/env/struct.Args.html">Args的頁面</a>時，我們看到它實現了<code>IntoIterator</code>。這意味著我們可以.用所有我們知道的關於迭代器的方法來讀取和改變它。讓我們試試這個:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

fn main() {
    let input = args();

    for entry in input {
        println!(&quot;You entered: {}&quot;, entry);
    }
}
</code></pre></pre>
<p>現在它說:</p>
<pre><code class="language-text">You entered: target\debug\rust_book.exe
You entered: but
You entered: with
You entered: some
You entered: extra
You entered: words
</code></pre>
<p>你可以看到，第一個參數總是程序名，所以你經常會想跳過它，比如這樣:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

fn main() {
    let input = args();

    input.skip(1).for_each(|item| {
        println!(&quot;You wrote {}, which in capital letters is {}&quot;, item, item.to_uppercase());
    })
}
</code></pre></pre>
<p>這將打印:</p>
<pre><code class="language-text">You wrote but, which in capital letters is BUT
You wrote with, which in capital letters is WITH
You wrote some, which in capital letters is SOME
You wrote extra, which in capital letters is EXTRA
You wrote words, which in capital letters is WORDS
</code></pre>
<p><code>Args</code>的一個常見用途是用於用戶設置。你可以確保用戶寫出你需要的輸入，只有在正確的情況下才運行程序。這裡有一個小程序，可以讓字母變大(大寫)或變小(小寫)。</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

enum Letters {
    Capitalize,
    Lowercase,
    Nothing,
}

fn main() {
    let mut changes = Letters::Nothing;
    let input = args().collect::&lt;Vec&lt;_&gt;&gt;();

    if input.len() &gt; 2 {
        match input[1].as_str() {
            &quot;capital&quot; =&gt; changes = Letters::Capitalize,
            &quot;lowercase&quot; =&gt; changes = Letters::Lowercase,
            _ =&gt; {}
        }
    }

    for word in input.iter().skip(2) {
      match changes {
        Letters::Capitalize =&gt; println!(&quot;{}&quot;, word.to_uppercase()),
        Letters::Lowercase =&gt; println!(&quot;{}&quot;, word.to_lowercase()),
        _ =&gt; println!(&quot;{}&quot;, word)
      }
    }

}
</code></pre></pre>
<p>下面是它給出的一些例子。</p>
<p>輸入: <code>cargo run please make capitals</code>:</p>
<pre><code class="language-text">make capitals
</code></pre>
<p>輸入:<code>cargo run capital</code>:</p>
<pre><code class="language-text">// Nothing here...
</code></pre>
<p>輸入:<code>cargo run capital I think I understand now</code>:</p>
<pre><code class="language-text">I
THINK
I
UNDERSTAND
NOW
</code></pre>
<p>輸入:<code>cargo run lowercase Does this work too?</code></p>
<pre><code class="language-text">does
this
work
too?
</code></pre>
<p>除了用戶給出的 <code>Args</code>，在 <code>std::env::args()</code> 中可用，還有系統變量<code>Vars</code>。這些都是用戶沒有輸入的程序的基本設置。你可以用<code>std::env::vars()</code>把它們都看成一個<code>(String, String)</code>。這個有非常多，比如說:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for item in std::env::vars() {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>運行這段代碼，就能顯示出你的用戶會話的所有信息。它將顯示這樣的信息:</p>
<pre><code class="language-text">(&quot;CARGO&quot;, &quot;/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo&quot;)
(&quot;CARGO_HOME&quot;, &quot;/playground/.cargo&quot;)
(&quot;CARGO_MANIFEST_DIR&quot;, &quot;/playground&quot;)
(&quot;CARGO_PKG_AUTHORS&quot;, &quot;The Rust Playground&quot;)
(&quot;CARGO_PKG_DESCRIPTION&quot;, &quot;&quot;)
(&quot;CARGO_PKG_HOMEPAGE&quot;, &quot;&quot;)
(&quot;CARGO_PKG_NAME&quot;, &quot;playground&quot;)
(&quot;CARGO_PKG_REPOSITORY&quot;, &quot;&quot;)
(&quot;CARGO_PKG_VERSION&quot;, &quot;0.0.1&quot;)
(&quot;CARGO_PKG_VERSION_MAJOR&quot;, &quot;0&quot;)
(&quot;CARGO_PKG_VERSION_MINOR&quot;, &quot;0&quot;)
(&quot;CARGO_PKG_VERSION_PATCH&quot;, &quot;1&quot;)
(&quot;CARGO_PKG_VERSION_PRE&quot;, &quot;&quot;)
(&quot;DEBIAN_FRONTEND&quot;, &quot;noninteractive&quot;)
(&quot;HOME&quot;, &quot;/playground&quot;)
(&quot;HOSTNAME&quot;, &quot;f94c15b8134b&quot;)
(&quot;LD_LIBRARY_PATH&quot;, &quot;/playground/target/debug/build/backtrace-sys-3ec4c973f371c302/out:/playground/target/debug/build/libsqlite3-sys-fbddfbb9b241dacb/out:/playground/target/debug/build/ring-cadba5e583648abb/out:/playground/target/debug/deps:/playground/target/debug:/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib:/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib&quot;)
(&quot;PATH&quot;, &quot;/playground/.cargo/bin:/playground/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;)
(&quot;PLAYGROUND_EDITION&quot;, &quot;2018&quot;)
(&quot;PLAYGROUND_TIMEOUT&quot;, &quot;10&quot;)
(&quot;PWD&quot;, &quot;/playground&quot;)
(&quot;RUSTUP_HOME&quot;, &quot;/playground/.rustup&quot;)
(&quot;RUSTUP_TOOLCHAIN&quot;, &quot;stable-x86_64-unknown-linux-gnu&quot;)
(&quot;RUST_RECURSION_COUNT&quot;, &quot;1&quot;)
(&quot;SHLVL&quot;, &quot;1&quot;)
(&quot;SSL_CERT_DIR&quot;, &quot;/usr/lib/ssl/certs&quot;)
(&quot;SSL_CERT_FILE&quot;, &quot;/usr/lib/ssl/certs/ca-certificates.crt&quot;)
(&quot;USER&quot;, &quot;playground&quot;)
(&quot;_&quot;, &quot;/usr/bin/timeout&quot;)
</code></pre>
<p>所以如果你需要這些信息，<code>Vars</code>就是你想要的。</p>
<p>獲得單個<code>Var'的最簡單方法是使用</code>env!<code>宏。你只要給它變量的名字，它就會給你一個</code>&amp;str'的值。如果變量拼寫錯誤或不存在，它就不起作用，所以如果你不確定，就用<code>option_env!</code>代替。如果我們在Playground上寫這個:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{}&quot;, env!(&quot;USER&quot;));
    println!(&quot;{}&quot;, option_env!(&quot;ROOT&quot;).unwrap_or(&quot;Can't find ROOT&quot;));
    println!(&quot;{}&quot;, option_env!(&quot;CARGO&quot;).unwrap_or(&quot;Can't find CARGO&quot;));
}
</code></pre></pre>
<p>然後我們得到輸出:</p>
<pre><code class="language-text">playground
Can't find ROOT
/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo
</code></pre>
<p>所以<code>option_env!</code>永遠是比較安全的宏。如果你真的想讓程序在找不到環境變量時崩潰，那麼<code>env!</code>會更好。</p>
<h2 id="使用文件"><a class="header" href="#使用文件">使用文件</a></h2>
<p>現在我們在電腦上使用Rust，我們可以開始處理文件了。你會注意到，現在我們會開始在代碼中越來越多的看到<code>Result</code>。這是因為一旦你開始處理文件和類似的事情，很多事情都會出錯。一個文件可能不在那裡，或者計算機無法讀取它。</p>
<p>你可能還記得，如果你想使用<code>?</code>運算符，調用它的函數必須返回一個<code>Result</code>。如果你記不住錯誤類型，你可以什麼都不給它，讓編譯器告訴你。讓我們用一個試圖用<code>.parse()</code>創建一個數字的函數來試試。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
fn give_number(input: &amp;str) -&gt; Result&lt;i32, ()&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;));
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;));
}
</code></pre></pre>
<p>編譯器告訴我們到底該怎麼做。</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src\main.rs:4:5
  |
3 | fn give_number(input: &amp;str) -&gt; Result&lt;i32, ()&gt; {
  |                                --------------- expected `std::result::Result&lt;i32, ()&gt;` because of return type
4 |     input.parse::&lt;i32&gt;()
  |     ^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `std::num::ParseIntError`
  |
  = note: expected enum `std::result::Result&lt;_, ()&gt;`
             found enum `std::result::Result&lt;_, std::num::ParseIntError&gt;`
</code></pre>
<p>很好! 所以我們只要把返回值改成編譯器說的就可以了:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;));
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;));
}
</code></pre></pre>
<p>現在程序可以運行了!</p>
<pre><code class="language-text">Ok(88)
Ok(5)
</code></pre>
<p>所以現在我們想用<code>?</code>，如果能用就直接給我們數值，如果不能用就給錯誤。但是如何在<code>fn main()</code>中做到這一點呢？如果我們嘗試在main中使用<code>?</code>，那就不行了。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;)?);
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;)?);
}
</code></pre></pre>
<p>它說:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
  --&gt; src\main.rs:8:22
   |
7  | / fn main() {
8  | |     println!(&quot;{:?}&quot;, give_number(&quot;88&quot;)?);
   | |                      ^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
9  | |     println!(&quot;{:?}&quot;, give_number(&quot;5&quot;)?);
10 | | }
   | |_- this function should return `Result` or `Option` to accept `?`
</code></pre>
<p>但實際上<code>main()</code>可以返回一個<code>Result</code>，就像其他函數一樣。如果我們的函數能工作，我們不想返回任何東西(main()並沒有給其他任何東西)。而如果它不工作，我們將錯誤返回。所以我們可以這樣寫:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;)?);
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;)?);
    Ok(())
}
</code></pre></pre>
<p>不要忘了最後的<code>Ok(())</code>:這在Rust中是很常見的，它的意思是<code>Ok</code>，裡面是<code>()</code>，也就是我們的返回值。現在它打印出來了:</p>
<pre><code class="language-text">88
5
</code></pre>
<p>只用<code>.parse()</code>的時候不是很有用，但是用文件就很有用。這是因為<code>?</code>也為我們改變了錯誤類型。下面是用簡單英語寫的<a href="https://doc.rust-lang.org/std/macro.try.html">?運算符頁面</a>:</p>
<pre><code class="language-text">If you get an `Err`, it will get the inner error. Then `?` does a conversion using `From`. With that it can change specialized errors to more general ones. The error it gets is then returned.
</code></pre>
<p>另外，Rust在使用<code>File</code>s和類似的東西時，有一個方便的<code>Result</code>類型。它叫做<code>std::io::Result</code>，當你在使用<code>?</code>對文件進行打開和操作時，通常在<code>main()</code>中看到的就是這個。這其實是一個類型別名。它的樣子是這樣的:</p>
<pre><code class="language-text">type Result&lt;T&gt; = Result&lt;T, Error&gt;;
</code></pre>
<p>所以這是一個<code>Result&lt;T, Error&gt;</code>，但我們只需要寫出<code>Result&lt;T&gt;</code>部分。</p>
<p>現在讓我們第一次嘗試使用文件。<code>std::fs</code>是處理文件的方法所在，有了<code>std::io::Write</code>，你就可以寫。有了它，我們就可以用<code>.write_all()</code>來寫進文件。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut file = fs::File::create(&quot;myfilename.txt&quot;)?; // Create a file with this name.
                                                        // CAREFUL! If you have a file with this name already,
                                                        // it will delete everything in it.
    file.write_all(b&quot;Let's put this in the file&quot;)?;     // Don't forget the b in front of &quot;. That's because files take bytes.
    Ok(())
}
</code></pre></pre>
<p>然後如果你打開新文件<code>myfilename.txt</code>，會看到內容<code>Let's put this in the file</code>。</p>
<p>不過我們不需要寫兩行，因為我們有<code>?</code>操作符。如果有效，它就會傳遞我們想要的結果，有點像在迭代器上很多方法一樣。這時候<code>?</code>就變得非常方便了。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::File::create(&quot;myfilename.txt&quot;)?.write_all(b&quot;Let's put this in the file&quot;)?;
    Ok(())
}
</code></pre></pre>
<p>所以這是說 &quot;請嘗試創建一個文件，然後檢查是否成功。如果成功了，那就使用<code>.write_all()</code>，然後檢查是否成功。&quot;</p>
<p>而事實上，也有一個函數可以同時做這兩件事。它叫做<code>std::fs::write</code>。在它裡面，你給它你想要的文件名，以及你想放在裡面的內容。再次強調，要小心! 如果該文件已經存在，它將刪除其中的所有內容。另外，它允許你寫一個<code>&amp;str</code>，前面不寫<code>b</code>，因為這個:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write&lt;P: AsRef&lt;Path&gt;, C: AsRef&lt;[u8]&gt;&gt;(path: P, contents: C) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>就是為什麼你可以給它任何一個。</p>
<p>很簡單的:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>所以這就是我們要用的文件。這是一個名叫Calvin的漫畫人物和他爸爸的對話，他爸爸對他的問題並不認真。有了這個，每次我們都可以創建一個文件來使用。</p>
<p>打開一個文件和創建一個文件一樣簡單。你只要用<code>open()</code>代替<code>create()</code>就可以了。之後(如果它找到了你的文件)，你就可以做<code>read_to_string()</code>這樣的事情。要做到這一點，你可以創建一個可變的 <code>String</code>，然後把文件讀到那裡。它看起來像這樣:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::fs::File;
use std::io::Read; // this is to use the function .read_to_string()

fn main() -&gt; std::io::Result&lt;()&gt; {
     fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;


    let mut calvin_file = File::open(&quot;calvin_with_dad.txt&quot;)?; // Open the file we just made
    let mut calvin_string = String::new(); // This String will hold it
    calvin_file.read_to_string(&amp;mut calvin_string)?; // Read the file into it

    calvin_string.split_whitespace().for_each(|word| print!(&quot;{} &quot;, word.to_uppercase())); // Do things with the String now

    Ok(())
}
</code></pre></pre>
<p>會打印:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CALVIN: DAD, HOW COME OLD PHOTOGRAPHS ARE ALWAYS BLACK AND WHITE? DIDN'T THEY HAVE COLOR FILM BACK THEN? DAD: SURE THEY DID. IN 
FACT, THOSE PHOTOGRAPHS *ARE* IN COLOR. IT'S JUST THE *WORLD* WAS BLACK AND WHITE THEN. CALVIN: REALLY? DAD: YEP. THE WORLD DIDN'T TURN COLOR UNTIL SOMETIMES IN THE 1930S...
<span class="boring">}
</span></code></pre></pre>
<p>好吧，如果我們想創建一個文件，但如果已經有另一個同名的文件就不做了怎麼辦？也許你不想為了創建一個新的文件而刪除已經存在的其他文件。要做到這一點，有一個結構叫<code>OpenOptions</code>。其實，我們一直在用<code>OpenOptions</code>，卻不知道。看看<code>File::open</code>的源碼吧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        OpenOptions::new().read(true).open(path.as_ref())
    }
<span class="boring">}
</span></code></pre></pre>
<p>有意思，這好像是我們學過的建造者模式。<code>File::create</code>也是如此。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())
    }
<span class="boring">}
</span></code></pre></pre>
<p>如果你去<a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html">OpenOptions的頁面</a>，你可以看到所有可以選擇的方法。大多數採取<code>bool</code>。</p>
<ul>
<li><code>append()</code>: 意思是 &quot;添加到已經存在的內容中，而不是刪除&quot;。</li>
<li><code>create()</code>: 這讓 <code>OpenOptions</code> 創建一個文件。</li>
<li><code>create_new()</code>: 意思是隻有在文件不存在的情況下才會創建文件。</li>
<li><code>read()</code>: 如果你想讓它讀取文件，就把這個設置為 <code>true</code>。</li>
<li><code>truncate()</code>: 如果你想在打開文件時把文件內容剪為0(刪除內容)，就把這個設置為true。</li>
<li><code>write()</code>: 這可以讓它寫入一個文件。</li>
</ul>
<p>然後在最後你用<code>.open()</code>加上文件名，就會得到一個<code>Result</code>。我們來看一個例子。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
use std::fs;
use std::fs::OpenOptions;

fn main() -&gt; std::io::Result&lt;()&gt; {
     fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;

    let calvin_file = OpenOptions::new().write(true).create_new(true).open(&quot;calvin_with_dad.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>首先我們用<code>new</code>做了一個<code>OpenOptions</code>(總是以<code>new</code>開頭)。然後我們給它的能力是<code>write</code>。之後我們把<code>create_new()</code>設置為<code>true</code>，然後試著打開我們做的文件。打不開，這是我們想要的。</p>
<pre><code class="language-text">Error: Os { code: 80, kind: AlreadyExists, message: &quot;The file exists.&quot; }
</code></pre>
<p>讓我們嘗試使用<code>.append()</code>，這樣我們就可以向一個文件寫入。為了寫入文件，我們可以使用 <code>.write_all()</code>，這是一個嘗試寫入你給它的一切內容的方法。</p>
<p>另外，我們將使用 <code>write!</code> 宏來做同樣的事情。你會記得這個宏，我們在為結構體做<code>impl Display</code>的時候用到過。這次我們是在文件上使用它，而不是在緩衝區上。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::fs::OpenOptions;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;

    let mut calvin_file = OpenOptions::new()
        .append(true) // Now we can write without deleting it
        .read(true)
        .open(&quot;calvin_with_dad.txt&quot;)?;
    calvin_file.write_all(b&quot;And it was a pretty grainy color for a while too.\n&quot;)?;
    write!(&amp;mut calvin_file, &quot;That's really weird.\n&quot;)?;
    write!(&amp;mut calvin_file, &quot;Well, truth is stranger than fiction.&quot;)?;

    println!(&quot;{}&quot;, fs::read_to_string(&quot;calvin_with_dad.txt&quot;)?);

    Ok(())
}
</code></pre></pre>
<p>這個打印:</p>
<pre><code class="language-text">Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...And it was a pretty grainy color for a while too.
That's really weird.
Well, truth is stranger than fiction.
</code></pre>
<h2 id="cargo文檔"><a class="header" href="#cargo文檔">cargo文檔</a></h2>
<p>你可能已經注意到，Rust文檔看起來總是幾乎一樣。在左邊你可以看到<code>struct</code>和<code>trait</code>，代碼例子在右邊等等。這是因為你只要輸入<code>cargo doc</code>就可以自動創建文檔。</p>
<p>即使是創建一個什麼都不做的項目，也可以幫助你瞭解Rust中的特性。例如，這裡有兩個幾乎什麼都不做的結構體，以及一個也什麼都不做的<code>fn main()</code>。</p>
<pre><pre class="playground"><code class="language-rust">struct DoesNothing {}
struct PrintThing {}

impl PrintThing {
    fn prints_something() {
        println!(&quot;I am printing something&quot;);
    }
}

fn main() {}
</code></pre></pre>
<p>但如果你輸入<code>cargo doc --open</code>，你可以看到比你想象中更多的信息。首先它給你顯示的是這樣的:</p>
<pre><code class="language-text">Crate rust_book

Structs
DoesNothing
PrintThing

Functions
main
</code></pre>
<p>但是如果你點擊其中的一個結構，會讓你看到很多你沒有想到的trait。</p>
<pre><code class="language-text">Struct rust_book::DoesNothing
[+] Show declaration
Auto Trait Implementations
impl RefUnwindSafe for DoesNothing
impl Send for DoesNothing
impl Sync for DoesNothing
impl Unpin for DoesNothing
impl UnwindSafe for DoesNothing
Blanket Implementations
impl&lt;T&gt; Any for T
where
    T: 'static + ?Sized,
[src]
[+]
impl&lt;T&gt; Borrow&lt;T&gt; for T
where
    T: ?Sized,
[src]
[+]
impl&lt;T&gt; BorrowMut&lt;T&gt; for T
where
    T: ?Sized,
[src]
[+]
impl&lt;T&gt; From&lt;T&gt; for T
[src]
[+]
impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
[src]
[+]
impl&lt;T, U&gt; TryFrom&lt;U&gt; for T
where
    U: Into&lt;T&gt;,
[src]
[+]
impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,
</code></pre>
<p>這是因為Rust自動為每個類型實現的所有trait。</p>
<p>那麼如果我們添加一些文檔註釋，當你輸入<code>cargo doc</code>的時候就可以看到。</p>
<pre><pre class="playground"><code class="language-rust">/// This is a struct that does nothing
struct DoesNothing {}
/// This struct only has one method.
struct PrintThing {}
/// It just prints the same message.
impl PrintThing {
    fn prints_something() {
        println!(&quot;I am printing something&quot;);
    }
}

fn main() {}
</code></pre></pre>
<p>現在會打印:</p>
<pre><code class="language-text">Crate rust_book
Structs
DoesNothing This is a struct that does nothing
PrintThing  This struct only has one method.
Functions
main
</code></pre>
<p>當你使用很多別人的crate時，<code>cargo doc</code>是非常好的。因為這些crate都在不同的網站上，可能需要一些時間來搜索所有的crate。但如果你使用<code>cargo doc</code>，你就會把它們都放在你硬盤的同一個地方。</p>
<h2 id="結束了嗎"><a class="header" href="#結束了嗎">結束了嗎？</a></h2>
<p>簡單英語學Rust就這樣結束了。但是我還在這裡，如果你有什麼問題可以告訴我。歡迎<a href="https://twitter.com/mithridates">在Twitter上聯繫我</a>或者添加一個pull request、issue等。如果有些地方不容易理解，你也可以告訴我。簡單英語學Rust需要非常容易理解，所以請告訴我英語太難的地方。當然，Rust本身也可能是很難理解的，但我們至少可以確保英語是容易的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-安裝環境"><a class="header" href="#rust-安裝環境">Rust-安裝環境</a></h2>
<h3 id="安裝rustup"><a class="header" href="#安裝rustup">安裝rustup</a></h3>
<p>rustup是rust版本管理器</p>
<p>安裝指令如下</p>
<pre><code class="language-jsx">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>接著安裝rust總共有三個版可以選擇</p>
<ul>
<li>stable</li>
<li>beta</li>
<li>nightly</li>
</ul>
<pre><code class="language-bash">rustup install stable
</code></pre>
<p>輸入下面指令檢查版本，如果有顯示就是代表安裝成功</p>
<pre><code class="language-bash">rustc --version
rustc 1.54.0 (a178d0322 2021-07-26)
</code></pre>
<p>也可以透過這個 ~/.cargo/bin 目錄查看到安裝的rust工具</p>
<pre><code class="language-bash">ls ~/.cargo/bin

cargo cargo-clippy cargo-fmt cargo-miri clippy-driver rls rust-gdb rust-lldb rustc rustdoc rustfmt rustup
</code></pre>
<h3 id="升級rust"><a class="header" href="#升級rust">升級rust</a></h3>
<pre><code class="language-bash">rustup update
</code></pre>
<h3 id="切換rust版本-1"><a class="header" href="#切換rust版本-1">切換rust版本</a></h3>
<p>查看目前所以安裝的版本</p>
<pre><code class="language-bash">ls ~/.rustup/toolchains/

beta-x86_64-apple-darwin
stable-x86_64-apple-darwin
</code></pre>
<p>切換預設版本</p>
<pre><code class="language-bash">rustup default beta-x86_64-apple-darwin

info: using existing install for 'beta-x86_64-apple-darwin'
info: default toolchain set to 'beta-x86_64-apple-darwin'

  beta-x86_64-apple-darwin unchanged - rustc 1.55.0-beta.9 (27e88d367 2021-08-28)
</code></pre>
<p>針對專案設定版本</p>
<pre><code class="language-bash">rustup override set nightly

info: using existing install for 'beta-x86_64-apple-darwin'
info: override toolchain for '/Users/ken_jan/rust/hello' set to 'beta-x86_64-apple-darwin'

  beta-x86_64-apple-darwin unchanged - rustc 1.55.0-beta.9 (27e88d367 2021-08-28)
</code></pre>
<h3 id="卸載rust"><a class="header" href="#卸載rust">卸載rust</a></h3>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<p>如果你只是想嘗試看看，完成不想安裝，也可以使用瀏覽線上版本</p>
<p><a href="https://play.rust-lang.org/">Rust Playground</a></p>
<p>相對於golang的安裝，rust官方就內建版本控制方便許多</p>
<p>這部分rust大勝</p>
<h2 id="rust-編輯器設定"><a class="header" href="#rust-編輯器設定">Rust-編輯器設定</a></h2>
<p>如何設定開發環境這邊使用VSCode來當開發工具</p>
<h3 id="rustfmt-自動格式化"><a class="header" href="#rustfmt-自動格式化">rustfmt 自動格式化</a></h3>
<p>rustfmt是Rust官方提供自動格式化代碼的工具，用來統一代碼風格，避免有人用Tab有人用空格來縮排或是在大括號之後該換行之類的</p>
<p>透過rustup安裝</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rustup component add rustfmt
<span class="boring">}
</span></code></pre></pre>
<p>透過指令來格式化代碼</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rustfmt main.rs
<span class="boring">}
</span></code></pre></pre>
<p>也可以透過cargo格式化整個專案</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo fmt
<span class="boring">}
</span></code></pre></pre>
<p>也可以單純檢查並列出沒排好的地放</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rustfmt --check main.rs

cargo fmt -- --check 
<span class="boring">}
</span></code></pre></pre>
<p>預設的rustfmt風格就很好用了，但如果你的團隊或是個人習慣想要不一樣排版風格也是可以的，透過rustfmt.toml設定檔來改變</p>
<p>例如二元運算子多行時要放在頭還是放在尾的部分</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>binop_separator = &quot;Front&quot; (默認)

let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo
        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

---------------------------------------------------------------
binop_separator = &quot;Back&quot;

let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||
        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;
<span class="boring">}
</span></code></pre></pre>
<p>還有其他很多設定，可以參考這文件</p>
<p>https://github.com/rust-lang/rustfmt/blob/master/Configurations.md</p>
<p>讓vscode支援rust代碼提示，需要安裝Rust套件模組</p>
<p>https://marketplace.visualstudio.com/items?itemName=rust-lang.rust</p>
<p>安裝時會順便安裝rls, rust-src, and rust-analysis</p>
<p>如果要讓存檔時自動格式化代碼需要修改</p>
<p>File &gt; Preferences &gt; Settings. 裡面的 editor.formatOnSave 打勾 就可以了</p>
<h2 id="rust-hello-world"><a class="header" href="#rust-hello-world">Rust-Hello, World!</a></h2>
<p>先建立一個hello的目錄，編輯main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<p>儲存然後在Terminal用rustc編譯</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rustc main.rs
<span class="boring">}
</span></code></pre></pre>
<p>會產生出main檔案，執行main就會出現Hello, world!了</p>
<pre><code class="language-bash">./main
Hello, World!
</code></pre>
<h3 id="分析程式碼"><a class="header" href="#分析程式碼">分析程式碼</a></h3>
<ul>
<li><strong>fu</strong>是rust的關鍵字，function的簡寫</li>
<li>main是函式名稱，執行rust程式時將執行，如果沒有main哪可能是一個library</li>
<li>print! 是rust的巨集(macro) 如果沒有&quot;!&quot;表示是函示有的話則是巨集</li>
<li>&quot;Hello, world!&quot; 表示字串內容</li>
<li>最後用&quot;;&quot;表示語法結束</li>
</ul>
<p>rust對大小寫是敏感的</p>
<h3 id="print-用法"><a class="header" href="#print-用法">Print! 用法</a></h3>
<p>利用&quot;{}&quot;站位符輸出字串，類似golang的fmt.Printf(&quot;%s, %s!&quot;, &quot;Hello&quot;, &quot;World&quot;)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;World&quot;)

輸出
Hello, World!
<span class="boring">}
</span></code></pre></pre>
<p>利用&quot;{}&quot;站位符輸出數字，類似golang的fmt.Printf(&quot;%s: %d&quot;, &quot;Num&quot;, 9527)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;{}: {}&quot;, &quot;Num&quot;, 9527)

輸出
Num: 9527
<span class="boring">}
</span></code></pre></pre>
<p>用&quot;\n&quot;輸出多行字串</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;Hello, World!\nHello, World!\nHello, World!&quot;)

輸出
Hello, World!
Hello, World!
Hello, World!
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-變數"><a class="header" href="#rust-變數">Rust-變數</a></h2>
<h3 id="變數宣告"><a class="header" href="#變數宣告">變數宣告</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 宣告區域變數
let local_var = 123;
<span class="boring">}
</span></code></pre></pre>
<h3 id="不可變變數"><a class="header" href="#不可變變數">不可變變數</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let immutable_var = 123;

print!(&quot;{}&quot;, immutable_var);

immutable_var = 456;

print!(&quot;{}&quot;, immutable_var);
<span class="boring">}
</span></code></pre></pre>
<p>上面這段程式碼在編譯時會出現&quot;cannot assign twice to immutable variable&quot;錯誤，表示不可變變數無法重新賦予值</p>
<p>有點類似golang中的const(常數)但又不太一樣，rust本身也有const關鍵字</p>
<h3 id="可變變數"><a class="header" href="#可變變數">可變變數</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut mutable_var = 123;

print!(&quot;{}&quot;, mutable_var);

mutable_var = 456;

print!(&quot;{}&quot;, mutable_var);
<span class="boring">}
</span></code></pre></pre>
<p>透過在宣告變時增加mut(mutable)來讓這個變數可以重新賦予值</p>
<h3 id="未變化的可變變數"><a class="header" href="#未變化的可變變數">未變化的可變變數</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut mutable_var = 123;

print!(&quot;{}&quot;, mutable_var);
<span class="boring">}
</span></code></pre></pre>
<p>如果宣告了可變變數，但是後面又沒重新賦予值時編譯會出現&quot;help: remove this <code>mut</code>&quot;警告來建議移除mut</p>
<h3 id="未初始化的變數"><a class="header" href="#未初始化的變數">未初始化的變數</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let immutable_var :i32;

print!(&quot;{}&quot;, immutable_var);
<span class="boring">}
</span></code></pre></pre>
<p>編譯時會出現&quot;use of possibly-uninitialized <code>immutable_var</code>&quot;錯誤</p>
<p>初始化變數也可以在宣告變數之後，只要在變數使用之前初始化就可以，例如下面例子</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let immutable_var :i32;

immutable_var = 123;

print!(&quot;{}&quot;, immutable_var);
<span class="boring">}
</span></code></pre></pre>
<h3 id="型別和可變化的改變"><a class="header" href="#型別和可變化的改變">型別和可變化的改變</a></h3>
<p>rust允許在變數宣告後又重新宣告相同名稱的變數，下面這些行為在rust是合法</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut var = 123;

print!(&quot;{}&quot;, var);

var = 456;

print!(&quot;{}&quot;, var);

// 重新宣告為不可變變數
let var = 789;

print!(&quot;{}&quot;, var);

// 重新宣告為字串類型
let var = &quot;hello word&quot;;

print!(&quot;{}&quot;, var);
<span class="boring">}
</span></code></pre></pre>
<h3 id="未使用的變數"><a class="header" href="#未使用的變數">未使用的變數</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let immutable_var = 123;
<span class="boring">}
</span></code></pre></pre>
<p>未使用變數時會出現&quot;help: if this is intentional, prefix it with an underscore: <code>_immutable_var</code>&quot;警告，如果不想出現警告可以在變數前面加個下底線&quot;_&quot;</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _immutable_var = 123;
<span class="boring">}
</span></code></pre></pre>
<p>或是單純只是要一個站位符也可以這樣</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = 123;
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-值變數物件"><a class="header" href="#rust-值變數物件">Rust-值，變數，物件</a></h2>
<p>不應將值，變數，物件混淆為一體</p>
<p>單詞&quot;值&quot;表示抽象的數學概念，</p>
<p>例如值：&quot;9527&quot;是指數學9527的數學概念，在數學上&quot;9527&quot;只會有一個&quot;9527&quot;的數字</p>
<p>例如值：&quot;hello, word!&quot;從概念上也只會有一個</p>
<p>值可以存在電腦裡的記憶體裡，可以在記憶體的多個位置儲存數字&quot;9527&quot;，可以有兩個不同位置都儲放&quot;9257&quot;</p>
<p>在記憶體中包含值的部分稱為物件，兩個位於記憶體中不同位置的不同物件如果包含相同的內容則可以稱為它們&quot;相等&quot;</p>
<p>在編譯Rust時，生成可以執行的程式會包含具有存儲位置和值的物件，這些物件沒有名稱
但是在程式碼中會希望將名稱與物件相關聯，以便以後可以引用它們這個東西可以稱為變數</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = 9527;
print!(&quot;{}&quot;, num);

輸出9257
<span class="boring">}
</span></code></pre></pre>
<p>第一行表示：</p>
<ul>
<li>它在記憶中劃出一個足夠大的物件，以包含一個整數</li>
<li>它以二進制格式將值&quot;9527&quot;儲存在該物件中</li>
<li>它將名稱num與該物件做關聯，以便之後在程式碼中使用該名稱num來指示這個物件</li>
</ul>
<h3 id="建立識別字-identifier-的規則"><a class="header" href="#建立識別字-identifier-的規則">建立識別字 (Identifier) 的規則</a></h3>
<p>變數名稱又稱為識別字。識別字原本在 Rust 程式中是沒有意義的，透過宣告變數這項動作對特定識別字賦予關聯。</p>
<p>Rust 的識別字採用以下規則：</p>
<ul>
<li>第一個字元為英文或底線 _</li>
<li>第二個之後的字元為英文、數字或底線</li>
<li>只有單一的底線 _ 不是變數</li>
</ul>
<p>以下是合 Rust 規範的變數名稱：</p>
<ul>
<li>a</li>
<li>a1</li>
<li>a_var</li>
<li>aVar</li>
<li>_var</li>
</ul>
<p>Rust建議使用蛇行(snake case)命名(例:a_var_snake_name)</p>
<p>而非駝峰(camel case)命名(例:aVarCamelName)</p>
<p>跟golang顛倒，沒有好壞只要統一風格就好</p>
<p>Rust會對不符合其撰碼風格的變數或函式名稱發出警告訊息，但不會引發錯誤</p>
<h2 id="rust-資料型別-整數浮點數"><a class="header" href="#rust-資料型別-整數浮點數">Rust-資料型別-整數、浮點數</a></h2>
<p>Rust是靜態型別語言，所以在編譯時需要知道變數的型別是什麼</p>
<p>前面的程式範例很多是沒有宣吿型別但是卻可以編譯，這邊用到的是透過</p>
<p>通常編譯器能通過數值來推導型別是什麼</p>
<p>Rust 有四種主要純量型別：整數、浮點數、布林以及字元</p>
<h3 id="整數型別"><a class="header" href="#整數型別">整數型別</a></h3>
<p>整數是沒有小數點的數字，分有帶號(signed)跟非帶號(unsigned)，差別就是一個有負值一個沒有負值</p>
<p>帶號範圍-(2^n - 1) 到 (2^n - 1) - 1</p>
<p>非帶號範圍0到2^n - 1</p>
<p>isize跟usize則是依據運行環境的電腦是32位元還是還64位元決定大小</p>
<p>Rust預設整數型別是i32
<img src="rust/images/20129675QRiTSVLrMG.png" alt="" /></p>
<h3 id="溢位問題"><a class="header" href="#溢位問題">溢位問題</a></h3>
<p>Rust在執行時會檢查是否有溢位</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n: i32 = i32::max_value();
 
// Overflow
n = n + 1;

出現panic錯誤
thread 'main' panicked at 'attempt to add with overflow'
<span class="boring">}
</span></code></pre></pre>
<p>如果你想要讓溢位也視為正常的可以在編譯時增加參數</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rustc用法
rustc -O main.rs

// cargo用法
cargo build --release
<span class="boring">}
</span></code></pre></pre>
<h3 id="浮點數型別"><a class="header" href="#浮點數型別">浮點數型別</a></h3>
<p>浮點數只有兩種型別</p>
<ul>
<li>f32 32位元大小</li>
<li>f64 64位元大小</li>
</ul>
<p>浮點數是依照 IEEE-754</p>
<p>Rust預設浮點數型別是f64</p>
<h2 id="rust-資料型別-布林值"><a class="header" href="#rust-資料型別-布林值">Rust-資料型別-布林值</a></h2>
<p>Rust 為了表示真假值，使用關鍵字true和false</p>
<p>這樣的關鍵字具有非數字類型的表達式稱為布林</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let true_var = true;
let false_var = false;
print!(&quot;{} {}&quot;, true_var, false_var);

輸出
true false
<span class="boring">}
</span></code></pre></pre>
<p>除了關鍵字true和false賦予值也可以透過比較運算表達式來賦予值</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let true_var = 456 &gt; 123 ;
let false_var = -456 &gt;= 123;
print!(&quot;{} {} {}&quot;, true_var, false_var, -123 &lt; 123);

輸出
true false true
<span class="boring">}
</span></code></pre></pre>
<p>比較運算子如下：</p>
<ul>
<li>
<p>==：等於</p>
</li>
<li>
<p>!=：不等於</p>
</li>
<li>
<p>&lt;：小於</p>
</li>
<li>
<blockquote>
<p>：大於</p>
</blockquote>
</li>
<li>
<p>&lt;=：小於或是等於</p>
</li>
<li>
<blockquote>
<p>=：大於或是等於</p>
</blockquote>
</li>
</ul>
<p>跟常見語言都一樣</p>
<p>除了比較數字之外也能比較字串</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;{} {} {}&quot;, &quot;efg&quot; &lt; &quot;efgh&quot;, &quot;efg&quot; &lt; &quot;efh&quot;, &quot;D&quot; &lt; &quot;d&quot;);

輸出 true true true
<span class="boring">}
</span></code></pre></pre>
<p>字串的比較規則就是比較兩個字串的第一個字母，然後繼續比較兩個字串相同位置的字母直到發生下列情況之一：</p>
<ul>
<li>如果兩個字母都沒有其他字母了，則相等</li>
<li>如果一個字串沒有其他字母，而另一個還有其他字母，則較少字母的字串較小</li>
<li>如果兩個字串相同位置的字母比較，字母表在前的比較小，字母大寫比字母小寫小</li>
</ul>
<p>邏輯運算子如下：</p>
<ul>
<li>!：not</li>
<li>&amp;&amp;：且</li>
<li>||：或</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let true_var = true;
let false_var = false;

print!(&quot;{} {}&quot;, !true_var, !false_var);
輸出
false true

print!(&quot;{} {} {} {}&quot;, true_var &amp;&amp; true_var, false_var &amp;&amp; false_var, true_var &amp;&amp; false_var, false_var &amp;&amp; true_var);
輸出
true false false false

print!(&quot;{} {} {} {}&quot;, true_var || true_var, false_var || false_var, true_var || false_var, false_var || true_var);
輸出
true false true true
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-資料型別-字元字串"><a class="header" href="#rust-資料型別-字元字串">Rust-資料型別-字元.字串</a></h2>
<p>Rust的char型別是最基本的字母型別，用單引號包起來</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 'b';
<span class="boring">}
</span></code></pre></pre>
<p>Rust的字串分兩種</p>
<ul>
<li>str</li>
<li>String</li>
</ul>
<p>嚴格來講Rust在核心語言中只有一個字串型別，哪就是切片字串(&amp;str)是不可變的(stack)</p>
<p>String則是Rust標準函式庫提供的型別，String是可變(Heap)</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// &amp;str型別
let str_var = &quot;字串&quot;;

// String型別
let string_var = str_var.to_string();
// String型別
let string_var = String::from(&quot;字串&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>索引字串切片</p>
<p>因為字串是使用 UTF-8 編碼，每個字符可能有多個位元組所以用字串索引會容易出現錯誤</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let str_var = &quot;安安&quot;;

println!(&quot;{}&quot;, &amp;str_var[0..1]);

會出現錯誤
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '安' (bytes 0..3) of `安安`'
<span class="boring">}
</span></code></pre></pre>
<p>比較好得做法透過as_bytes或是chars方法來取直</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let str_var = &quot;安安你好啊&quot;;

for b in str_var.as_bytes() {
    print!(&quot;{}, &quot;, b);
}

for c in str_var.chars() {
    print!(&quot;{}, &quot;, c);
}

輸出
229, 174, 137, 229, 174, 137, 228, 189, 160, 229, 165, 189, 229, 149, 138,
安, 安, 你, 好, 啊,
<span class="boring">}
</span></code></pre></pre>
<p>字串相加，這邊會使用到&amp;借用，後面會講解</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string1_var = String::from(&quot;安安&quot;);
let string2_var = String::from(&quot;你好啊&quot;);

println!(&quot;{}&quot;, string1_var + &amp;string2_var);

輸出
安安你好啊
<span class="boring">}
</span></code></pre></pre>
<p>Rust沒有提供型別判斷的方法，如果想要知道變數是什麼型別可以利用編譯時的錯來查看</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// char型別
let char_var = 'c';
char_var.not_found;

出現錯誤
`char` is a primitive type and therefore doesn't have fields

// &amp;str型別
let str_var = &quot;str&quot;;
str_var.not_found;

出現錯誤
no field `not_found` on type `&amp;str`
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-資料型別-複合型別"><a class="header" href="#rust-資料型別-複合型別">Rust-資料型別-複合型別</a></h2>
<p>複合型別是指多個數值組為一個型別</p>
<p>Rust 有兩個基本複合型別</p>
<h3 id="元組型別tupl"><a class="header" href="#元組型別tupl">元組型別(tupl)</a></h3>
<p>元組型別是指將多個不同型別組成一個複合型別</p>
<p>固定長度，宣告好就無法增減長度</p>
<p>每一格都是一個獨立型別</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 宣告時就指定型別
let tup: (i32, f64, u8, &amp;str) = (1, 3.1417, 1, &quot;hello&quot;);

// 自動判斷型別的宣告方式
let tup = (1, 3.1417, 1, &quot;hello&quot;);

println!(&quot;{:?}&quot;, tup);

輸出
(1, 3.1417, 1, &quot;hello&quot;)

// 多維元組
let tup = (&quot;1&quot;, (&quot;2&quot;, (&quot;3&quot;)));
<span class="boring">}
</span></code></pre></pre>
<p>元組也可以透過解構(destructuring)拆分各個型別</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, u8, &amp;str) = (1, 3.1417, 1, &quot;hello&quot;);

// 解構成各個變數
let (a, b, c, d) = tup;

println!(&quot;{} {} {} {}&quot;, a, b, c, d);

輸出
1 3.1417 1 hello
<span class="boring">}
</span></code></pre></pre>
<p>也可以透過&quot;.&quot;再加上索引位置來取得元組內的值</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, u8, &amp;str) = (1, 3.1417, 1, &quot;hello&quot;);

// 索引從0開始
println!(&quot;{} {} {} {}&quot;, tup.0, tup.1, tup.2, tup.3);

輸出
1 3.1417 1 hello
<span class="boring">}
</span></code></pre></pre>
<h3 id="陣列型別array"><a class="header" href="#陣列型別array">陣列型別(array)</a></h3>
<p>和元組一樣固定長度，差別是陣列中的型別必須要一樣的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 宣告時指定型別和長度i32是型別;之後的5是陣列的長度
let array: [i32; 5] = [1, 2, 3, 4, 5];

// 自動判斷型別的宣告方式
let array = [1, 2, 3, 4, 5];

// 簡化的宣告方式，陣列裡全是hello長度為5
let array = [&quot;hello&quot;; 5];
<span class="boring">}
</span></code></pre></pre>
<p>透果索引位址取值的方式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

println!(&quot;{} {} {} {} {}&quot;, a[0], a[1], a[2], a[3], a[4]);

輸出
1 2 3 4 5
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-流程控制-if"><a class="header" href="#rust-流程控制-if">Rust-流程控制-if</a></h2>
<p>利用布林值來決定如何繼續執行程式進行決策</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 3;

if n &gt; 2 {
    println!(&quot;執行&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>if 跟其他語言差不多，if關鍵字後面布林求值稱為條件只有當true才會執行大括號裡面的語法</p>
<p>大括號裡面可以包含零個多個語法，用大括號包起來的稱為塊(block)</p>
<p>條件必須是布林類型，因此不允許下面的語法</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不允許
if 1 {
   print!(&quot;執行&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>條件不需要用小括號包起來，會出現警告</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 出現警告
if (3 &gt; 2) {
   println!(&quot;執行&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>條件之後需要一個塊(block)包起來</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不允許
i 3 &gt; 2 println!(&quot;執行&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>如果要在條件為false情況執行流程可以使用else關鍵字</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 3;

if n &gt; 5 {
    println!(&quot;執行&quot;)
} else 
    println!(&quot;false執行&quot;)
}

輸出
false執行
<span class="boring">}
</span></code></pre></pre>
<p>Rust也有類似PHP的三元運算</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 3;

let str = if n &gt; 2 { &quot;true_str&quot; } else { &quot;false_str&quot; };

println!(&quot;{}&quot;, str);

輸出
true_str
<span class="boring">}
</span></code></pre></pre>
<p>以下範例是不允許的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不允許，因為無法定義str的型別
let str = if true { &quot;true_str&quot; }

// 不允許，因為型別不一樣，一個是字串一個是數字
let str = if true { &quot;true_str&quot; } else { 9527 }
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-流程控制-while"><a class="header" href="#rust-流程控制-while">Rust-流程控制-while</a></h2>
<p>類似PHP的while迴圈，計算其後的布林條件如果是值為true則執行大括號下面的語法，會重複條件的檢查執行直到條件值為false為止或是其他原因退出</p>
<p>假設要打印1到100的整數可以使用下面的語法來達到</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 1;

while i &lt;= 100 {
    print!(&quot;{} &quot;, i);
    i += 1;
}

輸出
1 2 3 4 5 ... 100
<span class="boring">}
</span></code></pre></pre>
<p>雖然Rust沒有do while的語法但也有break contiune語法</p>
<p>例如只想印出雙數</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 1;

 while i &lt;= 100 {
     i += 1;
     if i % 2 != 0 {
        continue;
     }
     print!(&quot;{} &quot;, i);
}

輸出
2 4 6 8 10 ... 100
<span class="boring">}
</span></code></pre></pre>
<p>或是碰到50的值就中斷退出</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 1;

while i &lt;= 100 {
    if i == 50 {
        break;
    }
    print!(&quot;{} &quot;, i);
		i += 1;
}

輸出
1 2 3 4 5 ... 49
<span class="boring">}
</span></code></pre></pre>
<h3 id="無限循環loop"><a class="header" href="#無限循環loop">無限循環(loop)</a></h3>
<p>如果要執行無限循環的迴圈直到程式被強制中斷或是通過退出循環語法break，可以透過loop語法</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 透過whilce 會出現警告
let mut i = 1;

while true {
    if i == 50 {
        break;
    }
    i += 1;
}

// 透過loop
let mut i = 1;

loop {
    if i == 50 {
         break;
    }
    i += 1;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-流程控制-for"><a class="header" href="#rust-流程控制-for">Rust-流程控制-for</a></h2>
<p>如果想印出1到100的數字，更常的做法是使用for迴圈而不是while</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..101 {
    println!(&quot;{}&quot;, i);
}

輸出
1 2 3 4 5 ... 100
<span class="boring">}
</span></code></pre></pre>
<p>for和in是關鍵字在用兩個數字加&quot;..&quot;符號分隔</p>
<p>i變數一開始由第一個數字(1)賦予該值，然後i值依序的加1直到值達到第二數字(101)，當值到達第二數是&quot;不&quot;執行的並結束for迴圈，所以要1到100需要寫1..101</p>
<p>i是for迴圈的區域變數所以前面如果有宣告都會被忽略，而且在迴圈結束就銷毀</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = 99; // 被屏蔽的
for i in 0..11 {
		// 這裡的i是區域變數
    print!(&quot;{} &quot;, i);
}
// 這裡的i是一開始宣告的99
print!(&quot;{}&quot;, i);

輸出
0 1 2 3 4 5 6 7 8 9 10 99
<span class="boring">}
</span></code></pre></pre>
<p>for迴圈也可以用來遍歷集合的每個元素</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let set = [1, 2, 3, 4, 5];

for var in set {
    print!(&quot;{} &quot;, var);
}

輸出
1 2 3 4 5
<span class="boring">}
</span></code></pre></pre>
<p>或是反轉範圍從100印到1</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for var in (1..101).rev() {
    print!(&quot;{} &quot;, var);
}

輸出
100 99 98 97 96 ... 1
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-枚舉enumeration"><a class="header" href="#rust-枚舉enumeration">Rust-枚舉(enumeration)</a></h2>
<p>枚舉就是列出有窮序列的型別</p>
<p>透過enum關鍵字新增了新的Browser型別在範例中列出了一個組項分別為</p>
<p>Firefox，Chrome，IE，Safari內部值分別為0u8，1u8，2u8，3u8表示</p>
<p>通常都是以整數為內部關聯值</p>
<p>透過枚舉寫以下的代碼</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Browser {
    Firefox,
    Chrome,
    Ie,
    Safari,
}

let browser = Browser::Ie;

match browser {
    Browser::Firefox =&gt; println!(&quot;F&quot;),
    Browser::Chrome =&gt; println!(&quot;C&quot;),
    Browser::Ie =&gt; println!(&quot;I&quot;),
    Browser::Safari =&gt; println!(&quot;S&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>不要編寫這樣的代碼</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FIREFOX: u8 = 0;
const CHROME: u8 = 1;
const IE: u8 = 2;
const SAFARI: u8 = 3;

let browser = IE;

if browser == FIREFOX {
    println!(&quot;F&quot;);
} else if browser == CHROME {
    println!(&quot;C&quot;);
} else if browser == IE {
    println!(&quot;I&quot;);
} else if browser == SAFARI {
    println!(&quot;S&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="再怎樣也不要寫magic-number"><a class="header" href="#再怎樣也不要寫magic-number">再怎樣也不要寫<a href="https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">magic number</a></a></h3>
<h3 id="如何使用枚舉"><a class="header" href="#如何使用枚舉">如何使用枚舉</a></h3>
<p>使用Use的方式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 顯式的指定要使用的枚舉
use Browser::{Chrome, Firefox, Ie, Safari};

let browser = Ie;

match browser {
    Firefox =&gt; println!(&quot;F&quot;),
    Chrome =&gt; println!(&quot;C&quot;),
    Ie =&gt; println!(&quot;I&quot;),
    Safari =&gt; println!(&quot;S&quot;),
}

// 自動的使用Browser內部所有的枚舉
use Browser::*;

let browser = Ie;

match browser {
    Firefox =&gt; println!(&quot;F&quot;),
    Chrome =&gt; println!(&quot;C&quot;),
    Ie =&gt; println!(&quot;I&quot;),
    Safari =&gt; println!(&quot;S&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>使用帶有C風格的用法</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Browser {
    Firefox,
    Chrome,
    Ie,
    Safari,
}

println!(&quot;{}&quot;, Browser::Firefox as i32)
<span class="boring">}
</span></code></pre></pre>
<p>枚舉不能使用&quot;==&quot;運算子做比較</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let browser = Browser::Ie;

if browser == Browser::Ie {
    println!(&quot;{}&quot;, &quot;hello word&quot;)
}

// 編譯時會出錯
// binary operation `==` cannot be applied to type `Browser`
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-match控制流運算子"><a class="header" href="#rust-match控制流運算子">Rust-Match控制流運算子</a></h2>
<p>Match是使用枚舉的基本工具，類似Golang的Switch語法</p>
<p>Match取值後對每個條件進行比較依照順序比較，一但匹配成功就對右側求值，並結算Match語法</p>
<p>每個條件分支右側都必須是單個表達式</p>
<p>例</p>
<p>前面三個都是無效的表達式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match browser {
    Firefox =&gt; let var = 777;, // 無效的表達式
    Chrome =&gt; let var = 777, // 無效的表達式
    Ie =&gt;  fu funct() {}, // 無效的表達式
    Safari =&gt; println!(&quot;S&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>如果需要在右側好幾個表達式或是非表達式可以用塊來包起來</p>
<p>例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Browser {
    Firefox,
    Chrome,
    Ie,
    Safari,
}

let browser = Browser::Ie;

match browser {
    Browser::Firefox =&gt; {
        browser = Browser::Ie;
        println!(&quot;F&quot;);
    },
    Browser::Chrome =&gt; {
        let var = 777;
        println!(&quot;C&quot;)
    },
    Browser::Ie =&gt; println!(&quot;I&quot;),
    Browser::Safari =&gt; println!(&quot;S&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>處理所有可能</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Browser {
    Firefox,
    Chrome,
    Ie,
    Safari,
}

let browser = Browser::Ie;

match browser {
    Browser::Ie =&gt; println!(&quot;I&quot;),
    Browser::Safari =&gt; println!(&quot;S&quot;),
}

// 編譯時會出
patterns `Firefox` and `Chrome` not covered
<span class="boring">}
</span></code></pre></pre>
<p>因為少了Firefox和Chrome條件分支，Rust要求mtch需要顯式的處理所有可能的情況</p>
<p>可以使用空處理</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let browser = Browser::Ie;

match browser {
    Browser::Firefox =&gt; {}, // 使用空處理
    Browser::Chrome =&gt; {}, // 使用空處理
    Browser::Ie =&gt; println!(&quot;I&quot;),
    Browser::Safari =&gt; println!(&quot;S&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>或是使用&quot;_&quot;下底線，類似Golang的Default</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let browser = Browser::Ie;

match browser {
    Browser::Ie =&gt; println!(&quot;I&quot;),
    Browser::Safari =&gt; println!(&quot;S&quot;),
    _ =&gt; {},
}
<span class="boring">}
</span></code></pre></pre>
<p>如果Default放在條件最上面會因為順序關係什麼都不處理</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let browser = Browser::Ie;

match browser {
    _ =&gt; {}, // 永遠都跑到這裡
    Browser::Ie =&gt; println!(&quot;I&quot;),
    Browser::Safari =&gt; println!(&quot;S&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="對型別使用match"><a class="header" href="#對型別使用match">對型別使用Match</a></h3>
<p>match除了對枚舉之外也可以對一般型別</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match &quot;value&quot; {
    &quot;value&quot; =&gt; println!(&quot;value&quot;),
    _ =&gt; println!(&quot;other&quot;),
}

match 1 {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;other&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>因為型別不像枚舉有可窮舉出所有，所以一定需要&quot;_&quot;(Default) 條件，不然編譯會出現錯誤</p>
<h2 id="rust-結構體struct"><a class="header" href="#rust-結構體struct">Rust-結構體(Struct)</a></h2>
<p>struct 是命名並封裝數個欄位數值所組合的自訂型別</p>
<p>struct 有 3 種類型</p>
<ul>
<li>元組結構體(tuple struct)，就是具名元組而已</li>
<li>經典的C語言風格結構體(C struct)</li>
<li>單元結構體(unit struct)，不帶字段，在泛型中很有用</li>
</ul>
<p>前幾篇所講的元組型別(tupl)，只要元組包含少量的字段就很好用但是當字段一多就容易將它們搞混
並且代碼也很容易理解</p>
<p>例如下面的代碼，不能很輕易的知道哪個字段相加，而且元組型別是有序的如果在開頭增加字段哪變成後面的字段都需要往後遞延非常不直覺</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = (1, 'a', 'b', 199.199, true, -100);
println!(&quot;{}&quot;, data.0 + data.5);
<span class="boring">}
</span></code></pre></pre>
<p>這時候使用結構體(Struct)就非常有用，可以為字段命名並標示型別</p>
<p>它以struct關鍵字開頭後面接著要聲明的類型再以大括號包起來</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 經典的C語言風格結構體(C struct)
struct User {
    username: String,
    email: String,
    active: bool,
}

let user = User {
    email: String::from(&quot;user@usermail.com&quot;),
    username: String::from(&quot;user123&quot;),
    active: true,
};

println!(&quot;{} {} {}&quot;, user.email, user.username, user.active)
<span class="boring">}
</span></code></pre></pre>
<p>元組結構，擁有元組型別和結構兩個特性又不完全一樣</p>
<ul>
<li>需要事先聲明</li>
<li>字段沒有名稱</li>
</ul>
<p>實際上這種結構不常使用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User(String, String, bool);

let user = User(
    String::from(&quot;user@usermail.com&quot;),
    String::from(&quot;user123&quot;),
    true,
);

println!(&quot;{} {} {}&quot;, user.0, user.1, user.2)
<span class="boring">}
</span></code></pre></pre>
<p>單元結構體</p>
<p>單元結構體適合用在當要實作一個特徵(trait)或某種型別，但沒有任何需要儲存在型別中的資料</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AlwaysEqual;

let subject = AlwaysEqual;
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-定義函式function一"><a class="header" href="#rust-定義函式function一">Rust-定義函式Function(一)</a></h2>
<p>如果編寫多次相同的代碼，則可以把代碼封裝在一個塊中，然後為該代碼命名</p>
<p>通過這種方式就定義了函式，然後可以通過命名的名稱來調用該函式</p>
<p>要訂一個函式需要使用&quot;fn&quot;關鍵字後面接著函式的名稱跟圓括號然後是一個大括號塊</p>
<p>大括號的塊稱為函式體，函式體之前都稱為簽名</p>
<p>下面例子簡單使用函式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_word() {
    println!(&quot;hello word!&quot;)
}

hello_word();
hello_word();
hello_word();

輸出
hello word!
hello word!
hello word!
<span class="boring">}
</span></code></pre></pre>
<p>後定義函式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a;
let a = 5; // 非法使用變數

hello_word(); // 合法使用後定義的函式
fn hello_word() {
    println!(&quot;hello word!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>函式屏蔽其他函式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_word() {}
fn hello_word() {} // 多次定義函式

編譯時會出錯
the name `hello_word` is defined multiple times
<span class="boring">}
</span></code></pre></pre>
<p>但是可以包在塊裡多次定義fn</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    fn hello_word() {
        println!(&quot;hello word 1&quot;)
    }

    hello_word();
}
{
    fn hello_word() {
        println!(&quot;hello word 2&quot;)
    }

    hello_word();
}

輸出
hello word 1
hello word 2
<span class="boring">}
</span></code></pre></pre>
<p>每個定義函式只能在塊裡面有效，下面是不合法的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    fn hello_word() {
        println!(&quot;hello word 2&quot;)
    }
}

hello_word();

編譯時會出錯
cannot find function `hello_word` in this scope
<span class="boring">}
</span></code></pre></pre>
<p>也可以在屏蔽外的塊級定義另一個函式</p>
<p>在main外部定義函式hello_word()，因其內部也定義了hello_word，所以永遠用不到外部的定義函式</p>
<p>通常編譯器會警告</p>
<pre><pre class="playground"><code class="language-rust">fn hello_word() {
    println!(&quot;hello word 1&quot;)
}

fn main() {
    hello_word();

    {
        hello_word();
        fn hello_word() {
            println!(&quot;hello word 2&quot;)
        }
    }

    hello_word();
    fn hello_word() {
        println!(&quot;hello word 3&quot;)
    }
}

</code></pre></pre>
<p>這邊輸出</p>
<pre><code>hello word 3
hello word 2
hello word 3
</code></pre>
<h2 id="rust-定義函式function二"><a class="header" href="#rust-定義函式function二">Rust-定義函式Function(二)</a></h2>
<h3 id="函式傳遞參數"><a class="header" href="#函式傳遞參數">函式傳遞參數</a></h3>
<p>每次調用函式時都打印相同的hello word的函式不是很有用處</p>
<p>這時候可以傳遞參數給函式會顯得更有意義</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_word(name: String) {
    println!(&quot;{} hello&quot;, name)
}

hello_word(String::from(&quot;Mike&quot;));

輸出
Mike hello
<span class="boring">}
</span></code></pre></pre>
<p>函式參數的定義與變數定義非常相似</p>
<p>因此可以將面的函式解釋為</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let name: String = String::from(&quot;Mike&quot;);
    println!(&quot;{} hello&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<p>變數的定義與函式參數的定義主要的差別在於函式定義需要明確的指定類型</p>
<p>變數的定義可以依賴類型推斷</p>
<p>編譯器會使用類型推斷來檢查參數值是否合法</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(c: i16) {}

f(5.); // 非法因為是浮點數
f(5u16); // 非法因為是u16型別
f(5i16); // 合法
f(5); // 合法因為傳遞是無約束得整數類型參數會變函式限制為i16類型
<span class="boring">}
</span></code></pre></pre>
<h3 id="函式按值傳遞參數"><a class="header" href="#函式按值傳遞參數">函式按&quot;值&quot;傳遞參數</a></h3>
<p>參數不僅僅是傳遞物件的新名稱是傳遞物件的副本，此副本在調用函式時創建並在函式結束且控制返回到調用者時銷毀它</p>
<p>例如下面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test(mut f: f64) {
    f *= 10.;
    println!(&quot;{}&quot;, f)
}

let f = 5.;
test(f);
println!(&quot;{}&quot;, f);

輸出
50
5
<span class="boring">}
</span></code></pre></pre>
<p>在一開始就宣告的f變數在傳遞給test函式的，並在函式中保留使用f變數並更改變數得值並打印，函式結束反給調用者，然侯在印出f變數，這個變數與調用時一樣</p>
<p>實際上傳遞給函式的不是這個變數而是變數的&quot;值&quot;並在函式結尾時銷毀</p>
<h3 id="函式返回值"><a class="header" href="#函式返回值">函式返回值</a></h3>
<p>函式除了能接收參數之外還可以計算結果並返回給調用者</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test(f: f64) -&gt; f64 {
    return f * 10.;
}

println!(&quot;{}&quot;, test(5.));
<span class="boring">}
</span></code></pre></pre>
<p>返回值需要再函式簽名之後用&quot;→&quot;並指定型別</p>
<h2 id="rust-定義函式function三"><a class="header" href="#rust-定義函式function三">Rust-定義函式Function(三)</a></h2>
<h3 id="提前退出"><a class="header" href="#提前退出">提前退出</a></h3>
<p>正常情況是必須達到函示的末尾，但是如果編寫包含許多語法的函式通常會在意識到沒有更多計算要做時因此需要提前退出該函式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x: i32) -&gt; i32 {
    if x &lt;= 0 {
        return 0;
    }

    return x * 5;
}

println!(&quot;{} {}&quot;, f(10), f(0))

輸出
50 0
<span class="boring">}
</span></code></pre></pre>
<h3 id="返回多個值"><a class="header" href="#返回多個值">返回多個值</a></h3>
<p>如果要從函式返回多個值，可以使用元組型別</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x: i32) -&gt; (i32, i32) {
    return (x * 5, 10);
}

println!(&quot;{:?}&quot;, f(10))

輸出
(50, 10)
<span class="boring">}
</span></code></pre></pre>
<p>或是也可以用返回結構，元組結構，數組或是向量來返回多個</p>
<h3 id="更改調用者的變數"><a class="header" href="#更改調用者的變數">更改調用者的變數</a></h3>
<p>假設有個包含數字的數組，要更改其中的數字</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(mut a: [i32; 5]) {
    for i in 0..5 {
        if a[i] &gt; 0 {
            a[i] *= 2;
        }
    }
}

let mut arr = [5, -1, 2, -2, 8];
f(arr);
println!(&quot;{:?}&quot;, arr);

輸出
[5, -1, 2, -2, 8]
<span class="boring">}
</span></code></pre></pre>
<p>可以看到並沒有改變數組，並且在編譯時出現警告variable does not need to be mutable</p>
<p>告訴我們mut聲明arr之後卻沒有改變可以移除</p>
<p>比較麻煩的作法，可以透過回傳值回傳一個新的數組，缺點就是數組會複製兩次</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(mut a: [i32; 5]) -&gt; [i32; 5] {
    for i in 0..5 {
        if a[i] &gt; 0 {
            a[i] *= 2;
        }
    }

    return a;
}

let mut arr = [5, -1, 2, -2, 8];
arr = f(arr);
println!(&quot;{:?}&quot;, arr);

輸出
[10, -1, 4, -2, 16]
<span class="boring">}
</span></code></pre></pre>
<p>可以透過引用傳遞參數的方式來改變數組</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(a: &amp;mut [i32; 5]) {
    for i in 0..5 {
        if (*a)[i] &gt; 0 {
            (*a)[i] *= 2;
        }
    }
}

let mut arr = [5, -1, 2, -2, 8];
f(&amp;mut arr);
println!(&quot;{:?}&quot;, arr);

輸出
[10, -1, 4, -2, 16]
<span class="boring">}
</span></code></pre></pre>
<p>透過&amp;符號來表示物件記憶體位址，而使用*符號表示記憶體位址的物件</p>
<p>通過型別宣告&amp;mut [i32; 5]指定它是物件的地址(可以稱為指針Pointer或是引用reference)</p>
<p>這邊的使用跟C++使用很像，區別是Rust還允許顯式的取消引用可以省略*符號</p>
<p>這個函式等同於上面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(a: &amp;mut [i32; 5]) {
    for i in 0..5 {
        if a[i] &gt; 0 { // 省略了*
            a[i] *= 2; // 省略了*
        }
    }
}

let mut arr = [5, -1, 2, -2, 8];
f(&amp;mut arr);
println!(&quot;{:?}&quot;, arr);

輸出
[10, -1, 4, -2, 16]
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-定義泛型函式"><a class="header" href="#rust-定義泛型函式">Rust-定義泛型函式</a></h2>
<p>Rust是強型別語言，執行嚴格的資料型別檢查，因此當定義使用某種型別參數的函式時比如說</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>square(x: f32) -&gt; f32
<span class="boring">}
</span></code></pre></pre>
<p>調用函式的程式碼必須傳遞一個嚴格屬於這種型別的表達式例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>square(1.3414f32)
<span class="boring">}
</span></code></pre></pre>
<p>或者是每次使用該函式時都執行顯式的型別轉換例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>square(1.3414f64 as f32)
<span class="boring">}
</span></code></pre></pre>
<p>對於使用的人非常不方便，對於編寫該函式的人也不方便</p>
<p>由於Rust有很多數字類的型別，如果決定了參數型別是i32型別但每次調用幾乎都是用i64哪最好是更改參數型別為i64，而且如果函式有多個模塊或是多個程式在使用則很難滿足每個調用者的需求</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(s: char, n1: i16, n2: i16) -&gt; i16 {
    if s == '1' {
        return n1;
    }

    return n2;
}

println!(&quot;{}&quot;, f('1', 10, 20));

輸出
10
<span class="boring">}
</span></code></pre></pre>
<p>這時候想用f32當參數肯定是無法使用這函式，但總不能為了這個需求又寫了邏輯一樣的函式只差在參數不同，這時候就可以使用泛型函式了</p>
<h3 id="定義泛型函式"><a class="header" href="#定義泛型函式">定義泛型函式</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
		println!(&quot;{}&quot;, f::&lt;i16&gt;('1', 10, 20));
    println!(&quot;{}&quot;, f::&lt;f32&gt;('1', 10.1, 20.1));
}

fn f&lt;T&gt;(s: char, n1: T, n2: T) -&gt; T {
    if s == '1' {
        return n1;
    }

    return n2;
}

輸出
10
10.1
</code></pre></pre>
<p>這個函式既可以輸入i16也可以輸入f32當參數了</p>
<p>在定義函式中，函式名之後用&lt;&gt;包起來字母T，該字母為函式宣告的型別參數</p>
<p>這個表示宣告的不是具體函式而是由T型別參數來參數化的泛型函式，只有在編譯時為該T參數指定具體型別時該函式才成為具體函式</p>
<p>在使用泛型函式需要將T參數替換成實際使用f::的型別來護得具體函式</p>
<p>上面例子有三個地方宣告成T型別，在使用時需要三個都是相同型別不然在編譯時會出現錯誤</p>
<h3 id="推斷參數型別"><a class="header" href="#推斷參數型別">推斷參數型別</a></h3>
<p>可以透過Rust的型別推斷簡化成下面使用範例</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{}&quot;, f('1', 10, 20)); // 透別推斷型別簡化
    println!(&quot;{}&quot;, f('1', 10.1, 20.1)); // 透別推斷型別簡化
}

fn f&lt;T&gt;(s: char, n1: T, n2: T) -&gt; T {
    if s == '1' {
        return n1;
    }

    return n2;
}

</code></pre></pre>
<h2 id="rust-定義泛型結構"><a class="header" href="#rust-定義泛型結構">Rust-定義泛型結構</a></h2>
<p>既然有泛型函數當然少不瞭泛型結構</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S1&lt;T1, T2&gt; {
   n1: T1,
   n2: T2,
}

let s = S {n1:957, n2:996.1}
<span class="boring">}
</span></code></pre></pre>
<p>第一句語法宣告了兩個型別T1和T2參數化的泛型結構S1，第一個字段n1為T1第二字段n2為T2</p>
<p>第二句語法n1字段的參數隱式的替換成i32，n2字段的參數隱式替換成f64</p>
<p>也可以使用泛型元組結構</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SE&lt;T1, T2&gt; (T1, T2)

let se = SE (957, 996.1)
<span class="boring">}
</span></code></pre></pre>
<h3 id="泛型機制"><a class="header" href="#泛型機制">泛型機制</a></h3>
<p>通過下面程式碼來理解編譯泛型機制概念</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn swap&lt;T1, T2&gt;(p1: T1, p2: T2) -&gt; (T2, T1) {
    return (p2, p1);
}

let x = swap(5i16, 9u16);
let y = swap(6f32, true);

println!(&quot;{:?} {:?}&quot;, x, y);

輸出
(9, 5) (true, 6.0)
<span class="boring">}
</span></code></pre></pre>
<p>第一階段編譯器會掃描程式碼並且每次找到泛型函式宣告(swap)時，它在資料結構中加載該函式內部表示形式檢查泛型程式碼是否有語法錯誤</p>
<p>第二階段編譯器再次掃描程式碼在每次遇到泛型函式調用時，編譯器都會檢查此類用法與泛型宣告的相應內部表示關聯，在確認後再其資料結構中加載這種對應關係</p>
<p>第三階段再將掃描所有泛型函式調用，對於每個泛型函式調用者都定義每個泛型參數的具體型別，這種具體型別可以是在用法中顯式的或者如上面範例一樣用推斷出來的</p>
<p>在確定替換泛型參數的具體型別之後都會產生泛型函式的具體版本對應程式碼如下</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn swap_i16_u16(p1: i16, p2: u16) -&gt; (u16, i16) {
    return (p2, p1);
}

fn swap_f32_bool(p1: f32, p2: bool) -&gt; (f32, bool) {
    return (p2, p1);
}

let x = swap_i16_u16(5i16, 9u16);
let y = swap_f32_bool(6f32, true);

println!(&quot;{:?} {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>泛型編譯有幾個特點</p>
<ul>
<li>與非泛型程式碼相比多階段編譯相對較慢一些</li>
<li>生成的程式碼針對每個特定的調用進行高度優化，它完成使用調用者使用的型別無須進行轉換因此優化了運行時性能</li>
<li>泛型函式如果執行很多具有不同型別參數的調用，則產生大量的機器代碼，最好不要再單個函式調用太多型別會給CPU緩存造成負擔</li>
</ul>
<p>幾種流行的泛型語言的代價
Slow Compiler: c++/rust
Slow Performance: java/scala
Slow Programmer: go1</p>
<h2 id="rust-所有權一"><a class="header" href="#rust-所有權一">Rust-所有權(一)</a></h2>
<p>所有權可以說是Rust核心概念，這讓Rust不需要垃圾回收(garbage collector)就可以保障記憶體安全。Rust的安全性和所有權的概念息息相，因此理解Rust中的所有權如何運作是非常重要的</p>
<h3 id="所有權的規則-1"><a class="header" href="#所有權的規則-1">所有權的規則</a></h3>
<ul>
<li>Rust 中每個數值都會有一個變數作為它的<strong>擁有者（owner）</strong>。</li>
<li>同時間只能有一個擁有者。</li>
<li>當擁有者離開作用域時，數值就會被丟棄。</li>
</ul>
<h3 id="變數作用域-1"><a class="header" href="#變數作用域-1"><strong>變數作用域</strong></a></h3>
<p>用下面這段程序描述變數範圍的概念</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 在宣告以前，變數s無效
    let s = &quot;hello&quot;;
    // 這裡是變數s的可用範圍
}
// 變數範圍已經結束，變數s無效
<span class="boring">}
</span></code></pre></pre>
<p>變數作用域是變數的一個屬性，其代表變數的可使用範圍，默認從宣告變數開始有效直到變數所在作用域結束。</p>
<h3 id="記憶體與分配-1"><a class="header" href="#記憶體與分配-1">記憶體與分配</a></h3>
<p>定義一個變數並賦予值，這個變數的值存在記憶體中，例如需要用戶輸入的一串字串由於長度的不確定只能存放在堆(heap)上，這需要記憶體分配器在執行時請求記憶體並在不需要時還給分配器</p>
<p>在擁有垃圾回收機制(garbage collector, GC)的語言中，GC會追蹤並清除不再使用的記憶體，如果沒有GC的話則需要在不使用時顯式的呼叫釋放記憶體</p>
<p>例如C語言</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{    
    char *s = strdup(&quot;hello&quot;);    
    free(s); *// 釋放s資源*
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust選擇了一個不同的道路，當變數在離開作用域時會自動釋放例如下面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s 在此開始視為有效
    // 使用 s
} // 此作用域結束，釋放s變數     
<span class="boring">}
</span></code></pre></pre>
<p>當變數離開作用域(大括號結束)時會自動呼叫特殊函示drop來釋放記憶體</p>
<h3 id="變數與資料互動的方式-1"><a class="header" href="#變數與資料互動的方式-1">變數與資料互動的方式</a></h3>
<p><strong>移動(Move)</strong></p>
<p>變數可以在Rust中以不同的方式與相同的資料進行互動</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 100;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p>這個代碼將值100綁定到變數x，然後將x的值復制並賦值給變數y現在棧(stack)中將有兩個值100。此情況中的數據是&quot;純量型別&quot;的資料，不需要存儲到堆中，僅在棧(stack)中的資料的&quot;移動&quot;方式是直接複製，這不會花費更長的時間或更多的存儲空間。&quot;純量型別&quot;有這些：</p>
<ul>
<li>所有整數類型，例如 i32 、 u32 、 i64 等</li>
<li>布爾類型 bool，值為true或false</li>
<li>所有浮點類型，f32和f64</li>
<li>字符類型 char</li>
<li>僅包含以上類型數據的元組(Tuples)</li>
</ul>
<p>現在來看一下非純量型別的移動</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>String物件的值&quot;hello&quot;為不固定長度長度型別所以被分配到堆(heap)</p>
<p>當s1賦值給s2，String的資料會被拷貝，不過我們拷貝是指標、長度和容量。我們不會拷貝指標指向的資料</p>
<p>前面説當變數超出作用域時，Rust自動調用釋放資源函數並清理該變數的記憶體。但是s1和s2都被釋放的話堆(heap)區中的&quot;hello&quot;被釋放兩次，這是不被系統允許的。為了確保安全，在給s2賦值時 s1已經無效了</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1; 
println!(&quot;{}, world!&quot;, s1); // 會發生錯誤 s1已經失效了
<span class="boring">}
</span></code></pre></pre>
<p><strong>克隆(clone)</strong></p>
<p>正常情況下Rust在較大資料上都會以淺拷貝的方式，當然也有提供深拷貝的method</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
println!(&quot;{} {}&quot;, s1, s2);

輸出
hello hello
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-所有權二"><a class="header" href="#rust-所有權二">Rust-所有權(二)</a></h2>
<h3 id="所有權與函式-1"><a class="header" href="#所有權與函式-1">所有權與函式</a></h3>
<p>將一個變數當作函式的參數傳給其他函式，怎樣安全的處理所有權</p>
<p>傳遞數值給函式這樣的語義和賦值給變數是類似的。傳遞變數給函式會是移動或拷貝就像賦值一樣</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // s被宣告
    let s = String::from(&quot;hello&quot;); // s進入作用域

    takes_ownership(s); // s的值被當作參數傳入函式 所以可以當作s已經被移動，從這開始已經無效

    // x被宣告
    let x = 5; // x進入作用域

    makes_copy(x); // x的值被當作參數傳入函式，但x是純量型別 i32被copy，依然有效
} // 函式結束，x無效，接著是s的值已經被移動了它不會有任何動作

fn takes_ownership(some_string: String) {
    // 一個String參數some_string傳入，有效
    println!(&quot;{}&quot;, some_string);
} // 函式結束，參數some_string佔用的記憶體被釋放

fn makes_copy(some_integer: i32) {
    // 一個i32參數some_integer傳入，有效
    println!(&quot;{}&quot;, some_integer);
} // 函式結束，參數some_integer是純量型別，沒有任何動作發生
</code></pre></pre>
<p>如果在呼叫takes_ownership之後在使用s變數在編譯時會出錯</p>
<h3 id="回傳值與作用域-1"><a class="header" href="#回傳值與作用域-1">回傳值與作用域</a></h3>
<p>回傳值轉移所有權</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership(); // gives_ownership移動它的回傳值給s1
    let s2 = String::from(&quot;哈囉&quot;); // s2進入作用域
    let s3 = takes_and_gives_back(s2); // s2移入takes_and_gives_back，該函式又將其回傳值移到s3
} // s3 在此離開作用域並釋放
  // s2 已被移走，所以沒有任何動作發生
  // s1 離開作用域並釋放

// 此函式回傳一個String
fn gives_ownership() -&gt; String {
    let some_string = String::from(&quot;hello&quot;); // some_string進入作用域

    return some_string; // 回傳some_string並移動給呼叫它的函式
}

// 此函式會取得一個String然後回傳它
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string進入作用域
    return a_string; // 回傳a_string並移動給呼叫的函式
}
</code></pre></pre>
<p>引用與借用在前面介紹<a href="https://ithelp.ithome.com.tw/articles/10269251">定義函式</a>時有介紹過了，這邊就不多講了</p>
<p>講一下迷途指標(dangling pointer)，這個在很多指標語言常發生的錯誤</p>
<p>簡單講就是用到空指標，Rust會在編譯時檢查這類型的錯誤</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangle() -&gt; &amp;String { // 回傳String的迷途引用
    let s = String::from(&quot;hello&quot;); // 宣告一個新的String
    return &amp;s // 回傳String的引用
} // s在此會離開作用域並釋放
<span class="boring">}
</span></code></pre></pre>
<p>編譯時會產生錯誤 missing lifetime specifier</p>
<p>這個有關於生命週期的會在下一篇講</p>
<h2 id="rust-定義closure閉包"><a class="header" href="#rust-定義closure閉包">Rust-定義Closure(閉包)</a></h2>
<p>一般來說Rust如果要排序數組會這樣寫</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut arr = [10, 5, 9, 7, 6]

arr.sort();

println!(&quot;{:?}&quot;, arr);

輸出
[5, 6, 7, 9, 10]
<span class="boring">}
</span></code></pre></pre>
<p>剛剛升序如果要降序就必須使用sort_by 需要自己寫函式來傳給sort_by排序決定用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut arr = [10, 5, 9, 7, 6]

use std::cmp::Ordering;

fn descFn(a: &amp;i32, b: &amp;i32) -&gt; Ordering {
    if  a &lt; b {
        return Ordering::Greater;
    } else if a &gt; b  {
        return Ordering::Less
    } else {
        return Ordering::Equal
    }
}

arr.sort_by(descFn);

println!(&quot;{:?}&quot;, arr);

輸出
[10, 9, 7, 6, 5]
<span class="boring">}
</span></code></pre></pre>
<p>造上面這樣使用有個缺點就是必須在宣告一個函式，如果只用一次的話就可用更簡短的使用匿名函式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut arr = [10, 5, 9, 7, 6]

use std::cmp::Ordering;

arr.sort_by(|a: &amp;i32, b: &amp;i32|
    if  a &lt; b {
        return Ordering::Greater;
    } else if a &gt; b  {
        return Ordering::Less
    } else {
        return Ordering::Equal
    }
);

println!(&quot;{:?}&quot;, arr);
輸出
[10, 9, 7, 6, 5]
<span class="boring">}
</span></code></pre></pre>
<p>使用一個匿名函式就可以簡短許多不用再宣告新的函式</p>
<p>Rust跟一般語言的匿名函式有個特別的限制就是無法使用外部宣告的變數</p>
<p>例如這樣是不合法的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let outVal = 10;

fn printOutVal() {
    println!(&quot;{}&quot;, outVal); // 無法訪問outVal變數
}

printOutVal();

// 編譯時會出現錯誤
<span class="boring">}
</span></code></pre></pre>
<p>但是使用靜態變數或是常量例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CONSTVAL: i32 = 10;

fn printOutVal() {
    println!(&quot;{}&quot;, CONSTVAL); // 合法使用
}

printOutVal();

-----------------------------

static STATICVAL: i32 = 0;

fn printOutVal() {
    println!(&quot;{}&quot;, CONSTVAL); // 合法使用
}

printOutVal();
<span class="boring">}
</span></code></pre></pre>
<p>Rust這樣限制應該基於所有權的設計關係，這樣有個好處就是避免亂引用變數造成BUG也比較好閱讀</p>
<p>當然Closure有更多複雜的使用這邊只簡單介紹最基本的使用方法</p>
<h2 id="rust-命令行的輸入輸出"><a class="header" href="#rust-命令行的輸入輸出">Rust-命令行的輸入輸出</a></h2>
<h3 id="命令行參數"><a class="header" href="#命令行參數">命令行參數</a></h3>
<p>一般來說編譯好的執行檔都是透過命令行來制執有些時候需要讀取一些命令行參數或是環境參數</p>
<p>程式輸入的最基本形式事示通命令行</p>
<p>例如下面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for arg in  std::env::args() {
    println!(&quot;{}&quot;, arg)
}
<span class="boring">}
</span></code></pre></pre>
<p>這時候編譯好的執行檔名稱如果是main在命令行執行</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>./main arg1 arg2 arg3

輸出
./main
arg1
arg2
arg3
<span class="boring">}
</span></code></pre></pre>
<p>args標準庫函式會返回命令行參數上的跌代器類別是Args並生成String值</p>
<p>第一個是程式名稱包含路徑其餘都是參數指令</p>
<h3 id="環境變數"><a class="header" href="#環境變數">環境變數</a></h3>
<p>輸入輸出的另一種形式通過環境變數</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for env in std::env::vars() {
    println!(&quot;{:?}&quot;, env)
}

輸出
(&quot;CARGO_HOME&quot;, &quot;/playground/.cargo&quot;)
**(&quot;CARGO_MANIFEST_DIR&quot;, &quot;/playground&quot;)
(&quot;CARGO_PKG_AUTHORS&quot;, &quot;The Rust Playground&quot;)
(&quot;CARGO_PKG_DESCRIPTION&quot;, &quot;&quot;)
(&quot;CARGO_PKG_HOMEPAGE&quot;, &quot;&quot;)
(&quot;CARGO_PKG_LICENSE&quot;, &quot;&quot;)
...**
<span class="boring">}
</span></code></pre></pre>
<p>剛剛是把每個環境變數都印出來假如要讀取特定環境變數可以透過var函示指定key</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:?}&quot;, std::env::var(&quot;envkey&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>既然能讀取當然也能寫入，下面就透過set_var函式來寫入環境變數</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::env::set_var(&quot;setenvkey&quot;, &quot;env_value&quot;);

println!(&quot;{:?}&quot;, std::env::var(&quot;setenvkey&quot;));

輸出
Ok(&quot;env_value&quot;)
<span class="boring">}
</span></code></pre></pre>
<h3 id="命令行的輸入"><a class="header" href="#命令行的輸入">命令行的輸入</a></h3>
<p>可以在程式啟動後獲取從鍵盤輸入的一行字直到用戶按下Enter鍵在輸出</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut line = String::new();

std::io::stdin().read_line(&amp;mnt line);

println!(&quot;{}&quot;, line);
<span class="boring">}
</span></code></pre></pre>
<h2 id="rust-特徵trait一"><a class="header" href="#rust-特徵trait一">Rust-特徵(Trait)(一)</a></h2>
<h3 id="什麼是特徵"><a class="header" href="#什麼是特徵">什麼是特徵</a></h3>
<p>根據官網的解釋就是</p>
<p>特徵會告訴編譯器特定型別與其他型別共享的功能。可以使用特徵定義來抽象出共同行為。可以使用特徵界限(trait bounds)來指定泛型型別為擁有特定行為的任意型別。</p>
<p>簡單講就是其他語言中的介面(interface)，只是有少許不同而已</p>
<h3 id="特徵的需求"><a class="header" href="#特徵的需求">特徵的需求</a></h3>
<p>假設我們需要一個函式需計算四次平方根，可以用標準庫sqrtx來寫</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn quartic(x: f64) -&gt; f64 {
        return x.sqrt().sqrt();
    }

    let qr = quartic(100.);

    println!(&quot;{} {}&quot;, qr * qr * qr * qr, qr);
}

輸出
100.00000000000003 3.1622776601683795
</code></pre></pre>
<p>但假如要還需要一個計算32位元浮點數的四次平方根又要再寫一個quarticf32函式</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quarticf64(x: f64) -&gt; f64 {
    return x.sqrt().sqrt();
}

fn quarticf32(x: f32) -&gt; f32 {
    return x.sqrt().sqrt();
}
<span class="boring">}
</span></code></pre></pre>
<p>這時候可能會寫一個泛型函式來取代前面兩個函式</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn quartic&lt;T&gt;(x: T) -&gt; T {
        return x.sqrt().sqrt();
    }

    let qrf32 = quartic(100f32);
	let qrf64 = quartic(100f64);

    println!(&quot;{} {}&quot;, qrf32, qrf64);
}

會出現編譯錯誤
no method named `sqrt` found for type parameter `T` in the current scope
</code></pre></pre>
<p>會出現這樣的錯誤是因為x變數是屬於泛型型別T，是剛剛在建立出來的並沒有sqrt的mehtod</p>
<p>這時候就可以特徵派上用場的時候了，可以這樣使用解決剛剛的問題</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    trait HasSqrt {
        fn sq(self) -&gt; Self;
    }

    impl HasSqrt for f32 {
        fn sq(self) -&gt; Self {
            return f32::sqrt(self);
        }
    }

    impl HasSqrt for f64 {
        fn sq(self) -&gt; Self {
            return f64::sqrt(self);
        }
    }

    fn quartic&lt;T&gt;(x: T) -&gt; T
    where
        T: HasSqrt,
    {
        return x.sq().sq();
    }

    let qr32 = quartic(100f32);
    let qr64 = quartic(100f64);

    println!(&quot;{} {}&quot;, qr32, qr64);
}

輸出
3.1622777 3.1622776601683795
</code></pre></pre>
<p>一開先宣告HasSqrt trait然後使用impl關鍵字替f32和f64實現sq函式</p>
<h2 id="rust-特徵trait二"><a class="header" href="#rust-特徵trait二">Rust-特徵(Trait)(二)</a></h2>
<h3 id="沒有trait界限的泛型函式"><a class="header" href="#沒有trait界限的泛型函式">沒有Trait界限的泛型函式</a></h3>
<p>上一篇範例中在宣告泛型函式中使用了where</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>where
    T: HasSqrt,
{
<span class="boring">}
</span></code></pre></pre>
<p>在泛型函式的宣告中如果沒有where的子句引用類型參數，則該型別就沒有與任何trait關聯</p>
<p>因此只能對該泛型型別的物件做很少的事情</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T&gt;(x: T) -&gt; T {
    let c: T = x;
    let mut d = c;
    f = f2(d)
    return f
}
<span class="boring">}
</span></code></pre></pre>
<p>使用無界限的類型參數&quot;T&quot;只能</p>
<ul>
<li>通過值或引用將其作函式參數傳遞</li>
<li>通過值或引用得從函式返回</li>
<li>局部變數宣告或是初始化</li>
</ul>
<h3 id="多函式trait"><a class="header" href="#多函式trait">多函式Trait</a></h3>
<p>Trait也可以包含多個函式例如上一篇的範例如果要再增加絕對值abs的函式可以這樣寫</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    trait HasSqrt {
        fn sq(self) -&gt; Self;
        fn abs(self) -&gt; Self;
    }

    impl HasSqrt for f32 {
        fn sq(self) -&gt; Self {
            return f32::sqrt(self);
        }

        fn abs(self) -&gt; Self {
            return f32::abs(self);
        }
    }

    impl HasSqrt for f64 {
        fn sq(self) -&gt; Self {
            return f64::sqrt(self);
        }

        fn abs(self) -&gt; Self {
            return f64::abs(self);
        }
    }

    fn quartic&lt;T&gt;(x: T) -&gt; T
    where
        T: HasSqrt,
    {
        return x.abs.sq().sq();
    }

    let qr32 = quartic(100f32);
    let qr64 = quartic(100f64);

    println!(&quot;{} {}&quot;, qr32, qr64);
}
</code></pre></pre>
<p>有時候可能只會需要平方根函式不需要絕對值函式這時候就可以抽兩個Trait會更靈活</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    trait HasSqrt {
        fn sq(self) -&gt; Self;
    }

    trait HasAbs {
        fn abs(self) -&gt; Self;
    }

    impl HasSqrt for f32 {
        fn sq(self) -&gt; Self {
            return f32::sqrt(self);
        }
    }

    impl HasAbs for f32 {
        fn abs(self) -&gt; Self {
            return f32::abs(self);
        }
    } 

    impl HasSqrt for f64 {
        fn sq(self) -&gt; Self {
            return f64::sqrt(self);
        }
    }

    impl HasAbs for f64 {
        fn abs(self) -&gt; Self {
            return f64::abs(self);
        }
    }

    fn quartic&lt;T&gt;(x: T) -&gt; T
    where
        T: HasSqrt + HasAbs , // 這裡界限宣告兩個trait
    {
        return x.abs.sq().sq();
    }

    let qr32 = quartic(100f32);
    let qr64 = quartic(100f64);

    println!(&quot;{} {}&quot;, qr32, qr64);
}
</code></pre></pre>
<h3 id="self和self傻傻分不清楚"><a class="header" href="#self和self傻傻分不清楚">&quot;self&quot;和&quot;Self&quot;傻傻分不清楚</a></h3>
<p>Rust式區分大小寫得</p>
<p>在前面的範例都使用到self和Self其中</p>
<ul>
<li>小寫開頭的self表示函式的值</li>
<li>大寫開頭的Self標示self的型別</li>
</ul>
<p>&quot;self&quot;和&quot;Self&quot;只能在trait或impl範圍裡面使用並且如果self必須是是方法的第一個參數</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這幾個範例是等效的
fn f(self) -&gt; Self
fn f(self: Self) -&gt; Self
fn f(self: i32) -&gt; Self
fn f(self) -&gt; i32
fn f(self: Self) -&gt; i32
fn f(self: i32) -&gt; i32
<span class="boring">}
</span></code></pre></pre>
<h3 id="預設實作"><a class="header" href="#預設實作">預設實作</a></h3>
<p>可以針對Trait預設行為，不必要求每個型別都要實作方法，當然也可以覆蓋這個預設的方法</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    trait HasSqrt {
        fn sq(self) -&gt; Self;
        fn helloWord(&amp;self) -&gt; String { // 預設實作
            return String::from(&quot;hello word&quot;);
        }
    }

    impl HasSqrt for f32 {
        fn sq(self) -&gt; Self {
            return f32::sqrt(self);
        }
    }

    fn quartic&lt;T&gt;(x: T) -&gt; T
    where
        T: HasSqrt,
    {
        println!(&quot;{}&quot;, x.helloWord());
        return x.sq().sq();
    }

    let qr32 = quartic(100f32);
}
</code></pre></pre>
<h2 id="rust-並行並發一"><a class="header" href="#rust-並行並發一">Rust-並行&amp;並發(一)</a></h2>
<p>有關於並行和並發的定義每個人可能有不一樣的解釋</p>
<ul>
<li>並行指的是在同一時刻，多條指令在 CPU 上同時執行</li>
<li>並發指的是在同一時間區間內，多條指令在 CPU 上同時執行</li>
</ul>
<p><img src="rust/images/201296758kIF7WxTG3.jpg" alt="img" /></p>
<p>Rust以安全高效處理並行程式設計著稱</p>
<h3 id="透過spawn建立新的執行緒"><a class="header" href="#透過spawn建立新的執行緒">透過spawn建立新的執行緒</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;{}&quot;, i);
            thread::sleep(Duration::from_millis(1)); // 讓執行短暫sleep一下
        }
    });

    thread::sleep(Duration::from_millis(5)); // 讓執行短暫sleep一下
}
</code></pre></pre>
<p>透過範例可以看到印出來並不是如預期的都會把1-10印出來，主要是因為main已經執行完退出造成新建的執行緒還沒跑完就被中斷了，雖然可以透過更久的sleep讓main晚點退出但是有更好的作法</p>
<h3 id="使用join等待所有執行緒完成"><a class="header" href="#使用join等待所有執行緒完成">使用join等待所有執行緒完成</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;{}&quot;, i);
            thread::sleep(Duration::from_millis(1)); // 讓執行短暫sleep一下
        }
    });

    handle.join().unwrap(); // (Blocking)讓全部執行完才繼續往下
}
</code></pre></pre>
<p>透過儲存thread::spawn回傳的數值為變數，可以修正產生的執行緒完全沒有執行或沒有執行完成的問題。handle呼叫join方法來確保產生的執行緒會在main離開之前完成</p>
<h3 id="透過執行緒使用move閉包"><a class="header" href="#透過執行緒使用move閉包">透過執行緒使用move閉包</a></h3>
<p>閉包透過move讓thread::spawn執行緒可以使用其他執行緒的資料。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || { // 透過move讓執行緒可以擁有v變數的所有權
        println!(&quot;{:?}&quot;, v);
    }); // 在這個執行緒執行完之前v所有權都不會釋放

    handle.join().unwrap();
}
</code></pre></pre>
<h2 id="rust-並行並發二"><a class="header" href="#rust-並行並發二">Rust-並行&amp;並發(二)</a></h2>
<h3 id="channel"><a class="header" href="#channel">channel</a></h3>
<p>通常channel都是搭配並行使用，沒有使用並行就沒有使用channel的意義
「別透過共享記憶體來溝通，而是透過溝通來共享記憶體」。沒錯Golang的口號在Rust也是通用
Rust標準函式庫也有提供類似Golang的Channel函式
Channel函式會回傳兩個變數分別為發送者(transmitter)與接收者(receiver)
Channel可以多個發送者(transmitter)，單一接收者(receiver)
藉由這兩變數來傳遞訊息</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel(); // 建立新的channel，回傳一個元組，拆成兩個變數

    thread::spawn(move || {
        let val = String::from(&quot;hello word&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap(); // (Blocking)等到有資料才會繼續往下 
    println!(&quot;{}&quot;, received);
}
</code></pre></pre>
<p>channel如果要在同一個通道多個執行緒使用發送者(transmitter)時，會因為所有權的關係造成錯誤，所以可以用clone來製造多個發送者(transmitter)</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    let tx1 = tx.clone(); // 複製發送者
    let tx2 = tx.clone(); // 複製發送者
    thread::spawn(move || {
        let val = String::from(&quot;hello word tx&quot;);
        tx.send(val).unwrap();
    });

    thread::spawn(move || {
        let val = String::from(&quot;hello word tx1&quot;);
        tx1.send(val).unwrap();
    });

    thread::spawn(move || {
        let val = String::from(&quot;hello word tx2&quot;);
        tx2.send(val).unwrap();
    });

    for received in rx {
        println!(&quot;{}&quot;, received);
    }
}

輸出
hello word tx
hello word tx2
hello word tx1
</code></pre></pre>
<p>雖然channel本身不支援多個接收者(receiver)，但是可以利用上鎖讓多個執行序同時使用接收者</p>
<h2 id="錯誤處理"><a class="header" href="#錯誤處理">錯誤處理</a></h2>
<p>Rust將錯誤分成兩大類</p>
<ul>
<li>不可復原的(unrecoverable)</li>
<li>可復原的(recoverable)</li>
</ul>
<p>至於什麼時候該用什麼樣的錯誤就要看使用情境了</p>
<p>例如程式啟動時讀不到設定檔這個就可以使用不可復原的錯誤</p>
<h3 id="不可復原的錯誤使用panic"><a class="header" href="#不可復原的錯誤使用panic">不可復原的錯誤使用panic!</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!(&quot;恐慌性錯誤&quot;);
}

輸出
thread 'main' panicked at '恐慌性錯誤', main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre></pre>
<p>panic會印出錯誤訊息以及第幾行的訊息，還有提示可以設定RUST_BACKTRACE環境變數顯示錯誤回朔資訊</p>
<p>下面執行時增加環境變數RUST_BACKTRACE=1</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RUST_BACKTRACE=1 ./main

輸出
thread 'main' panicked at '恐慌性錯誤', main.rs:2:5
stack backtrace:
   0: std::panicking::begin_panic
   1: main::main
   2: core::ops::function::FnOnce::call_once
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
<span class="boring">}
</span></code></pre></pre>
<p>這時候可以看到簡略的錯誤，也可以設定RUST_BACKTRACE=full會列出整個過程</p>
<p>Rust的panic不像Golang可以recover回來</p>
<h3 id="可復原的的錯誤使用result"><a class="header" href="#可復原的的錯誤使用result">可復原的的錯誤使用Result</a></h3>
<p>Resut是個枚舉型別</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Reust是枚舉型別就可以透過match來判斷是回傳OK還是回傳Err，再依裡面的泛型參數取值</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let _ = match f {
        Ok(file) =&gt; {
            println!(&quot;{:?}&quot;, file)
        }
        Err(error) =&gt; {
            println!(&quot;{:?}&quot;, error)
        }
    };
}

輸出
Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre></pre>
<p>如果覺得match判斷錯誤太麻煩，也可以透過unwrap或expect來直接產生panic錯誤</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;hello.txt&quot;).unwrap(); // 無法指定錯誤訊息
let f = File::open(&quot;hello.txt&quot;).expect(&quot;開啟hello.txt錯誤&quot;); // 可以指定錯誤訊息
<span class="boring">}
</span></code></pre></pre>
<p>也可以在寫函式時回傳Result型別，這邊簡單定義Result泛型型別</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ok = return_result_ok();
    println!(&quot;{:?}&quot;, ok);
    let error = return_result_error();
    println!(&quot;{:?}&quot;, error);
}

fn return_result_ok() -&gt; Result&lt;String, String&gt; {
    let s = String::from(&quot;成功&quot;);
    return Ok(s);
}

fn return_result_error() -&gt; Result&lt;String, String&gt; {
    let s = String::from(&quot;失敗&quot;);
    return Ok(s);
}
</code></pre></pre>
<h2 id="rust-30天的心得"><a class="header" href="#rust-30天的心得">Rust-30天的心得</a></h2>
<p>分享一下這30天從無到有的學習下來的一點點心得
先說一下為什麼要學習Rust是因為最近比較紅之外還有就是它滿常被拿來跟Golnag比較
身為一個Gopher當然要抱著他山之石可以攻玉心去了解一下Rust跟Golang的差別</p>
<p>Go和Rust有很多共同點。兩者都是比較近代的語言，兩者都是為了應對創建者在行業內現有語言中遇到的缺點而創建的，尤其是開發者生產力、可擴展性、安全性和並發性方面的缺點。</p>
<p>網路上搜尋&quot;Rust vs. Go&quot;滿滿的比較文這邊就不再講了
對我來說Rust優點有哪裡</p>
<ul>
<li>沒有GC</li>
<li>零成本抽象</li>
<li>記憶體控管</li>
<li>安全性</li>
<li>強大的編譯器錯誤提示</li>
</ul>
<p>要說缺點就只有學習曲線比較陡，並不是很好上手
Rust用了複雜的方式解決複雜的問題，有時候解決的方式比問題更複雜</p>
<p>至於它有沒有比Golang好就不多做評論了，
但是隻聽說從Golang跳到Rust沒聽過從Rust跳到Golang
語言沒有好壞(<del>不是南北拳的問題，是你的問題</del>)</p>
<p>出處： https://ithelp.ithome.com.tw/users/20129675/ironman/4260</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模組-module-和套件-package"><a class="header" href="#模組-module-和套件-package">模組 (Module) 和套件 (Package)</a></h2>
<p>我們學會函式後，程式碼可以分離，然而，隨著專案規模上升，函式名稱有可能相互衝突。雖然，我們也可以修改函式名稱，但是，只靠函數名稱來區分函式，往往會造成函數名稱變得冗長。像 C 語言中，沒有額外的機制處理函式名稱的衝突，就會看到很多長名稱的函式，像是 <code>gtk_application_get_windows</code> (出自 GTK+ 函式庫)。Rust 提供模組 (module) 的機制，處理函式命名衝突的問題。</p>
<p><em>註：在許多程式語言中，以命名空間 (namespace) 提供類似的機制。</em></p>
<p>在我們先前的內容中，函式和主程式都寫在同一個檔案。在實務上，我們會將函式或物件獨立出來，製成套件 (package)，之後可以重覆利用。例如，同一套函式庫，可供終端機或圖形介面等不同使用者介面來使用。在 Rust 中，套件和模組相互關連。Rust 的套件又稱為 crate。</p>
<h3 id="使用模組"><a class="header" href="#使用模組">使用模組</a></h3>
<p>雖然我們在先前的內容沒有強調模組，實際上，我們已經在使用模組了。我們回頭看先前的一個例子：</p>
<pre><pre class="playground"><code class="language-rust">// Call f64 module
use std::f64;
 
fn main() {
    // Call sqrt function
    let n = f64::sqrt(4.0);
 
    println!(&quot;{}&quot;, n);
}
</code></pre></pre>
<p>在這個例子中，我們呼叫 <code>std</code> 函式庫之中的 <code>f64</code> 模組，之後，就可以呼叫該模組內的 <code>sqrt</code> 函式。</p>
<h3 id="撰寫模組"><a class="header" href="#撰寫模組">撰寫模組</a></h3>
<p>在 Rust 中，使用 <code>mod</code> 這個關鍵字來建立模組。如下例：</p>
<pre><pre class="playground"><code class="language-rust">mod english {
    pub fn hello(name: &amp;str) {
        println!(&quot;Hello, {}&quot;, name);
    }
}
 
mod chinese {
    pub fn hello(name: &amp;str) {
        println!(&quot;你好，{}&quot;, name);
    }
}
 
fn main() {
    // Call modules
    use english;
    use chinese;
 
    // Call two functions with the same name
    english::hello(&quot;Michael&quot;);
    chinese::hello(&quot;麥可&quot;);
}
</code></pre></pre>
<p>在本例中，我們在兩個模組中定義了同名而不同功能的函式。由於這兩個函式被區隔不同的模組中，不會有命名衝突的問題。模組除了區隔函式名稱外，也提供私有區塊，在模組中的函式或物件，需以 <code>pub</code> 關鍵字宣告，否則無法在模組外使用。</p>
<p>如同我們先前看到的範例，模組也可以內嵌。如下例：</p>
<pre><pre class="playground"><code class="language-rust">mod english {
    pub mod greeting {
        pub fn hello(name: &amp;str) {
            println!(&quot;Hello, {}&quot;, name);
        }
    }
 
    pub mod farewell {
        pub fn goodbye(name: &amp;str) {
            println!(&quot;Goodbye, {}&quot;, name);
        }
    }
}
 
fn main() {
    use english;
 
    english::greeting::hello(&quot;Michael&quot;);
    english::farewell::goodbye(&quot;Michael&quot;);
}
</code></pre></pre>
<p>由本例可知，透過模組的機制，可以協助我們整理函式。</p>
<h3 id="建立套件"><a class="header" href="#建立套件">建立套件</a></h3>
<p>在我們先前的範例中，我們建立的是應用程式專案，如下：</p>
<pre><code class="language-sh">cargo new --bin myapp
</code></pre>
<p>但若想將函式或物件獨立出來，供其他 Rust 程式使用，則要用函式庫專案，如下：</p>
<pre><code class="language-sh">cargo new --lib mylib
</code></pre>
<p>我們現在實際建立一個函式庫套件。以上述指令建立 mylib 函式庫套件。加入以下函式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// mylib/src/lib.rc
pub fn hello(name: &amp;str) -&gt; String {
    format!(&quot;Hello, {}&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<p>之後，退回到上一層目錄，建立 myapp 主程式套件。加入以下內容：</p>
<pre><pre class="playground"><code class="language-rust">// myapp/src/main.rs
 
// Call mylib
extern crate mylib;
 
fn main() {
    assert_eq!(mylib::hello(&quot;Michael&quot;), &quot;Hello, Michael&quot;);
}
</code></pre></pre>
<p>透過 <code>extern crate</code> 可以呼叫外部專案。另外，要修改 Cargo.toml 紀錄檔，加入以下內容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
mylib = { path = &quot;../mylib&quot; }
<span class="boring">}
</span></code></pre></pre>
<p>之後，執行該專案，若可正確執行，代表我們成功地建立套件。</p>
<p>如果函式庫存放在遠端站臺上，需修改存取位置。在下例中，我們存取以 Git 存放的函式庫：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot; }
<span class="boring">}
</span></code></pre></pre>
<p>Cargo.toml 是 Rust 套件 (i.e. crate) 使用的設定檔。建議花一些時間熟悉其<a href="http://doc.crates.io/guide.html">官方文件</a>。</p>
<h3 id="在套件中使用模組"><a class="header" href="#在套件中使用模組">在套件中使用模組</a></h3>
<p>在我們先前的例子中，透過 mylib 函式庫對函式命名做最基本的區隔。不過，我們也可以在函式庫中使用模組來進一步區隔函式。我們先以實例看加入模組後的效果：</p>
<pre><pre class="playground"><code class="language-rust">// Call external library
extern crate phrase;
 
fn main() {
    assert_eq!(&quot;Hello, Michael&quot;, phrase::english::greeting::hello(&quot;Michael&quot;));
    assert_eq!(&quot;你好，麥可&quot;, phrase::chinese::greeting::hello(&quot;麥可&quot;));
}
</code></pre></pre>
<p>同樣地，需於 Cargo.toml 加入套件位置：</p>
<pre><code class="language-sh">[dependencies]
phrase = { path = &quot;../phrase&quot; }
</code></pre>
<p>我們現在要實際建立這個函式庫。退回上一層目錄，建立 phrase 函式庫專案：</p>
<pre><code class="language-sh">cargo new --lib phrase
</code></pre>
<pre><code class="language-sh">$ tree
.
├── Cargo.lock
├── Cargo.toml
└── src
    ├── chinese
    │   ├── greeting.rs
    │   └── mod.rs
    ├── english
    │   ├── greeting.rs
    │   └── mod.rs
    └── lib.rs
</code></pre>
<p>在 <em>src/lib.rs</em> 中宣告模組，記得要宣告公開權限：</p>
<p>在 <em>src/english/mod.rs</em> 中宣告子模組：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod greeting;
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hello(name: &amp;str) -&gt; String {
    format!(&quot;Hello, {}&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<p>同樣地，在 <em>src/chinese/mod.rs</em> 中宣告子模組：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod greeting;
<span class="boring">}
</span></code></pre></pre>
<p>同樣地，在 src/chinese/greeting.rs 中實作函式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hello(name: &amp;str) -&gt; String {
	format!(&quot;你好，{}&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<p>由於 Rust 的模組及套件和檔案名稱是連動的，若使用錯誤的檔案名稱將無法編譯，需注意。</p>
<h3 id="進階的模組使用方式"><a class="header" href="#進階的模組使用方式">進階的模組使用方式</a></h3>
<p>在先前的例子中，由於函式庫結構較複雜，使得函式呼叫的動作變得繁瑣，Rust 提供別名來簡化這個動作。如下例：</p>
<pre><pre class="playground"><code class="language-rust">extern crate phrase;
 
use phrase::english::greeting as en_greeting;
use phrase::chinese::greeting as zh_greeting;
 
fn main() {
    assert_eq!(&quot;Hello, Michael&quot;, en_greeting::hello(&quot;Michael&quot;));
    assert_eq!(&quot;你好，麥可&quot;, zh_greeting::hello(&quot;麥可&quot;));
}
</code></pre></pre>
<p>Rust 官方文件中提供了另一個更複雜的模組呼叫範例：</p>
<pre><pre class="playground"><code class="language-rust">// Rename crate
extern crate phrases as sayings;
 
// Rename module
use sayings::japanese::greetings as ja_greetings;
 
// Glob all functions in a module, NOT a good style
use sayings::japanese::farewells::*;
 
// A complex renaming scheme
use sayings::english::{self, greetings as en_greetings, farewells as en_farewells};
 
fn main() {
    println!(&quot;Hello in English; {}&quot;, en_greetings::hello());
    println!(&quot;And in Japanese: {}&quot;, ja_greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, english::farewells::goodbye());
    println!(&quot;Again: {}&quot;, en_farewells::goodbye());
 
    // Use a globbed function, AVOID it when possible.
    println!(&quot;And in Japanese: {}&quot;, goodbye());
}
</code></pre></pre>
<p>稍微閱讀一下程式碼，大概就知道如何呼叫模組。要注意的是，globbing 的動作，會直接暴露函式名稱到主程式中，喪失使用模組區隔函式名稱的用意，應盡量避免。</p>
<hr />
<h2 id="rust模組組織結構"><a class="header" href="#rust模組組織結構">Rust模組組織結構</a></h2>
<p>出處 ：https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</p>
<ol>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%9F%BA%E6%9C%AC%E8%AA%AA%E6%98%8E">基本說明</a></p>
</li>
<li>
<p>Package、Crate和Module</p>
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%8C%85-Crate">包 Crate</a></li>
<li>項目 Package
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BA%8C%E9%80%B2%E5%88%B6-Package">二進制 Package</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%BA%AB-Package">庫 Package</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84-Package-%E5%92%8C%E5%8C%85">易混淆的 Package 和包</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%85%B8%E5%9E%8B%E7%9A%84-Package-%E7%B5%90%E6%A7%8B">典型的 Package 結構</a></li>
</ol>
</li>
<li>模組 Module
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%89%B5%E5%BB%BA%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%A1%8A">建立巢狀模組</a></li>
<li>模組樹
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%88%B6%E5%AD%90%E6%A8%A1%E5%A1%8A">父子模組</a></li>
</ol>
</li>
<li>用路徑引用模組
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%B5%95%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%BC%95%E7%94%A8">絕對路徑引用</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%9B%B8%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%BC%95%E7%94%A8">相對路徑引用</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%B5%95%E5%B0%8D%E9%82%84%E6%98%AF%E7%9B%B8%E5%B0%8D%EF%BC%9F">絕對還是相對？</a></li>
</ol>
</li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BB%A3%E7%A2%BC%E5%8F%AF%E8%A6%8B%E6%80%A7">程式碼可見性</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BD%BF%E7%94%A8-super-%E5%BC%95%E7%94%A8%E6%A8%A1%E5%A1%8A">使用 super 引用模組</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BD%BF%E7%94%A8-self-%E5%BC%95%E7%94%A8%E6%A8%A1%E5%A1%8A">使用 self 引用模組</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%B5%90%E6%A7%8B%E9%AB%94%E5%92%8C%E6%9E%9A%E8%88%89%E7%9A%84%E5%8F%AF%E8%A6%8B%E6%80%A7">結構體和列舉的可見性</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E6%A8%A1%E5%A1%8A%E8%88%87%E6%96%87%E4%BB%B6%E5%88%86%E9%9B%A2">模組與檔案分離</a></li>
</ol>
</li>
</ol>
</li>
<li>
<p>使用 use 及受限可見性</p>
<ol>
<li>基本引入方式
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%B5%95%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%BC%95%E5%85%A5%E6%A8%A1%E5%A1%8A">絕對路徑引入模組</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E7%9B%B8%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%BC%95%E5%85%A5%E6%A8%A1%E5%A1%8A%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B8">相對路徑引入模組中的函數</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%BC%95%E5%85%A5%E6%A8%A1%E5%A1%8A%E9%82%84%E6%98%AF%E5%87%BD%E6%95%B8%EF%BC%9F">引入模組還是函數？</a></li>
</ol>
</li>
<li>避免同名引用
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E6%A8%A1%E5%A1%8A-%E5%87%BD%E6%95%B8">模組::函數</a></li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#as-%E5%88%A5%E5%90%8D%E5%BC%95%E7%94%A8">as 別名引用</a></li>
</ol>
</li>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%BC%95%E5%85%A5%E9%A0%85%E5%86%8D%E5%B0%8E%E5%87%BA">引入項再匯出</a></li>
</ol>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85">使用第三方包</a></p>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BD%BF%E7%94%A8-%E7%B0%A1%E5%8C%96%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F">使用 {} 簡化引入方式</a></p>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%BD%BF%E7%94%A8-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%A1%8A%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E9%A0%85">使用 * 引入模組下的所有項</a></p>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%85%B6%E4%BB%96%E5%BC%95%E5%85%A5%E6%A8%A1%E5%A1%8A%E7%9A%84%E6%96%B9%E5%BC%8F">其他引入模組的方式</a></p>
</li>
<li>
<p>受限的可見性</p>
<ol>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E9%99%90%E5%88%B6%E5%8F%AF%E8%A6%8B%E6%80%A7%E8%AA%9E%E6%B3%95">限制可見性語法</a></li>
</ol>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E4%B8%80%E5%80%8B%E5%96%AE%E6%96%87%E4%BB%B6%E5%A4%9A%E6%A8%A1%E5%A1%8A%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">一個單檔案多模組的使用案例</a></p>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%A4%9A%E5%80%8B%E7%9B%AE%E9%8C%84%E9%96%93%E6%A8%A1%E5%A1%8A%E5%BC%95%E7%94%A8">多個目錄間模組引用</a></p>
</li>
<li>
<p><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E5%A4%9A%E5%80%8BCargo%E4%B9%8B%E9%96%93%E9%80%B2%E8%A1%8C%E5%BC%95%E7%94%A8">多個Cargo之間進行引用</a></p>
</li>
</ol>
<ul>
<li><a href="https://jasonkayzk.github.io/2022/11/19/Rust%E6%A8%A1%E5%A1%8A%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B/#%E9%99%84%E9%8C%84">附錄</a></li>
</ul>
<p>本文講述了Rust中模組的組織形式和約定；</p>
<p>原始碼：</p>
<ul>
<li>https://github.com/JasonkayZK/rust-learn/tree/project-structure</li>
</ul>
<h1 id="rust模組組織結構-1"><a class="header" href="#rust模組組織結構-1"><strong>Rust模組組織結構</strong></a></h1>
<h2 id="基本說明"><a class="header" href="#基本說明"><strong>基本說明</strong></a></h2>
<p>當工程規模變大時，把程式碼寫到一個甚至幾個檔案中，都是不太聰明的做法，可能存在以下問題：</p>
<ol>
<li>單個檔案過大，導致打開、翻頁速度大幅變慢</li>
<li>查詢和定位效率大幅降低，類比下，你會把所有知識內容放在一個幾十萬字的文件中嗎？</li>
<li>只有一個程式碼層次：函數，難以維護和協作，想像一下你的作業系統只有一個根目錄，剩下的都是單層子目錄會如何：<code>disaster</code></li>
</ol>
<p>同時，將大的程式碼檔案拆分成包和模組，還允許我們實現程式碼抽象和復用：將你的程式碼封裝好後提供給使用者，那麼使用者只需要呼叫公共介面即可，無需知道內部該如何實現；</p>
<p>Rust 有自己的規則和約定來組織其模組；例如：一個 crate 包最多可以有一個庫 <code>crate</code>，任意多個二進制<code>crate</code>、匯入資料夾內的模組的兩種約定方式等等；</p>
<p>先把一些術語說明一下：</p>
<ul>
<li>項目(Packages)：<strong>一個 <code>Cargo</code> 提供的 <code>feature</code>，可以用來建構、測試和分享包；</strong></li>
<li>包(Crate)：<strong>一個由多個模組組成的樹形結構，可以作為三方庫進行分發，也可以生成可執行檔案進行運行；</strong></li>
<li>模組(Module)：<strong>可以一個檔案多個模組，也可以一個檔案一個模組</strong>，模組可以被認為是真實項目中的程式碼組織單元；</li>
</ul>
<p>首先，<code>包(crate)</code> 是 Cargo 中的定義，執行 <code>cargo new xxxx</code> 就是建立了一個包，<code>crate</code> 是二進制(bin)或庫(lib)項目；</p>
<p>Rust 約定：在 <code>Cargo.toml</code> 的同級目錄下：</p>
<ul>
<li>包含<code>src/main.rs</code>檔案，就是<strong>與包同名的二進制<code>crate</code>；</strong></li>
<li>包含<code>src/lib.rs</code>，就是與<strong>包同名的庫<code>crate</code>；</strong></li>
</ul>
<p>一個包內可以有多個 <code>crate</code>，多個<code>crates</code>就是一個模組的樹形結構；例如，如果一個包內同時包含<code>src/main.rs</code>和<code>src/lib.rs</code>，那麼他就有兩個<code>crate</code>；</p>
<p>如果想要包含多個二進制<code>crate</code>，<code>rust</code>規定：需要將檔案放在<code>src/bin</code>目錄下，每個檔案就是一個單獨的<code>crate</code>！</p>
<p><code>crate root</code> 是用來描述如何建構<code>crate</code>的檔案；例如：<code>src/main.rs</code>、<code>src/lib.rs</code> 都是<code>crate root</code>；</p>
<p><strong><code>crate root</code>將由<code>Cargo</code>傳遞給<code>rustc</code>來實際建構庫或者二進制項目！</strong></p>
<blockquote>
<p><strong>這也是為什麼，入口檔案中要寫入各個模組：<code>mod xxx;</code> 才能使其生效！</strong></p>
</blockquote>
<p><strong>帶有 <code>Cargo.toml</code> 檔案的包用來整體描述如何建構<code>crate</code>；同時，一個包可以最多有一個庫<code>crate</code>，任意多個二進制<code>crate</code>；</strong></p>
<h2 id="packagecrate和module"><a class="header" href="#packagecrate和module"><strong>Package、Crate和Module</strong></a></h2>
<p>項目 <code>Package</code> 和包 <code>Crate</code> 的概念很容易被搞混，甚至在很多書中，這兩者都是不分的，但是由於官方對此做了明確的區分，因此我們會在本章節中試圖(掙紮著)理清這個概念；</p>
<h3 id="包-crate"><a class="header" href="#包-crate"><strong>包 Crate</strong></a></h3>
<p>對於 Rust 而言，<strong>crate 是一個獨立的可編譯單元，它編譯後會生成一個可執行檔案或者一個庫；</strong></p>
<p>一個包會將相關聯的功能打包在一起，使得該功能可以很方便的在多個項目中分享；</p>
<p>例如：標準庫中沒有提供、而是在三方庫中提供的 <code>rand</code> 包；它提供了隨機數生成的功能，我們只需要將該包通過 <code>use rand;</code> 引入到當前項目的範疇中，就可以在項目中使用 <code>rand</code> 的功能：<code>rand::XXX</code>；</p>
<p>**同一個包中不能有同名的類型，但是在不同包中就可以；**例如，雖然 <code>rand</code> 包中，有一個 <code>Rng</code> 特徵，可是我們依然可以在自己的項目中定義一個 <code>Rng</code>，前者通過 <code>rand::Rng</code> 訪問，後者通過 <code>Rng</code> 訪問，對於編譯器而言，這兩者的邊界非常清晰，不會存在引用歧義；</p>
<h3 id="項目-package"><a class="header" href="#項目-package"><strong>項目 Package</strong></a></h3>
<p>鑑於 Rust 團隊標新立異的起名傳統，以及包的名稱被 <code>crate</code> 佔用，庫的名稱被 <code>library</code> 佔用，經過斟酌， 我們決定將 <code>Package</code> 翻譯成項目，你也可以理解為工程、軟體包；</p>
<p>由於 <code>Package</code> 就是一個項目，因此它<strong>包含有獨立的 <code>Cargo.toml</code> 檔案，以及因為功能性被組織在一起的一個或多個包；一個 <code>Package</code> 只能包含一個庫(library)類型的包，但是可以包含多個二進制可執行類型的包；</strong></p>
<h4 id="二進制-package"><a class="header" href="#二進制-package"><strong>二進制 Package</strong></a></h4>
<p>下面的命令可以建立一個二進制 <code>Package</code>：</p>
<pre><code>$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>這裡，Cargo 為我們建立了一個名稱是 <code>my-project</code> 的 <code>Package</code>，同時在其中建立了 <code>Cargo.toml</code> 檔案，可以看一下該檔案，裡面並沒有提到 <code>src/main.rs</code> 作為程序的入口；</p>
<p>原因是 Cargo 有一個慣例：<strong><code>src/main.rs</code> 是二進制包的根檔案，該二進制包的包名跟所屬 <code>Package</code> 相同，在這裡都是 <code>my-project</code>，所有的程式碼執行都從該檔案中的 <code>fn main()</code> 函數開始；</strong></p>
<p>使用 <code>cargo run</code> 可以運行該項目，輸出：<code>Hello, world!</code>；</p>
<h4 id="庫-package"><a class="header" href="#庫-package"><strong>庫 Package</strong></a></h4>
<p>再來建立一個庫類型的 <code>Package</code>：</p>
<pre><code>$ cargo new my-lib --lib
     Created library `my-lib` package
$ ls my-lib
Cargo.toml
src
$ ls my-lib/src
lib.rs
</code></pre>
<p>首先，如果你試圖運行 <code>my-lib</code>，會報錯：</p>
<pre><code>$ cargo run
error: a bin target must be available for `cargo run`
</code></pre>
<p>原因是：<strong>庫類型的 <code>Package</code> 只能作為三方庫被其它項目引用，而不能獨立運行，只有之前的二進制 <code>Package</code> 才可以運行；</strong></p>
<p>與 <code>src/main.rs</code> 一樣，Cargo 知道，如果一個 <code>Package</code> 包含有 <code>src/lib.rs</code>，意味它包含有一個庫類型的同名包 <code>my-lib</code>，該包的根檔案是 <code>src/lib.rs</code>；</p>
<h4 id="易混淆的-package-和包"><a class="header" href="#易混淆的-package-和包"><strong>易混淆的 Package 和包</strong></a></h4>
<p>看完上面，相信大家看出來為何 <code>Package</code> 和包容易被混淆了吧？因為你用 <code>cargo new</code> 建立的 <code>Package</code> 和它其中包含的包是同名的！</p>
<p>不過，只要你牢記：<strong><code>Package</code> 是一個項目工程，而包只是一個編譯單元，基本上也就不會混淆這個兩個概念了：<code>src/main.rs</code> 和 <code>src/lib.rs</code> 都是編譯單元，因此它們都是包；</strong></p>
<h4 id="典型的-package-結構"><a class="header" href="#典型的-package-結構"><strong>典型的 <code>Package</code> 結構</strong></a></h4>
<p>上面建立的 <code>Package</code> 中僅包含 <code>src/main.rs</code> 檔案，意味著它僅包含一個二進制同名包 <code>my-project</code>；</p>
<p>如果一個 <code>Package</code> 同時擁有 <code>src/main.rs</code> 和 <code>src/lib.rs</code>，那就意味著它包含兩個包：庫包和二進制包；</p>
<p><strong>同時，這兩個包名也都是 <code>my-project</code> —— 都與 <code>Package</code> 同名；</strong></p>
<p>一個真實項目中典型的 <code>Package</code>，會包含多個二進制包，這些包檔案被放在 <code>src/bin</code> 目錄下，每一個檔案都是獨立的二進制包，同時也會包含一個庫包，該包只能存在一個 <code>src/lib.rs</code>：</p>
<pre><code>.
├── Cargo.toml
├── Cargo.lock
├── src
│   ├── main.rs
│   ├── lib.rs
│   └── bin
│       └── main1.rs
│       └── main2.rs
├── tests
│   └── some_integration_tests.rs
├── benches
│   └── simple_bench.rs
└── examples
    └── simple_example.rs
</code></pre>
<ul>
<li><strong>唯一庫包：<code>src/lib.rs</code></strong></li>
<li><strong>默認二進制包：<code>src/main.rs</code>，編譯後生成的可執行檔案與 <code>Package</code> 同名</strong></li>
<li><strong>其餘二進制包：<code>src/bin/main1.rs</code> 和 <code>src/bin/main2.rs</code>，它們會分別生成一個檔案同名的二進制可執行檔案</strong></li>
<li><strong>整合測試檔案：<code>tests</code> 目錄下</strong></li>
<li><strong>基準性能測試 <code>benchmark</code> 檔案：<code>benches</code> 目錄下</strong></li>
<li><strong>項目示例：<code>examples</code> 目錄下</strong></li>
</ul>
<p>這種目錄結構基本上是 Rust 的標準目錄結構，在 <code>GitHub</code> 的大多數項目上，你都將看到它的身影；</p>
<p>理解了包的概念，我們再來看看構成包的基本單元：模組；</p>
<h3 id="模組-module"><a class="header" href="#模組-module"><strong>模組 Module</strong></a></h3>
<p>本小節講深入講解 Rust 的程式碼構成單元：模組；</p>
<p>使用模組可以將包中的程式碼按照功能性進行重組，最終實現更好的可讀性及易用性；</p>
<p>同時，我們還能非常靈活地去控制程式碼的可見性，進一步強化 Rust 的安全性；</p>
<h4 id="建立巢狀模組"><a class="header" href="#建立巢狀模組"><strong>建立巢狀模組</strong></a></h4>
<p>小餐館，相信大家都挺熟悉的，學校外的估計也沒少去，那麼咱就用小餐館為例，來看看 Rust 的模組該如何使用；</p>
<p>可以使用 <code>cargo new --lib restaurant</code> 建立一個小餐館；</p>
<p>注意，這裡建立的是一個庫類型的 <code>Package</code>，然後將以下程式碼放入 <code>src/lib.rs</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 餐廳前廳，用於吃飯
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>以上的程式碼（在同一個檔案中就）建立了三個模組</strong>，有幾點需要注意的：</p>
<ul>
<li><strong>使用 <code>mod</code> 關鍵字來建立新模組，後面緊跟著模組名稱；</strong></li>
<li><strong>模組可以巢狀，這裡巢狀的原因是招待客人和服務都發生在前廳，因此我們的程式碼模擬了真實場景；</strong></li>
<li><strong>模組中可以定義各種 Rust 類型，例如函數、結構體、列舉、特徵等；</strong></li>
<li><strong>所有模組均定義在同一個檔案中；</strong></li>
</ul>
<p>類似上述程式碼中所做的，使用模組，我們就能將功能相關的程式碼組織到一起，然後通過一個模組名稱來說明這些程式碼為何被組織在一起，這樣其它程式設計師在使用你的模組時，就可以更快地理解和上手；</p>
<h4 id="模組樹"><a class="header" href="#模組樹"><strong>模組樹</strong></a></h4>
<p>之前我們提到過 <code>src/main.rs</code> 和 <code>src/lib.rs</code> 被稱為包根(crate root)，是由於這兩個檔案的內容形成了一個模組 <code>crate</code>，該模組位於包的樹形結構(由模組組成的樹形結構)的根部：</p>
<pre><code>crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>這顆樹展示了模組之間<strong>彼此的巢狀</strong>關係，因此被稱為<strong>模組樹</strong>；</p>
<p>其中 <code>crate</code> 包根是 <code>src/lib.rs</code> 檔案，包根檔案中的三個模組分別形成了模組樹的剩餘部分；</p>
<h5 id="父子模組"><a class="header" href="#父子模組"><strong>父子模組</strong></a></h5>
<p>如果模組 <code>A</code> 包含模組 <code>B</code>，那麼 <code>A</code> 是 <code>B</code> 的父模組，<code>B</code> 是 <code>A</code> 的子模組；</p>
<p>在上例中，<code>front_of_house</code> 是 <code>hosting</code> 和 <code>serving</code> 的父模組，反之，後兩者是前者的子模組；</p>
<p>聰明的讀者，應該能聯想到，模組樹跟電腦上檔案系統目錄樹的相似之處；</p>
<p>然而不僅僅是組織結構上的相似，就連使用方式都很相似：<strong>每個檔案都有自己的路徑，使用者可以通過這些路徑使用它們，在 Rust 中，我們也通過路徑的方式來引用模組；</strong></p>
<h4 id="用路徑引用模組"><a class="header" href="#用路徑引用模組"><strong>用路徑引用模組</strong></a></h4>
<p>想要呼叫一個函數，就需要知道它的路徑，在 Rust 中，這種路徑有兩種形式：</p>
<ul>
<li><strong>絕對路徑</strong>，從包根開始，路徑名以包名或者 <code>crate</code> 作為開頭</li>
<li><strong>相對路徑</strong>，從當前模組開始，以 <code>self</code>，<code>super</code> 或當前模組的識別碼作為開頭</li>
</ul>
<p>讓我們繼續經營那個慘淡的小餐館，這次為它實現一個小功能：</p>
<p>src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 餐廳前廳，用於吃飯
pub mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 絕對路徑
    crate::front_of_house::hosting::add_to_waitlist();

    // 相對路徑
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><code>eat_at_restaurant</code> 是一個定義在 crate root 中的函數，在該函數中使用了兩種方式對 <code>add_to_waitlist</code> 進行呼叫；</p>
<h5 id="絕對路徑引用"><a class="header" href="#絕對路徑引用"><strong>絕對路徑引用</strong></a></h5>
<p>因為 <code>eat_at_restaurant</code> 和 <code>add_to_waitlist</code> 都定義在一個包中，因此在絕對路徑引用時，可以直接以 <code>crate</code> 開頭，然後逐層引用，每一層之間使用 <code>::</code> 分隔：</p>
<pre><code>crate::front_of_house::hosting::add_to_waitlist();
</code></pre>
<p>對比下之前的模組樹：</p>
<pre><code>crate
 └── eat_at_restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>可以看出，絕對路徑的呼叫，完全符合了模組樹的層級遞進，非常符合直覺；</p>
<p>如果類比檔案系統，就跟使用絕對路徑呼叫可執行程序差不多：<code>/front_of_house/hosting/add_to_waitlist</code>，使用 <code>crate</code> 作為開始就和使用 <code>/</code> 作為開始一樣；</p>
<h5 id="相對路徑引用"><a class="header" href="#相對路徑引用"><strong>相對路徑引用</strong></a></h5>
<p>再回到模組樹中，因為 <code>eat_at_restaurant</code> 和 <code>front_of_house</code> 都處於 <code>crate root</code> 中，因此相對路徑可以使用 <code>front_of_house</code> 作為開頭：</p>
<pre><code>front_of_house::hosting::add_to_waitlist();
</code></pre>
<p>如果類比檔案系統，那麼它<strong>類似於呼叫同一個目錄下的程序</strong>，你可以這麼做：<code>front_of_house/hosting/add_to_waitlist</code>；</p>
<h5 id="絕對還是相對"><a class="header" href="#絕對還是相對"><strong>絕對還是相對？</strong></a></h5>
<p><strong>如果只是為了引用到指定模組中的對象，那麼兩種都可以；</strong></p>
<p>但是在實際使用時，需要遵循一個原則：<strong>當程式碼被挪動位置時，儘量減少引用路徑的修改，相信大家都遇到過，修改了某處程式碼，導致所有路徑都要挨個替換，這顯然不是好的路徑選擇；</strong></p>
<p>回到之前的例子：</p>
<p>如果我們把 <code>front_of_house</code> 模組和 <code>eat_at_restaurant</code> 移動到一個模組中 <code>customer_experience</code>，那麼絕對路徑的引用方式就必須進行修改：<code>crate::customer_experience::front_of_house ...</code>；</p>
<p>但是假設我們使用的相對路徑，那麼該路徑就無需修改，因為它們兩個的相對位置其實沒有變：</p>
<pre><code>crate
 └── customer_experience
    └── eat_at_restaurant
    └── front_of_house
        ├── hosting
        │   ├── add_to_waitlist
        │   └── seat_at_table
</code></pre>
<p>從新的模組樹中可以很清晰的看出這一點；</p>
<p>再比如，其它的都不動，把 <code>eat_at_restaurant</code> 移動到模組 <code>dining</code> 中，如果使用相對路徑，你需要修改該路徑，但如果使用的是絕對路徑，就無需修改：</p>
<pre><code>crate
 └── dining
     └── eat_at_restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
</code></pre>
<p>不過，如果不確定哪個好，你可以考慮<strong>優先使用絕對路徑，因為呼叫的地方和定義的地方往往是分離的，而定義的地方較少會變動；</strong></p>
<h4 id="程式碼可見性"><a class="header" href="#程式碼可見性"><strong>程式碼可見性</strong></a></h4>
<p>Rust 出於安全的考慮，默認情況下，所有的類型都是私有化的，包括函數、方法、結構體、列舉、常數，是的，就連模組本身也是私有化的；</p>
<p>在 Rust 中，<strong>父模組<code>完全無法訪問</code>子模組中的私有項，但是子模組卻可以訪問父模組、父父..模組的私有項！</strong></p>
<p>例如下面的程式碼是無法編譯通過的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 絕對路徑
    crate::front_of_house::hosting::add_to_waitlist();

    // 相對路徑
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><code>hosting</code> 模組是私有的，無法在包根進行訪問；</p>
<p>那麼為何 <code>front_of_house</code> 模組就可以訪問？</p>
<p>因為它和 <code>eat_at_restaurant</code> 同屬於一個包根範疇內，<strong>同一個模組內的程式碼自然不存在私有化問題</strong>(所以我們之前章節的程式碼都沒有報過這個錯誤！)；</p>
<p>類似其它語言的 <code>public</code> 或者 Go 語言中的首字母大寫，Rust 提供了 <code>pub</code> 關鍵字，通過它你可以控制模組和模組中指定項的可見性；</p>
<h4 id="使用-super-引用模組"><a class="header" href="#使用-super-引用模組"><strong>使用 <code>super</code> 引用模組</strong></a></h4>
<p>在上文用路徑引用模組小節，使用路徑引用模組中，我們提到了相對路徑有三種方式開始：<code>self</code>、<code>super</code>和 <code>crate</code> 或者模組名，其中第三種在前面已經講到過，現在來看看通過 <code>super</code> 的方式引用模組項；</p>
<p><code>super</code> 代表的是<strong>父模組為開始的引用方式，非常類似於檔案系統中的 <code>..</code>；</strong></p>
<p>語法：<code>../a/b</code> 檔案名稱：</p>
<p>src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 餐廳前廳，用於吃飯
pub mod front_of_house {
    pub mod serving {
        fn serve_order() {}

        // 廚房模組
        mod back_of_house {
            fn fix_incorrect_order() {
                cook_order();
                super::serve_order();
            }

            fn cook_order() {}
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在廚房模組中，使用 <code>super::serve_order</code> 語法，呼叫了父模組中的 <code>serve_order</code> 函數；</p>
<p>那麼你可能會問，為何不使用 <code>crate::serve_order</code> 的方式？</p>
<p>其實也可以，不過如果你確定未來這種層級關係不會改變，那麼 <code>super::serve_order</code> 的方式會更穩定，未來就算它們都不在 crate root了，依然無需修改引用路徑；</p>
<p>所以路徑的選用，往往還是取決於場景，以及未來程式碼的可能走向；</p>
<h4 id="使用-self-引用模組"><a class="header" href="#使用-self-引用模組"><strong>使用 <code>self</code> 引用模組</strong></a></h4>
<p><code>self</code> 其實就是引用自身模組中的項，也就是說和我們之前章節的程式碼類似，都呼叫同一模組中的內容，區別在於之前章節中直接通過名稱呼叫即可，而 <code>self</code>，你得多此一舉：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod serving {

  fn serve_order() {
    self::back_of_house::cook_order()
  }

  // 廚房模組
  mod back_of_house {
    pub fn cook_order() {}
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>是的，多此一舉，因為完全可以直接呼叫 <code>back_of_house</code>，但是 <code>self</code> 還有一個大用處，在後文中會講；</p>
<h4 id="結構體和列舉的可見性"><a class="header" href="#結構體和列舉的可見性"><strong>結構體和列舉的可見性</strong></a></h4>
<p>為何要把結構體和列舉的可見性單獨拎出來講呢？因為這兩個傢伙的成員欄位擁有完全不同的可見性：</p>
<ul>
<li><strong>將結構體設定為 <code>pub</code>，但它的所有欄位依然是私有的；</strong></li>
<li><strong>將列舉設定為 <code>pub</code>，它的所有欄位則將對外可見；</strong></li>
</ul>
<p>原因在於：<strong>列舉和結構體的使用方式不一樣：</strong></p>
<ul>
<li>如果列舉的成員對外不可見，那該列舉將一點用都沒有，因此列舉成員的可見性自動跟列舉可見性保持一致，這樣可以簡化使用者的使用；</li>
<li>而結構體的應用場景比較複雜，其中的欄位也往往部分在 A 處被使用，部分在 B 處被使用，因此無法確定成員的可見性，那索性就設定為全部不可見，將選擇權交給程式設計師；</li>
</ul>
<h4 id="模組與檔案分離"><a class="header" href="#模組與檔案分離"><strong>模組與檔案分離</strong></a></h4>
<p>在之前的例子中，我們所有的模組都定義在 <code>src/lib.rs</code> 中，但是當模組變多或者變大時，需要<strong>將模組放入一個單獨的檔案中</strong>，讓程式碼更好維護；</p>
<p>現在，把 <code>front_of_house</code> 前廳分離出來，放入一個單獨的檔案中：</p>
<p>src/front_of_house.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 餐廳前廳，用於吃飯
pub mod hosting {
    pub fn add_to_waitlist() {}

    fn seat_at_table() {}
}

pub mod serving {
    fn take_order() {}

    fn serve_order() {
        self::back_of_house::cook_order()
    }

    fn take_payment() {}

    // 廚房模組
    mod back_of_house {
        fn fix_incorrect_order() {
            cook_order();
            super::serve_order();
        }

        pub fn cook_order() {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然後，將以下程式碼留在 <code>src/lib.rs</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    // 絕對路徑
    hosting::add_to_waitlist();

    // 相對路徑
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>其實跟之前在同一個檔案中也沒有太大的不同，但是有幾點值得注意：</p>
<ul>
<li><code>mod front_of_house</code>：告訴 Rust 從另一個和模組 <code>front_of_house</code> 同名的檔案中載入該模組的內容；</li>
<li>使用絕對路徑的方式來引用 <code>hosting</code> 模組：<code>crate::front_of_house::hosting</code>；</li>
</ul>
<p>需要注意的是，和之前程式碼中 <code>mod front_of_house{..}</code> 的完整模組不同：</p>
<p>現在的程式碼中，<strong>模組的聲明和實現是分離的</strong>，實現是在單獨的 <code>front_of_house.rs</code> 檔案中，然後通過 <code>mod front_of_house;</code> 這條聲明語句從該檔案中把模組內容載入進來；</p>
<p><strong>因此我們可以認為：模組 <code>front_of_house</code> 的定義還是在 <code>src/lib.rs</code> 中，只不過模組的具體內容被移動到了 <code>src/front_of_house.rs</code> 檔案中；</strong></p>
<p>在這裡出現了一個新的關鍵字 <code>use</code>，聯想到其它章節我們見過的標準庫引入 <code>use std::fmt;</code>，可以大致猜測，該關鍵字<strong>用來將外部模組中的項引入到當前範疇中來，這樣無需冗長的父模組前綴即可呼叫</strong>：<code>hosting::add_to_waitlist();</code>，在下節中，我們將對 <code>use</code> 進行詳細的講解；</p>
<h2 id="使用-use-及受限可見性"><a class="header" href="#使用-use-及受限可見性"><strong>使用 use 及受限可見性</strong></a></h2>
<p>如果程式碼中，通篇都是 <code>crate::front_of_house::hosting::add_to_waitlist</code> 這樣的函數呼叫形式，我不知道有誰會喜歡；</p>
<p>因此我們需要一個辦法來簡化這種使用方式，在 Rust 中，<strong>可以使用 <code>use</code> 關鍵字把路徑提前引入到當前範疇中，隨後的呼叫就可以省略該路徑，極大地簡化了程式碼；</strong></p>
<h3 id="基本引入方式"><a class="header" href="#基本引入方式"><strong>基本引入方式</strong></a></h3>
<p>在 Rust 中，引入模組中的項有兩種方式：<a href="https://course.rs/basic/crate-module/module.html#%E7%94%A8%E8%B7%AF%E5%BE%91%E5%BC%95%E7%94%A8%E6%A8%A1%E5%A1%8A">絕對路徑和相對路徑</a>，這兩者在前文中都講過，就不再贅述；</p>
<p>先來看看使用絕對路徑的引入方式；</p>
<h4 id="絕對路徑引入模組"><a class="header" href="#絕對路徑引入模組"><strong>絕對路徑引入模組</strong></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>這裡，我們使用 <code>use</code> 和絕對路徑的方式，將 <code>hosting</code> 模組引入到當前範疇中，然後只需通過 <code>hosting::add_to_waitlist</code> 的方式，即可呼叫目標模組中的函數；</p>
<p>相比 <code>crate::front_of_house::hosting::add_to_waitlist()</code> 的方式要簡單的多；</p>
<p>那麼，還能更簡單嗎？</p>
<h4 id="相對路徑引入模組中的函數"><a class="header" href="#相對路徑引入模組中的函數"><strong>相對路徑引入模組中的函數</strong></a></h4>
<p>在下面程式碼中，我們不僅要使用相對路徑進行引入，而且與上面引入 <code>hosting</code> 模組不同，直接引入該模組中的 <code>add_to_waitlist</code> 函數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>很明顯，函數呼叫又變得更短了；</p>
<h4 id="引入模組還是函數"><a class="header" href="#引入模組還是函數"><strong>引入模組還是函數？</strong></a></h4>
<p>從使用簡潔性來說，引入函數自然是更甚一籌，但是在某些時候，引入模組會更好：</p>
<ul>
<li><strong>需要引入同一個模組的多個函數</strong></li>
<li><strong>範疇中存在同名函數</strong></li>
</ul>
<p>在以上兩種情況中，使用 <code>use front_of_house::hosting</code> 引入模組要比 <code>use front_of_house::hosting::add_to_waitlist;</code> 引入函數更好；</p>
<p><strong>例如，如果想使用 <code>HashMap</code>，那麼直接引入該結構體是比引入模組更好的選擇，因為在 <code>collections</code> 模組中，我們只需要使用一個 <code>HashMap</code> 結構體：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p>其實嚴格來說，對於引用方式並沒有需要遵守的慣例，主要還是取決於你的喜好，不過我們建議：</p>
<p><strong>優先使用最細粒度(引入函數、結構體等)的引用方式，如果引起了某種麻煩(例如前面兩種情況)，再使用引入模組的方式；</strong></p>
<h3 id="避免同名引用"><a class="header" href="#避免同名引用"><strong>避免同名引用</strong></a></h3>
<p>根據上一章節的內容，我們只要<strong>保證同一個模組中不存在同名項</strong>就行；</p>
<p>話雖如此，一起看看，如果遇到同名的情況該如何處理；</p>
<h4 id="模組函數"><a class="header" href="#模組函數"><strong>模組::函數</strong></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>rust上面的例子給出了很好的解決方案，使用模組引入的方式，具體的 <code>Result</code> 通過 <code>模組::Result</code> 的方式進行呼叫；</p>
<p>可以看出，<strong>避免同名衝突的關鍵，就是使用父模組的方式來呼叫；</strong></p>
<p>除此之外，還可以給予引入的項起一個別名；</p>
<h4 id="as-別名引用"><a class="header" href="#as-別名引用"><strong><code>as</code> 別名引用</strong></a></h4>
<p>對於同名衝突問題，還可以使用 <code>as</code> 關鍵字來解決，它可以賦予引入項一個全新的名稱：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所示，首先通過 <code>use std::io::Result</code> 將 <code>Result</code> 引入到範疇，然後使用 <code>as</code> 給予它一個全新的名稱 <code>IoResult</code>，這樣就不會再產生衝突：</p>
<ul>
<li><code>Result</code> 代表 <code>std::fmt::Result；</code></li>
<li><code>IoResult</code> 代表 <code>std:io::Result</code>；</li>
</ul>
<h3 id="引入項再匯出"><a class="header" href="#引入項再匯出"><strong>引入項再匯出</strong></a></h3>
<p><strong>當外部的模組項 <code>A</code> 被引入到當前模組中時，它的可見性自動被設定為私有的，如果你希望允許其它外部程式碼引用我們的模組項 <code>A</code>，那麼可以對它進行再匯出：</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p>如上，<strong>使用 <code>pub use</code> 即可實現：</strong></p>
<p><strong>這裡 <code>use</code> 代表引入 <code>hosting</code> 模組到當前範疇，<code>pub</code> 表示將該引入的內容再度設定為可見；</strong></p>
<p>當你希望將內部的實現細節隱藏起來或者按照某個目的組織程式碼時，可以使用 <code>pub use</code> 再匯出；</p>
<p>例如，統一使用一個模組來提供對外的 API，那該模組就可以引入其它模組中的 API，然後進行再匯出，最終對於使用者來說，所有的 API 都是由一個模組統一提供的；</p>
<h2 id="使用第三方包"><a class="header" href="#使用第三方包"><strong>使用第三方包</strong></a></h2>
<p>之前我們一直在引入標準庫模組或者自訂模組，現在來引入下第三方包中的模組；</p>
<p>關於如何引入外部依賴，在 <a href="https://course.rs/first-try/cargo.html#package-%E9%85%8D%E7%BD%AE%E6%AE%B5%E8%90%BD">Cargo 入門</a>中就有講，這裡直接給出操作步驟：</p>
<ol>
<li><strong>修改 <code>Cargo.toml</code> 檔案，在 <code>[dependencies]</code> 區域新增一行：<code>rand = &quot;0.8.3&quot;</code></strong></li>
<li><strong>此時，如果你用的是 <code>VSCode</code> 和 <code>rust-analyzer</code> 外掛，該外掛會自動拉取該庫，你可能需要等它完成後，再進行下一步（VSCode 左下角有提示）</strong></li>
</ol>
<p>好了，此時，<code>rand</code> 包已經被我們新增到依賴中，下一步就是在程式碼中使用：</p>
<pre><pre class="playground"><code class="language-rust">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
</code></pre></pre>
<p>這裡使用 <code>use</code> 引入了第三方包 <code>rand</code> 中的 <code>Rng</code> 特徵，因為我們需要呼叫的 <code>gen_range</code> 方法定義在該特徵中；</p>
<blockquote>
<p><strong>crates.io，lib.rs</strong></p>
<p>Rust 社區已經為我們貢獻了大量高品質的第三方包，你可以在 <code>crates.io</code> 或者 <code>lib.rs</code> 中檢索和使用；</p>
<p>從目前來說尋找包更推薦 <code>lib.rs</code>，搜尋功能更強大，內容展示也更加合理，但是下載依賴包還是得用<code>crates.io</code>；</p>
</blockquote>
<h2 id="使用--簡化引入方式"><a class="header" href="#使用--簡化引入方式"><strong>使用 <code>{}</code> 簡化引入方式</strong></a></h2>
<p>對於以下一行一行的引入方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::collections::BTreeMap;
use std::collections::HashSet;

use std::cmp::Ordering;
use std::io;
<span class="boring">}
</span></code></pre></pre>
<p>可以使用 <code>{}</code> 來一起引入進來，在大型項目中，使用這種方式來引入，可以減少大量 <code>use</code> 的使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap,BTreeMap,HashSet};
use std::{cmp::Ordering, io};
<span class="boring">}
</span></code></pre></pre>
<p>對於下面的同時引入模組和模組中的項：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<p>可以使用 <code>{}</code> 的方式進行簡化:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>self</strong></p>
<p>上面使用到了模組章節提到的 <code>self</code> 關鍵字，用來替代模組自身，結合上一節中的 <code>self</code>，可以得出它在模組中的兩個用途：</p>
<ul>
<li><strong><code>use self::xxx</code>，表示載入當前模組中的 <code>xxx</code>。此時 <code>self</code> 可省略</strong></li>
<li><strong><code>use xxx::{self, yyy}</code>，表示，載入當前路徑下模組 <code>xxx</code> 本身，以及模組 <code>xxx</code> 下的 <code>yyy</code></strong></li>
</ul>
</blockquote>
<h2 id="使用--引入模組下的所有項"><a class="header" href="#使用--引入模組下的所有項"><strong>使用 <code>\*</code> 引入模組下的所有項</strong></a></h2>
<p>對於之前一行一行引入 <code>std::collections</code> 的方式，我們還可以使用</p>
<pre><code>use std::collections::*;
</code></pre>
<p>以上這種方式來引入 <code>std::collections</code> 模組下的所有公共項，這些公共項自然包含了 <code>HashMap</code>，<code>HashSet</code> 等想手動引入的集合類型；</p>
<p>當<strong>使用 <code>\*</code> 來引入的時候要格外小心，因為你很難知道到底哪些被引入到了當前範疇中，有哪些會和你自己程序中的名稱相衝突：</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::*;

struct HashMap;
fn main() {
   let mut v =  HashMap::new();
   v.insert(&quot;a&quot;, 1);
}
</code></pre></pre>
<p>以上程式碼中，<code>std::collection::HashMap</code> 被 <code>*</code> 引入到當前範疇，但是由於存在另一個同名的結構體，因此 <code>HashMap::new</code> 根本不存在，因為對於編譯器來說，<strong>本地同名類型的優先順序更高；</strong></p>
<p>在實際項目中，<strong>這種引用方式往往用於快速寫測試程式碼，它可以把所有東西一次性引入到 <code>tests</code> 模組中；</strong></p>
<h2 id="其他引入模組的方式"><a class="header" href="#其他引入模組的方式"><strong>其他引入模組的方式</strong></a></h2>
<p>通過 <code>#[path =&quot;你的路徑&quot;]</code> 可以放在任何目錄都行，如：</p>
<pre><code>#[path =&quot;你的路徑&quot;]
mod core;
</code></pre>
<p>可以無視 <code>mod.rs</code> 或者目錄方式：</p>
<p><a href="https://user-images.githubusercontent.com/100085326/164968138-0efae930-8bc0-4c8b-b4e8-163e6c566d5a.png"><img src="rust/images/164968138-0efae930-8bc0-4c8b-b4e8-163e6c566d5a.png" alt="image" /></a></p>
<p>當然，也可以在目錄下建立 <code>mod.rs</code> 檔案，但是需要一層一層的 <code>pub mod</code> 匯出，或者採用 <code>2018</code> 版本的模組目錄和模組.rs 同名方式（<strong>官方推薦</strong>)，總之，<code>#[path]</code> 方式最靈活（慎用）；</p>
<p>三種方式對比：</p>
<p><code>Rust</code> 模組引用三種方式：</p>
<table><thead><tr><th style="text-align: left">Rust 2015</th><th style="text-align: left">Rust 2018</th><th style="text-align: left">#[path = “路徑”]</th></tr></thead><tbody>
<tr><td style="text-align: left">. ├── lib.rs └── foo/ ├── mod.rs └── bar.rs</td><td style="text-align: left">. ├── lib.rs ├── foo.rs └── foo/ └── bar.rs</td><td style="text-align: left">. ├── lib.rs └── pkg/ // 任意目錄名 ├── foo.rs // #[path = “./pkg/foo.rs”] └── bar.rs // #[path = “./pkg/bar.rs”]</td></tr>
</tbody></table>
<h2 id="受限的可見性"><a class="header" href="#受限的可見性"><strong>受限的可見性</strong></a></h2>
<p>在上一節中，我們學習了<a href="https://course.rs/basic/crate-module/module.html#%E4%BB%A3%E7%A2%BC%E5%8F%AF%E8%A6%8B%E6%80%A7">可見性</a>這個概念，這也是模組體系中最為核心的概念，控制了模組中哪些內容可以被外部看見，但是在實際使用時，光被外面看到還不行，我們還想控制哪些人能看，這就是 Rust 提供的受限可見性；</p>
<p>例如，<strong>在 Rust 中，包是一個模組樹，我們可以通過 <code>pub(crate) item;</code> 這種方式來實現：<code>item</code> 雖然是對外可見的，但是隻在當前包內可見，外部包無法引用到該 <code>item</code>；</strong></p>
<p>所以，如果我們想要<strong>讓某一項可以在整個包中都可以被使用，那麼有兩種辦法：</strong></p>
<ul>
<li><strong>在crate root中定義一個非 <code>pub</code> 類型的 <code>X</code>(父模組的項對子模組都是可見的，因此包根中的項對模組樹上的所有模組都可見)；</strong></li>
<li><strong>在子模組中定義一個 <code>pub</code> 類型的 <code>Y</code>，同時通過 <code>use</code> 將其引入到包根；</strong></li>
</ul>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    pub mod b {
        pub fn c() {          
            println!(&quot;{:?}&quot;,crate::X);
        }

      // 在子模組中定義一個 `pub` 類型的 `Y`，同時通過 `use` 將其引入到包根
        #[derive(Debug)]
        pub struct Y;
    }
}

// 在crate root中定義一個非 `pub` 類型的 `X`(父模組的項對子模組都是可見的，因此包根中的項對模組樹上的所有模組都可見)
#[derive(Debug)]
struct X;
use a::b::Y;
fn d() {
    println!(&quot;{:?}&quot;,Y);
}
<span class="boring">}
</span></code></pre></pre>
<p>以上程式碼充分說明瞭之前兩種辦法的使用方式，但是有時我們會遇到這兩種方法都不太好用的時候；</p>
<p>例如希望對於某些特定的模組可見，但是對於其他模組又不可見：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 目標：`a` 匯出 `I`、`bar` and `foo`，其他的不匯出
pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -&gt; i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -&gt; i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -&gt; i32 {
        semisecret(I) + y
    }

    mod b {
        mod c {
            const J: i32 = 4;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>這段程式碼會報錯，因為與父模組中的項對子模組可見相反，子模組中的項對父模組是不可見的；</p>
<p>這裡 <code>semisecret</code> 方法中，<code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> 形成了父子模組鏈，那 <code>c</code> 中的 <code>J</code> 自然對 <code>a</code> 模組不可見；</p>
<p>如果使用之前的可見性方式，那麼想保持 <code>J</code> 私有，同時讓 <code>a</code> 繼續使用 <code>semisecret</code> 函數的辦法是：將該函數移動到 <code>c</code> 模組中，然後用 <code>pub use</code> 將 <code>semisecret</code> 函數進行再匯出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod a {
    pub const I: i32 = 3;

    use self::b::semisecret;

    pub fn bar(z: i32) -&gt; i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -&gt; i32 {
        semisecret(I) + y
    }

    mod b {
        pub use self::c::semisecret;
        mod c {
            const J: i32 = 4;
            pub fn semisecret(x: i32) -&gt; i32 {
                x + J
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>這段程式碼說實話問題不大，但是有些破壞了我們之前的邏輯；</p>
<p>如果想保持程式碼邏輯，同時又只讓 <code>J</code> 在 <code>a</code> 內可見該怎麼辦？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -&gt; i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -&gt; i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -&gt; i32 {
        semisecret(I) + y
    }

    mod b {
        pub(in crate::a) mod c {
            pub(in crate::a) const J: i32 = 4;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通過 <code>pub(in crate::a)</code> 的方式，我們指定了模組 <code>c</code> 和常數 <code>J</code> 的可見範圍都只是 <code>a</code> 模組中，<code>a</code> 之外的模組是完全訪問不到它們的！</p>
<h4 id="限制可見性語法"><a class="header" href="#限制可見性語法"><strong>限制可見性語法</strong></a></h4>
<p><code>pub(crate)</code> 或 <code>pub(in crate::a)</code> 就是限制可見性語法，前者是限制在整個包內可見，後者是通過絕對路徑，<strong>限制在包內的某個模組內可見</strong>，總結一下：</p>
<ul>
<li><strong><code>pub</code> 意味著可見性無任何限制；</strong></li>
<li><strong><code>pub(crate)</code> 表示在當前包可見；</strong></li>
<li><strong><code>pub(self)</code> 在當前模組可見；</strong></li>
<li><strong><code>pub(super)</code> 在父模組可見；</strong></li>
<li><strong><code>pub(in &lt;path&gt;)</code> 表示在某個路徑代表的模組中可見，其中 <code>path</code> 必須是父模組或者祖先模組；</strong></li>
</ul>
<h2 id="一個單檔案多模組的使用案例"><a class="header" href="#一個單檔案多模組的使用案例"><strong>一個單檔案多模組的使用案例</strong></a></h2>
<p>下面是一個模組的綜合例子：</p>
<p>my_mod/src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">// 一個名為 `my_mod` 的模組
mod my_mod {
    // 模組中的項默認具有私有的可見性
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // 使用 `pub` 修飾語來改變默認可見性。
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // 在同一模組中，項可以訪問其它項，即使它是私有的。
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // 模組也可以巢狀
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // 使用 `pub(in path)` 語法定義的函數隻在給定的路徑中可見。
        // `path` 必須是父模組（parent module）或祖先模組（ancestor module）
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;);
            public_function_in_nested()
        }

        // 使用 `pub(self)` 語法定義的函數則只在當前模組中可見。
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested&quot;);
        }

        // 使用 `pub(super)` 語法定義的函數隻在父模組中可見。
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // `pub(crate)` 使得函數隻在當前包中可見
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // 巢狀模組的可見性遵循相同的規則
    mod private_nested {
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn main() {
        // 模組機制消除了相同名字的項之間的歧義。
        function();
        my_mod::function();

        // 公有項，包括巢狀模組內的，都可以在父模組外部訪問。
        my_mod::indirect_access();
        my_mod::nested::function();
        my_mod::call_public_function_in_my_mod();

        // pub(crate) 項可以在同一個 crate 中的任何地方訪問
        my_mod::public_function_in_crate();

        // pub(in path) 項只能在指定的模組中訪問
        // 報錯！函數 `public_function_in_my_mod` 是私有的
        //my_mod::nested::public_function_in_my_mod();

        // 模組的私有項不能直接訪問，即便它是巢狀在公有模組內部的

        // 報錯！`private_function` 是私有的
        //my_mod::private_function();

        // 報錯！`private_function` 是私有的
        //my_mod::nested::private_function();

        // 報錯！ `private_nested` 是私有的
        //my_mod::private_nested::function();
    }
}
</code></pre></pre>
<blockquote>
<p><strong>上面的內容90%以上整理自：</strong></p>
<ul>
<li>https://course.rs/basic/crate-module/intro.html</li>
</ul>
<p><strong>一本神一樣的 Rust 語言聖經！</strong></p>
</blockquote>
<h2 id="多個目錄間模組引用"><a class="header" href="#多個目錄間模組引用"><strong>多個目錄間模組引用</strong></a></h2>
<p>前面給出的例子大多都是在單個模組中引用；</p>
<p>本小節來看一看在不同目錄之間的引用；</p>
<p>看一下目錄結構：</p>
<pre><code>$ tree .                      
.
├── Cargo.lock
├── Cargo.toml
└── src
    ├── main.rs
    └── user_info
        ├── mod.rs
        └── user.rs

3 directories, 9 files
</code></pre>
<p><strong><code>rust</code>約定在目錄下使用<code>mod.rs</code>將模組匯出；</strong></p>
<p>看一下user.rs的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct User {
    name: String,
    age: i32
}

impl User {
    pub fn new_user(name: String, age: i32) -&gt; User {
        User{
            name,
            age
        }
    }
    pub fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}

pub fn add(x: i32, y: i32) -&gt; i32 {
    x + y 
}
<span class="boring">}
</span></code></pre></pre>
<p>然後在<code>mod.rs</code>裡匯出：</p>
<pre><code>pub mod user;
</code></pre>
<p>在<code>main.rs</code>呼叫：</p>
<pre><pre class="playground"><code class="language-rust">mod user_info;
use user_info::user::User;

fn main() {
    let u1 = User::new_user(String::from(&quot;tom&quot;), 5);
    println!(&quot;user name: {}&quot;, u1.name());
    println!(&quot;1+2: {}&quot;, user_info::user::add(1, 2));
}
</code></pre></pre>
<h2 id="多個cargo之間進行引用"><a class="header" href="#多個cargo之間進行引用"><strong>多個Cargo之間進行引用</strong></a></h2>
<p>最後，再來看看多個 Cargo 項目之間的引用；</p>
<p>首先分別建立一個可執行項目和一個庫項目：</p>
<pre><code>cargo new multi-crate
cargo new utils --lib
</code></pre>
<p>在utils庫中，已經生成了程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在我們的二進制庫的<code>Cargo.toml</code>引入該庫：</p>
<pre><code>[dependencies]
utils = { path = &quot;../utils&quot;, version = &quot;0.1.0&quot; }
</code></pre>
<p><code>path</code>就是庫項目的路徑；</p>
<p><code>main.rs</code>使用<code>use</code>引入就可以使用了：</p>
<pre><pre class="playground"><code class="language-rust">use utils::add;

fn main() {
    let x = add(1, 2);
    println!(&quot;utils::add(1, 2): {}&quot;, x);
}
</code></pre></pre>
<h1 id="附錄"><a class="header" href="#附錄"><strong>附錄</strong></a></h1>
<p>原始碼：</p>
<ul>
<li>https://github.com/JasonkayZK/rust-learn/tree/project-structure</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-與記憶體"><a class="header" href="#rust-與記憶體">Rust 與記憶體</a></h1>
<p>本文譯自 <a href="https://medium.com/@orbitalK/why-the-machine-b9803a77fa29">Rust &amp;TheMachine</a> by Prolific K</p>
<h1 id="譯者前言"><a class="header" href="#譯者前言">譯者前言</a></h1>
<p>對於 Rust 初學、尤其是之前慣用記憶體回收器語言（例如 Go、Python、Java）的開發者來說，Rust 提出的各種智慧指標種類繁多，各有其使用情境與限制，光是最單純的借用機制就常在生命週期限制下卡成一團，初學時面臨的各種編譯錯誤不免令人萌生退意。本文作者試圖從底層運作原理上解釋，並提出一些使用指標與架構上的原則；就算偷懶硬背其結論而不去深入理解，仍能維持一定的開發流暢性。</p>
<p>本文不免用到部份 C/C++ 用語，雖非理解本文所必要，仍鼓勵非 C/C++ 背景的開發者們在讀後試著瞭解一下那些概念。許多譯文用語儘量貼近本國用語，然而部份用字可能保留原文，以利讀者自行找尋第一手原文參考資料：</p>
<ul>
<li>計算機科學中的 stack 和 heap 與其相關操作方法 pop &amp; push</li>
<li>Rust 語法定義的關鍵名詞，例如 trait</li>
</ul>
<h1 id="作者前言"><a class="header" href="#作者前言">作者前言</a></h1>
<p>本文主要是寫給正在入門 Rust、已理解基本的語法、卻正與編譯器纏鬥的開發者。我們將從底層的機器運作模型為出發點進行討論，如此更<strong>有助於讓人脫離對執行期垃圾回收機制的倚賴</strong>。我相信這樣的解釋方式比毫無頭緒地逐條解釋編譯資訊更有效率。</p>
<p>**Rust 的記憶體管理機制相當巧妙，語意表現上很容易讓人忽略自己正在做什麼。這種設計導致編譯器錯誤報告相當不直覺。**如果你對於計算機組織有基本的認識，知道函式的執行與記憶體互動原理，或是樂於學習這方面的知識，這篇文章將有效助你理解並流暢地使用 Rust。</p>
<h1 id="一些心理準備"><a class="header" href="#一些心理準備">一些心理準備</a></h1>
<p>如果你想縱觀 Rust 全貌，你<strong>一定</strong>得把以下幾個要點牢記在腦海中：</p>
<ul>
<li>從組合語言層級理解函式呼叫的運作原理。至少請記得<a href="https://youtu.be/d-2Peb3pCBg">什麼是 call stack</a>、<a href="https://courses.cs.washington.edu/courses/cse351/13sp/lecture-slides/09-procedures-I.pdf">指標與 stack 之間的關係</a>、以及 stack 在記憶體中的運作方式。如果你需要復習一下，YouTube 上可以找到一些關於計算機組織的教學影片。</li>
<li>Heap 是一堆片段的記憶體區塊，而 stack 是有序、線性、且總是隻從一端變化的記憶體空間。Heap 上可能產生不連續的遺棄資料。</li>
<li>多執行緒的情境，縱使每個執行緒各有各的 stack，但仍共用同一個 heap。</li>
<li>程式指令與靜態資料在程式開始時便一直存在，且不會被移動，因此我們總是能引用這些靜態資料。</li>
</ul>
<h1 id="妥善管理-stack-上的資料"><a class="header" href="#妥善管理-stack-上的資料">妥善管理 Stack 上的資料</a></h1>
<p>「擁有權」這種抽象概念體現於許多行為上，例如記憶體空間管理和指標操作。編譯器檢驗擁有權的同時，也保證我們永遠不會創造出無效的指標、或忘記回收記憶體空間。記憶體空間管理與擁有權之間的關係很直覺，如果我們不使用指標，RAII 資源回收機制會幫我們善後；編譯器鮮少在這種使用情境抱怨什麼。</p>
<p>然而，有時為了實作某些精巧的演算法，或為了避免在呼叫函式時一再複製資料，而希望在程式多處存取同一記憶體位址。我們確實需要指標。每當指標指涉的位址未隨著資料移動或銷毀，無效指標因而誕生。在 Rust 中，除了移動語意以外<strong>所有的擁有權合法性則規設計都為防止在 stack 中指涉無效資料。</strong></p>
<p>接下來的內容，首先，我們會先來看看所有權與借用概念如何用在 stack 的運作上。接著，釐清所有在 heap 上放的資料資料所屬的 stack，我們得以將這些資料的生命週期與所有權反映在 stack 上。這些映射關係使我們得以清楚地確定資料銷毀的時間點，同時確保不會持有無效指標。</p>
<h2 id="從正確的-stack-pop-順序開始"><a class="header" href="#從正確的-stack-pop-順序開始">從正確的 Stack Pop 順序開始</a></h2>
<p><em>注意：包括 x86 在內的架構設計上，stack 是從高位址往低位址成長，與電腦科學討論用的慣例有微妙的不同；因此在本文中，我們使用「上游（upstream）」與「下游（downstream）」這兩個字眼：<strong>呼叫函式進入「下游」，而後向「上游」傳回結果</strong>，回到本來發動呼叫的地方。</em></p>
<p>借用都是往下游遞送，以指向上游的資料。<code>&amp;T</code> 總是指向上游 stack 內的資料 <code>T</code>，並總是比其指涉本體還要早被 pop 出去。</p>
<ul>
<li>最單純常見的情境，<code>&amp;T</code> 出現於下游，且指向上游的 <code>T</code></li>
<li>將擁有權整合進資料結構時也適用上述情境。當 <code>&amp;T</code> 指向一個結構內的成員 <code>T</code>，其後又將 <code>&amp;T</code> 塞進其它結構體，則任何擁有 <code>&amp;T</code> 的東西應往下游傳遞，並指回上游的 <code>T</code>。</li>
<li>如此這般，<code>T</code> 總是在所有的 <code>&amp;T</code> 都消失之後才被 pop 出 stack。</li>
<li>複雜結構的使用情境常常很難讓編譯器相信上述原則沒有被打破，單純情境則總是易於操作</li>
</ul>
<h2 id="在-pop-間保證因果關係"><a class="header" href="#在-pop-間保證因果關係">在 pop 間保證因果關係</a></h2>
<p>編譯器不容許在產生資料之後向其上游傳遞借用。這條規則有很多誤觸方式，包括試圖傳回一個區域資料的借用、在原資料生命週期不夠長的情況下把其借用塞進另一個資料結構、或是在現有出借行為未結束前試圖移動原資料。</p>
<p>以下是參數與傳回值傳遞時對於不同種資料擁有權的規則：</p>
<ul>
<li><code>&amp;T</code>（借用）可以向下作為函式傳入參數，其內容指涉上層資料。</li>
<li><code>T</code>（擁有）可向下作為函式傳入參數。它可作為傳回值再度移回上層，或是隨著 stack 一同被回收。</li>
<li>在所在函式內產生的資料 <code>T</code> 可以被移往上層（離開當前 stack）或與該層 stack 共存亡。</li>
<li>若 <code>&amp;T</code> 指涉的對象是所在函式內擁有的資料，則此借用不可作為傳回值送進上層。只有資料所有權本身可以往上傳回，因為該資料本身會隨著函式結束而消失，進而使得 <code>&amp;T</code> 指向不合法的位址。</li>
<li>如果該 <code>&amp;T</code> 本已作為參數被傳入，那麼同樣也能傳回上層。</li>
</ul>
<p>資料間的相對關係會在函式呼叫間保留，這些關係因此可在不同 stack 之間跨層傳遞。一般而言，資料都會往上游（過去）指涉，而向下遊（未來）傳送或夾帶。你也可以把這些規則歸納成兩條：</p>
<ul>
<li>傳入借用或所有權</li>
<li>傳回所有權，或是指向仍存在的上游資料的借用</li>
</ul>
<p>好，現在你開始有個底。我們現在知道 stack 上資料的正確清除順序，也為此訂下一些規則以確保不會發生意外。現在讓我們來看看 heap。</p>
<h2 id="利用-box-把擁有權放在-heap-上"><a class="header" href="#利用-box-把擁有權放在-heap-上">利用 Box 把擁有權放在 Heap 上</a></h2>
<p><code>Box&lt;T&gt;</code> 是一種擁有權指標，其內部有一個指標，指向一塊放在 heap 上的資料。<code>Box&lt;T&gt;</code> 是一個放在 stack 上的 <code>Box</code> 與放在 heap 上的 <code>T</code> 的合成物。它實際上就是在 heap 上的一塊你擁有的資料。你可以傳遞它、移動它、改變它所指涉的目標，也可以將之作為傳回值。當它被銷毀時，它所對應在 heap 上的空間、資料內擁有的其它資料也會同時被回收。<code>Box</code> 的借用（<code>&amp;Box</code>）同前節所述可以被向下傳遞、而只能在不超過 <code>Box</code> 壽命範圍內向上傳遞。</p>
<p>你可以籍由呼叫 <code>Box::new(myT)</code> 以把 <code>T</code> 移上 heap。在呼叫之前，資料都還位於 stack 上，而在呼叫後搬上 heap。<code>Arc::new(myT)</code> 是另一種把資料搬上 heap 的容器，一樣是在產生容器的過程把資料搬上去。<code>Vec::with_capacity(usize)</code> 是一種可變大小的 heap 空間，你隨時可以籍由 push 把資料放上去；<code>Vec</code> 的所有權在你手上，而其內資料被 <code>Vec</code> 擁有。</p>
<ul>
<li>Stack 擁有 heap</li>
<li>當 stack 失去其所擁有的 heap → heap 上的資料隨之銷毀</li>
</ul>
<p>受到 <code>Box</code> 掌握的 heap 會一直存活到 <code>Box</code> 壽命結束。<strong>一般而言，heap 上的空間當視為 stack 的衍伸空間，而 stack 本身的生命週期相當簡單直覺。</strong></p>
<p>即便你弄出像是 <code>Box&lt;…Box&lt;Box&lt;T&gt;&gt;…&gt;</code> 的東西，把一堆指標一起扔上 heap，這些東西依然受到最外層的容器 <code>Box</code> 所掌握，最外層容器仍位於 stack 上，結繫在函式的能見範圍裡，終將隨著函式的結束而一個一個跟著被回收。另一方面，就算籍由 <code>Box::new(&amp;myT)</code> 把借用扔上 heap，你仍無法只留下資料所有權的同時把這個包裝用的 <code>Box</code> 當作傳回值。把借用放上 heap 並不會把讓 <code>&amp;T</code> 憑空變出可傳遞性。</p>
<p>這些抽象概念讓我們幾乎不需要手動處理記憶體區塊的配置與釋放。你仍可以利用 <code>std::mem</code> 來配置記憶體，但這並非常見手法。</p>
<h2 id="引用計數的生命週期"><a class="header" href="#引用計數的生命週期">引用計數的生命週期</a></h2>
<p>我們必須來特別探討一下 <code>Rc</code> 和 <code>Arc</code>（<em>Atomic reference counter</em>，原子化引用計數）在 heap 與 stack 的使用情境。我們無法確定某些資料需要存在多久，因此將之放上 heap 並以引用計數來管理。<code>Arc</code> 是原子化計數，因此可跨執行緒使用；<code>Rc</code> 則是一般性把資料放上 heap 的版本。這些引用計數容器像是放在 stack 上的遙控器，可以任意傳遞傳回，而且<strong>可以多次複製</strong>，只有在最後一個備份被銷毀時才會動手清除其內指涉的資料。這種容器本身並不提供其內資料的可變性，但你可以把可變資料包裝後塞在裡面。</p>
<h2 id="借用的生命週期--不可移動的區間"><a class="header" href="#借用的生命週期--不可移動的區間">借用的生命週期 = 不可移動的區間</a></h2>
<p>當資料已出借的期間內，其本體便不可被移動。當一個借用指向被移動過的資料，實際上就是一個懸置指標。<code>Rc</code> 和 <code>Arc</code> 便是可行的替代方案，可以任意地被複製（copy / clone）其所指涉內容，或是傳遞引用計數本身。另一個選項則是一開始就把所有權設計在上游，如此一來下游都只是在移動借用。</p>
<h2 id="將多個所有權結合在一起就會產生生命週期註記"><a class="header" href="#將多個所有權結合在一起就會產生生命週期註記">將多個所有權結合在一起，就會產生生命週期註記</a></h2>
<p>每當你創造東西，它就會有生命週期；但如果它引用指涉了另一個不同生命週期的東西，你就開始需要生命週期註記（lifetime annotation）。這些註記與所有權息息相關。編譯器會檢查這些註記與所有權關係是否與實際所需生命週期一致。</p>
<p>最直接的例子，你試著設計一種資料結構，而這種結構有個成員借用了另一些資料，編譯器會馬上開始問生命週期相關細節。如果你有兩個引用，編譯器會試圖釐清這兩個引用對象的生命週期究竟是否相同。生命週期註記的存在就是為了計算這些資訊。</p>
<h1 id="函式呼叫需要事先確定所需空間"><a class="header" href="#函式呼叫需要事先確定所需空間">函式呼叫需要事先確定所需空間</a></h1>
<p>當編譯器發出 unsized types 警告時，是在告訴我們它需要這些容量資訊來規劃 stack 上的記憶體分配方式。編譯器可以處理任意數量的函式呼叫或記憶體對齊等細節，<strong>但若無法確定資料型態所佔容量，則編譯器將不知如何將它塞進 stack</strong>。</p>
<ul>
<li>需要把未知容量資料作為傳入參數？請用 <code>&amp;</code> 或 <code>Box</code> 或其它已知容量的容器包裝它</li>
<li>需要把未知容量資料作為傳回值？我們無法將區域變數的引用（<code>&amp;</code>）傳出它的存在範圍，請改用 <code>Box</code> 包裝它</li>
<li>借用（&amp;）只是一種指標，而指標的大小是固定的：<code>fn (foo: &amp; dyn Trait) { .. }</code></li>
<li>陣列大小要在執行期才能決定？或是大小有變動的可能性？你需要 heap，意即需要一個 <code>Box</code></li>
<li>數值實際型別可能有好幾種？或是需要把不同型別的東西放在同一個容器內？<code>Vec&lt;Box&lt;dyn Trait&gt;&gt;</code> 可以幫你盛裝各種不同但皆實作某一 <code>Trait</code> 的資料，而 <code>foo (t: &amp; dyn Trait)</code> 這樣的函式允許傳入各種已實作特定 <code>Trait</code> 的資料</li>
<li>記住：像是 <code>Vec::push</code> 等等各種容器操作都須先決定傳入值的容量資訊</li>
</ul>
<p>編譯器可能為了各種不能確定資料大小的狀況而抱怨。<code>Box</code> 本身的大小是確定的，且是一種資料擁有者。每當無法在編譯期確定資料大小時，請善用 <code>Box</code> 把那些資料放上 heap。</p>
<h2 id="struct-也需要佔用空間"><a class="header" href="#struct-也需要佔用空間">Struct 也需要佔用空間</a></h2>
<p>函式的傳入與傳回值都是由你設計的，你可以推算得出容量資訊。對於那些特殊容量的資料型態（譯註：例如 <code>&amp;[T; length]</code>），其容量標註在最後的欄位裡面。</p>
<h2 id="引入物件導向設計"><a class="header" href="#引入物件導向設計">引入物件導向設計</a></h2>
<p>從前在寫有垃圾回收機制的語言，你可以把一堆相關的資料與處理邏輯通通塞進一個 class，隔絕內外部狀態變換邏輯，並享受分割 API 帶來的好處。然而在 Rust 的世界裡，所有權借用的概念迫使我們必須連帶考量資料大小與存在時間相關要素。C 和 C++ 的開發者們過去利用指標來處理這類事務。</p>
<blockquote>
<p>我可以定義 <code>struct</code>。這些 <code>struct</code> 各有其對應的成員方法，讓我處理各式 <code>&amp;self</code>、<code>self</code> 和 <code>Self</code>，且在此還有些叫作 trait object 的玩意。雖說沒有繼承機制，但我可以用這些語言特性實作物件導向設計嗎？</p>
</blockquote>
<p>可以，但也不能完全自由發揮。<strong>千萬不要在可解藕生命週期的情況下把不相關的資料包裝在一起</strong>。如果一個借用目標的生命週期與你的 struct 不同，你便不得不開始面對那些炫炮難搞的生命週期註記。請儘量從那些較為迷你單純的 struct 開始設計，並把其對應的成員方法介面單純化，以利未來使用在不同的地方。</p>
<h2 id="千萬不要從建構式裡面借用資料"><a class="header" href="#千萬不要從建構式裡面借用資料">千萬不要從建構式裡面借用資料</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DontBorrowFromConstructorScopeValues::new()
<span class="boring">}
</span></code></pre></pre>
<p><strong>建構式也只是一種函式</strong>。在不得不撰寫複雜的建構式時，記住 <code>T</code> 和 <code>&amp;T</code> 的傳遞原則。<strong>千萬別從區域變數產生資料之後又將它的借用塞進另一個 struct</strong>。你的資料結構必須直接擁有那些資料，或是借用自上游。</p>
<p>一般來說，你可以不要<strong>在建構式裡面借用自身成員</strong>；千萬別這樣搞自己，你將無法輕易移動這種資料結構的擁有權，除非用上某些奇技淫巧。如果資料成員以這種方式借用，其生命週期會對不起來。你只能把結構性資料向下遊借出，進入結構內部，傳回已借用的部份資料借用，或是再向下游傳遞借用。</p>
<h2 id="我真的需要多態polymorphism嗎"><a class="header" href="#我真的需要多態polymorphism嗎">我真的需要多態（polymorphism）嗎？</a></h2>
<p>如果你需要在一段程式裡面輪替使用一些不同型別實作的同一種方法，且這種方法屬於特定的 trait（trait 可以說是在 Rust 裡面最接近 interface 語意的介面宣告），則這是使用 trait object 的好機會。當你利用 <code>dyn</code> 關鍵字將變數綁定特定的 trait 而非型別，trait object 隨之產生。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn polycaller(thing: Box&lt;dyn Trait&gt;) {
thing.trait_method()
}
<span class="boring">}
</span></code></pre></pre>
<p>以上這種函式呼叫便是一種多態的表現，實際上的行為是利用 vtable（virtual table， 虛擬函式表）在執行期決定其行為。舉例來說，<code>Vec&lt;Box&lt;dyn Trait&gt;&gt;</code> 可以用以儲存一連串實作同一 trait 的各種物件。Trait object 幫助我們統一並限制這些物件的行為。</p>
<p>一個常令入門者意外的點是，由於這種執行期的型別不確定性，因此必須籍由借用、或包裝後放上 heap 才能作為參數傳遞；畢竟編譯器在安排函式呼叫行為前必須先確定 stack 容量需求，像這種必須執期行動態查找 vtable 才能決定實際呼叫對象的運作機制是無法直接編譯的。</p>
<h1 id="容器的選用幾乎可以視為語言層面的文法問題"><a class="header" href="#容器的選用幾乎可以視為語言層面的文法問題">容器的選用幾乎可以視為語言層面的文法問題</a></h1>
<p>你在使用變數時需要考量的點在於，資料應存在哪種空間裡、如何避免資料競爭、是否需要再次覆寫、需要多長的生命週期。變數借用只是一種文法表現，不產生額外成本，卻保留了執行期顯式或隱式函式呼叫的彈性。C 語言中等同於 <code>Box</code> 的寫法基本上就只是個指標，而 Rust 中 <code>Box::new(myT)</code> 語意上卻也包括了 <code>malloc</code>。這就是為何當初設計語言時僅將這些機制設計成容器型別，而不直接嵌進文法。</p>
<h2 id="tldr-以下這幾種常見容器的使用時機"><a class="header" href="#tldr-以下這幾種常見容器的使用時機">TL;DR 以下這幾種常見容器的使用時機：</a></h2>
<h3 id="single-thread-單一執行緒"><a class="header" href="#single-thread-單一執行緒">Single Thread 單一執行緒</a></h3>
<ul>
<li>可能有多個所有權持有者、且資料放在 heap 上：<code>Rc&lt;T&gt;</code></li>
<li>不可變引用、但未來可能需要所指涉對象的內容可變性：<code>Cell&lt;T&gt;</code></li>
<li>需要對不可複製（copy）對象保有內部可變性、或是該對象內部亦有保有內部可變性需求：<code>&amp;mut self RefCell&lt;T&gt;</code></li>
</ul>
<h3 id="multi-threaded-跨執行緒"><a class="header" href="#multi-threaded-跨執行緒">Multi-Threaded 跨執行緒</a></h3>
<ul>
<li>可能有多個所有權持有者、且資料放在 heap 上：<code>Arc&lt;T&gt;</code></li>
<li>不但多持有者、且讀寫行為具有排它性：<code>Arc&lt;Mutex&lt;T&gt;&gt;</code></li>
<li>不但多持有者、寫入行為具排它性、但允許共時讀取：<code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
</ul>
<p>筆者認為除了《<a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>》以外，<a href="https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">這是將容器使用方法解釋得最好的一篇文章</a>。</p>
<h1 id="rust-的世界中多執行緒環境下的情境更為單純"><a class="header" href="#rust-的世界中多執行緒環境下的情境更為單純">Rust 的世界中，多執行緒環境下的情境更為單純</a></h1>
<p>由於可以移入、甚至在不同執行緒間傳遞的資料種類相當有限，你可以用在跨執行緒的邊界處理手段反而比前述 stack 與 heap 更為單純。<strong>此其中唯一的難點在於，如何將本來用在單一執行緒內部的資料組合，運用在多執行緒情境。</strong></p>
<h2 id="執行緒彼此不分享-stack"><a class="header" href="#執行緒彼此不分享-stack">執行緒彼此不分享 stack</a></h2>
<p>執行緒彼此無法預測其它執行緒上資料的生命週期，因此把指標指向其它執行緒 stack 內的資料是不安全的。想在這樣的情境下共享資料，勢必得讓資料以某種形式存在於 heap 上。</p>
<p>你用 clone 產生並操作那些放在 stack 裡的 <code>Arc</code>，實際資料與引用計數則理所當然位於 heap 裡。這樣的操作介面使得各執行緒得以各自處理資料生命週期。</p>
<p>而所有需要跨執行緒共用的指標，其所指目標也都必須放在 heap 上，不可在 stack 裡。</p>
<h2 id="遞送並非共享"><a class="header" href="#遞送並非共享">遞送並非共享</a></h2>
<ul>
<li><code>Sync</code> 是可用來跨執行緒分享的 trait</li>
<li><code>Send</code> 則是用來跨執行緒移動的 trait</li>
</ul>
<p>所謂的 send 行為，大致是先將資料擁有權移進一個緩衝區，而後交給另一個執行緒，從緩衝區再度移進該執行緒的 stack。遞送一個 <code>Box</code> 並非罕見行為。當使用一些第三方 crate 自定義的資料型別時，可用在跨執行緒的型別通常會宣告成 <code>Send + Sync</code>；但當 API 只想將這類特性用於內部實作時，也可以籍由隱藏 <code>Send</code> 或 <code>Sync</code> 以避免使用者誤用。</p>
<h2 id="確保只有一個擁有者--可移動或可復製--可以在執行緒間遞送"><a class="header" href="#確保只有一個擁有者--可移動或可復製--可以在執行緒間遞送">確保只有一個擁有者 + 可移動或可復製 ≈ 可以在執行緒間遞送</a></h2>
<p>關鍵字：send。<code>Box</code>、<code>struct</code>、<code>Cell</code> 這種單一擁有者、可移動的資料，可以被包裝並透過像是 <code>std::sync::mpsc::channel</code> 之類的介面進行傳遞。</p>
<p>具有 <code>Copy</code> 性質的資料，通常是一些我們不在乎其是否為同一個體的資料（例如 <code>777u32</code>），也總是可以被傳遞。</p>
<p>正在被借用的資料不可被移動，當然也不可被傳遞。某些特定型別不允許移動，也因此無法被傳遞。</p>
<p><code>Rc</code> 就是一種非固定擁有者的例子。你無法確定現在有多少使用者，無法將其轉換為單一擁有者的資料型別，因此無法將它傳遞到別的執行緒上。其內部的引用計數計算並不保證原子性，以致無法正確地跨執行緒追蹤資料生命週期。</p>
<h2 id="執行緒間只能在資料擁有權與可變性的分享上保證原子性"><a class="header" href="#執行緒間只能在資料擁有權與可變性的分享上保證原子性">執行緒間只能在資料擁有權與可變性的分享上保證原子性</a></h2>
<p>就算只讀不寫，你仍必須保證資料在需要的時候依舊存在。為了避免造成未定義行為，你必須防止資料競爭；而如前文所述，你不能直接使用那些把生命週期結繫在另一個 stack 上的東西，結論就是你必須用 <code>Arc</code> 這種既可複製又可傳遞的包裝，來跨 stack 存取資料。</p>
<p>那些本身即具原子性的資料型別，籍由正確安全的資料存取設計，讓我們得以在擁有權與生命週期系統的管制下安全地使用它們，並進而預防資料競爭問題。</p>
<h2 id="跨執行緒分享--在-heap-上具有原子性的東西"><a class="header" href="#跨執行緒分享--在-heap-上具有原子性的東西">跨執行緒分享 ≈ 在 heap 上具有原子性的東西</a></h2>
<p>每當你想在執行緒間分享某些資料，因為 Rust 不會放任你做出孕釀資料競爭的溫床，你遲早會發現最直覺的做法即是採用那些已設計用來保證原子性的型別，或是它們的衍伸型別，例如 <code>Arc</code>、<code>AtomicBool</code>、<code>Mutex</code> 等等。</p>
<p>最容易在 heap 上處理這類事務的就是 <code>Arc</code>。當你需要自動且正確地處理布林值時，<code>Arc&lt;AtomicBool&gt;</code> 是最佳選擇，或是用 <code>Arc</code> 包裝的其它原子性型別。<code>AtomicBool</code> 和那些定義在 <code>std::sync::atomic</code> 裡的型別們，在多執行緒情境下非常好用。</p>
<p>至此，我們只用了相當小的篇幅討論 Rust 底層視角下的跨執行緒資料分享。在這個情境中，所有的可用性與可變性都被限制包裝在原子性容器之中，而資料內容變動與生命週期的維護都發生在 heap 上。以執行緒安全為前題，最易變、最不可測的資料無疑會以最受限的 API 所管制。</p>
<h1 id="進階閱讀"><a class="header" href="#進階閱讀">進階閱讀</a></h1>
<ul>
<li><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Container cheat sheet with excellent memory layout diagrams</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04%E2%80%9301-what-is-ownership.html#the-stack-and-the-heap">Rust Book section on stack &amp; heap in relation to ownership</a></li>
<li><a href="https://speice.io/2019/02/summary.html">What are the Allocation Rules?</a></li>
<li><a href="https://speice.io/2019/02/the-whole-world.html">Global Memory Usage: The Whole World</a></li>
<li><a href="https://speice.io/2019/02/stacking-up.html">Fixed Memory: Stacking Up</a></li>
</ul>
<h1 id="作者後記為何從底層運作為出發點"><a class="header" href="#作者後記為何從底層運作為出發點">作者後記：為何從底層運作為出發點？</a></h1>
<p>《<a href="https://doc.rust-lang.org/book">The Rust book</a>》試圖用一種語言設計理論的角度解釋資料生命週期，讓你從抽象後的行為開始學習，而非出於執行機制。該著作有提到一些 heap，但對於已理解底層運作的高階語言使用者而言，這樣的解釋方式確實易使人感到無所適從。在釐清底層機器運作與高階學術性質模型之間的關聯之前，語言學習者很容易受到編譯器的震憾教育。</p>
<p>類似於底層機器運作式的心智模型對於學習有莫大幫助；雖然純抽象理論式學習遲早能讓人上手，但個人認為這種作法的學習效率不佳。機器運作相關知識不難入門，且裨益良多，系統程式開發者遲早需要學習底層運作機制，因此簡化的執行模型對於程式開發者而言有不錯的解釋效果。</p>
<p>部份抱怨提到，這篇文章掩飾了許多編譯器理論上可以達成、在語言理論上合理卻違反直覺或難以簡單解釋的部份。直接解釋運作原理可以讓人快速吸收概念，且不含任何欺瞞成份。另一方面，如果擁有權與生命週期的抽象概念比機器運作更為基礎，我們便難以檢視其概念與抽象機模型之間概念轉換的完整性。直接從完全抽象概念作為出發點也許並不那麼理想。</p>
<p>C 和 C++ 背景的開發者們對於這類艱澀且大量的底層資訊可能習以為常；但對於 Java 和 .Net 業界人士、甚至 Python 或 JavaScript 使用者而言，無論變數允不允借用、哪些東西可否用於參數或回傳值、如何跨執行緒傳遞資料，這些細節在過去常被忽略，因此在討論這類議題時我們不得重新從底層運作從頭闡述。</p>
<p>我必須承認，在這篇文章中仍有許多關於執行緒的細節未討論，且忽略 Rust 中那些標註為 <code>unsafe</code> 的部份功能。如果對於初入此領域者沒有幫助，這部份就不會被納入本文討論範圍，這也是為何我將環狀引用問題與 <code>Weak&lt;T&gt;</code> 相關章節移除的原因。</p>
<h1 id="譯者後記"><a class="header" href="#譯者後記">譯者後記</a></h1>
<p>本文旨在解釋生命週期運作概念、因應這些設計需求而生的資料型別的使用時機與禁忌。文中提到容器種類繁多，或許一時難以牢記，以下這張小抄或許有助快速複習：<a href="https://github.com/usagi/rust-memory-container-cs">Rust Memory Container Cheat-sheet</a></p>
<p><a href="https://github.com/usagi/rust-memory-container-cs"><img src="rust/images/container_cheatsheet.png" alt="Container cheatsheet" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="變量聲明和賦值"><a class="header" href="#變量聲明和賦值">變量聲明和賦值</a></h3>
<p>在Rust中，使用let關鍵字聲明變量，使用等號進行賦值。類型可以自動推斷或顯式指定。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10; // 自動推斷類型
let y: f64 = 3.14; // 顯式指定類型
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，使用類型名稱聲明變量，使用等號進行賦值。</p>
<pre><code class="language-c++">int x = 10;
double y = 3.14;

</code></pre>
<h2 id="整數運算"><a class="header" href="#整數運算">整數運算</a></h2>
<p>在Rust中，整數運算符號使用和C ++相同。但是，除法操作符號使用/而不是C ++中的整數除法符號//。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let y = 3;
let z = x + y;
let w = x * y;
let q = x / y; // 此處使用/操作符號
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，整數運算符號使用和Rust相同。</p>
<pre><code class="language-c++">int x = 10;
int y = 3;
int z = x + y;
int w = x * y;
int q = x / y;
</code></pre>
<h3 id="浮點數運算"><a class="header" href="#浮點數運算">浮點數運算</a></h3>
<p>在Rust中，浮點數運算符號使用和C ++相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3.14;
let y = 2.71;
let z = x + y;
let w = x * y;
let q = x / y;
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，浮點數運算符號使用和Rust相同。</p>
<pre><code class="language-c++">double x = 3.14;
double y = 2.71;
double z = x + y;
double w = x * y;
double q = x / y;
</code></pre>
<h3 id="布爾運算"><a class="header" href="#布爾運算">布爾運算</a></h3>
<p>在Rust中，布爾運算符號使用and（&amp;&amp;）和or（||）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true;
let y = false;
let z = x &amp;&amp; y;
let w = x || y;
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，布爾運算符號使用and（&amp;&amp;）和or（||）。</p>
<pre><code class="language-c++">bool x = true;
bool y = false;
bool z = x &amp;&amp; y;
bool w = x || y;
</code></pre>
<h3 id="條件語句"><a class="header" href="#條件語句">條件語句</a></h3>
<p>在Rust中，if / else語句可以作為表達式使用，並且必須包含在大括號內。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
if x &lt; 5 {
    println!(&quot;x is less than 5&quot;);
} else {
    println!(&quot;x is greater than or equal to 5&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，if / else語句不能作為表達式使用，並且可以省略大括號。</p>
<pre><code class="language-c++">int x = 10;
if (x &lt; 5) {
    cout &lt;&lt; &quot;x is less than 5&quot; &lt;&lt; endl;
} else {
    cout &lt;&lt; &quot;x is greater than or equal to 5&quot; &lt;&lt; endl;
}
</code></pre>
<h3 id="迴圈"><a class="header" href="#迴圈">迴圈</a></h3>
<p>迴圈 在Rust中，for循環可用於迭代集合，並且可以使用range運算符號創建集合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..5 {
    println!(&quot;{}&quot;, i);
}

let arr = [1, 2, 3, 4, 5];
for i in arr.iter() {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，for循環可用於迭代集合，並且可以使用range運算符號創建集合。</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 5; i++) {
    cout &lt;&lt; i &lt;&lt; endl;
}

int arr[] = {1, 2, 3, 4, 5};
for (int i : arr) {
    cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<h3 id="函數定義和調用"><a class="header" href="#函數定義和調用">函數定義和調用</a></h3>
<p>在Rust中，函數定義使用fn關鍵字，並且可以指定參數和返回類型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let result = add(2, 3);
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，函數定義使用函數名稱，並且可以指定參數和返回類型。</p>
<pre><code class="language-cpp">int add(int x, int y) {
    return x + y;
}

int result = add(2, 3);
</code></pre>
<h3 id="字符串處理"><a class="header" href="#字符串處理">字符串處理</a></h3>
<p>在Rust中，字符串是utf8編碼的unicode字符集，使用&amp;str類型表示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;hello&quot;;
let s2 = &quot;world&quot;;
let s3 = format!(&quot;{} {}&quot;, s1, s2);
println!(&quot;{}&quot;, s3);
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，字符串是char類型的數組，使用std :: string類型表示。</p>
<pre><code class="language-cpp">#include &lt;string&gt;

std::string s1 = &quot;hello&quot;;
std::string s2 = &quot;world&quot;;
std::string s3 = s1 + &quot; &quot; + s2;
cout &lt;&lt; s3 &lt;&lt; endl;
</code></pre>
<h3 id="指標"><a class="header" href="#指標">指標</a></h3>
<p>在Rust中，指針是具有所有權語義的智能指針，使用&amp;和*運算符號。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let p = &amp;x;
let y = *p;
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，指針是一個可以存儲變量地址的變量，使用*和&amp;運算符號。</p>
<pre><code class="language-cpp">int x = 10;
int* p = &amp;x;
int y = *p;
</code></pre>
<h3 id="類別"><a class="header" href="#類別">類別</a></h3>
<p>在Rust中，類是結構體struct和實現trait的組合，使用impl關鍵字實現方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
    age: i32,
}

impl Person {
    fn new(name: &amp;str, age: i32) -&gt; Self {
        Person { name: name.to_string(), age }
}

fn say_hello(&amp;self) {
    println!(&quot;Hello, my name is {} and I am {} years old.&quot;, self.name, self.age);
}
    
let person = Person::new(&quot;Alice&quot;, 30);
person.say_hello();
<span class="boring">}
</span></code></pre></pre>
<p>在C ++中，類是具有成員變量和成員函數的結構，使用class關鍵字定義。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
public:
    Person(const std::string&amp; name, int age) : name(name), age(age) {}

    void say_hello() {
        std::cout &lt;&lt; &quot;Hello, my name is &quot; &lt;&lt; name &lt;&lt; &quot; and I am &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl;
    }

private:
    std::string name;
    int age;
};

Person person(&quot;Alice&quot;, 30);
person.say_hello();
</code></pre>
<h3 id="命名空間"><a class="header" href="#命名空間">命名空間</a></h3>
<p>在C ++中，命名空間是一種將名稱分類為一個範圍的方式，可以避免名稱衝突。</p>
<pre><code class="language-cpp">namespace math {
    const double PI = 3.14159265358979323846;

    double sin(double x) {
        // ...
    }

    double cos(double x) {
        // ...
    }
}

double x = math::PI;
double y = math::sin(x);
</code></pre>
<p>在Rust中，沒有傳統意義上的命名空間，但可以使用模塊來組織代碼，並且可以使用pub關鍵字公開模塊內的項目。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod math {
    pub const PI: f64 = 3.14159265358979323846;

    pub fn sin(x: f64) -&gt; f64 {
        // ...
    }

    pub fn cos(x: f64) -&gt; f64 {
        // ...
    }
}

let x = math::PI;
let y = math::sin(x);
<span class="boring">}
</span></code></pre></pre>
<h3 id="結構體-2"><a class="header" href="#結構體-2">結構體</a></h3>
<p>在C ++中，結構體是一種自定義的數據類型，可以包含多個成員變量。</p>
<pre><code class="language-cpp">struct Point {
    double x;
    double y;
};

Point p = { 1.0, 2.0 };
double x = p.x;
double y = p.y;
</code></pre>
<p>在Rust中，結構體struct也是一種自定義的數據類型，可以包含多個字段。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
let x = p.x;
let y = p.y;
<span class="boring">}
</span></code></pre></pre>
<h3 id="枚舉-2"><a class="header" href="#枚舉-2">枚舉</a></h3>
<p>在C ++中，枚舉是一種自定義的數據類型，可以包含多個常量值。</p>
<pre><code class="language-cpp">enum Color {
    Red,
    Green,
    Blue,
};

Color c = Color::Green;
</code></pre>
<p>在Rust中，枚舉enum也是一種自定義的數據類型，可以包含多個變體variant。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Green,
    Blue,
}

let c = Color::Green;
<span class="boring">}
</span></code></pre></pre>
<h3 id="泛型-3"><a class="header" href="#泛型-3">泛型</a></h3>
<p>在C ++中，泛型是一種將代碼寫成可以處理多種數據類型的方式。</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T max(T a, T b) {
    return a &gt; b ? a : b;
}

int x = max(1, 2);
double y = max(1.0, 2.0);
</code></pre>
<p>在Rust中，泛型是一種類型參數化的方式。</p>
<pre><pre class="playground"><code class="language-rust">fn max&lt;T: std::cmp::PartialOrd&gt;(a: T, b: T) -&gt; T {
    if a &gt; b {
        a
    } else {
        b
    }
}

fn main() {
    let x = max(1.0f32, 2.0f32);
    let y = max(1.0f64, 2.0f64);
}
</code></pre></pre>
<h3 id="介面"><a class="header" href="#介面">介面</a></h3>
<p>在Rust中，Trait是一種定義方法簽名的接口。</p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn name(&amp;self) -&gt; &amp;'static str;
    fn make_sound(&amp;self) -&gt; &amp;'static str;
}

struct Dog;
impl Animal for Dog {
    fn name(&amp;self) -&gt; &amp;'static str {
        &quot;Dog&quot;
    }

    fn make_sound(&amp;self) -&gt; &amp;'static str {
        &quot;Bark&quot;
    }
}

struct Cat;
impl Animal for Cat {
    fn name(&amp;self) -&gt; &amp;'static str {
        &quot;Cat&quot;
    }

    fn make_sound(&amp;self) -&gt; &amp;'static str {
        &quot;Meow&quot;
    }
}

fn main() {
    let animals: [&amp;dyn Animal; 2] = [&amp;Dog, &amp;Cat];

    for animal in animals.iter() {
        println!(&quot;{} says {}&quot;, animal.name(), animal.make_sound());
    }
}
</code></pre></pre>
<p>在C ++中，類似的概念是接口interface。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Animal {
public:
    virtual const char* name() = 0;
    virtual const char* make_sound() = 0;
};

class Dog : public Animal {
public:
    const char* name() override { return &quot;Dog&quot;; }
    const char* make_sound() override { return &quot;Bark&quot;; }
};

class Cat : public Animal {
public:
    const char* name() override { return &quot;Cat&quot;; }
    const char* make_sound() override { return &quot;Meow&quot;; }
};

int main() {
    Animal* animals[2] = { new Dog(), new Cat() };

    for (int i = 0; i &lt; 2; i++) {
        std::cout &lt;&lt; animals[i]-&gt;name() &lt;&lt; &quot; says &quot; &lt;&lt; animals[i]-&gt;make_sound() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<h3 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h3>
<p>在 Rust 中，每個值都有一個擁有者(Owner)，該擁有者負責管理其值的生命週期，並自動在不再需要該值時銷毀它。</p>
<pre><pre class="playground"><code class="language-rust">fn print_string(s: String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s = String::from(&quot;Hello, Rust!&quot;);

    print_string(s);

    // s has been moved and is no longer valid
    // println!(&quot;{}&quot;, s); // error: use of moved value: `s`
}
</code></pre></pre>
<p>在C++中，類似的概念是對象的所有權(Ownership)，但是C++沒有自動回收機制，因此需要使用智能指針等手段來管理資源的生命週期。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

void print_string(const std::string&amp; s) {
    std::cout &lt;&lt; s &lt;&lt; std::endl;
}

int main() {
    std::unique_ptr&lt;std::string&gt; s = std::make_unique&lt;std::string&gt;(&quot;Hello, C++!&quot;);

    print_string(*s);

    // s will be automatically destroyed when it goes out of scope
    return 0;
}
</code></pre>
<p>在 Rust 中，為了避免所有權所有權被移動，可以使用引用(Reference)。引用是對某個值的參考，而不擁有該值本身。</p>
<pre><pre class="playground"><code class="language-rust">fn print_string(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s = String::from(&quot;Hello, Rust!&quot;);

    print_string(&amp;s);

    // s is still valid
    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<p>在C++中，引用與Rust中的引用類似，但在C++中引用是非空的，而且可以在函數中更改值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

void print_string(const std::string&amp; s) {
    std::cout &lt;&lt; s &lt;&lt; std::endl;
}

int main() {
    std::string s = &quot;Hello, C++!&quot;;

    print_string(s);

    // s is still valid
    std::cout &lt;&lt; s &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>在Rust中，為了同時允許讀取和寫入某個值，可以使用可變引用(Mutable Reference)。</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(mut x: &amp;mut i32) {
    *x += 1;
}

fn main() {
    let mut x = 0;

    add_one(&amp;mut x);

    // x is now 1
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>在C++中，類似的概念是指針(Pointer)。指針是一種特殊的變數，其值是另一個變數的地址。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void add_one(int* x) {
    (*x)++;
}

int main() {
    int x = 0;

    add_one(&amp;x);

    // x is now 1
    std::cout &lt;&lt; x &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<p>在 Rust 中，可以使用模式匹配(Pattern Matching)來進行分支處理。模式匹配可以用於匹配不同類型的值，比如整數、枚舉、結構體、元組等。</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

fn handle_message(msg: Message) {
    match msg {
        Message::Quit =&gt; println!(&quot;Quit&quot;),
        Message::Move { x, y } =&gt; println!(&quot;Move to ({}, {})&quot;, x, y),
        Message::Write(text) =&gt; println!(&quot;Write '{}'&quot;, text),
    }
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from(&quot;Hello&quot;));

    handle_message(msg1);
    handle_message(msg2);
    handle_message(msg3);
}
</code></pre></pre>
<p>在C++中，也可以使用switch語句來進行分支處理，但是switch語句只能匹配整數值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

enum class Message { Quit, Move, Write };

struct MoveMessage {
    int x, y;
};

void handle_message(Message msg) {
    switch (msg) {
        case Message::Quit:
            std::cout &lt;&lt; &quot;Quit&quot; &lt;&lt; std::endl;
            break;
        case Message::Move:
            {
                MoveMessage move_msg = {10, 20};
                std::cout &lt;&lt; &quot;Move to (&quot; &lt;&lt; move_msg.x &lt;&lt; &quot;, &quot; &lt;&lt; move_msg.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
            }
            break;
        case Message::Write:
            std::cout &lt;&lt; &quot;Write 'Hello'&quot; &lt;&lt; std::endl;
            break;
    }
}

int main() {
    Message msg1 = Message::Quit;
    Message msg2 = Message::Move;
    Message msg3 = Message::Write;

    handle_message(msg1);
    handle_message(msg2);
    handle_message(msg3);

    return 0;
}
</code></pre>
<p>在Rust中，模式匹配也可以用於解構(Deconstruction)元組和結構體。</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 10, y: 20 };

    match point {
        Point { x, y } =&gt; println!(&quot;({}, {})&quot;, x, y),
    }

    let tuple = (1, &quot;hello&quot;);

    match tuple {
        (i, s) =&gt; println!(&quot;({}, {})&quot;, i, s),
    }
}
</code></pre></pre>
<p>在C++中，也可以使用解構來獲取元組和結構體的成員。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;

struct Point {
    int x, y;
};

int main() {
    Point point = {10, 20};
    std::tie(std::ignore, std::ignore, point.y) = point;

    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; point.x &lt;&lt; &quot;, &quot; &lt;&lt; point.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;

    std::tuple&lt;int, std::string&gt; tuple = std::make_tuple(1, &quot;hello&quot;);
    int i;
    std::string s;
    std::tie(i, s) = tuple;

    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; s &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="智能指針"><a class="header" href="#智能指針">智能指針</a></h3>
<p>Rust 中有三種智能指針：Box、Rc、Arc。</p>
<p>Box<T> 表示一個指向堆上的 T 類型值的指針，它是唯一所有權的。Box<T> 主要用於解決擁有大量資料或者需要在運行時創建出來的資料的所有權問題。Box<T> 的內存佈局和指針類似，只是多了一個 vtable 指向 T 的方法表。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Box::new(42);

    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>在 C++ 中也有智能指針，主要有 unique_ptr、shared_ptr 和 weak_ptr。</p>
<p>unique_ptr<T> 表示一個唯一所有權的指針，它負責釋放 T 類型對象的內存。unique_ptr<T> 可以通過 move 轉移所有權，也可以使用 std::move 函數轉移所有權。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::unique_ptr&lt;int&gt; x(new int(42));

    std::cout &lt;&lt; *x &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>shared_ptr<T> 表示一個共享所有權的指針，多個 shared_ptr<T> 可以指向同一個 T 類型對象，它們共享 T 類型對象的所有權。shared_ptr<T> 使用引用計數的方式來實現所有權管理，當引用計數為 0 時，shared_ptr<T> 會自動釋放對象的內存。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; x(new int(42));

    std::cout &lt;&lt; *x &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>weak_ptr<T> 表示一個弱引用指針，它不擁有對 T 類型對象的所有權，可以從一個 shared_ptr<T> 構造出來。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; x(new int(42));
    std::weak_ptr&lt;int&gt; y(x);

    std::cout &lt;&lt; *x &lt;&lt; std::endl;
    std::cout &lt;&lt; *y.lock() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<h3 id="trait-和-interface"><a class="header" href="#trait-和-interface">Trait 和 Interface</a></h3>
<p>在 Rust 中，Trait 是一個定義方法的集合，可以實現多態性。一個類型可以實現多個 Trait，實現 Trait 的類型必須實現 Trait 中定義的方法。Trait 可以與泛型一起使用，讓函數和類型更加通用。</p>
<pre><pre class="playground"><code class="language-rust">trait Printable {
    fn print(&amp;self);
}

struct Point {
    x: i32,
    y: i32,
}

impl Printable for Point {
    fn print(&amp;self) {
        println!(&quot;({}, {})&quot;, self.x, self.y);
    }
}

fn print_all&lt;T: Printable&gt;(list: Vec&lt;T&gt;) {
    for item in list {
        item.print();
    }
}

fn main() {
    let list = vec![Point { x: 1, y: 2 }, Point { x: 3, y: 4 }];
    print_all(list);
}
</code></pre></pre>
<p>在 C++ 中，Interface 是一個包含純虛函數的抽象基類，純虛函數沒有實現，需要子類實現。Interface 可以實現多態性，也可以與泛型一起使用，讓函數和類型更加通用。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

class Printable {
public:
    virtual void print() = 0;
};

class Point : public Printable {
public:
    Point(int x, int y) : x(x), y(y) {}

    void print() override {
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    }

private:
    int x, y;
};

template&lt;typename T&gt;
void print_all(std::vector&lt;T&gt;&amp; list) {
    for (auto&amp; item : list) {
        item.print();
    }
}

int main() {
    std::vector&lt;Point&gt; list = { Point(1, 2), Point(3, 4) };
    print_all(list);

    return 0;
}
</code></pre>
<h3 id="oo"><a class="header" href="#oo">OO</a></h3>
<p>Rust 支持面向對象編程，但與 C++ 相比，其面向對象特性較為簡化。Rust 的結構體可以包含方法，但是不能繼承和多態，也沒有 C++ 中的訪問控制和友元等機制。</p>
<pre><pre class="playground"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;The area of the circle is {}&quot;, c.area());
}
</code></pre></pre>
<p>C++ </p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;

class Circle {
private:
    double x;
    double y;
    double radius;

public:
    Circle(double _x, double _y, double _r) : x(_x), y(_y), radius(_r) {}

    double area() {
        return M_PI * (radius * radius);
    }
};

int main() {
    Circle c(0.0, 0.0, 2.0);
    std::cout &lt;&lt; &quot;The area of the circle is &quot; &lt;&lt; c.area() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h3 id="異常處理"><a class="header" href="#異常處理">異常處理</a></h3>
<p>Rust 和 C++ 都支援異常處理，但是 Rust 推崇使用 Result 類型來處理錯誤，而 C++ 則常常使用 try-catch 塊來捕獲和處理異常。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::prelude::*;
use std::io::Error;

fn read_file(path: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}

fn main() {
    let path = &quot;test.txt&quot;;
    match read_file(path) {
        Ok(contents) =&gt; println!(&quot;The contents of the file are:\n{}&quot;, contents),
        Err(err) =&gt; eprintln!(&quot;Error reading file: {}&quot;, err),
    }
}
</code></pre></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;

void read_file(const std::string&amp; path) {
    std::ifstream file(path);
    if (!file.is_open()) {
        throw std::runtime_error(&quot;Error opening file&quot;);
    }
    std::string line;
    while (getline(file, line)) {
        std::cout &lt;&lt; line &lt;&lt; std::endl;
    }
}

int main() {
    std::string path = &quot;test.txt&quot;;
    try {
        read_file(path);
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; &quot;Exception caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-中的-bin-lib-rlib-a-so-概念介紹"><a class="header" href="#rust-中的-bin-lib-rlib-a-so-概念介紹">Rust 中的 bin, lib, rlib, a, so 概念介紹</a></h1>
<p>出處:https://cloud.tencent.com/developer/article/1583081</p>
<p>寫了這麼久的 Rust 程式碼了，可能很多人還對 Rust 的編譯後的檔案格式不是很清晰。本篇我們就來理一下，Rust 中的 bin, lib, rlib, a, so 是什麼，如何生成，以及其它一些細節。</p>
<h3 id="從-cargo-new-說起"><a class="header" href="#從-cargo-new-說起"><strong>從 cargo new 說起</strong></a></h3>
<p>我們建立一個新工程，通常從下面兩句入手：</p>
<pre><code class="language-javascript">cargo new foobar
</code></pre>
<p>複製</p>
<p>或</p>
<pre><code class="language-javascript">cargo new --lib foobar
</code></pre>
<p>複製</p>
<p>前者建立一個可執行工程，而後者建立一個庫工程。</p>
<p>實際上，你去探索上述命令列生成的檔案，發現它們的 Cargo.toml 完全一樣，區別僅在於 src 目錄下，可執行工程是一個 main.rs，而庫工程是一個 lib.rs。</p>
<p>這是因為 main.rs 和 lib.rs 對於一個 crate 來講，是兩個特殊的檔案名稱。rustc 內建了對這兩個特殊檔案名稱的處理（當然也可以通過 Cargo.toml 進行組態，不詳談），我們可以認為它們就是一個 crate 的入口。</p>
<p>可執行 crate 和庫 crate 是兩種不同的 crate。下面我們就來一併說一下它們的兄弟姐妹及其之間的異同。</p>
<h3 id="crate-type"><a class="header" href="#crate-type"><strong>crate type</strong></a></h3>
<p>執行</p>
<pre><code class="language-javascript">rustc --help|grep crate-type
</code></pre>
<p>複製</p>
<p>可得到如下輸出</p>
<pre><code class="language-javascript">       --crate-type [bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]
</code></pre>
<p>複製</p>
<p>才發現，原來有這麼多種 crate type。下面挨個看一下。</p>
<h4 id="bin"><a class="header" href="#bin"><strong>bin</strong></a></h4>
<p>二進制可執行 crate，編譯出的檔案為二進制可執行檔案。必須要有 main 函數作為入口。這種 crate 不需要在 Cargo.toml 中或 --crate-type 命令列參數中指定，會自動識別。</p>
<h4 id="lib"><a class="header" href="#lib"><strong>lib</strong></a></h4>
<p>庫 crate。它其實並不是一種具體的庫，它指代後面各種庫 crate 中的一種，可以認為是一個代理名稱（alias）。</p>
<p>通常來講，如果什麼都不組態，默認指的是 rlib, 會生成 .rlib 的檔案。</p>
<h4 id="rlib"><a class="header" href="#rlib"><strong>rlib</strong></a></h4>
<p>rlib 是 Rust Library 特定靜態中間庫格式。如果只是純 Rust 程式碼項目之間的依賴和呼叫，那麼，用 rlib 就能完全滿足使用需求。</p>
<p>rlib 實現為一個 ar 歸檔檔案。</p>
<pre><code class="language-javascript">&gt; file target/debug/libfoobar.rlib
target/debug/libfoobar.rlib: current ar archive
</code></pre>
<p>複製</p>
<p>rlib 中包含很多 metadata 資訊（比如可能的上游依賴資訊），用來做後面的 linkage。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-javascript">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;rlib&quot;]
</code></pre>
<p>複製</p>
<p>可以指定生成 rlib，但是一般沒必要設定，因為默認 lib 就是 rlib。</p>
<p>rlib 是平臺（Linux, MacOS, Windows ...）無關的。</p>
<h4 id="dylib"><a class="header" href="#dylib"><strong>dylib</strong></a></h4>
<p>動態庫。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-javascript">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;dylib&quot;]
</code></pre>
<p>複製</p>
<p>會在編譯的時候，生成動態庫（Linux 上為 .so, MacOS 上為 .dylib, Windows 上為 .dll）。</p>
<p>動態庫是平臺相關的庫。動態庫在被依賴並連結時，不會被連結到目標檔案中。這種動態庫只能被 Rust 寫的程序(或遵循 Rust 內部不穩定的規範的程序)呼叫。這個動態庫可能依賴於其它動態庫（比如，Linux 下用 C 語言寫的 <a href="https://cloud.tencent.com/product/postgresql?from=10680">PostgreSQL</a> 的 libpq.so，或者另一個編譯成 &quot;dylib&quot; 的 Rust 動態庫）。</p>
<h4 id="cdylib"><a class="header" href="#cdylib"><strong>cdylib</strong></a></h4>
<p>C規範動態庫。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-javascript">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>複製</p>
<p>與 dylib 類似，也會生成 .so, .dylib 或 .dll 檔案。但是這種動態庫可以被其它語言呼叫（因為幾乎所有語言都有遵循 C 規範的 FFI 實現），也就是跨語言 FFI 使用。這個動態庫可能依賴於其它動態庫（比如，Linux 下用 C 語言寫的 PostgreSQL 的 libpq.so）。</p>
<h4 id="staticlib"><a class="header" href="#staticlib"><strong>staticlib</strong></a></h4>
<p>靜態庫。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-javascript">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>複製</p>
<p>編譯會生成 .a 檔案（在 Linux 和 MacOS 上），或 .lib 檔案（在 Windows 上）。</p>
<p>編譯器會把所有實現的 Rust 庫程式碼以及依賴的庫程式碼全部編譯到一個靜態庫檔案中，也就是對外界不產生任何依賴了。這特別適合將 Rust 實現的功能封裝好給第三方應用使用。</p>
<h4 id="proc-macro"><a class="header" href="#proc-macro"><strong>proc-macro</strong></a></h4>
<p>過程宏 crate.</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-javascript">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;proc-macro&quot;]
</code></pre>
<p>複製</p>
<p>這種 crate 裡面只能匯出過程宏，被匯出的過程宏可以被其它 crate 引用。</p>
<hr />
<p>Crate type 以及它們之間的區別就介紹到這裡了，有些細節還是需要仔細理解的。本篇意在闡述一些基礎知識，而不打算成為一篇完整的參考檔案，如要查看 Rust Linkage 的詳細內容，直接訪問 Rust Reference。</p>
<p>https://doc.rust-lang.org/reference/linkage.html</p>
<p>這一篇帖子非常有用：</p>
<p>https://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-中的-bin-lib-rlib-a-so-概念介紹-1"><a class="header" href="#rust-中的-bin-lib-rlib-a-so-概念介紹-1">Rust 中的 bin, lib, rlib, a, so 概念介紹</a></h2>
<p>出處: https://blog.51cto.com/u_15683898/5426916</p>
<p>在 Rust 中，常見的可執行檔和庫文件格式包括：</p>
<ul>
<li><strong>可執行檔（bin）</strong>：在 Rust 中，可執行檔指的是一個由 Rust 編譯器直接編譯出的二進制 ELF 或 Mach-O 檔案格式文件。可執行檔不能被其他程式直接使用，而只能由終端用戶執行。在 Rust 的項目中，所有的可執行檔都位於 <code>src/bin</code> 目錄中，每個可執行檔都是一個獨立的 Rust 程式。將其命名為 <code>foo.rs</code> 將會產生一個可執行檔 <code>foo</code>。</li>
<li><strong>函式庫（lib）</strong>：在 Rust 中，函式庫指的是一個二進制或共享庫，它提供了一組用於更大程式中使用的函數。函式庫可以在 Rust 程式中被引用，以避免代碼重複。在 Rust 的項目中，所有的函式庫都位於 <code>src/lib</code> 目錄中。根據文件生成不同的庫類型，可以分為靜態庫（<code>.a</code>）和動態庫（<code>.so</code>）。靜態庫被編譯進可執行檔，而動態庫則僅在運行時被加載，並在多個程序之間共享。</li>
<li><strong>靜態庫（rlib）</strong>：在 Rust 中，靜態庫需要通過 <code>rustc</code> 生成，其文件格式為 RLIB。靜態庫（<code>.rlib</code>）是一個經過 Rust 編譯器優化並靜態鏈接的二進制文件。靜態庫可以直接與 Rust 可執行文件一起複製和發布。與函式庫（<code>.so</code>）相比，靜態庫具有更快的加載時間和更好的可移植性。在 Rust 中，編譯靜態庫需要執行以下命令： <code>rustc --crate-type=staticlib path/to/library.rs</code>。</li>
<li><strong>動態庫（so）</strong>：在 Rust 中，動態庫使用共享庫（<code>.so</code>）文件作為文件格式。動態庫被編譯成一個獨立的文件並可以在多個執行檔之間共享。在 Rust 項目中編譯動態庫需要使用 cargo 的 build 命令，並將 crate-type 設置為 <code>cdylib</code>。</li>
</ul>
<p>在 Rust 中，可執行檔和函式庫都遵循 ELF（可執行和可鏈接格式）標準，該標準應用於 Linux 和其他類Unix系統。因此，這些檔案可以透明地在 Linux 系統上被解析和執行。</p>
<p>在 Linux 系統上，要執行 Rust 可執行檔或函式庫，必須首先確保文件已被正確編譯。對於 Rust 的可執行檔案或函式庫，您可以使用以下命令進行編譯：</p>
<ul>
<li>
<p>可執行檔：將 <code>Cargo.toml</code> 中的 <code>bin</code> 選項設置為正在編譯的可執行檔，然後使用以下命令編譯：</p>
<pre><code>$ cargo build --bin your_bin_name
</code></pre>
<p>或者，使用以下命令在優化模式下編譯：</p>
<pre><code>$ cargo build --release --bin your_bin_name `
</code></pre>
</li>
<li>
<p>函式庫（靜態庫或動態庫）：將 <code>Cargo.toml</code> 中的 <code>lib</code> 選項設置為正在編譯的函式庫，然後使用以下命令編譯：</p>
<pre><code>$ cargo build --lib
</code></pre>
<p>或者，使用以下命令編譯動態庫（請注意，<code>crate-type</code> 選項需要設置為 <code>cdylib</code>）：</p>
<pre><code>$ cargo build --release --lib --features cdylib `
</code></pre>
</li>
</ul>
<p>完成編譯後，您可以使用命令行運行 Rust 的可執行檔，並將函式庫鏈接到其他程式中。在 Linux 上執行 Rust 程式和函式庫與運行任何其他 ELF 文件一樣，只需確保它們是正確生成並遵循了 ELF 規範即可。</p>
<p>在編譯可執行檔或庫文件時，應將文件命名為該文件的用途並使用相應的擴展名，例如：將可執行檔命名為 <code>foo.rs</code> 並編譯生成可執行檔 <code>foo</code>；將靜態庫命名為 <code>libfoo.rs</code> 並執行命令 <code>rustc --crate-type=staticlib libfoo.rs</code>；將動態庫命名為 <code>libfoo.rs</code> 並執行 <code>cargo build --release</code> 命令來編譯動態庫文件 <code>libfoo.so</code>。</p>
<p>寫了這麼久的 Rust 程式碼了，可能很多人還對 Rust 的編譯後的檔案格式不是很清晰。本篇我們就來理一下，Rust 中的 bin, lib, rlib, a, so 是什麼，如何生成，以及其它一些細節。</p>
<p>從 cargo new 說起
我們建立一個新工程，通常從下面兩句入手：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo new foobar
<span class="boring">}
</span></code></pre></pre>
<p>或</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo new --lib foobar
<span class="boring">}
</span></code></pre></pre>
<p>前者建立一個可執行工程，而後者建立一個庫工程。</p>
<p>實際上，你去探索上述命令列生成的檔案，發現它們的 Cargo.toml 完全一樣，區別僅在於 src 目錄下，可執行工程是一個 main.rs，而庫工程是一個 lib.rs。</p>
<p>這是因為 main.rs 和 lib.rs 對於一個 crate 來講，是兩個特殊的檔案名稱。rustc 內建了對這兩個特殊檔案名稱的處理（當然也可以通過 Cargo.toml 進行組態，不詳談），我們可以認為它們就是一個 crate 的入口。</p>
<p>可執行 crate 和庫 crate 是兩種不同的 crate。下面我們就來一併說一下它們的兄弟姐妹及其之間的異同。</p>
<h3 id="crate-type-1"><a class="header" href="#crate-type-1">crate type</a></h3>
<p>執行</p>
<pre><code class="language-sh">rustc --help|grep crate-type
</code></pre>
<p>可得到如下輸出</p>
<pre><code class="language-sh">--crate-type [bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]
</code></pre>
<p>才發現，原來有這麼多種 crate type。下面挨個看一下。</p>
<h3 id="bin-1"><a class="header" href="#bin-1">bin</a></h3>
<p>二進制可執行 crate，編譯出的檔案為二進制可執行檔案。必須要有 main 函數作為入口。這種 crate 不需要在 Cargo.toml 中或 --crate-type 命令列參數中指定，會自動識別。</p>
<h3 id="lib-1"><a class="header" href="#lib-1">lib</a></h3>
<p>庫 crate。它其實並不是一種具體的庫，它指代後面各種庫 crate 中的一種，可以認為是一個代理名稱（alias）。</p>
<p>通常來講，如果什麼都不組態，默認指的是 rlib, 會生成 .rlib 的檔案。</p>
<h3 id="rlib-1"><a class="header" href="#rlib-1">rlib</a></h3>
<p>rlib 是 Rust Library 特定靜態中間庫格式。如果只是純 Rust 程式碼項目之間的依賴和呼叫，那麼，用 rlib 就能完全滿足使用需求。</p>
<p>rlib 實現為一個 ar 歸檔檔案。</p>
<blockquote>
<p>file target/debug/libfoobar.rlib
target/debug/libfoobar.rlib: current ar archive</p>
<ol>
<li></li>
<li></li>
</ol>
<p>rlib 中包含很多 metadata 資訊（比如可能的上游依賴資訊），用來做後面的 linkage。</p>
</blockquote>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-toml">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;rlib&quot;]
</code></pre>
<p>可以指定生成 rlib，但是一般沒必要設定，因為默認 lib 就是 rlib。</p>
<p>rlib 是平臺（Linux, MacOS, Windows ...）無關的。</p>
<p>dylib
動態庫。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-toml">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;dylib&quot;]
</code></pre>
<p>會在編譯的時候，生成動態庫（Linux 上為 .so, MacOS 上為 .dylib, Windows 上為 .dll）。</p>
<p>動態庫是平臺相關的庫。動態庫在被依賴並連結時，不會被連結到目標檔案中。這種動態庫只能被 Rust 寫的程序(或遵循 Rust 內部不穩定的規範的程序)呼叫。這個動態庫可能依賴於其它動態庫（比如，Linux 下用 C 語言寫的 PostgreSQL 的 libpq.so，或者另一個編譯成 &quot;dylib&quot; 的 Rust 動態庫）。</p>
<h3 id="cdylib-1"><a class="header" href="#cdylib-1">cdylib</a></h3>
<p>C規範動態庫。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-toml">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>與 dylib 類似，也會生成 .so, .dylib 或 .dll 檔案。但是這種動態庫可以被其它語言呼叫（因為幾乎所有語言都有遵循 C 規範的 FFI 實現），也就是跨語言 FFI 使用。這個動態庫可能依賴於其它動態庫（比如，Linux 下用 C 語言寫的 PostgreSQL 的 libpq.so）。</p>
<h3 id="staticlib-1"><a class="header" href="#staticlib-1">staticlib</a></h3>
<p>靜態庫。</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-toml">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>編譯會生成<code>.a</code> 檔案（在 Linux 和 MacOS 上），或 .lib 檔案（在 Windows 上）。</p>
<p>編譯器會把所有實現的 Rust 庫程式碼以及依賴的庫程式碼全部編譯到一個靜態庫檔案中，也就是對外界不產生任何依賴了。這特別適合將 Rust 實現的功能封裝好給第三方應用使用。</p>
<h3 id="proc-macro-1"><a class="header" href="#proc-macro-1">proc-macro</a></h3>
<p>過程宏 crate.</p>
<p>在 Cargo.toml 中組態：</p>
<pre><code class="language-toml">[lib]
name = &quot;foobar&quot;
crate-type = [&quot;proc-macro&quot;]
</code></pre>
<p>這種 crate 裡面只能匯出過程宏，被匯出的過程宏可以被其它 crate 引用。</p>
<p>Crate type 以及它們之間的區別就介紹到這裡了，有些細節還是需要仔細理解的。本篇意在闡述一些基礎知識，而不打算成為一篇完整的參考檔案，如要查看 Rust Linkage 的詳細內容，直接訪問 Rust Reference。</p>
<p>https://doc.rust-lang.org/reference/linkage.html</p>
<p>這一篇帖子非常有用：</p>
<p>https://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="print-function-name-dump-stack"><a class="header" href="#print-function-name-dump-stack">print-function-name-dump-stack</a></h2>
<pre><code>cargo new print-function-name-dump-stack
</code></pre>
<ul>
<li>Cargo.toml</li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;print-function-name-dump-stack&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
stdext = &quot;0.3.1&quot;
backtrace = &quot;0.3.65&quot;
</code></pre>
<ul>
<li>main.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use backtrace::Backtrace;
use std::process;
use std::thread;
use stdext::function_name;

macro_rules! print_current_info {
    () =&gt; {{
        println!(
            &quot;pid={},tid={:?} {}:{} {}&quot;,
            process::id(),
            thread::current().id(),
            file!(),
            line!(),
            function_name!()
        );
    }};
}

fn dump_stack_test() {
    let bt = Backtrace::new();
    print_current_info!();
    println!(&quot;backtrace dump start ===============&quot;);
    println!(&quot;{:?}&quot;, bt);
}

fn test_func() {
    print_current_info!();
    dump_stack_test();
}

fn main() {
    print_current_info!();
    test_func();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-筆記-1"><a class="header" href="#rust-筆記-1">Rust 筆記</a></h1>
<ul>
<li>as_ptr()</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn main() {
    let free_coloring_book = vec![
        &quot;mercury&quot;, &quot;venus&quot;, &quot;earth&quot;, &quot;mars&quot;, &quot;jupiter&quot;, &quot;saturn&quot;, &quot;uranus&quot;, &quot;neptune&quot;,
    ];
    // 1. free_coloring_book堆上數據的地址
    println!(&quot;address: {:p}&quot;, free_coloring_book.as_ptr());

    // 2. free_coloring_book棧上的地址
    let a = &amp;free_coloring_book;
    println!(&quot;address: {:p}&quot;, a);

    let mut friends_coloring_book = free_coloring_book;

    // 3. friends_coloring_book堆上數據的地址，和1一樣
    println!(&quot;address: {:p}&quot;, friends_coloring_book.as_ptr());

    // 4. friends_coloring_book棧上的地址
    let b = &amp;friends_coloring_book;
    println!(&quot;address: {:p}&quot;, b);
}
</code></pre></pre>
<ul>
<li>Rc / Box 用法</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

struct Aa {
    id: i32,
}

impl Drop for Aa {
    fn drop(&amp;mut self) {
        println!(&quot;Aa Drop, id: {}&quot;, self.id);
    }
}

fn print_type_of&lt;T&gt;(_: &amp;T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn test_1() {
    let a1 = Aa { id: 1 }; // 數據分配在棧中
    let a1 = Rc::new(a1); // 數據 move 到了堆中？
    print_type_of(&amp;a1);
    //drop(a1);
    println!(&quot;xxxxxxx&quot;);
}

fn test_2() {
    let a1 = Aa { id: 1 }; // 數據分配在棧中
    let a1 = Box::new(a1); // 數據 move 到了堆中？
    print_type_of(&amp;a1);
}

fn main() {
    test_1();
    test_2();
}
</code></pre></pre>
<ul>
<li>data  bss text heap stack</li>
</ul>
<pre><pre class="playground"><code class="language-rust">/// .Text段存放的是程序中的可執行代碼
/// .Data段保存的是已經初始化了的全局變量和靜態變量
/// .ROData（ReadOnlyData）段存放程序中的常量值，如字符串常量
/// .BSS段存放的是未初始化的全局變量和靜態變量，程序執行前會先進行一遍初始化
const G_ARRAY: [i32; 5] = [10; 5];
const G_X: i32 = 100;
static G_VAR: i32 = 1000;

fn test06_heap_or_stack() {
    let s: &amp;str = &quot;test list&quot;;
    //字符串字面量，位於ROData段
    println!(&quot;&amp;str: {:p}&quot;, s); //&amp;str: 0x7ff77e4c6b88
    println!(&quot;{:p}&quot;, &amp;G_ARRAY); //data段:0x7ff6c5fc6bb8
    println!(&quot;{:p}&quot;, &amp;G_X); //data段:0x7ff6c5fc64f0
    println!(&quot;{:p}&quot;, &amp;G_VAR); //data段:0x7ff77e4c6200
    println!(&quot;{}&quot;, &quot;-&quot;.repeat(10));

    // 位於堆
    let bi = Box::new(30);
    println!(&quot;{:p}&quot;, bi); //堆:0x19f6c6585e0
                          // 將字符串字面量從內存中的代碼區（ROData段）復制一份到堆
                          // 棧上分配的變量s1指向堆內存
    let mut s1: String = String::from(&quot;Hello&quot;);
    // 可以通過std::mem::transmute將
    // 從24字節的長度的3個uszie讀出來
    let pstr: [usize; 3] = unsafe { std::mem::transmute(s1) };
    // pstr[0]是一個堆內存地址
    println!(&quot;ptr: 0x{:x}&quot;, pstr[0]); //ptr: 0x19f6c658750

    println!(&quot;{}&quot;, &quot;-&quot;.repeat(10));
    // 位於棧
    let nums1 = [1, 2, 3, 4, 5, 6];
    let mut list: Vec&lt;i32&gt; = vec![20, 30, 40];
    let t = 100;
    println!(&quot;{:p}&quot;, &amp;t); //棧0x116aeff104
    println!(&quot;{:p}&quot;, &amp;nums1); //棧0x116aeff0d0
    println!(&quot;{:p}&quot;, &amp;list); //棧0x116aeff0e8
                             // 從ROData區復制了一份字符串字面量放到堆上，
                             // 然後用棧上分配的s指向堆
    let s: String = &quot;Hello&quot;.to_owned();
    println!(&quot;{:p}&quot;, &amp;s); //0x116aeff1f8
    let s: String = String::from(&quot;Hello&quot;);
    println!(&quot;{:p}&quot;, &amp;s); //0x116aeff260
    let s: String = &quot;Hello&quot;.into();
    println!(&quot;{:p}&quot;, &amp;s); //0x116aeff2c8
}

fn main() {
    test06_heap_or_stack();
}
</code></pre></pre>
<h2 id="ownership有個特性是個大坑-1"><a class="header" href="#ownership有個特性是個大坑-1">ownership有個特性是個大坑</a></h2>
<pre><pre class="playground"><code class="language-rust">// ownership有個特性，感覺是個大坑，把不可變資料的ownership move到可變資料，那麼就改值了。這個設定不安全。
fn main() {
    let immutable = Box::new(5u32);
    println!(&quot;{:}&quot;, immutable);

    let mut mutable_box = immutable;
    println!(&quot;{:}&quot;, mutable_box);
    *mutable_box = 4;
    println!(&quot;{:}&quot;, mutable_box);
} 
</code></pre></pre>
<h2 id="rust中mut--mut的區別-1"><a class="header" href="#rust中mut--mut的區別-1">Rust中mut, &amp;, &amp;mut的區別</a></h2>
<p>資源：記憶體區塊。不同的記憶體區塊位置和大小就是不同的資源。</p>
<h3 id="str-1"><a class="header" href="#str-1">str</a></h3>
<p>let a = &quot;xxx&quot;.to_string();　　
含義：a繫結到字串資源A上，擁有資源A的所有權</p>
<p>let mut a = &quot;xxx&quot;.to_string();　
含義：a繫結到字串資源A上，擁有資源A的所有權，同時a還可繫結到新的資源上面去（更新繫結的能力，但新舊資源類型要同）；</p>
<h3 id="value-1"><a class="header" href="#value-1">value</a></h3>
<p>let b = a;
含義：a繫結的資源A轉移給b，b擁有這個資源A</p>
<p>let b = &amp;a;　　
含義：a繫結的資源A借給b使用，b只有資源A的讀權限</p>
<p>let b = &amp;mut a;　　
含義：a繫結的資源A借給b使用，b有資源A的讀寫權限</p>
<p>let mut b = &amp;mut a;　　
含義：a繫結的資源A借給b使用，b有資源A的讀寫權限。同時，b可繫結到新的資源上面去（更新繫結的能力）</p>
<h3 id="string-2"><a class="header" href="#string-2">String</a></h3>
<p>fn do(c: String) {}　　
含義：傳參的時候，實參d繫結的資源D的所有權轉移給c</p>
<p>fn do(c: &amp;String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D唯讀</p>
<p>fn do(c: &amp;mut String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D可讀寫</p>
<p>fn do(mut c: &amp;mut String) {}　　
含義：傳參的時候，實參d將繫結的資源D借給c使用，c對資源D可讀寫。同時，c可繫結到新的資源上面去（更新繫結的能力）</p>
<p>函數參數裡面，冒號左邊的部分，mut c，這個mut是對函數體內部有效；冒號右邊的部分，&amp;mut String，這個 &amp;mut 是針對外部實參傳入時的形式化（類型）說明。</p>
<p>下面的例子輸出是什麼：</p>
<pre><pre class="playground"><code class="language-rust">fn concat_literal(s: &amp;mut String) {     
    s.extend(&quot;world!&quot;.chars());         
}                                       
                                          
fn main() {                             
    let mut s = &quot;hello, &quot;.to_owned();   
    concat_literal(&amp;mut s);             
    println!(&quot;{}&quot;, s);                  
}  
</code></pre></pre>
<h2 id="打印-borrow-位址-1"><a class="header" href="#打印-borrow-位址-1">打印 borrow 位址</a></h2>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn test(a: &amp;mut i32) {
    println!(&quot;{:p}&quot;, *&amp;a); // 打印 reference address 
    println!(&quot;{:p}&quot;, a); // 打印 reference address 
    println!(&quot;{:}&quot;, a);
    *a = 100;
    println!(&quot;{:p}&quot;, &amp;a);
}

fn main() {
    let mut a = 10;
    print_type_of(a);
    let b = &amp;mut a;
    *b = 50;
    print_type_of(b);
    println!(&quot;{:p}&quot;, &amp;a);
    test(&amp;mut a);
    println!(&quot;{:}&quot;, a);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn print_type_of&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn main() {
    let a: i32 = 5;
    print_type_of(a);
    println!(&quot;addr：{:p}&quot;, &amp;a);
    let b = &amp;a;
    print_type_of(b);
    println!(&quot;addr：{:p}&quot;, b);
    println!(&quot;value ：{:}&quot;, b);
    //&amp;a先轉成raw指針，然後再把指針轉成usize，這個可以print的
    let addr = &amp;a as *const i32 as usize;
    println!(&quot;addr：0x{:X}&quot;, addr);

    //為了驗證剛才的地址是不是正確的，我們修改這個指針指向的數據
    //pa就是addr對應的raw指針
    let pa = addr as *mut i32;
    //解引用，*pa其實就是&amp;mut a了，給他賦值100
    unsafe { *pa = 100 };

    //打印a，可以看到a已經變成100了
    println!(&quot;value:{}&quot;, a);
}
</code></pre></pre>
<h2 id="self-和-self-的區別-1"><a class="header" href="#self-和-self-的區別-1">&amp;self 和 self 的區別</a></h2>
<p>在 Rust 的方法中，第一個參數為 &amp; self，那麼如果改成 self（不是大寫的 Self）行不行，兩者有什麼區別。
&amp;self，表示向函數傳遞的是一個引用，不會發生對像所有權的轉移；
self，表示向函數傳遞的是一個對象，會發生所有權的轉移，對象的所有權會傳遞到函數中。
原文作者：linghuyichong
轉自鏈接：https://learnku.com/articles/39050</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyType {
    name: String,
}

impl MyType {
    fn do_something(self, age: u32) {
        //等價於 fn do_something(self: Self, age: u32) {
        //等價於 fn do_something(self: MyType, age: u32) {
        println!(&quot;name = {}&quot;, self.name);
        println!(&quot;age = {}&quot;, age);
    }

    fn do_something2(&amp;self, age: u32) {
        println!(&quot;name = {}&quot;, self.name);
        println!(&quot;age = {}&quot;, age);
    }
}

fn main() {
    let my_type = MyType {
        name: &quot;linghuyichong&quot;.to_string(),
    };
    //使用self
    my_type.do_something(18); //等價於MyType::do_something(my_type, 18);
                              //println!(&quot;my_type: {:#?}&quot;, my_type);    //在do_something中，傳入的是對象，而不是引用，因此my_type的所有權就轉移到函數中了，因此不能再使用

    //使用&amp;self
    let my_type2 = MyType {
        name: &quot;linghuyichong&quot;.to_string(),
    };
    my_type2.do_something2(18);
    my_type2.do_something2(18);
    println!(&quot;my_type2: {:#?}&quot;, my_type2); //在do_something中，傳入是引用，函數並沒有獲取my_type2的所有權，因此此處可以使用
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li>
<p>模擬C++ 建構/解構</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::process;

struct MyStruct {
    value: i32,
}

impl MyStruct {
    fn new(value: i32) -&gt; MyStruct {
        println!(&quot;MyStruct with value {} created by pid {} tid {:?}&quot;, value, process::id(), thread::current().id());
        MyStruct { value: value }
    }
}

impl Drop for MyStruct {
    fn drop(&amp;mut self) {
        println!(&quot;MyStruct with value {} dropped by pid {} tid {:?}&quot;, self.value, process::id(), thread::current().id());
    }
}

fn main() {
    let my_struct = MyStruct::new(42);
}
</code></pre></pre>
</li>
<li>
<p>trait</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
/*
 * 這個程式碼定義了一個名叫 Movable 的 trait，這個 trait 定義了一個 movement 方法。
 * Human 和 Rabbit 是兩個結構體，分別實現了 Movable trait。在每個實現中，
 * 都定義了一個 movement 方法，實現了結構體如何移動的行為。
 * 在 main 函數中，我們創建了一個 Human 和一個 Rabbit 的實例，存儲在 human 和 rabbit 變數中。
 * 然後，我們依次對這兩個變數分別調用了 movement 方法，分別輸出了 &quot;Human walk&quot; 和 &quot;Rabbit jump&quot;。
 * 這個程式碼展示瞭如何使用 Rust 的 trait 和結構體來實現多態行為。
 * 使用 trait，可以將類似的操作組織成一個介面，並將其實現為多個不同的類型。這使得代碼更加模組化，可重用性更高。
 * */
trait Movable {
    fn movement(&amp;self);
}

struct Human;

impl Movable for Human {
    fn movement(&amp;self) {
        println!(&quot;Human walk&quot;);
    }
}

struct Rabbit;

impl Movable for Rabbit {
    fn movement(&amp;self) {
        println!(&quot;Rabbit jump&quot;);
    }
}

fn main() {
    let human = Human;
    let rabbit = Rabbit;

    human.movement();
    rabbit.movement();
}
</code></pre></pre>
<ul>
<li>Rust 中有三種方式來引用這個結構實例：<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>。下面舉例說明這三種實例引用方式的不同之處。</li>
</ul>
<p>self<code>和</code>&amp;mut self` 都用於引用結構體實例，但有著不同的含義。</p>
<p><code>self</code> 表示方法使用結構體實例的所有權；而 <code>&amp;mut self</code> 則表示方法使用結構體實例的可變引用。</p>
<p>具體來說，當使用 <code>self</code> 定義方法時，這個方法會接受結構體實例的所有權，即將結構體實例移動到方法中，可以在方法內部進行修改或銷毀。當方法執行完畢後，結構體實例的控制權會返回到調用方。</p>
<p>而使用 <code>&amp;mut self</code> 定義方法時，這個方法會接受結構體實例的可變引用。當方法被調用時，結構體實例依然保持存在，並且可以在方法內部進行修改。當方法執行完畢後，結構體實例保持存在並且可以繼續使用。</p>
<p>總體來說，使用 <code>self</code> 比使用 <code>&amp;mut self</code> 更加靈活，但也更加危險，因為它轉移了結構體實例的所有權。而使用 <code>&amp;mut self</code> 可以讓方法在調用時保留結構體實例，並可以在方法內部進行修改，但需要注意如果結構體同時被多個可讀寫的引用進行修改，就會產生賽博會同步錯誤。因此，方法的實現必須小心處理對結構體實例的存儲和修改依賴關係。</p>
<p>首先，讓我們定義一個結構 <code>Person</code>，其中包含了一個名稱屬性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>接下來，我們為這個結構定義三種方法，分別使用 <code>self</code>、<code>&amp;self</code> 和 <code>&amp;mut self</code> 來引用實例。</p>
<ol>
<li>使用 <code>self</code> 引用實例，並修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn set_name(self, new_name: String) -&gt; Person {
        Person { name: new_name }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在這個方法中，<code>self</code> 為結構體的值，透過使用 <code>set_name</code> 方法，我們可以將一個 <code>Person</code> 結構體的名稱屬性更改為一個新的名稱，然後返回一個新的 <code>Person</code> 結構體，原來的實例沒有被修改。這種方式可以原地修改實例，因為它轉移了所有權。</p>
<ol>
<li>使用 <code>&amp;self</code> 引用實例，但不修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn greet(&amp;self) {
        println!(&quot;Hi, my name is {}&quot;, self.name);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在這個方法中，<code>&amp;self</code> 為結構體的借用引用，它將 <code>Person</code> 結構體的所有權借用給了 <code>greet</code> 方法，但不允許 <code>greet</code> 方法修改該實例的任何屬性。因此，這種方式適用於只需要讀取結構屬性的方法。</p>
<ol>
<li>使用 <code>&amp;mut self</code> 引用實例，並修改結構屬性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn rename(&amp;mut self, new_name: String) {
        self.name = new_name;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在這個方法中，<code>&amp;mut self</code> 為結構體的可變引用，透過使用 <code>rename</code> 方法，我們可以將一個 <code>Person</code> 結構體的名稱屬性更改為一個新的名稱。這種方式允許修改結構屬性，因為它使用了結構體的可變引用。</p>
<p>總結來說，這三種方式分別提供了不同的實例引用方法。使用 <code>self</code> 從原始的實例移動所有權，這在歸還新創建的 <code>Person</code> 結構體時特別有用。使用 <code>&amp;self</code> 或 <code>&amp;mut self</code> 以引用的方式讀取和修改結構屬性。使用 <code>&amp;self</code>可以保證實例是不可變的，而使用 <code>&amp;mut self</code> 允許修改實例的內容。</p>
<ul>
<li>
<p>在 Rust 中，<code>self</code> 和 <code>Self</code> 都表示結構體或枚舉的類型，但有著不同的含義。</p>
<p>self<code>在方法定義中是用來引用實例自身，而</code>Self<code>則用來表示結構體或枚舉本身的類型。下面是一個示例，說明瞭</code>Self<code>和</code>self` 的使用：</p>
<p>在這個示例中，我們定義了一個名為 <code>Rectangle</code> 的結構體，並為其實現了三個方法：<code>new</code>、<code>area</code> 和 <code>same</code>。</p>
<p>在 <code>new</code> 方法中，我們使用了 <code>Self</code> 來表示結構體的類型，並使用了 <code>self</code> 變量，它是一個引用結構體實例的不可變引用。這個方法創建了一個新的 <code>Rectangle</code> 結構體實例，並將其返回。</p>
<p>在 <code>area</code> 方法中，我們使用了 <code>&amp;self</code> 引用，這個方法只是計算結構體實例的面積，但不修改它。</p>
<p>在 <code>same</code> 方法中，我們使用了 <code>&amp;Self</code> 引用，這個方法不需要引用結構體實例本身，而是可以直接使用 <code>Rectangle</code> 類型來比較兩個實例是否具有相同的寬度和高度。</p>
<p>在 <code>main</code> 函數中，我們創建了一個 <code>Rectangle</code> 結構體實例，調用了 <code>area</code> 方法來計算實例的面積，並調用了 <code>same</code> 方法來檢查實例是否是一個正方形。</p>
<p>總結來說，<code>self</code> 主要用於方法中引用結構體實例本身，而 <code>Self</code> 則用作表示結構體或枚舉的類型。</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn new(width: u32, height: u32) -&gt; Self {
        Self { width, height }
    }

    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn same(rect: &amp;Self) -&gt; bool {
        rect.width == rect.height
    }
}

fn main() {
    let rectangle = Rectangle::new(10, 5);
    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rectangle.area()
    );
    println!(&quot;Is the rectangle a square? {}&quot;, Rectangle::same(&amp;rectangle));
}

</code></pre></pre>
<h2 id="handle-trait-的方式不同-1"><a class="header" href="#handle-trait-的方式不同-1"><code>Handle</code> trait 的方式不同</a></h2>
<p>第一個代碼示例中，我們在 <code>Handle</code> trait 中定義了一個實例方法 <code>handle()</code>，它接受一個 <code>&amp;self</code> 參數，表示該方法是與 <code>Handler</code> 結構體實例相關聯的。在實現 <code>Handle</code> trait 時，我們對每個需要處理的類型都分別實現了 <code>handle()</code> 方法，通過 <code>impl Handle&lt;i32&gt; for Handler</code> 和 <code>impl Handle&lt;f64&gt; for Handler</code> 定義了對 <code>i32</code> 和 <code>f64</code> 類型的處理過程。在 <code>main()</code> 中，我們創建了 <code>Handler</code> 結構體對象 <code>handler</code>，然後調用 <code>handler.handle(10)</code> 和 <code>handler.handle(10.5)</code> 方法來處理輸入的不同類型數據。</p>
<pre><pre class="playground"><code class="language-rust">struct Handler;

trait Handle&lt;T&gt; {
    fn handle(&amp;self, input: T);
}

impl Handle&lt;i32&gt; for Handler {
    fn handle(&amp;self, input: i32) {
        println!(&quot;This is i32: {}&quot;, input);
    }
}

impl Handle&lt;f64&gt; for Handler {
    fn handle(&amp;self, input: f64) {
        println!(&quot;This is f64: {}&quot;, input);
    }
}

fn main() {
    let handler = Handler;

    // 使用 i32 類型的 Handler
    handler.handle(10);

    // 使用 f64 類型的 Handler
    handler.handle(10.5);
}
</code></pre></pre>
<p>第二個代碼示例中，我們在 <code>Handle</code> trait 中定義了一個關聯函數 <code>handle()</code>，它不需要 <code>&amp;self</code> 參數，表示該函數與 <code>Handler</code> 結構體實例無關。在實現 <code>Handle</code> trait 時，我們同樣對每個需要處理的類型都分別實現了 <code>handle()</code> 關聯函數，通過 <code>impl Handle&lt;i32&gt; for Handler</code> 和 <code>impl Handle&lt;f64&gt; for Handler</code> 定義了對 <code>i32</code> 和 <code>f64</code> 類型的處理過程。在 <code>main()</code> 中，我們不創建任何 <code>Handler</code> 的對象，而是直接對 <code>Handler</code> 結構體類型調用 <code>Handler::handle(10)</code> 和 <code>Handler::handle(10.5)</code>方法來處理輸入的不同類型數據。</p>
<p>因此，這兩段代碼的區別在於實現 <code>Handle</code> trait 的方式不同。第一個代碼示例中實現了一個實例方法 <code>handle()</code>，第二個代碼示例中實現了一個關聯函數 <code>handle()</code>。這兩個方法/函數的調用方式也不同。</p>
<pre><pre class="playground"><code class="language-rust">struct Handler;

trait Handle&lt;T&gt; {
    fn handle(&amp;self, input: T);
}

impl Handle&lt;i32&gt; for Handler {
    fn handle(&amp;self, input: i32) {
        println!(&quot;This is i32: {}&quot;, input);
    }
}

impl Handle&lt;f64&gt; for Handler {
    fn handle(&amp;self, input: f64) {
        println!(&quot;This is f64: {}&quot;, input);
    }
}

fn main() {
    let handler = Handler;

    // 使用 i32 類型的 Handler
    handler.handle(10);

    // 使用 f64 類型的 Handler
    handler.handle(10.5);
}
</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="30-天深入淺出-rust系列"><a class="header" href="#30-天深入淺出-rust系列"><a href="https://ithelp.ithome.com.tw/users/20111802/ironman/1742">30 天深入淺出 Rust</a>系列</a></h1>
<p>https://ithelp.ithome.com.tw/articles/10199503</p>
<p>這系列會假設你有基礎的程式能力，不管是什麼語言都行，至少知道一下比如「參考 (reference) 」是什麼，雖說我也會盡量以初學程式的角度講解，只是 Rust 這個語言本身就包含了不少比較進階的觀念，加上我很可能會舉其它程式語言當對照，同時本系列會以類 Unix (Linux, Mac) 的環境為主，如果你使用的是 Windows 大部份情況下應該不會有什麼問題。</p>
<p>本系列的程式都會在 Ubuntu 18.04 下測試過，如果有任何問題歡迎回報，如果你有任何問題歡迎留言問我，我很樂意解答的，或是你有任何建議也行，我會很高興的。</p>
<p>Rust 是由 Mozilla 所主導的系統程式語言，旨在快速，同時保證記憶體與多執行緒的安全，這代表者使用 Rust 開發基本上不會再看到諸如 Segmentation Fault 等等的記憶體錯誤了，強大的 trait 系統，可以方便的擴充標準函式庫，這讓 Rust 雖然是靜態的程式語言，卻也有極大的靈活性，同時目前也有不少的應用，比如網頁後端、系統程式還有 WebAssembly ，另外也因為其速度快與語法簡潔跟豐富的生態，也有不少公司用來處理極需要速度的部份，比如 Dropbox, npm 想知道還有誰用可以去看看<a href="https://www.rust-lang.org/en-US/friends.html">還有誰也在用</a></p>
<p>預計會花 20 篇左右把 Rust 語言介紹完，剩下的則是來實作一些實際的專案，以及介紹一些 Rust 的套件與生態系，
預計會做的有：</p>
<ul>
<li>連結 c 函式庫，跟現有的程式碼或第三方函式庫做整合，讓你不用重新造輪子</li>
<li>寫一個 python 的 native extension ，擴充 python 的功能</li>
<li>寫個指令列的程式，介紹使用 clap 做 argument parsing</li>
<li>寫個網頁後端，介紹 Rust 的 ORM diesel 與非同步的 tower-web 後端框架</li>
</ul>
<p>或是有任何建議，或者你覺得改做什麼樣的專案會更有趣的也歡迎提出。</p>
<h1 id="安裝環境"><a class="header" href="#安裝環境">安裝環境</a></h1>
<p>在正式開始教學前，我們要先把環境安裝好，請在終端機輸入以下指令：</p>
<pre><code class="language-shell">$ curl https://sh.rustup.rs -sSf | sh -- -y
</code></pre>
<blockquote>
<p><code>$</code> 是代表終端機的提示符號，你並不需要輸入這個符號</p>
</blockquote>
<p>另外 Rust 需要 GCC 之類的工具，如果您的環境是 Ubuntu，可以直接用以下指令安裝：</p>
<pre><code class="language-shell">$ sudo apt-get install -y build-essential
</code></pre>
<p>如果您的環境是 Windows，請至 <a href="https://rustup.rs/">https://rustup.rs</a> 下載 rustup-init 來安裝，而因本教學會使用到相當多指令，我會建議使用 <a href="http://cmder.net/">cmder</a> 來取代原本 Windows 內建的 cmd，或是直接使用 Visual Studio Code（VSCode）。</p>
<p>完成以上步驟後，您的電腦現在應該已安裝了以下程式：</p>
<ul>
<li>rustup: Rust 本身的安裝軟體及版本管理以及更新系統</li>
<li>rustc: Rust 的編譯器</li>
<li>cargo: Rust 的套件管理器</li>
</ul>
<p>剛安裝完，為了確保環境變數有正確設定，你需要在終端機執行下方指令：</p>
<pre><code class="language-shell">$ source $HOME/.cargo/env
</code></pre>
<p>而在你下次登入後 Rust 應該已經幫你自動設定好環境變數了，你就不需要再執行上面那條指令。</p>
<p>接著，可以使用 rustc --version 來查看已安裝的版本，如有正確顯示目前的版本，就代表安裝好囉，在本文撰寫時穩定版為 1.29.1。</p>
<p>一切都安裝設置好後，不免的，我們來寫個「Hello, World!」吧！開啟喜歡的編輯器並輸入以下程式碼：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<blockquote>
<p>這邊的 <code>!</code> 並不是打錯了， <code>println!</code> 是在一起的，在 Rust 裡以 <code>!</code> 結尾的東西是巨集 (macro) ，現在只需理解 <code>println!</code> 在背後會幫你產生一些程式碼，讓你可以用簡單的方式就完成印到螢幕這個動作，之後會介紹如何自己寫巨集。</p>
</blockquote>
<p>完成後將程式存檔為 hello.rs ，並在終端機執行下方指令：</p>
<pre><code class="language-shell">$ rustc hello.rs
</code></pre>
<p>沒意外的話在同一個資料夾下將會看到名稱為 hello 的執行檔（Windows 下為 hello.exe）， 在終端機下執行：</p>
<pre><code class="language-shell">Hello world
</code></pre>
<p>恭喜您，您已完成了第一個 Rust 程式，從下一篇開始，我們將正式開始旅程，不過在這之前，讓我們安裝幾個好東西，這會讓我們接下來更佳順利。</p>
<pre><code class="language-shell">$ rustup component add rls-preview rustfmt-preview
</code></pre>
<p>最後的最後，Rust 有個線上的測試環境：<a href="https://play.rust-lang.org/">https://play.rust-lang.org</a> ，並且還安裝好了很多常用的套件，如果臨時有什麼想測試的可以直接在這個網站使用。</p>
<h1 id="rust-的套件管理工具-cargo-與套件倉庫"><a class="header" href="#rust-的套件管理工具-cargo-與套件倉庫">Rust 的套件管理工具 Cargo 與套件倉庫</a></h1>
<p>這篇要介紹的是 Rust 的套件管理工具 Cargo 以及套件倉庫 <a href="https://crates.io/">crates.io</a> 目前 crates.io 上有一萬八千多個套件，很多功能你都可以在上面找到別人幫你寫好的套件。</p>
<p>在 Rust 要使用別人寫好的套件你需要直接修改 <code>Cargo.toml</code> 這個檔案，把套件的名字以及你需要的版本加進去，但無需擔心，它的寫法很簡單的，以下是個範例：</p>
<pre><code class="language-toml">[package]
name = &quot;guess&quot;
version = &quot;0.1.0&quot;
authors = [&quot;DanSnow&quot;]

[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<blockquote>
<p><code>Cargo.toml</code> 跟 Node.js 的 <code>package.json</code> 的用途很像。</p>
</blockquote>
<p>我們來建立我們的第一個專案吧，請打開終端機輸入以下的指令：</p>
<pre><code class="language-shell">$ cargo init guess
</code></pre>
<p>這時你的目錄下應該有個名稱為 <code>guess</code> 的資料夾並且你可以看到底下的檔案與資料夾：</p>
<pre><code class="language-plain">guess
├── Cargo.toml
├── .gitignore
└── src
    └── main.rs
</code></pre>
<blockquote>
<p><code>.</code> 開頭的檔案或目錄在類 Unix 系統下是隱藏檔，如果你使用的是 Ubuntu 預設的檔案管理員的話你可以按 <code>Ctrl+H</code> 顯示所有檔案。你也可以使用指令 <code>ls -a</code> 顯示檔案。</p>
</blockquote>
<p>其中 <code>src/main.rs</code> 就是我們接下來要修改的專案主程式的程式碼了，你會看到裡面已經有 Hello world， <code>Cargo.toml</code> 也已經幫你填好了基本的設定， 我們現在試著輸入 <code>cargo run</code> 來執行看看：</p>
<pre><code class="language-shell">$ cargo run
   Compiling guess v0.1.0 (guess)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/guess`
Hello, world!
</code></pre>
<p>這次要做的是個終極密碼的小遊戲，主要遊戲方式是由使用者輸入數字，電腦回答是比答案大還是小，若沒猜中則猜到中為止的遊戲，接下來我們會一邊介紹基本語法一邊完成這個遊戲，不過我們先幫我們的專案加上一個套件吧，打開 <code>Cargo.toml</code> ，找到有一行為 <code>[depeendencies]</code> ，在它底下加上：</p>
<pre><code class="language-toml">rand = &quot;0.5.5&quot;
</code></pre>
<p>這個套件的功能是產生隨機的數字，如果沒有它，我們的小遊戲每次的答案就要一樣了。</p>
<p>不過像這樣手動編輯檔案也挺容易出錯的，我們有個更好的方法，請你輸入底下的指令：</p>
<pre><code class="language-shell">$ cargo install cargo-edit
</code></pre>
<p>這會幫 cargo 擴充新的功能，現在我們可以用底下的指令來加上套件了：</p>
<pre><code class="language-shell">$ cargo add rand
</code></pre>
<p>是不是方便多了？</p>
<h1 id="rust-基礎"><a class="header" href="#rust-基礎">Rust 基礎</a></h1>
<p>我們直接打開 <code>main.rs</code> 來寫我們的程式吧，首先 <code>//</code> 開頭的是程式的註解，它是給人看的，電腦看到會直接忽略，我直接使用註解來說明程式的內容，希望你可以照著程式碼自己打一遍，這樣做相信會比較有印像，當然，註解的部份可以不用照著打，你也可以用你自己的方式用註解做筆記。請照著底下的內容輸入：</p>
<pre><pre class="playground"><code class="language-rust">// 宣告使用外部的函式庫 rand
// 這告訴我們的編譯器我們要使用 rand 這個套件
extern crate rand;

// 引入需要的函式，如果不引入的話我們就需要在程式中打出全名來，
// 比如像下面使用到的 thread_rng 的全名就是 rand::thread_rng ，
// 但這裡我們選擇引入 rand::prelude::* 這是個比較方便的寫法，
// 很多套件的作者為了使用者方便，都會提供個叫 prelude 的模組，
// 讓你可以快速的引入必要的函式，我們要使用的 thread_rng 也有包含在裡面，
// 但並不是每個套件作者都會這麼做，請注意。
use rand::prelude::*;

// 這是標準輸入，也就是來自鍵盤的輸入，我們等下要從鍵盤讀玩家的答案。
use std::io::stdin;

// 這是一備函式，函式就是一段的程式，
// 我們可以在一個程式裡根據不同的功能將程式拆成一個個的函式，
// 不過今天這個程式並不大，我們直接全部寫在 main 這個函式裡就好了，
// main 是個特殊的函式， Rust 的程式都會從 main 開始執行。
fn main() {
    // 我們在這定義了一個變數 ans 來當作我們的答案，
    // 將它設定成 1~100 之間的隨機數字
    let ans = thread_rng().gen_range(1, 100);

    // 這邊又定義了兩個變數，分別代表答案所在的上下範圍，
    // 之後我們要把這個範圍做為提示顯示給玩家，
    // 因為之後需要修改這兩個變數的值，所以這邊必須加上 mut 來表示這是可修改的
    let mut upper_bound = 100;
    let mut lower_bound = 1;

    // 這是迴圈，它會重覆的執行包在這裡面的內容，
    // 因為這邊的迴圈沒有條件，所以它會一直反覆的執行，
    // 直到執行到如 break 才會結束，
    // 等下還會介紹另外兩種有條件的迴圈
    loop {
        // 這邊要建一個用來暫放玩家輸入的答案用的變數，
        // String 是個存放一串文字用的型態，也就是字串型態，
        // String::new 會建立一個空的字串
        let mut input = String::new();

        // 這邊要印出提示使用者輸入的顯示，同時我們也印出答案所在的上下界，
        // println! 在印完會自動的換行，也就是接下來的輸入輸出會從下一行開始，
        // 而裡面的 {} 則是用來佔位子用的，分別是我們要印出上下界的位置，
        // 之後傳給 println! 的變數就會被放在這兩個位置
        println!(
            &quot;答案在 {}~{} 之間，請輸入一個數字&quot;,
            lower_bound, upper_bound
        );

        // 這邊我們使用 read_line 從鍵盤讀入一整行進來，
        // 也就是到玩家按下 Enter 的字都會讀進來，
        // 讀進來的文字會被放進 input 裡，
        // 而因為放進 input 代表著修改 input 的內容，
        // 所以這邊比較特別一點，我們要加上 &amp;mut 來允許 read_line 修改 input ，
        // 而 read_line 會除了把輸入放進 input 外也會傳回是否有成功讀取輸入，
        // 於是這邊就使用了 expect 來處理，若回傳的值代表錯誤時，
        // expect 會印出使用者傳給它的訊息並結束掉程式
        stdin().read_line(&amp;mut input).expect(&quot;Fail to read input&quot;);

        // trim() 會把字串前後的空白字元 (空格與換行) 去掉，
        // 而 parse::&lt;i32&gt;() 則是把字串從原本的文字型態轉換成數字，
        // 這樣我們在之後才可以拿它來跟答案做比較，
        // 我們這邊又重新定義了一次 input 來放轉換成數字後的結果，
        // 如果你有學過其它的語言可能會覺得奇怪，為什麼允許這麼做，
        // 這也是 Rust 一個有趣的地方， Rust 允許你重覆使用同一個變數名稱，
        // parse 也是回傳代表正確或錯誤的 Result 不過這次我們不用 expect 了，
        // 這次我們判斷是不是轉換失敗，如果是則代表玩家輸入了不是數字的東西，
        // 那我們就讓玩家再輸入一次， match 是用來比對多個條件的語法，之後
        // 會有一篇來介紹這個語法，因為它是 Rust 裡一個很強大的功能。
        let input = match input.trim().parse::&lt;i32&gt;() {
            // Ok 代表的是正確，同時它會包含我們需要的結果
            // 因此這邊把轉換完的數字拿出來後回傳
            // Rust 裡只要沒有分號，就會是回傳值
            Ok(val) =&gt; val,
            // Err 則是錯誤，它會包含一個錯誤訊息，不過我們其實不需要，
            // 這邊我們直接提示使用者要輸入數字並結束這次迴圈的執行
            Err(_) =&gt; {
                println!(&quot;Please input a number!!!&quot;);
                // continue 會直接跳到迴圈的開頭來執行，也就是 loop 的位置
                continue;
            }
        };

        // 這邊使用 if 來判斷玩家的答案跟正確答案是不是一樣，
        // if 會判斷裡面的判斷式成不成立，如果成立就執行裡面的程式，
        // 要注意的是判斷相等是雙等號，因為單個等於已經用在指定了。
        if input == ans {
            println!(&quot;恭喜你，你答對了&quot;);
            // break 則會直接結束迴圈的執行，
            // 於是我們就可以離開這個會一直跑下去的迴圈
            break;
        // 如果不一樣，而且玩家的答案比正確答案大的話就更新答案的上限
        } else if input &gt; ans {
            upper_bound = input;
        // else 會在 if 的條件不成立時執行，並且可以串接 if 做連續的判斷，
        // 像上面一樣。都不是上面的情況的話就更新下限
        } else {
            lower_bound = input;
        }
    }
}
</code></pre></pre>
<h2 id="變數宣告-1"><a class="header" href="#變數宣告-1">變數宣告</a></h2>
<p>定義一個變數的語法是像這樣的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ans: i32 = 42;
<span class="boring">}
</span></code></pre></pre>
<p>變數是用來存放程式的資料用的，等號在這邊是指定的意思，並不是數學上的相等，我們把 <code>42</code> 指定給 <code>ans</code> 這個變數，而因為 <code>42</code> 是一個數字，因此我們把 <code>ans</code> 這個變數指定為 <code>i32</code> 這個整數型態，然而事實上大部份情況下其實是不需要給型態的，因為 Rust 可以自動的從初始值，也就是你一開始指定的值推導出你的變數的型態。</p>
<p>在 Rust 裡預設變數是不可以修改的，一但給了值就不能改變，如果要能修改就必須加上 <code>mut</code> ，這可以讓你在之後還能修改變數的值。</p>
<h3 id="錯誤的範例"><a class="header" href="#錯誤的範例">錯誤的範例：</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ans = 42;
ans = 123; // 這邊重新指定了值給 ans ，但 ans 並沒有宣告為可改變的
<span class="boring">}
</span></code></pre></pre>
<h3 id="正確的範例"><a class="header" href="#正確的範例">正確的範例：</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ans = 42;
ans = 123;
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中的變數都必須要有初始值，如果沒有初始值會是一個錯誤，當然，你可以先宣告再給值，但只要有可能會發生沒有指定初始值的情況就會發生錯誤。</p>
<h3 id="錯誤的範例-1"><a class="header" href="#錯誤的範例-1">錯誤的範例：</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ans;
if true {
    ans = 42;
}
// 這邊我們沒有 else 的情況就使用了，所以 Rust 認為 ans 可能沒有初始值
println!(&quot;{}&quot;, ans);
<span class="boring">}
</span></code></pre></pre>
<h3 id="正確的範例-1"><a class="header" href="#正確的範例-1">正確的範例：</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ans;
if true {
    ans = 42;
} else {
    ans = 0;
}
println!(&quot;{}&quot;, ans);
<span class="boring">}
</span></code></pre></pre>
<h1 id="基本型態"><a class="header" href="#基本型態">基本型態</a></h1>
<p>在電腦裡資料都有其型態，電腦必須知道資料屬於哪一種才能做出正確的處理，而 Rust 的基本型態則有：</p>
<blockquote>
<p>以下為了說明都有在定義變數時把型態寫出來，但平常因為可以自動推導，所以並沒有必要寫出來。</p>
</blockquote>
<ul>
<li>unit: 型態是 <code>()</code> ，同時值也是 <code>()</code> ，這是一個代表「無」的型態</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  就是「無」，你沒辦法拿這個值來做什麼
let unit: () = ();
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>布林值 <code>bool</code>: 值只有真 <code>true</code> 與假 <code>false</code> ，一個代表真假的型態，同時也是判斷式所回傳的型態</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t: bool = true;

// if 判斷的結果一定要是布林值，其實所有的判斷式的結果也都是布林值
if t {
    println!(&quot;這行會印出來&quot;);
}

if false {
    println!(&quot;這行不會印出來&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>整數: 上面使用的 <code>i32</code> 就是整數，實際上整數家族有具有正負號的 <code>i8</code> 、 <code>i16</code> 、 <code>i32</code> 、 <code>i64</code> 、 <code>i128</code> 與只能有正整數的的 <code>u8</code> 、 <code>u16</code> 、 <code>u32</code>、 <code>u64</code> 、 <code>u128</code> 它們之間的差別在有沒有正負號，以及能存的數字最大的大小，平常通常只會用到 <code>i32</code> ，先只要記得 <code>i32</code> 就行了</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i32 = 123;
// 數字你可以做基本的四則運算：加法 (+) 、減法 (-) 、乘法 (*) 、除法 (/)
// 和 取餘數 (%) ，當然也還有比如取絕對值之類的方法在，不過這邊先不提
println!(&quot;1 + 1 = {}&quot;, 1 + 1);
println!(&quot;10 % 3 = {}&quot;, 10 % 3);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>浮點數： 就是小數，有 <code>f32</code> 與 <code>f64</code> ，但平常只會用到 <code>f64</code> ，浮點數也可以像整數一樣做計算，只是無法取餘數</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi: f64 = 3.14;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>字串: <code>String</code> ，代表的是一串的文字，另外還有切片型態的 <code>str</code> (這兩個詳細的差別之後再提) ，如果你要讀使用者的輸入或是要能夠修改內容的要用 <code>String</code> ，如果要放固定的字串 (比如顯示的訊息) 用 <code>str</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message: &amp;str = &quot;這是個固定的訊息&quot;;
println!(&quot;{}&quot;, message);
let mut s: String = String::from(&quot;可以用 from 來建一個 String&quot;);
s.push_str(&quot;，同時你也可以增加內容在 String 的結尾&quot;);
println!(&quot;{}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>字元: <code>char</code> 一個字就是一個字元，比如 <code>'a'</code> 或是 <code>'三'</code> 也是</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c1: char = '中';
let c2: char = '文';
let c3: char = '也';
let c4: char = '行';
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>這邊為了說明都有在變數後加上型態，如果平常沒加型態而是讓編譯器自動推導的話，整數預設會使用 <code>i32</code> ，符點數會使用 <code>f64</code> ，但若之後把變數傳入了其它函式，則會配合那個函式的需求改變。</p>
</blockquote>
<h2 id="複合型態"><a class="header" href="#複合型態">複合型態</a></h2>
<ul>
<li>陣列 (array) ：由一串相同型態與固定長度的資料組成的</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i32 是元素的型態， 4 則是長度
let mut array: [i32; 4] = [1, 2, 3, 4];

// 這邊印出第一個數字與最後一個數字，陣列的編號是從 0 開始的
println!(&quot;{}, {}&quot;, array[0], array[3]);

// 我們也可以修改元素的值，同樣的，請注意上面的定義是有加 mut 的
array[1] = 42;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>元組 (tuple)：可由不同的型態組成</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 元組的型態要把每個欄位的型態都寫出來
let mut tuple: (i32, char) = (42, 'a');

// 印出第一個值
println!(&quot;{}&quot;, tuple.0);

// 改變第二個值
tuple.1 = 'c';
<span class="boring">}
</span></code></pre></pre>
<h2 id="條件判斷-if"><a class="header" href="#條件判斷-if">條件判斷 <code>if</code></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// if 裡面要放條件判斷，或是布林值，
// 條件判斷除了上面出現的 == 、 &gt; 、 &lt; 外還有個不等於
if 10 != 5 {
    println!(&quot;10 != 5&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果要判斷多個條件可以用底下的方式串起來：</p>
<ul>
<li><code>&amp;&amp;</code> ：「且」，兩邊都成立時才成立</li>
<li><code>||</code> ：「或」，其中一邊成立就成立</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if 2 &gt; 1 &amp;&amp; 3 &gt; 2 {
    println!(&quot;2 &gt; 1 且 3 &gt; 2&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>還有 <code>!</code> 可以把判斷式的結果反轉，也就是把布林值的 <code>true</code> 變 <code>false</code> ， <code>false</code> 變 <code>true</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !false {
    println!(&quot;這行會印出來&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>另外你可以用 <code>if</code> 來根據條件來指定變數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ans = if true {
// 請注意，這邊沒有分號
    42
} else {
    123
}; //  這邊要加分號
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 裡只要不加分號就會變回傳值</p>
</blockquote>
<h2 id="while"><a class="header" href="#while"><code>while</code></a></h2>
<p><code>while</code> 是有條件的迴圈，只有當條件滿足時才會繼續執行下去：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
while i &lt; 5 {
    println!(&quot;i = {}&quot;, i);
    // 這是 i = i + 1; 的縮寫，數學運算都可以這樣寫
    if i == 3 {
        // 我們在 i 為 3 時就結束迴圈了，所以你會看到從 0 印到 3
        break;
    }
    i += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>而 <code>break</code> 可以用來中斷迴圈，而 <code>continue</code> 可以直接結束這次的迴圈，跳到迴圈的開頭執行。</p>
<h2 id="for"><a class="header" href="#for"><code>for</code></a></h2>
<p><code>for</code> 是用來跑過一個「範圍」的資料的，比如像陣列，以後會再詳細介紹背後的機制。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in [1, 2, 3, 4, 5].iter() {
    println!(&quot;{}&quot;, item);
}

for item in 0..5 {
    println!(&quot;{}&quot;, item);
}
<span class="boring">}
</span></code></pre></pre>
<p>其中 <code>0..5</code> 是 Rust 的 <code>range</code> 代表的是 0~4 (不含結尾)，含結尾的話要寫成 <code>0..=5</code> (有等號)，這代表一個數字的範圍，以後講到切片時會再提到。</p>
<h2 id="函式-1"><a class="header" href="#函式-1">函式</a></h2>
<p>上面說了函式就是一小段的程式，如果你的程式裡出現了重覆的程式碼，你可以試著把程式碼抽出來變成函式，這樣以後要修改也會比較方便。</p>
<p>函式來自於數學的函數的觀念「給予一個值，會對應到另一個固定的值」，函式同樣的也需要輸入的值與輸出的值，底下是個範例：</p>
<pre><pre class="playground"><code class="language-rust">// 這個函式有兩個整數的輸入值 a 與 b 並且回傳一個整數
// 函式的開頭是 fn 接下來跟著函式的名字，後面的括號裡放著函式的輸入
// 其中當作輸入的鑾數都一定要有型態，之後 -&gt; 後放著的是回傳的型態
fn add(a: i32, b: i32) -&gt; i32 {
    // 這邊示範如何使用 return ，如果 a 與 b 都是 1 ，就直接回傳 2
    if a == 1 &amp;&amp; b == 1 {
        // return 會提早結束函式的執行，並且把後面的值當成回傳值
        return 2;
    }
    // 注意這邊沒有括號，沒有括號的代表回傳值，當然你也可以像上面使用 return
    a + b
}

// 這個函式沒有寫出回傳值，這代表它其實會回傳一個 () ，只是可以省略不寫出來而已
fn print_number(num: i32) {
    println!(&quot;{}&quot;, num);
}

// 所以其實 main 函式回傳的也是 unit
fn main() {
    // 像這樣子就可以呼叫函式了
    let num = add(1, 2);
    print_number(num);

    // 你也可以寫在一起
    print_number(add(1, 2));
}
</code></pre></pre>
<p>這篇我們很快的介紹了 Rust 的基本語法，下一篇要介紹的是 Rust 的參考，以及 Rust 中很重要的變數的所有權的觀念。</p>
<h1 id="變數的所有權與借出變數"><a class="header" href="#變數的所有權與借出變數">變數的所有權與借出變數</a></h1>
<h2 id="move-borrow--ownership"><a class="header" href="#move-borrow--ownership">Move, Borrow &amp; Ownership</a></h2>
<p>這篇與下一篇要介紹 Rust 中可說是最複雜，卻也是最重要的一個觀念，變數的所有權 (ownership) ，在 Rust 中每個變數都有其所屬的範圍 (scope) ，在變數的有效的範圍中，可以選擇將變數「借 (borrow)」給其它的 scope ，也可以將所有權整個轉移 (move) 出去，送給別人喔，當然，送出去的東西如果別人不還你的話是拿不回來的，但借出去的就只是暫時的給別人使用而已。</p>
<h2 id="move-1"><a class="header" href="#move-1">Move</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let message = String::from(&quot;Hello&quot;);
  {
    message;
  }
  println!(&quot;{}&quot;, message);
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?gist=2e8d72baf064c582fcd1d7563b0ed682&amp;version=stable&amp;mode=debug&amp;edition=2015"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<blockquote>
<p>範例的下方若有個 <img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /> 的連結，按下去就會連到 Rust Playground ，讓你可以直接執行範例。</p>
</blockquote>
<blockquote>
<p>補充一個之前忘了提的東西， <code>!</code> 在這邊並不是打錯了， <code>println!</code> 是一起的</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn greet(message: String) {
  println!(&quot;{}&quot;, message);
}

fn main() {
  let message = String::from(&quot;Hello&quot;);
  greet(message);
  println!(&quot;{}&quot;, message);
}
</code></pre></pre>
<p>猜看看上面的兩段程式碼的執行結果是什麼，猜到了嗎，答案都是無法編譯，編譯器會出現：</p>
<pre><code class="language-plain">error[E0382]: use of moved value: `message`
</code></pre>
<p>意思是使用了已經送給別人的變數，在 Rust 中一個程式碼的區塊， 也就是由 <code>{</code> 與 <code>}</code> 包圍的區域都是一個 scope ，這也包含了函式、迴圈的括號等等，只要你把變數傳給了其它區塊，都會把變數送出去，所以在上面的範例中， <code>message</code> 這個變數已經送出去，並且在接下來的 <code>println!</code> 無法使用了，另外在底下的情況也會送出變數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = String::from(&quot;a&quot;);
let b = a;
println!(&quot;{}&quot;, a); // 這邊也同樣不能編譯
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>或許你已經注意到了，這邊使用的都是 <code>String::from</code> ，都是在建立字串，如果把上面的例子都換成數字的話，你會發現不會出現任何錯誤，而能順利的執行，因為數字可以 <strong>複製</strong> ，字串不能複製嗎？也可以，只是字串的大小並不固定，有可能是很長的一篇文章，也有可能是一個空字串， Rust 並不允許在沒有明確的說要複製的情況下複製這種不知道會花費多少成本的型態，如果要改寫上面的範例，複製一個字串的話，可以使用 <code>clone</code>：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = String::from(&quot;a&quot;);
let b = a.clone();
println!(&quot;{}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?gist=bbd5cea5645d6f17a52376a1105d2ef6&amp;version=stable&amp;mode=debug&amp;edition=2015"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<blockquote>
<p>數字的大小則是固定的，於是在發生把變數送出去的情況時， Rust 會使用複製一份的方式給別人，所以就變成了兩個人都擁有，不會發生錯誤的情況。</p>
<blockquote>
<p>如果你想知道哪個型態可以被複製，可以參考文件的 <a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html"><code>std::marker::Copy</code></a> ，你會在底下看到如 <code>impl Copy for i32</code> 這就代表 <code>i32</code> 可以被複製</p>
</blockquote>
</blockquote>
<p>拿走的東西主動的還回去也是可以的：</p>
<pre><pre class="playground"><code class="language-rust">// 我要拿走整個 message 變數
fn greet(message: String) -&gt; String {
  println!(&quot;{}&quot;, message);
  message // 之後再還回去
}

fn main() {
  let message = String::from(&quot;Hello&quot;);

  // 這邊變數被拿走了，但是又還了回來，於是我們需要一個變數代表它
  // 當然你也可以使用同樣的名稱 message
  let msg = greet(message);

  println!(&quot;{}&quot;, msg); // 又拿回來了，於是可以使用
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?gist=0ef153bf8dae80d3d812b57dd934e6c9&amp;version=stable&amp;mode=debug&amp;edition=2015"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<h2 id="borrow"><a class="header" href="#borrow">Borrow</a></h2>
<p>Rust 中把出借變數直接稱為 borrow ， Rust 中使用在變數前面加一個 <code>&amp;</code> 來代表出借變數，borrow 的用途是當你不想把變數送出去時，你就可以把你的變數 <strong>借</strong> 出去，但還有個前提是對方要 <strong>願意跟你借</strong> ，底下是個借出變數給函式的範例：</p>
<pre><pre class="playground"><code class="language-rust">// 這邊在 String 的前面加上了 &amp; 代表我可以跟別人用借的
fn greet(message: &amp;String) {
  println!(&quot;{}&quot;, message);
}

fn main() {
  let message = String::from(&quot;Hello&quot;);
  greet(&amp;message); // 這邊加上了 &amp; 來表示借出去
  println!(&quot;{}&quot;, message); // 借出去的東西只是暫時給別人而已，自己還可以使用
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?gist=a1740013bff718d8141cec6cba465392&amp;version=stable&amp;mode=debug&amp;edition=2015"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<pre><pre class="playground"><code class="language-rust">// 這邊沒有加上 &amp; 代表我想要整個拿走
fn greet(message: String) {
  println!(&quot;{}&quot;, message);
}

fn main() {
  let message = String::from(&quot;Hello&quot;);
  // greet(&amp;message); // 這邊就算加上了 &amp; 也沒辦法把變數用借的借出去
  greet(message); // 一定要整個給它
  // println!(&quot;{}&quot;, message); // 因為被整個拿走了，所以這邊已經沒辦法使用了
}
</code></pre></pre>
<p>Rust 預設借給別人的東西別人必須原封不動的還回來，也就是借出去的變數是沒辦法被修改的，如果你想允許別人修改的話，你就必須使用 <code>&amp;mut</code> 對方也必須明確的使用 <code>&amp;mut</code> 來代表我要借到一個可以修改的變數：</p>
<pre><pre class="playground"><code class="language-rust">fn combine_string(target: &amp;mut String, source: &amp;String) {
  // push_str 會把傳進去的字串接到字串的後面
  target.push_str(source);
}

fn main() {
  // 這邊一定要加 mut ，因為這個變數會被修改，就算不是你自己改的也一樣
  let mut message = String::from(&quot;Hello, &quot;);
  let world = String::from(&quot;World&quot;);
  // 借給 combine_string 一個可以改的變數 message ，與一個不能改的 world
  combine_string(&amp;mut message, &amp;world);
  println!(&quot;{}&quot;, message); // 這邊就會印出 Hello, World
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?gist=845ebd1e9abf0c3cdf0def4f5dbcad1e&amp;version=stable&amp;mode=debug&amp;edition=2015"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<blockquote>
<p>還記得前一篇的猜數字裡有 <code>stdin().read_line(&amp;mut input)</code> 嗎？</p>
</blockquote>
<h2 id="borrow-的規則"><a class="header" href="#borrow-的規則">Borrow 的規則</a></h2>
<p>Rust 的出借變數是有其規則在的：</p>
<ol>
<li>所有的變數一次都只能用可以修改的方式 (<code>&amp;mut</code>) 出借一次</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 42;
let a = &amp;mut n;
let b = &amp;mut n; // 這裡用可以修改的方式總共借出去兩次了，這是不可以的
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>可以無限的用唯讀的方式借出去</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 42;
let a = &amp;n;
let b = &amp;n;
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>一旦用可以修改的方式 (<code>&amp;mut</code>) 出借，那你就不能用任何其它的方式存取變數了</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 42;
{
  let a = &amp;mut n;
  // println!(&quot;{}&quot;, n); // 你不可以使用原本的 n
  // let b = &amp;n; // 你也不可以再用任何方式借走 n
}
println!(&quot;{}&quot;, n); // 我們離開了 a 借走 n 的範圍了，於是 n 又可以用了
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>一旦你用唯讀的方式借出了變數，你就不可以修改變數</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 42;
{
  let a = &amp;n;
  // n = 123; // 又不可以了，有夠煩的(X
}
n = 123; // 這邊才可以修改
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>這些規則是用來確保多執行緒時不會有資料競爭用的，也就是同時有兩個人修改了同一個變數，於是一次只允許有一個變數的擁有者能修改變數的值，同時一但借出了變數就不能隨意修改，因為別人不一定會知道變數被修改了。雖然有點麻煩 (也真的很麻煩) ，但往好處想，變數不再會被隨意的修改了。</p>
</blockquote>
<p>有點可惜的是目前的 <code>borrow checker</code> ，也就是檢查，並執行上面這些規則的功能，它並不是很完善，比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [123, 456];
let a = &amp;mut array[0];
let b = &amp;mut array[1];
<span class="boring">}
</span></code></pre></pre>
<p>兩個變數分別借走了不相干的兩個部份，但這沒辦法通過檢查，不過這在 Rust 2018 將會有所改善，敬請期待。</p>
<blockquote>
<p>Q： Rust 2018 是什麼？
A： 在今年的年底 Rust 將要推出 2018 年版，版本號會是 1.30 ，將會有不少的改進以及部份的語法的變更。
Q： 什麼！那我現在學的這些東西到年底就都沒辦法用了？
A： 放心好了，大部份的是功能的增強與新的語法，只有一小部份的修改，之後會有一篇來討論這些修改，與看看有哪些新功能。
Q： 那我不想更新可以嗎？
A： 可以，你可以設定使用現在的語法版本，也就是 Rust 2015 版。
Q： 那我要怎麼設定？
A： 這個之後再說。</p>
</blockquote>
<h2 id="string--str-array--slice"><a class="header" href="#string--str-array--slice">String &amp; str, Array &amp; Slice</a></h2>
<p>我們之前應該有提到過 Rust 有兩種字串 <code>String</code> 與 <code>str</code> ，可是一直沒有詳細說明這兩個的差別，這邊我們要提到 Rust 的一個東西「切片 (slice)」，切片可以理解為一次出借如陣列或字串這類的連續的資料型態的一部份：</p>
<blockquote>
<p>如果你有寫過 Python 你可能知道 Python 的切片 <code>array[1:3]</code> ，只是這邊把 <code>:</code> 換成了 <code>..</code> 而已。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [0, 1, 2, 3, 4, 5];
{ // 建立一個區塊，不然我們等下沒辦法使用原本的 array
  let slice: &amp;mut [i32] = &amp;mut array[1..3]; // 這邊一次的借走了 array 的第 2 跟第 3 個元素

  // 然後我們修改了切片的第 1 個元素，對應到原本的 array 則是第二個元素
  slice[0] = 42;

  println!(&quot;{:?}&quot;, slice); // 會印出 [42, 2]
}
println!(&quot;{:?}&quot;, array); // 印出 [0, 42, 2, 3, 4, 5]
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 的切片會知道自己借走了多少長度的東西，而且跟原本的變數 <strong>會共用同一塊空間</strong> ，建立切片是不會複製任何資料的。</p>
</blockquote>
<p>你可以看到這邊的印出來的結果很明顯的修改了原本的資料，同時很重要的一點，切片 <strong>只能有 borrow 的型態</strong> ，因為切片的本質就是出借資料，切片能把資料出借一小段，而使用者可以把這段資料當成像陣列一樣使用。</p>
<blockquote>
<p><code>{:?}</code> 是把資料以 debug 的方式印出來，內建的型態不一定能直接印出來，但大部份都能用這種方式印出來，如果不能使用 <code>{}</code> 印出來時 <code>{:?}</code> 通常能派上用場。</p>
</blockquote>
<p>上面的 <code>slice</code> 的型態是 <code>&amp;mut [i32]</code> ，這就是切片型態的寫法，一般如果需要借走一個陣列都會使用切片型態，這樣可以給予使用者更大的彈性，比如決定要不要把整個陣列都借出去，或是隻借出一部份。</p>
<p>那終於可以來講 <code>str</code> 了， <code>str</code> 事實上就是字串的切片，而 <code>String</code> 則是一個可以在執行時改變大小的字串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 直接使用雙引號 (&quot;) 的字串都是字串的切片，它們都被 Rust 放在某個地方並且借給使用者使用而已
let hello: &amp;str = &quot;Hello&quot;;
// 建立一個 String
let string: String = String::from(hello);
// 借走字串的一部份，產生一個字串切片
let part_of_string: &amp;str = &amp;string[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>同樣的 <code>str</code> 也只能有 borrow 的型態。</p>
<h1 id="lifetime-borrow-的存活時間"><a class="header" href="#lifetime-borrow-的存活時間">Lifetime： Borrow 的存活時間</a></h1>
<p>Rust 有個重要的功能叫 borrow checker ，它除了檢查在上一篇提到的規則外，還檢查使用者會不會使用到懸空參照 (dangling reference) ，懸空參照是在電腦世界中一種現象： 如果你今天把一個變數借給別人，實際上借走的人只是知道我可以去哪裡找到這個別人借我的東西而已，那個東西的擁有者還是你本人，以現實世界做比喻的話，這像是借別人東西只是把放那個東西的儲物櫃位置，以及鑰匙暫時的交給別人而已，送別人東西則是直接把儲物櫃的擁有者變成他。</p>
<p>所以如果今天發生了一種情況，你把東西借給別人後，管理每個儲物櫃擁有者的系統馬上把你的使用權收回去呢？會發生什麼事，這沒人說的準，可能儲物櫃還沒被清空，你還是可以拿到借來的東西，或是馬上又換了主人，你已經不是拿到原本的東西了，就像以下的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt;&amp;i32 {
  // 這個變數在離開這個範圍後就消失了
  let a = 42;
  // 但是這邊卻回傳了 borrow
  &amp;a
}
<span class="boring">}
</span></code></pre></pre>
<p>上面這段 code 是無法編譯的。</p>
<p>為瞭解決這樣的一個問題， Rust 提出來的就是 lifetime 的觀念，只要函式的參數或回傳值有 borrow 出現，使用者就要幫 borrow 標上 lifetime ，標記後讓編譯器可以去追蹤每個變數借出去與釋放掉的情況，確保不會有釋放掉已經出借的變數的可能性。</p>
<p>Rust 使用 <code>'a</code> 一個單引號加上一個識別字當作 lifetime 的標記，所以這些都是可以的 <code>'b</code>, <code>'foo</code>, <code>'_bar</code> ，此外有兩個保留用作特殊用途的 lifetime: <code>'static</code> 和 <code>'_</code>：</p>
<ul>
<li><code>'static</code>： 這代表這是個整個程式都有效的 borrow 比如字串常數 <code>&quot;foo&quot;</code> 它的 lifetime 就是 <code>'static</code></li>
<li><code>'_</code>：這是保留給 Rust 2018 使用的，這裡先不提它的功能</li>
</ul>
<p>這邊是個加上 lifetime 標記後的範例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(a: &amp;'a i32) -&gt; &amp;'a i32 {
  a
}
<span class="boring">}
</span></code></pre></pre>
<p>其中我們必須在函式名稱後加上 <code>&lt;&gt;</code> 並在其中宣告我們的 lifetime ，接著把 borrow 的 <code>&amp;</code> 後都加上我們的 lifetime 標記，但事實上在上一篇文章中，我們完全沒用使用到 lifetime ， Rust 可以在某些情況下自動推導出正確的 lifetime ，使得實際上需要手動標註的情況並不多，最有可能遇到的情況是一個函式同時使用了兩個 borrow ：</p>
<pre><pre class="playground"><code class="language-rust">fn max&lt;'a&gt;(a: &amp;'a i32, b: &amp;'a i32) -&gt; &amp;'a i32 {
  if a &gt; b {
    a
  } else {
    b
  }
}

fn main() {
  let a = 3;
  let m = &amp;a;
  {
    let b = 2;
    let n = &amp;b;
    // 對於 max 來說， m 與 n 同時存活的這個範圍就是 'a ，
    // 而回傳值也可以在這個範圍內使用
    println!(&quot;{}&quot;, max(m, n));
  } // b 與 n 會在這邊消失
} // a 與 m 會在這邊消失
</code></pre></pre>
<p>這種情況編譯器因為看到了兩個 borrow ，於是沒辦法猜出來回傳的值應該要跟哪個 lifetime 一樣，這邊的作法就是全部都標記一樣的 lifetime ，讓 Rust 知道說我們的變數都會存活在同一個範圍內，同時回傳值也可以在同樣的範圍存活。</p>
<p>大部份的情況下編譯器都能自動的推導，所以需要手動標註的情況其實不多，通常是先嘗試讓編譯器做推導，如果編譯器報錯了才來想辦法標註。</p>
<p>lifetime 還有個用途是用來限制使用者傳入的參數必須是常數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_message(message: &amp;'static str) {
  println!(&quot;{}&quot;, message);
}
<span class="boring">}
</span></code></pre></pre>
<p>這個函式就只能接受如 <code>&quot;Hello&quot;</code> 這樣的常數了，雖說只是偶爾會有這樣的需求。</p>
<h2 id="lifetime-elision-lifetime-省略規則-進階-1"><a class="header" href="#lifetime-elision-lifetime-省略規則-進階-1">Lifetime Elision (Lifetime 省略規則) (進階)</a></h2>
<p>這部份大概的瞭解一下就好了</p>
<ol>
<li>所有的 borrow 都會自動的分配一個 lifetime</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: &amp;i32, b: &amp;i32);
fn foo&lt;'a, 'b&gt;(a: &amp;'a i32, b: &amp;'b i32); // 推導結果
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>如果函式只有一個 borrow 的參數，則它的 lifetime 會自動被應用到回傳值上</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: &amp;i32);
fn foo&lt;'a&gt;(a: &amp;'a i32) -&gt; &amp;'a i32; // 推導結果
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>如果有多個 borrow ，但其中一個是 <code>self</code> ，則 <code>self</code> 的 lifetime 會被應用在回傳值</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
  fn method(&amp;self, a: &amp;i32) -&gt; &amp;Self {
  }
}

// 推導結果
impl Foo {
  fn method&lt;'a, 'b&gt;(&amp;'a self, b: &amp;'b i32) -&gt; &amp;'a Self {
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>若不符合上面任一條規則，則必須要標註型態。</p>
<p>如果我們把以上的規則套用在上面的範例 <code>max</code> 上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: &amp;i32, b: &amp;i32) -&gt; &amp;i32 {
  if a &gt; b {
    a
  } else {
    b
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>套用規則 1 ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;'a, 'b&gt;(a: &amp;'a, i32, b: &amp;'b i32) -&gt; &amp;i32 {
  if a &gt; b {
    a
  } else {
    b
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>到這邊結束，編譯器已經沒有可用的規則了，但是回傳值的 lifetime 依然是未知，於是就編譯失敗。</p>
<h1 id="struct-與-oop"><a class="header" href="#struct-與-oop">Struct 與 OOP</a></h1>
<p>各位有在 C 裡實作過物件導向程式設計 (OOP) 嗎？
這篇要來介紹 Rust 中的 struct 以及 OOP。</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>首先來介紹一下結構 (structure) ， Rust 中宣告結構是用 <code>struct</code> 關鍵字，這跟 C/C++ 很像，不過不太一樣的是， Rust 中預設所有的成員 (member) 都是私有的 (private)。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
  pub public_member: i32,
  private_member: i32, // 這個結尾的逗號可加可不加，但是加上去是官方推薦的
}
<span class="boring">}
</span></code></pre></pre>
<p>結構讓你可以組合不同的型態，給每個欄位名字，最後組合出一個新的型態，在上面我們宣告了一個有公開的 <code>public_member</code> 與私有的 <code>private_member</code> 的 struct ，事不遲疑，我們寫個 <code>main</code> 來試用一下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let foo = Foo {
    public_member: 123,
    private_member: 456
  };
}
</code></pre></pre>
<p>Rust 裡建立一個結構就像這樣，在前面放上結構名稱，後面則是各個欄位以及它們的初始值，如果你有接觸過其它的 OOP 程式語言，你應該有注意到哪裡不太對勁了，為什麼我們可以直接使用應該是私有的 <code>private_member</code>？這不是違反封裝了嗎？在 Rust 中私有的成員代表的是隻能在這個 <code>package</code> 中存取 (你可以先理解為這個檔案，之後會詳細解釋 Rust 的模組架構) ，這就像 Java 的 <code>package</code> 修飾或 Kotlin 的 <code>internal</code> 或 C 中使用 <code>static</code> 的全域變數。</p>
<blockquote>
<p>封裝是把資料對外部隱藏起來，只允許使用方法存取，避免外部直接存取資料而導致程式的邏輯錯誤</p>
</blockquote>
<h2 id="more-struct"><a class="header" href="#more-struct">More Struct</a></h2>
<p>如果欄位的名稱不重要，或是隻是想建一個型態把其它的型態包裝起來的話
我們可以建一個 <strong>&quot;tuple struct&quot;</strong>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(i32, i32);
<span class="boring">}
</span></code></pre></pre>
<p>這像 tuple 與 struct 的融合體，如果要存取資料的話也跟 tuple 一樣：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Foo(1, 2);
foo.0;
foo.1;
<span class="boring">}
</span></code></pre></pre>
<p>另外還有完全沒有資料的 &quot;unit-like struct&quot;：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;
<span class="boring">}
</span></code></pre></pre>
<p>這個比較少用到，通常是配合 trait 來使用的。</p>
<h2 id="impl"><a class="header" href="#impl">Impl</a></h2>
<p>OOP 是把資料與操作資料的方法結合，藉此模擬現實的東西，於是少不了的，有了資料自然要有操作資料的方法。</p>
<pre><pre class="playground"><code class="language-rust">struct Person {
  name: String
}

impl Person {
  pub fn new(name: String) -&gt; Self {
    Person { name }
  }

  pub fn say_hello(&amp;self) {
    println!(&quot;Hello, my name is {}&quot;, self.name);
  }
}

fn main() {
  let john = Person::new(&quot;John&quot;.to_string());
  john.say_hello();
}
</code></pre></pre>
<p>Rust 使用一個分開的 <code>impl</code> 區塊來幫 struct 實作方法，這邊建立了一個 <code>Person</code> 的 struct ，與建構子 <code>new</code> 還有一個方法 <code>say_hello</code>，方法可以設定可見度，在前面加上 <code>pub</code> 就會變公開的方法了，在 Rust 中並沒有指定建構子的名字，所以稱為 <code>new</code> 只是一個慣例，因為 Rust 不允許多型 (Polymorphism)，也不允許函式的參數有預設值，所以在 Rust 中一個 struct 有多個不同的建構子也是常有的事，建構子所回傳的 <code>Self</code> 是一個特殊的型態，代表的是自己所實作的 struct ，在這邊你也可以寫 <code>Person</code>，不過如果要回傳自身都建議寫 <code>Self</code> ，因為它有一些好用的特性，在下一章會提到。</p>
<p>其中使用的 <code>Person { name }</code> 是個語法糖，當變數名稱與欄位名稱一致時，就可以把 <code>Person { name: name }</code> 簡寫。</p>
<p>若實作的 method 沒有 <code>self</code> 變數則代表這個方法是個 associated method ，它只是個跟 struct 搭配的方法而已，就像其它語言的 static method ，使用時要用 <code>Person::new</code> 來呼叫。</p>
<blockquote>
<p>多型是指函式可以有同一個名稱，但使用不同的參數，這在 OOP 也是很常見的一個特性，比如在 C++ 可以建立 <code>Persion()</code> 與 <code>Persion(string)</code> 兩個建構子，但接受不同的參數</p>
</blockquote>
<p><code>say_hello</code> 則是 <code>Persion</code> 的方法，而 <code>self</code> 是個特殊的變數，只會在實作時出現
它代表的是自己，如果要變成 struct 的方法則第一個參數必須是 <code>self</code>，同時宣告 <code>self</code> 時要決定使用什麼方式宣告，一般最常用的是唯讀的 borrow <code>&amp;self</code> 這代表你會用唯讀的方式存取自己，另外還有 <code>&amp;mut self</code> 這時候你就可以修改自己了，最後 <code>self</code> 這個比較少用， 若使用 <code>self</code> 代表你將會取得自身的所有權，呼叫這個方法將不再能存取這個 struct ，一般用在要將自身轉換成另一個型態，或是呼叫這個方法後自己就不再有效的情況。</p>
<p>大部份情況下還是使用 <code>&amp;self</code> 居多，呼叫方法則是用 <code>john.say_hello()</code> ，Rust 在這邊會自動的把 struct 轉成 borrow 的型態。</p>
<blockquote>
<p>Rust 中的所有的 function, method 都可以直接的存取與當成參數傳遞，比如在上面的例子，你可以使用 <code>Person::say_hello(&amp;john)</code> 來呼叫方法，這其實有一種像在 C 中實作 OOP 的感覺，而上面的呼叫方式反而像是語法糖一樣。</p>
</blockquote>
<h2 id="建造模式-builder-pattern"><a class="header" href="#建造模式-builder-pattern">建造模式 Builder Pattern</a></h2>
<p>Rust 不支援多型，也不支援預設參數，所以當建構子的參數多時就顯的很麻煩，把所有成員都設成公開的又破壞封裝，所以在 Rust 中常會看到建造模式，建造模式是個設計模式，其將會使用另一個 struct 以一系列的方法來建造我們要的目標，以 Rust 的標準函式庫中的 <a href="https://doc.rust-lang.org/stable/std/process/struct.Command.html"><code>std::process::Command</code></a> 為例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let output = Command::new(&quot;echo&quot;)
  .arg(&quot;Hello world&quot;)
  .output();
println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;output.stdout));
<span class="boring">}
</span></code></pre></pre>
<p>像這樣的方式就是建造模式，最後我們要拿到的目標是那個 <code>output</code> 變數，底下我們自己實做一個：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

impl Point {
    fn new(x: i32, y: i32, z: i32) -&gt; Self {
        Point { x, y, z }
    }
}

struct Builder {
  x: i32,
  y: i32,
  z: i32,
}

impl Builder {
  fn new(x: i32) -&gt; Self {
    Builder {
      x,
      y: 0,
      z: 0,
    }
  }

  fn y(&amp;mut self, y: i32) -&gt; &amp;mut Self {
    self.y = y;
    self
  }

  fn z(&amp;mut self, z: i32) -&gt; &amp;mut Self {
    self.z = z;
    self
  }
  
  fn build(&amp;self) -&gt; Point {
      Point::new(self.x, self.y, self.z)
  }
}

fn main() {
    let point = Builder::new(1)
        .y(2)
        .z(3)
        .build();
    println!(&quot;{:?}&quot;, point);
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?gist=5e7b08e230a379f9c05571f8bcb66d1b&amp;version=stable&amp;mode=debug&amp;edition=2015"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<p>這邊假設了 <code>x</code> 的值是必要的，另外兩個都可以用 0 當預設值，這樣就可以只指定想要的東西了。</p>
<h2 id="trait-與泛型-generic"><a class="header" href="#trait-與泛型-generic">Trait 與泛型 (Generic)</a></h2>
<h2 id="trait-1"><a class="header" href="#trait-1">Trait</a></h2>
<p>Trait 本身同時提供兩個功能，一是讓不同的型態去實作同樣的功能，再來就是提供實作來共用程式碼了，這同時也是 Rust 泛型的基礎。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Movable {
  fn move(&amp;self);
}

struct Human;

impl Movable for Human {
  fn move(&amp;self) {
    println!(&quot;Human walk&quot;);
  }
}

struct Rabbit;

impl Movable for Rabbit {
  fn move(&amp;self) {
    println!(&quot;Rabbit jump&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>於是不同的型別就能各自實作 trait 並提供自己專屬的實作，另外要注意的是： trait 的方法一定都是公開的。</p>
<p>trait 也可以提供預設的實作，與在使用者實作了特定的方法後提供像 mixin 的功能：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Greeter {
  fn greet(&amp;self) {
    println!(&quot;{}&quot;, self.message());
  }

  fn greet_to(&amp;self, name: &amp;str) {
    println!(&quot;{} {}&quot;, self.message(), name);
  }

  fn message(&amp;self) -&gt; &amp;'static str;
}

struct Someone;

impl Greeter for Someone {
  // 提供必要的方法
  fn message(&amp;self) -&gt; &amp;'static str {
    &quot;Hello&quot;
  }

  // 覆寫 (override) 預設實作
  fn greet_to(&amp;self, name: &amp;str) {
    println!(&quot;Yo {}&quot;, name);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>也可以指定要實作這個 trait 的同時要實作另一個 trait：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HasName: Greeter {
    fn name(&amp;self) -&gt; &amp;'static str;

    fn greet_with_name(&amp;self) {
        println!(&quot;{} my name is {}&quot;, self.message(), self.name());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>trait 中也可以宣告型態別名 (type alias)，這樣就能讓方法能輸入或回傳不同型態：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
  type Item;
  fn foo(&amp;self) -&gt; Self::Item;
}

struct Bar;

impl Foo for Bar {
  type Item = i32;

  fn foo(&amp;self) -&gt; Self::Item { 42 }
}
<span class="boring">}
</span></code></pre></pre>
<p>另外這邊我們都使用 <code>Self</code> ，因為你無法知道是誰會實作這個 trait。</p>
<h2 id="內建的-trait"><a class="header" href="#內建的-trait">內建的 Trait</a></h2>
<p>Rust 內建了很多的 trait ，只要實作了這些 trait 就能讓 Rust 知道你的型態能提供哪些功能，也能被標準函式庫或第三方的函式庫使用了，以下會介紹幾個比較重要的。</p>
<h3 id="display"><a class="header" href="#display">Display</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a> 是讓你的型態能被 <code>println!</code> 印出來</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);

// 當然這邊你可以先用 use std::fmt::Display; 這樣這邊就只需要使用 Display
impl std::fmt::Display for Point {
  fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
    write!(f, &quot;({}, {})&quot;, self.0, self.1)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>實作了這個 trait 還會自動實作 <a href="https://doc.rust-lang.org/stable/std/string/trait.ToString.html"><code>std::string::ToString</code></a> ，這是讓你的型態能轉換成字串。</p>
<h3 id="from"><a class="header" href="#from">From</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code>std::convert::From</code></a> 代表你的型態能從另一個型態轉換，之前所使用的 <code>String::from</code> 就是從這裡來的，同時若你實作了 <code>From</code> ，編譯器就會自動幫你實作 <code>Into</code>，<code>Into</code> 則是這個型態可以被轉換成某個固定的型態。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar;

// Foo 是來源的型態，這是等下要講的泛型
impl From&lt;Foo&gt; for Bar {
  fn from(_: Foo) -&gt; Self {
    Bar
  }
}

// 相對的你可以使用 let bar: Bar = Foo.into();
// 這裡也是少數要標記型態的，因為編譯器沒辦法自動推導
<span class="boring">}
</span></code></pre></pre>
<h3 id="add"><a class="header" href="#add">Add</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html"><code>std::ops::Add</code></a> 可以讓你的型態與別的東西做加法運算，同時這也是 Rust 的運算子重載， Rust 的所有運算子都有個 trait 在 <a href="https://doc.rust-lang.org/stable/std/ops/index.html"><code>std::ops</code></a>，只要實作了你就能使用那個運算子做運算了。</p>
<p>(這邊不提供範例，請去看文件裡的範例)</p>
<h3 id="deref-1"><a class="header" href="#deref-1">Deref</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>std::ops::Deref</code></a> 這是 Rust 裡一個很重要的運算子，就是取值的操作，只是這個取值也可以取得其它的型態，這代表著你可以用自己定義的型態去包裝不是由你建立的型態，並擴充它的功能，同時還能自動的「繼承」原先的型態所擁有的方法。</p>
<blockquote>
<p>這邊的繼承並不像其它語言的繼承，它只是在呼叫方法時透過 <code>Deref</code> 轉換成需要的型態而已。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::{ops::Deref, fmt};

#[derive(Copy, Clone)]
struct Num(i32);

impl fmt::Display for Num {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 直接呼叫被包裝的 i32 所實作的 fmt::Display
        fmt::Display::fmt(&amp;self.0, f)
    }
}

impl Num {
  fn inc_one(self) -&gt; Self {
    Num(self.0 + 1)
  }
}

impl Deref for Num {
  type Target = i32;

  fn deref(&amp;self) -&gt; &amp;Self::Target {
    &amp;self.0
  }
}

fn main() {
  let n = Num(42);
  println!(&quot;{}&quot;, n.inc_one()); // n 可以有新定義的方法
  println!(&quot;{}&quot;, n.abs()); // n 也可以有原本定義的方法
}
</code></pre></pre>
<h2 id="derivable-trait"><a class="header" href="#derivable-trait">Derivable Trait</a></h2>
<p>Derivable trait 是一些能自動 <strong>產生</strong> 實作的 trait ，如果要讓編譯器產生實作的話，就只要在你的型態上加上 <code>derive</code> 的標記：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default, Clone, Copy)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>請注意，它們是 <strong>產生</strong> 實作，這代表它們還是要有程式碼來實作，只是能自動產生而已，通常而言 derivable trait 會要求你的 struct 中每個欄位也都要實作同樣的 trait ，這樣才能遞迴下去</p>
</blockquote>
<p>也有不少內建的這樣的 trait ，以下也是介紹重要的</p>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>std::default::Default</code></a> 代表你的型態有預設值，Rust 裡的慣例也有如果實作了無參數的建構子，則也要實作 <code>Default</code> ，你也可以在建構子使用實作的 <code>Default</code> ，另外 <code>Default</code> 也還有個用途：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Point { x: i32, y: i32, z: i32 };

Point {
  x: 1,
  ..Default::default() // 剩下的值直接使用預設值
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="debug-1"><a class="header" href="#debug-1">Debug</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html"><code>std::fmt::Debug</code></a> 是用來印出 debug 資訊的，也就是 <code>println!</code> 使用 <code>{:?}</code> 印出來的結果。</p>
<h3 id="copy"><a class="header" href="#copy">Copy</a></h3>
<blockquote>
<p><code>Copy</code> 是個 marker trait ，這類的 trait 其實並沒有任何實作，它們的用途是讓編譯器知道這個型態的一些特性，以及在什麼情況下該怎麼處理。</p>
</blockquote>
<p><code>Copy</code> 是代表這個型態可以被簡單的複製，這通常代表你的型態裡只有包含像數字或是布林等型態的資料，如果包含了 <code>String</code> 或 <code>Vec</code> 就沒辦法實作這個 trait，另外如果有實作 <code>Copy</code> 則一定要實作 <code>Clone</code>。</p>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html"><code>std::clone::Clone</code></a> 是可被複製的型態，如果一個型態只有 <code>Clone</code> 而沒有 <code>Copy</code> 則通常代表這個型態的複製是需要成本的，比如 <code>String</code>，大部份的型態也都有實作 <code>Clone</code> ，如果你的型態允許複製也請務必實作 <code>Clone</code>，至於沒有實作 <code>Clone</code> 的型態基本上就是像 <code>File</code> 之類的因為它是對應到了一個實際存在的檔案。</p>
<h2 id="泛型-4"><a class="header" href="#泛型-4">泛型</a></h2>
<p>如果沒有泛型實際上 trait 也沒什麼作用，泛型可以讓一個函式接受不同型態的參數，同時透過指定要實作的 trait 來確保傳進來的參數一定滿足某些必要的條件，比如我想要傳進來的數字可以跟數字相加，而且回傳數字：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

fn print_add_one&lt;T: Add&lt;i32, Output = i32&gt;&gt;(n: T) {
  println!(&quot;{}&quot;, n + 1);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Add</code> 本身也是一個泛型的 trait 它的參數是用泛型，並且還帶有一個型態別名，我們可以在 <code>&lt;&gt;</code> 中指定泛型的參數，以及型態的別名，第一個 <code>i32</code> 指定的是泛型，而 <code>Output = i32</code> 指定的則是別名，於是這邊我們就能傳進去任何與 <code>i32</code> 相加後會回傳 <code>i32</code> 的東西了，你可以傳入數字，也可以試著把上面的 <code>Num</code> 加上 <code>Add</code> 的定義後傳進去試試， Rust 的編譯器在碰到泛型時會各別的幫出現的每個型態產生程式碼，所以是沒有任何額外的執行消耗的，這也是 Rust 所推的 zero-cost abstract。</p>
<p>泛型還有其它不同的寫法，比如你的型態太長了，那你可以先宣告，再補上 trait 的限制：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_add_one&lt;T&gt;(n: T)
  where T: Add&lt;i32, Output = i32&gt; {
  println!(&quot;{}&quot;, n + 1);
}
<span class="boring">}
</span></code></pre></pre>
<p>也可以直接寫在參數的宣告那邊，我比較喜歡這樣寫，這是在 Rust 1.27 後新增的語法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_add_one(n: impl Add&lt;i32, Output = i32&gt;) {
  println!(&quot;{}&quot;, n + 1);
}
<span class="boring">}
</span></code></pre></pre>
<p>另外你可以回傳實作了某種 trait 的回傳值，同樣是 1.27 的語法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_addable() -&gt; impl Add&lt;i32, Output = i32&gt;) {
  42
}
<span class="boring">}
</span></code></pre></pre>
<p>收到這個回傳值的使用者只會知道這個型態支援什麼東西，不會知道實際的型態</p>
<p>struct 或 trait 也可以使用泛型：</p>
<pre><pre class="playground"><code class="language-rust">struct Wrapper&lt;T&gt;{
  inner: T
}

impl&lt;T&gt; Deref for Wrapper&lt;T&gt; {
  type Target = T;
  fn deref(&amp;self) -&gt; &amp;T {
    &amp;self.inner
  }
}

fn main() {
  let n = Wrapper { inner: 42 };
  println!(&quot;{}&quot;, *n);
}
</code></pre></pre>
<h2 id="泛型--型態別名"><a class="header" href="#泛型--型態別名">泛型 &amp; 型態別名</a></h2>
<p>之前一直沒介紹 type alias 的語法，這語法其實並不是隻有在 trait 裡可以使用的，若你覺得某個型態你很常用到但太長了打起來很麻煩時你可以用這個語法來建立一個別名，也可以加上 pub 讓你的別名可以被外部使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyInt = i32;
<span class="boring">}
</span></code></pre></pre>
<p>像標準函式庫中的 <a href="https://doc.rust-lang.org/stable/std/io/type.Result.html"><code>std::io::Result</code></a> 就是一個很好的例子，它的定義如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Result&lt;T&gt; = Result&lt;T, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>這邊定義了有一個泛型的參數的 <code>Result</code> 做為原本的 <code>Result</code> 的別名，之後錯誤的型態則是使用 <code>Error</code> ，於是程式碼裡就不需要到處都是 <code>Result&lt;T, Error&gt;</code> 而只要寫 <code>Result&lt;T&gt;</code> 就可以了。</p>
<p>至於在 trait 中何時該用泛型，何時又該用型態別名呢？</p>
<p>大部份的情況下你應該使用型態別名，不過如果你的 trait 要可以針對不同的型態有不同的處理方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Handler;

trait Handle&lt;T&gt; {
  fn handle(input: T);
}

impl Handle&lt;i32&gt; for Handler {
  fn handle(input: i32) {
    println!(&quot;This is i32: {}&quot;, input);
  }
}

impl Handle&lt;f64&gt; for Handler {
  fn handle(input: f64) {
    println!(&quot;This is f64: {}&quot;, input);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>這時你該使用的是泛型。</p>
<h1 id="列舉解構模式比對"><a class="header" href="#列舉解構模式比對">列舉、解構、模式比對</a></h1>
<h2 id="列舉-enum"><a class="header" href="#列舉-enum">列舉 (Enum)</a></h2>
<p>列舉是 Rust 中的一個型態，其為多個 variant 所組成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
  Red,
  Green,
  Blue,
}
<span class="boring">}
</span></code></pre></pre>
<p>使用時必須要加上列舉的名稱，比如 <code>Color::Red</code> ，或是你也可以像引入函式庫一樣的，把 enum 內的 variant 用 <code>use</code> 引入，比如 <code>use Color::*</code> ，就會把 <code>Color</code> 下的 variant 都引入了。</p>
<p>不過 Rust 的列舉的特殊之處是 variant 可以帶值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum StringOrInt {
  String(String),
  Int(i32),
}
<span class="boring">}
</span></code></pre></pre>
<p>裡面的值就像 struct 一樣，也就是你可以不只一個值，或是給它們欄位的名稱：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Point {
  Point2D (i32, i32),
  Point3D {
    x: i32,
    y: i32,
    z: i32,
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中列舉除了用來表示有限的選項外，也可以用來傳遞型態不同的參數，像 <code>StringOrInt</code> 一樣。</p>
<p>另一個重要的應用是 <code>Option</code> 與 <code>Result</code> ，不知道大家還記不記得之前有提到過 <code>Result</code> 這個代表結果的型態呢，它就是列舉，其定義如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code>, <code>E</code> 是泛型的型態變數，分別代表正確時的回傳值，與發生錯誤時的錯誤物件，它是個泛型的列舉，而它也有提供一些方便的方法，比如 <code>expect</code> ，是的 Rust 的列舉是可以幫它定義方法的，同樣的用 <code>impl</code> 就可以了，也可以幫它實作 trait ，它就像 struct 一樣。</p>
<blockquote>
<p><code>Result::expect</code> 其實在之前就有使用過了，它的功能是在結果為 <code>Err</code> 時印出訊息並結束程式。</p>
</blockquote>
<p>再來我們剛剛還提到了 <code>Option</code> ， <code>Option</code> 是 Rust 中用來代表可能沒有值，它用來取代掉其它語言中的空指標 (<code>null</code>, <code>nil</code> ...) ，它用兩個值 <code>Some</code> 與 <code>None</code> 來代表有沒有值， Rust 中 <code>Result</code> 跟 <code>Option</code> 因為很常使用，所以它們跟它們的 variant 都已經被預先引入了，你可以不需要預先引入就可以使用。</p>
<p>它的定義則是這樣的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
  Some(T),
  None,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>在 Rust 中之所以沒有 <code>null</code> 的，因為 Rust 認為 <code>null</code> 很容易造成錯誤，並且使用 <code>Option</code> 可以強迫使用者先檢查是否有值。</p>
</blockquote>
<p>同時 <code>Option</code> 也同樣提供了很多方法可以使用，也有不少跟 <code>Result</code> 有共通的名稱與作用：</p>
<ul>
<li><code>Option::unwrap</code>: 直接把 <code>Option</code> 內的值取出來，若 <code>Option</code> 是 <code>None</code> 則會造成程式印出錯誤訊息後直接結束</li>
<li><code>Option::unwrap_or</code>: 取出值，若沒有值則回傳使用者提供的預設值</li>
<li><code>Option::unwrap_or_else</code>: 取出值，若沒有值則呼叫與使用者提供的函式，並使用回傳值當預設值</li>
</ul>
<p><code>unwrap_or_else</code> 常用在建立會需要消耗資源的情況，比如當我們在沒有值時需要空的 <code>String</code> 當預設值就會寫：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>something.unwrap_or_else(String::new);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>建議可以看一下 <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> 和 <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> 的文件，畢竟這兩個型態可說是一定會在 Rust 中接觸到，說不定它已經寫好函式提供你所要的功能了，上面列出的三個函式也都有 <code>Result</code> 的版本。</p>
</blockquote>
<p>而 Rust 也幫所有的型態實作了 <code>impl From&lt;T&gt; for Option&lt;T&gt;</code> 可以直接把任何型態的值轉換成 <code>Some</code>。</p>
<p>之前雖說沒有預設參數，不過搭配的泛型使用還是可以寫出像這樣的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">// 這邊的 i 用的是任何可以被轉換成 Option&lt;i32&gt; 的型態
fn print_number(i: impl Into&lt;Option&lt;i32&gt;&gt;) {
  println!(&quot;{}&quot;, i.into().unwrap_or(42));
}

fn main() {
  print_number(123);
  // 沒有值時還是需要明確傳 None 進去，這邊會印出 42
  print_number(None);
}
</code></pre></pre>
<h2 id="解構賦值-destructuring"><a class="header" href="#解構賦值-destructuring">解構賦值 (Destructuring)</a></h2>
<p>Rust 中的複合的型態 (陣列、元組、結構) 都可以做解構：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
  x: i32,
  y: i32,
}

let [a, b] = [1, 2];
let (num, msg) = (123, &quot;foo&quot;);
let Point { x, y } = Point { x: 10, y: 10 };
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是，解構是轉移所有權的操作，也就是說如果使用到了無法複製的型態，則它的值就會被移動，所以這邊要再來介紹一個關鍵字 <code>ref</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = &quot;Hello world&quot;.to_string();

// 底下這兩句的意思是一樣的
let borrowed_msg = &amp;msg;
let ref borrowed_msg = msg;
<span class="boring">}
</span></code></pre></pre>
<p>簡單來說 <code>ref</code> 代表要使用 borrow 來取得在右邊的變數，這在解構時非常有用，你可以這樣寫：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
  name: String,
}

let person = Person { name: &quot;John&quot;.to_string() };
let Person { ref name } = person;
<span class="boring">}
</span></code></pre></pre>
<p>這時候 <code>name</code> 就會用 borrow 的方式取得，而不會把原本的 <code>name</code> 值移出來。</p>
<p>同樣的也有 <code>ref mut</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Persion { ref mut name } = person;
<span class="boring">}
</span></code></pre></pre>
<p>這邊的 <code>name</code> 就會以可寫的方式 borrow，當然這邊也同樣的要套上之前介紹的 borrow 的規則，在 <code>name</code> 的 borrow 結束前你沒辦法使用 <code>person</code>。</p>
<p>如果想要在解構時忽略掉某一部份的的值的話怎麼辦呢，如果只想忽略掉某幾個值的話，你可以使用 <code>_</code>， <code>_</code> 是個特殊的變數名稱，Rust 不會把任何東西賦值給 <code>_</code> ，而會直接忽略，你可以想像它就是個黑洞：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [_, b, _] = [1, 2, 3];
let Point { x, y: _ } = Point { x: 1, y: 2 }; // 如果 y 的值是不能 copy 的，這邊並不會發生所有權轉移
<span class="boring">}
</span></code></pre></pre>
<p>如果想把其它的值都忽略掉呢，你可以使用 <code>..</code> ，這個目前只支援 struct 與 tuple：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (a, ..) = (1, 2, 3);
let Point { x, .. } = Point { x: 1, y: 2 };
<span class="boring">}
</span></code></pre></pre>
<p>要注意的是 <code>..</code> 只能在解構時出現一次</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (.., x, ..) = (1, 2, 3, 4); // 這裡的 x 應該要是多少呢
<span class="boring">}
</span></code></pre></pre>
<p><code>..</code> 也可以在你想要忽略掉 struct 中的私有成員時：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
  pub name: String,
  age: i32,
}

// 假設這邊是另一個模組，也就是無法取得私有成員的
// 因為你並不知道私有成員的名稱，所以是無法用 _ 的
let { ref name, .. } = person;
<span class="boring">}
</span></code></pre></pre>
<h2 id="模式比對-match"><a class="header" href="#模式比對-match">模式比對 (match)</a></h2>
<p>模式比對是 FP (Functional Programming) 裡一個重要的操作，它的語法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 若數字是 1 就印出「數字是 1」，以此類推
match 2 {
  1 =&gt; println!(&quot;數字是 1&quot;),
  2 =&gt; println!(&quot;數字是 2&quot;),
  3 =&gt; println!(&quot;數字是 3&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>match</code> ，這樣寫的話很像 C 的 <code>switch</code> ，除了它可以有回傳值以及沒有 <code>break</code> 的這點外</p>
</blockquote>
<p>那麼它強在哪邊呢，你可以把它搭配上面的解構使用，同時再加上可以帶值的列舉，就能寫出更複雜的判斷，像在 Rust 很常出現的一種錯誤處理方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match result {
  Ok(val) =&gt; {
    // 這邊就有成功的值可以用
  }
  Err(err) =&gt; {
    // 這邊可以做錯誤處理
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>如果你 <code>match</code> 裡放的是大括號的區塊，那可以不用加逗號，怕搞錯的話還是都加吧。</p>
</blockquote>
<p>你也可以比對一部份的值比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match [1, 2] {
  [1, _] =&gt; println!(&quot;陣列的開頭是 1&quot;),
  _ =&gt; println!(&quot;陣列的開頭不是 1&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>或是：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Point { x: 10, y: 20 } {
  Point { x: 10, .. } =&gt; println!(&quot;x 是 10&quot;),
  _ =&gt; println!(&quot;x 不是 10&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>還可以比對數字是不是在一個範圍內</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 3 {
  1...5 =&gt; println!(&quot;x 在 1~5&quot;),
  6...10 =&gt; println!(&quot;x 在 6~10&quot;),
  _ =&gt; println!(&quot;x 不在 1~10&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>那個 <code>...</code> 只有在 match 時支援而已，是代表包含上下界的範圍，如果在平常需要用到包含上下界的範圍，比如在做切片時要用 <code>..=</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3, 4, 5];
let slice = &amp;array[0..=2];
<span class="boring">}
</span></code></pre></pre>
<p>還可以加上條件判斷：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(3) {
  Some(x) if x &lt; 5 =&gt; println!(&quot;x &lt; 5: {}&quot;, x),
  Some(x) =&gt; println!(&quot;x &gt; 5: {}&quot;, x),
  None =&gt; println!(&quot;None&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以在一行裡比對數個情況</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 3 {
  1 | 2 | 3 =&gt; println!(&quot;是 1 ， 2 或 3&quot;),
  _ =&gt; println!(&quot;不是 1 ， 2 ， 3&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>你還可以用 <code>@</code> 來給比對成功的值一個變數</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 3 {
  // 若這邊比對 1...5 成功，則值會被放到 x 這個變數
  x @ 1...5 =&gt; println!(&quot;x 是 {}&quot;, x),
  6...10 =&gt; println!(&quot;x 在 6~10&quot;),
  _ =&gt; println!(&quot;x 不在 1~10&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 裡的模式比對要求要把所有可能出現的值都比對一次，如果沒有的話會是編譯錯誤， 所以你可以在最後用一個變數，或是不需要變數的話用 <code>_</code> 當預設的情況，你也可以使用 <code>if</code> ，只在碰到某種情況時處理，而忽略另一些情況：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這邊一定要有 let
if let Some(x) = Some(42) {
  println!(&quot;x 是 {}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>下一篇要來講 Rust 的模組架構，這樣就可以好好的組織程式碼，不用在全部都寫在 <code>main.rs</code> 裡了。</p>
<h1 id="module-1"><a class="header" href="#module-1">Module</a></h1>
<p>在 Rust 中要建立一個模組其實不難，只要像這樣：</p>
<pre><pre class="playground"><code class="language-rust">mod mymod {
  pub fn print_hello() {
    println!(&quot;Hello from mymod&quot;);
  }
}

fn main () {
  mymod::print_hello();
}
</code></pre></pre>
<p>這樣你就有一個模組了，在裡面的東西只要沒有宣告 <code>pub</code> 的話外面是不能用的：</p>
<pre><pre class="playground"><code class="language-rust">mod mymod {
  fn private() {
    println!(&quot;這是私有的函式&quot;);
  }
  pub fn public() {
    println!(&quot;這是公開的函式&quot;);
    private();
  }
}

fn main () {
  // mymod::private(); // 如果取消註解，這邊會出現編譯錯誤
  mymod::public();
}
</code></pre></pre>
<p>但這樣寫還是一樣是寫在同一個檔案裡，如果要分成不同的檔案的話也很簡單，建一個 <code>mymod.rs</code> 跟你的 <code>main.rs</code> 放在一起就好了，資料夾下會像這樣：</p>
<pre><code class="language-plain">src
├── main.rs
└── mymod.rs
</code></pre>
<p>之後在你的 <code>main.rs</code> 加上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod mymod;
<span class="boring">}
</span></code></pre></pre>
<p>跟上面不同的是這次後面沒有大括號與裡面的內容，這樣 Rust 就會去找看有沒有 <code>mymod.rs</code> 了。</p>
<p>如果想要更複雜一點的話，比如我想要模組下又有子模組呢？這時我們要介紹一個特殊的檔名 <code>mod.rs</code> 就像程式開始執行的地方也就是進入點是 <code>main.rs</code> 一樣，模組的進入點是 <code>mod.rs</code>，我們先在 <code>main.rs</code> 旁建一個叫 <code>mymod</code> 的資料夾，把原本的 <code>mymod.rs</code> 放進去後改名成 <code>mod.rs</code> ，於是結構會變成像這樣：</p>
<pre><code class="language-plain">src
├── main.rs
└── mymod
    └── mod.rs
</code></pre>
<p>到這邊你可以試著執行看看，結果應該會跟剛才完全一樣。</p>
<p>我們現在可以在 <code>mymod</code> 的資料夾加上子模組了，這邊加上一個叫 <code>submod.rs</code> 的檔案：</p>
<pre><code class="language-plain">src
├── main.rs
└── mymod
    ├── mod.rs
    └── submod.rs
</code></pre>
<p>然後在 <code>mymod/mod.rs</code> 中加上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submod;
<span class="boring">}
</span></code></pre></pre>
<p>到這邊子模組已經可以使用了，如果你想讓外部也能使用你的子模組的話，就在 <code>mod submod</code> 的前面加上 <code>pub</code> 吧：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod submod;
<span class="boring">}
</span></code></pre></pre>
<h2 id="self--super"><a class="header" href="#self--super">self &amp; super</a></h2>
<p><code>self</code> 也能被使用在引入的路徑中，它代表的是目前的模組，以上面的 <code>mymod</code> 舉例，如果要在 <code>mod.rs</code> 中使用 <code>submod</code> 中的東西可以寫成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use self::submod::something;
// 或把完整的路徑寫出來
use mymod::submod::something;
<span class="boring">}
</span></code></pre></pre>
<p><code>super</code> 則是代表上層的模組，比如：</p>
<pre><pre class="playground"><code class="language-rust">fn hello() {
  println!(&quot;Hello&quot;);
}

fn main() {
  sub::call_hello();
}

mod sub {
  use super::hello;
  pub fn call_hello() {
    hello();
  }
}
</code></pre></pre>
<p>這邊也可以注意到，子模組可以直接使用上層模組的東西，不論它有沒有宣告為公開的。</p>
<h2 id="use"><a class="header" href="#use">use</a></h2>
<p><code>use</code> 用在引入模組、函式、常數、或列舉中的 variant 等等，其實我們已經使用過很多次了，不過如果要從一個模組中引入很多東西時，你可以不用一行一行的寫，可以像這樣：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
  fmt, // 引入子模組
  fs::{File}, // 引入子模組下的 struct
  ops::{Add, Deref}, // 同時引入多個
  io::{self, Read}, // 這行會引入 io 這個模組本身，與在它之下的 Read
};
<span class="boring">}
</span></code></pre></pre>
<p>上面的用法你也可以繼續的往下組合，至於可讀性就見仁見智了。</p>
<h2 id="再匯出-re-export"><a class="header" href="#再匯出-re-export">再匯出 (Re-export)</a></h2>
<p>你可以在 <code>use</code> 前面加個 <code>pub</code> 把你引入的模組也再從你這個模組匯出：</p>
<pre><pre class="playground"><code class="language-rust">mod mymod {
  mod submod {
    pub fn foo() {}
  }

  pub use self::submod::foo;
  
  // 這邊可以使用 foo
}

// 可以從 mymod 引入 foo;
use mymod::foo;
// use mymod::submod::foo; // 這邊拿掉註解會編譯錯誤， submod 是私有的

fn main() {
  foo();
}
</code></pre></pre>
<p>有些 crate 所提供的 prelude 就是像這樣，把常用的東西全部在從 prelude 下重新匯出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod mymod {
  pub mod submod1 {
    pub fn often_use1() {}
    pub fn often_use2() {}
    pub fn rare_use() {}
  }

  pub mod submod2 {
    pub fn often_use3() {}
  }

  pub mod prelude {
    pub use super::submod1::{often_use1, often_use2};
    pub use super::submod2::often_use3;
  }
}

use mymod::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<h1 id="錯誤處理-1"><a class="header" href="#錯誤處理-1">錯誤處理</a></h1>
<p>現在大多的程式語言都有例外 (exception) ，這讓程式碰到錯誤時可以立即的拋出例外，拋出的例外會中斷目前整個程式的流程，並開始往上找例外處理的程式，可是 Rust 並沒有這種機制。</p>
<p>Rust 中主要是以回傳值 <code>Result</code> 來代表有無錯誤的，此外也有可以立即中止程式的 <code>panic!</code> 。</p>
<h2 id="panic"><a class="header" href="#panic"><code>panic!</code></a></h2>
<p>先介紹之前沒用過的 <code>panic!</code> ， <code>panic!</code> 會直接終止目前的執行緒，如果你呼叫了 <code>Result::unwrap</code> 或 <code>Option::unwrap</code> ，它們也會分別在值為 <code>Err</code> 或 <code>None</code> 時發生，這用在程式碰到了無法回復的錯誤。</p>
<blockquote>
<p><code>panic!</code> 也像 <code>println!</code> 是 macro ，所以那個驚嘆號是要加的，此外它裡面也可以放格式化字串，使用方法是一樣的。</p>
</blockquote>
<p>主執行緒遇到 <code>panic!</code> 時，程式會印出 <code>panic!</code> 內的訊息，與發生位置後結束程式，你也用以下方法執行程式，你會得到更詳細的輸出：</p>
<pre><code class="language-shell">$ RUST_BACKTRACE=1 cargo run
</code></pre>
<p>如果是子執行緒發生 panic 的話等到之後講到多執行緒時再來介紹。</p>
<blockquote>
<p>執行緒是電腦執行的單位，如果你的 CPU 有 4 核心，那你的電腦就能一次跑 4 個執行緒，所以現在很多程式為了加速會在一個程式裡產生多個執行緒，同時執行多個工作來加速，現在我們寫的程式都只有一個執行緒，也就是主執行緒而已。</p>
</blockquote>
<h2 id="result-2"><a class="header" href="#result-2">Result</a></h2>
<p>之前有介紹過 <code>Result</code> 是一個列舉，其由兩個 variant 組成，分別是 <code>Ok</code> 與 <code>Err</code> ，之前我們有在猜數字的遊戲中使用過 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse"><code>str::parse</code></a> 來把字串轉換成數字，它的回傳值的型態就是 <code>Result</code> ，但要怎麼知道是 <code>Result</code> 呢？除了看文件也有個簡單的辦法是像這樣：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let res: i32 = &quot;123&quot;.parse::&lt;i32&gt;();
}
</code></pre></pre>
<p>拿去編譯的話你就會看到像這樣的錯誤訊息：</p>
<pre><code class="language-plain">error[E0308]: mismatched types
 --&gt; src/main.rs:2:18
  |
2 |   let res: i32 = &quot;123&quot;.parse::&lt;i32&gt;();
  |                  ^^^^^^^^^^^^^^^^^^^^ expected i32, found enum `std::result::Result`
  |
  = note: expected type `i32`
             found type `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>或是如果你有裝好 VSCode 的 Rust 的外掛的話應該也可以在滑鼠移上去後看到像這樣的提示：</p>
<p><img src="https://i.imgur.com/K1QYzIj.png" alt="editor-hint" /></p>
<p>不過這邊的錯誤也只有可能是字串中有非數字的字元而已，另一個比較複雜的範例是開啟檔案：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = match File::open(&quot;myfile&quot;) {
  Ok(f) =&gt; f,
  Err(err) =&gt; {
    // ...
  }
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>關於 <code>File</code> 的文件在 <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html"><code>std::fs::File</code></a></p>
</blockquote>
<p>這邊的 <code>err</code> 是 <a href="https://doc.rust-lang.org/stable/std/io/struct.Error.html"><code>std::io::Error</code></a> ，這是在有讀寫，或是比較跟系統底層有關時， Rust 的標準函式庫常回傳的錯誤型態，同時它還有個與之搭配的列舉 <a href="https://doc.rust-lang.org/stable/std/io/enum.ErrorKind.html"><code>std::io::ErrorKind</code></a>，用來代表錯誤的類別，於是我們可以像這樣使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::ErrorKind;

let f = match File::open(&quot;myfile&quot;) {
  Ok(f) =&gt; f,
  // kind 是 std::io::Error 才有的方法，將會傳回代表錯誤類型的 ErrorKind
  Err(err) =&gt; match err.kind() {
    ErrorKind::NotFound =&gt; panic!(&quot;找不到檔案&quot;),
    ErrorKind::PermissionDenied =&gt; panic!(&quot;權限不足&quot;),
    err =&gt; panic!(&quot;開檔錯誤 {:?}&quot;, err),
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>像這樣子進行更複雜的處理，也可以在找不到時建立一個檔案也是行的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::ErrorKind;

let f = match File::open(&quot;myfile&quot;) {
  Ok(f) =&gt; f,
  // kind 是 std::io::Error 才有的方法，將會傳回代表錯誤類型的 ErrorKind
  Err(err) =&gt; match err.kind() {
    ErrorKind::NotFound =&gt; {
      match File::create(&quot;myfile&quot;) {
        // 檔案建立成功
        Ok(f) =&gt; f,
        Err(err) =&gt; panic!(&quot;無法建立檔案 {:?}&quot;, err),
      }
    }
    err =&gt; panic!(&quot;開檔錯誤 {:?}&quot;, err),
  }
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="-運算子"><a class="header" href="#-運算子"><code>?</code> 運算子</a></h2>
<p>不要懷疑，這個運算子就是 <code>?</code> ，如果有個函式在它呼叫其它函式時發生了錯誤的情況，它，它就把錯誤往上回傳：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Read};

fn read_and_append&lt;R: Read&gt;(reader: R) -&gt; io::Result&lt;String&gt; {
  let mut buf = String::new();
  match reader.read_to_string(&amp;mut buf) {
    // 成功的話什麼都不用做
    Ok(_) =&gt; {}
    // 失敗的話直接回傳錯誤
    err =&gt; return err,
  }
  // 假設這邊還要做些處理後才回傳
  buf.push_str(&quot;END&quot;);
  // 回傳成功的結果
  Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>Read</code> 是所有可讀取的東西會實作的一個 trait ，這包含檔案，或是標準輸入等等關於它的文件在 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code>std::io::Read</code></a></p>
</blockquote>
<p>其中的判斷錯誤，如果是錯誤就回傳的這段因為太常用到了，所以 Rust 就提供了個簡寫的方法，我們可以直接把上面的 <code>match</code> 那段改寫成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>reader.read_to_string(&amp;mut buf)?;
<span class="boring">}
</span></code></pre></pre>
<p>如果它在成功時是會有回傳值的，比如 <code>File::open</code> 成功會回傳 <code>File</code> ，一個代表檔案的 struct ，那你也可以使用 <code>?</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;filename&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p><code>?</code> 只能在會回傳 <code>Result</code> 的函式中使用，不過因為它實在是太方便了，所以後來 Rust 的 <code>main</code> 函式也支援回傳 <code>Result</code> 了：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;

fn main() -&gt; Result&lt;(), io::Error&gt; {
  let f = File::open(&quot;filename&quot;)?;
  // 因為回傳值變 Result 了，所以這邊要回傳 Ok
  Ok(())
}
</code></pre></pre>
<h2 id="該用-panic-還是回傳-result"><a class="header" href="#該用-panic-還是回傳-result">該用 <code>panic!</code> 還是回傳 <code>Result</code></a></h2>
<p>一般的規則就是，能被處理的就用 <code>Result</code> ，嚴重的錯誤才用 <code>panic!</code> 。</p>
<h2 id="自訂-error"><a class="header" href="#自訂-error">自訂 Error</a></h2>
<p>在 <a href="https://doc.rust-lang.org/stable/std/error/trait.Error.html"><code>std::error::Error</code></a> 中定義了一個代表 Error 的 struct 應該要支援的兩個方法 <code>description</code> 與 <code>cause</code> ，此外同時還要實作 <code>Debug</code> 與 <code>Display</code> ，不過實際上 <code>description</code> 與 <code>cause</code> 都有提供預設的實作，於是這些之中一定要實作的就只有 <code>Display</code> 了，此外也可以實作 <code>cause</code> 用來指明發生這個錯誤的原因：</p>
<pre><pre class="playground"><code class="language-rust">use std::io;
use std::fmt;
use std::error::Error;

// 建一個能包裝 io::Error 的 struct
#[derive(Debug)] // 實作 Debug
struct MyError(Option&lt;io::Error&gt;);

impl fmt::Display for MyError {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    // 寫出自訂的錯誤訊息
    f.write_str(&quot;這是自訂的錯誤: &quot;)?;
    match self.0 {
      Some(ref err) =&gt; {
        // 如果有包裝的 io::Error 就把它的訊息印出來
        write!(f, &quot;{}&quot;, err)
      }
      None =&gt; {
        write!(f, &quot;沒有包裝的 io::Error&quot;)
      }
    }
  }
}

impl Error for MyError {
  // 覆寫原本的 cause ，在如果有原本的 io::Error 時傳回去
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {
    // 這邊很可惜沒辦法用 Option::as_ref
    match self.0 {
      Some(ref err) =&gt; Some(err),
      None =&gt; None,
    }
  }
}

// 從 io::Error 轉換成 MyError
impl From&lt;io::Error&gt; for MyError {
  fn from(err: io::Error) -&gt; Self {
    MyError(Some(err))
  }
}

fn main() {
  let err = MyError(None);
  println!(&quot;{}&quot;, err);
  let err = MyError(Some(io::Error::new(io::ErrorKind::Other, &quot;Demo&quot;)));
  println!(&quot;{}&quot;, err);
}
</code></pre></pre>
<blockquote>
<p><code>write!</code> 的用法也和 <code>println!</code> 很像，只是第一個參數必須是可以寫入的，也就是有實作 <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Write.html"><code>std::io::Write</code></a> 的物件，所以也可以用在 <code>File</code> 上，而第二個開始才是原本的格式化字串，它不像 <code>println!</code> 一樣會自動加換行。</p>
</blockquote>
<p>這邊做了一個我們自己的 Error ，並還包裝了原本的 <code>io::Error</code> ，最後一個 <code>From</code> 的實作其實並不是必要的，只是實作了會很有用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Result&lt;(), MyError&gt; {
  Err(io::Error::new(io::ErrorKind::Other, &quot;Demo&quot;))?;
  unreachable!(&quot;這邊永遠不會執行到&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>unreachable!</code> 同樣也是個 macro 它的功能在提示編譯器這種情況不該發生，否則編譯器會認為你的程式可能沒有回傳值，那如果真的執行到了呢？答案是會 panic</p>
</blockquote>
<p>這邊可以看到我們用 <code>?</code> 運算子在碰到 <code>Err(io::Error)</code> 時提早回傳了，只是我們的回傳值明明是寫 <code>MyError</code> 呀，事實上用 <code>?</code> 運算子回傳時會使用 <code>MyError::from</code> 去轉換回傳的錯誤，當我們有幫 <code>MyError</code> 定義 <code>From&lt;io::Error&gt;</code> 時就能被自動轉換。</p>
<p>當你使用多個第三方的套件時，可能大家都會定義自己的錯誤型態，這時你可以嘗試使用列舉來包裝不同的錯誤型態，同時定義 <code>From</code> 來做轉換，這樣你就能在程式裡使用一個統一的錯誤型態了，因為這件事情太常用了，所以有個叫 <a href="https://github.com/rust-lang-nursery/failure">failure</a> 的套件就把這件事用比較簡單的方式完成了，可惜因為再介紹下去篇幅會有點長，所以到後面實作專案時再來介紹吧。</p>
<blockquote>
<p>題外話，實際上 <code>Result</code> 中代表錯誤的型態並沒有必要實作 <code>Error</code> ，只是一般還是會用實作了 <code>Error</code> 的型態來代表錯誤。</p>
</blockquote>
<h2 id="自訂-panic-的訊息-進階"><a class="header" href="#自訂-panic-的訊息-進階">自訂 panic 的訊息 (進階)</a></h2>
<p>你可以在程式開始時註冊一個處理 panic 的函式：</p>
<pre><pre class="playground"><code class="language-rust">use std::panic;

fn handle_panic&lt;'a&gt;(_info: &amp;panic::PanicInfo&lt;'a&gt;) {
  println!(&quot;天啊，程式爆炸了&quot;);
}

fn main() {
  panic::set_hook(Box::new(handle_panic));
  panic!(&quot;Boom&quot;);
}
</code></pre></pre>
<p>在這個函式裡你還可以拿到 panic 發生時的位置，與傳給 panic 的訊息：</p>
<pre><pre class="playground"><code class="language-rust">use std::panic;

fn handle_panic&lt;'a&gt;(info: &amp;panic::PanicInfo&lt;'a&gt;) {
  if let Some(loc) = info.location() {
    println!(&quot;在 {} 的第 {} 行&quot;, loc.file(), loc.line())
  } else {
    println!(&quot;不知道在哪邊&quot;);
  }

  // 這邊的 payload 的回傳值是 Any
  // downcast_ref 是嘗試把 Any 這個型態轉換成指定的型態
  // 如果轉換不成功就會回傳 None
  if let Some(msg) = info.payload().downcast_ref::&lt;&amp;str&gt;() {
    println!(&quot;訊息： {}&quot;, msg);
  } else {
     println!(&quot;沒有訊息或訊息不是 str&quot;);
  }
  println!(&quot;總之爆炸了&quot;);
}

fn main() {
  panic::set_hook(Box::new(handle_panic));
  panic!(&quot;Boom&quot;);
}
</code></pre></pre>
<blockquote>
<p>Any 是個特殊的 trait ，它幫大部份型態都實作過了一遍，透過編譯器的協助，幫每個型態都分配了一個代碼，要使用時你要使用 downcast_ref 或 downcast_mut ，只要你要求轉換的型態與原本的型態符合就會轉換成功，詳細可以參考文件的 <a href="https://doc.rust-lang.org/stable/std/any/trait.Any.html"><code>std::any::Any</code></a></p>
</blockquote>
<p>也有人使用 <code>set_hook</code> 的功能實作了一個會在 panic 時寫出紀錄檔的功能，有興趣可以看看這個專案 <a href="https://github.com/rust-clique/human-panic">human-panic</a> 。</p>
<blockquote>
<p>最開頭的地方說 Rust 沒有例外處理的機制也不是完全正確的， Rust 現在有能力捕捉 panic 了，只是這並沒有保證一定能捕捉到 panic 還要看編譯時的設定…等等的條件，有興趣可以看看 <a href="https://doc.rust-lang.org/stable/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind</code></a> ，這功能主要的目的是當你使用其它語言呼叫 Rust 的程式時，讓你可以避免 Rust 的 panic 影響到其它的程式語言，平常如果要回傳錯誤的話還是請用 <code>Result</code> ，不要依賴這個。</p>
</blockquote>
<h1 id="單元測試"><a class="header" href="#單元測試">單元測試</a></h1>
<p>寫程式難免會出錯，所以我們要寫點程式來測試我們的程式，這邊的程式並不難，你可以試著打開 Rust Playground 一起操作。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: i32, b: i32) -&gt; i32 {
  a + b
}

// 只在測試模式時編譯這個模組
#[cfg(test)]
mod tests {
  // 將上層的東西全部引入
  use super::*;

  // 標記這個是一個測試
  #[test]
  fn test_add_should_work_correctly() {
    // assert_eq! 會確定兩邊是相等的，若不是就會 panic
    assert_eq!(add(1, 1), 2);
    assert_eq!(add(2, 3), 5);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的程式碼當你在 Rust Playground 中輸入後，你應該會注意到上面原本通常都是 <code>RUN</code> 的按鈕變成了 <code>TEST</code> ，按下去就對了，你應該會看到以下結果：</p>
<pre><code class="language-plain">running 1 test
test tests::test_add_should_work_correctly ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>這代表我們的測試通過了，於是我們來加個不會通過的測試看看，請加上面的程式碼中的 tests 模組中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_this_should_fail() {
  assert_eq!(add(2, 2), 5);
}
<span class="boring">}
</span></code></pre></pre>
<p>這次應該會是這樣的輸出：</p>
<pre><code class="language-plain">running 2 tests
test tests::test_add_should_work_correctly ... ok
test tests::test_this_should_fail ... FAILED

failures:

---- tests::test_this_should_fail stdout ----
thread 'tests::test_this_should_fail' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:21:7
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_this_should_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>這應該要是個錯誤的範例，然而它真的「錯誤」了，我們來修正它，在 <code>#[test]</code> 的底下加上 <code>#[should_panic]</code> ，像這樣：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic] // 標記這個測試應該要失敗
fn test_this_should_fail() {
  assert_eq!(add(2, 2), 5);
}
<span class="boring">}
</span></code></pre></pre>
<p>再按一次測試，通過了吧。</p>
<p>你也可以使用回傳 <code>Result</code> 的方式來測試：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_use_result() -&gt; Result&lt;(), &amp;'static str&gt; {
  if add(1, 1) == 2 {
    Ok(())
  } else {
    Err(&quot;1 + 1 != 2&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>只是這個方法就沒辦法使用 <code>#[should_panic]</code> 了，看哪個比較方便了，這邊的 <code>Result</code> 的 <code>Err</code> 中的值只要能用 <code>{:?}</code> 印得出來就行了 (以 Rust 的說法就是有實作 <code>Debug</code>)，此外這邊的函式名稱也沒有規定一定要什麼格式，只要有標記 <code>#[test]</code> 就行了，分到另一個模組也是個慣例。</p>
<h2 id="斷言-assert"><a class="header" href="#斷言-assert">斷言 (Assert)</a></h2>
<p>程式語言常提供的一個功能就是斷言，它可以幫助你測試某些情況是不是真的成立，通常不成立時就會結束程式，上面所使用的 <code>assert_eq!</code> 就是其中一個，它們不只可以被使用在測試中，也可以用在一般程式，確認環境或參數符合假設的必要條件，比如不該用任何數除以 0 。</p>
<p>Rust 中一共提供了三種斷言：</p>
<ul>
<li><code>assert!</code>: 最基本款的，測試裡面的條件為真，如果裡面的條件為假 (<code>false</code>) 則引發 panic</li>
</ul>
<pre><code class="language-plain">assert!(false);

thread 'tests::demo' panicked at 'assertion failed: false', src/lib.rs:27:9
</code></pre>
<ul>
<li><code>assert_eq!</code>: 測試兩個參數是相等的，這個上面已經用過了</li>
<li><code>assert_ne!</code>: 測試兩個參數是不相等的</li>
</ul>
<pre><code class="language-plain">assert_ne!(1, 1);

thread 'tests::demo' panicked at 'assertion failed: `(left != right)`
  left: `1`,
 right: `1`', src/lib.rs:27:9
</code></pre>
<p>它們的用法都大同小異，同時它們還支援自訂訊息：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(false, &quot;是 false&quot;);
thread 'tests::demo' panicked at '是 false', src/lib.rs:27:9
<span class="boring">}
</span></code></pre></pre>
<p>後面也可以放格式化字串跟參數。</p>
<p>有人可能會擔心這些斷言會不會影響程式的效能，所以上面的斷言也都提供了除錯的版本，分別為： <code>debug_assert!</code> 、 <code>debug_assert_eq!</code> 、 <code>debug_assert_ne!</code> ，它們只在除錯模式時有作用， release 時是沒作用的，除錯模式就是平常使用 <code>cargo build</code> 產生的版本，那 release 版本的怎麼產生呢？使用 <code>cargo build --release</code> 就好了，這會花比較長的時間編譯，此外 <code>cargo run</code> 也可以使用 <code>cargo run --release</code> 執行 release 版本的程式。</p>
<h1 id="函數式程式設計"><a class="header" href="#函數式程式設計">函數式程式設計</a></h1>
<p>函數式程式設計的概念是來於數學上的函數，也就是一個輸入對應一個結果，不會受到其它東西的影響，所以程式講究沒有狀態，沒有副作用 (side effect) ，而在 Rust 中也融入了很多函數式程式的概念與設計，比如預設不能修改的變數，以及能直接當成參數傳遞的函式等等。</p>
<blockquote>
<p>所謂的副作用是對函式外部的環境或狀態造成改變，所以像 OOP 那樣的修改 struct 甚至是對螢幕輸出都被視為副作用。</p>
</blockquote>
<h2 id="vec-2"><a class="header" href="#vec-2">Vec</a></h2>
<p>這邊先介紹一個 Rust 中的一個集合型態， <code>Vec</code> 又稱為 vector (中文直翻為向量，但實際用途不同，所以這邊採用原文) ， <code>Vec</code> 可以想成一個可以動態成長的陣列，它必須儲存同樣類型的資料，如果你有個不確定大小的連續資料，比起使用陣列來存，用 <code>Vec</code> 來存就會方便很多。</p>
<p>定義一個空的 <code>Vec</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 因為我們接下來並沒有使用到，所以 Rust 這邊沒辦法自動推導裡面儲存的型態
// 所以只能用 Vec::&lt;i32&gt;::new 這樣的方式指定型態
let v = Vec::&lt;i32&gt;::new();

// 或是指定型態在變數後面
let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p>直接定義一個有值的 <code>Vec</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// 這會定義一個有 10 個 0 的 Vec
let v = vec![0; 10];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>vec!</code> 也是 macro ， 這邊使用的括號是 <code>[]</code> ，事實上 Rust 中並沒有規定 macro 最外層用來包住參數的括號要使用哪一種，所以 <code>()</code> 、 <code>[]</code> 或 <code>{}</code> 都是可以用的，只要是成對的就行，這邊使用 <code>[]</code> 只是慣例，其它的單行就使用 <code>()</code> ，多行的則使用 <code>{}</code> 。</p>
</blockquote>
<p>在 <code>Vec</code> 的尾端增加元素：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(1);
v.push(2);
v.push(3);

println!(&quot;{:?}&quot;, v);
<span class="boring">}
</span></code></pre></pre>
<p>這個結果會和上面的第一個一樣。</p>
<p>取值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// 這邊跟陣列一樣從 0 開始，若取超過範圍會 panic
let n = v[1];

// 這邊回傳的是 Option&lt;&amp;i32&gt; ，若超過範圍只會回傳 None
let n = v.get(1);
<span class="boring">}
</span></code></pre></pre>
<p>基本的使用大概是這樣，接下來我們要用到不少 <code>Vec</code> 。</p>
<h2 id="迭代-iterate"><a class="header" href="#迭代-iterate">迭代 (Iterate)</a></h2>
<p>還記得我們的 for 迴圈嗎？如果今天我們把陣列的每個元素都乘 2 並把結果存回一個 <code>Vec</code> 該怎麼寫呢？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let mut vec = Vec::new();

// 這邊的 i 型態是 &amp;i32
for i in array.iter() {
  vec.push(i * 2);
}

println!(&quot;{:?}&quot;, vec);
<span class="boring">}
</span></code></pre></pre>
<p>上面的 <code>.iter</code> 會回傳一個迭代器 (iterator) ，讓你可以用 for 迴圈跑過陣列的每個元素，但迭代器所能做到的不只是這樣，以函數式的做法的話會像這樣：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
// Vec&lt;_&gt; 可以這樣寫是因為中間的型態可以讓編譯器自動推導
let vec = array.iter().map(|x| x * 2).collect::&lt;Vec&lt;_&gt;&gt;();
// 如果你真的不喜歡 ::&lt;Vec&lt;_&gt; 的語法也可以改用型態標註
// let vec: Vec&lt;_&gt; = array.iter().map(|x| x * 2).collect();
println!(&quot;{:?}&quot;, vec);
<span class="boring">}
</span></code></pre></pre>
<p><code>map</code> 做的事是把每個元素都用其中的函式做轉換，再產生一個新的迭代器。</p>
<p><code>collect</code> 則是把迭代器的值再蒐集變成某個集合型態，注意的是這邊沒辦法使用陣列，因為它的大小必須在編譯時就決定，而 <code>collect</code> 只能使用能在執行時新增值的型態。</p>
<p>其中的 <code>|x| x * 2</code> 是接下來要介紹的閉包 (Closure) 的語法，它做的事情就是產生一個沒有名字的函式，也稱為匿名函式，將傳進來的參數乘 2 ，等下會詳細介紹語法與怎麼使用。</p>
<p>你也可以寫一個函式來做這件事：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這邊就像一般函式一樣要放型態了
fn time2(x: &amp;i32) -&gt; i32 { x * 2 }

let array = [1, 2, 3];
let vec = array.iter().map(time2).collect::&lt;Vec&lt;_&gt;&gt;();
println!(&quot;{:?}&quot;, vec);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 中在函式裡定義函式並不會出錯喔</p>
</blockquote>
<p>如果要計算總合你會怎麼寫呢？請你試著用 for 迴圈寫一個看看吧。</p>
<p>寫好了嗎？我們可以用迭代器的 <code>sum</code> 來做加總：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
println!(&quot;{}&quot;, array.iter().sum::&lt;i32&gt;());
<span class="boring">}
</span></code></pre></pre>
<p>如果要找出 1 到 10 之間的偶數，使用迭代器該怎麼做呢？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:?}&quot;, (1..=10).filter(|x| x % 2 == 0).collect::&lt;Vec&lt;_&gt;&gt;());
<span class="boring">}
</span></code></pre></pre>
<p>range 本身就是迭代器了，所以直接呼叫方法就行了，這邊使用了 <code>filter</code> 來過濾出符合條件的元素。</p>
<p>Rust 的迭代器是延遲求值的，也就是隻會使用到實際使用到的部份，所以如果使用一個有無限長度的迭代器，但只要只使用到有限的部份就不會出錯，讓我們來做高斯的經典題目吧：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, (1..).take(100).sum::&lt;i32&gt;());
<span class="boring">}
</span></code></pre></pre>
<p><code>1..</code> 會建一個從 1 開始一直到無限的範圍，但我們之後使用了 <code>take</code> 這使得它只會取前 100 個數字，最後再加總，你應該會看到它印出了 5050 。</p>
<blockquote>
<p>如果你把 <code>take</code> 拿掉，它也不會是無窮迴圈就是了，因為電腦整數的大小是有限的， Rust 會避免發生整數溢位，也就是當超過整數上限時，發生了數字變負數的一種情況。</p>
</blockquote>
<p>這邊介紹了一些迭代器的方法， Rust 中的迭代器其實挺快的，建議去看一下迭代器的文件，瞭解一下有哪些方法可以用。</p>
<h2 id="迭代器-iterator"><a class="header" href="#迭代器-iterator">迭代器 (Iterator)</a></h2>
<p>所以迭代器到底是什麼，我們實際來操作一次看看：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
// iter 中必須要記錄目前跑到哪個值，所以必須是 mut
let mut iter = array.iter();

println!(&quot;{:?}&quot;, iter.next()); // =&gt; Some(&amp;1)
println!(&quot;{:?}&quot;, iter.next()); // =&gt; Some(&amp;2)
println!(&quot;{:?}&quot;, iter.next()); // =&gt; Some(&amp;3)
// 已經沒有值了
println!(&quot;{:?}&quot;, iter.next()); // =&gt; None
// 沒有值後再繼續呼叫並不會錯誤，而是一直回傳 None
println!(&quot;{:?}&quot;, iter.next()); // =&gt; None
<span class="boring">}
</span></code></pre></pre>
<p>上面的 <code>=&gt;</code> 後的結果是印出來的結果，簡單來說迭代器就是每次呼叫 <code>next</code> 就會回傳一個 <code>Option</code> 並包含下一個值。</p>
<p>我們自己來做一個迭代器，讓它從 1 開始產生到指定的數字就停止，如果要做一個迭代器就必須要實作 <code>Iterator</code> 這個 trait ：</p>
<blockquote>
<p><code>Iterator</code> 的文件在 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a> ，在這邊還可以看到它提供了哪些方法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::iter::Iterator;

#[derive(Debug, Clone, Copy, Default)]
struct UpToIterator {
  // 這邊都採用無號整數，因為要是有負數很麻煩
  current: u32,
  upper_bound: u32,
}

impl UpToIterator {
  pub fn to(upper_bound: u32) -&gt; Self {
    UpToIterator { upper_bound, ..Default::default() }
  }
}

impl Iterator for UpToIterator {
  // 產生的值的型態
  type Item = u32;

  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    if self.current &lt; self.upper_bound {
      self.current += 1;
      Some(self.current)
    } else {
      None
    }
  }
}

fn main() {
  let mut iter = UpToIterator::to(10);
  for n in UpToIterator::to(10) {
    // 你應該會看到從 1 印到 10 的輸出
    println!(&quot;{}&quot;, n);
  }
}
</code></pre></pre>
<h2 id="重新認識-for-迴圈-進階"><a class="header" href="#重新認識-for-迴圈-進階">重新認識 for 迴圈 (進階)</a></h2>
<p>其實 for 在 Rust 裡只是語法糖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
for i in array.iter() {
  println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>這會被編譯器展開成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
{
  // 這是一個編譯器產生的暫時的變數
  let mut _iter = array.iter().into_iter();
  while let Some(i) = _iter.next() {
    println!(&quot;{}&quot;, i);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>這邊可以看到我們使用了 <code>while let</code> 的語法，這跟 <code>if let</code> 很像，只是變成是如果還是 <code>Some</code> 的話就繼續執行。</p>
<p><code>into_iter</code> 則是來自於 <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>std::iter::IntoIterator</code></a> 這個 trait ， for 迴圈必須保證它後面的東西是個迭代器，所以會呼叫 <code>into_iter</code> 確保它被轉換成迭代器，相對而言，只要你的型態有實作 <code>IntoIterator</code> 就能被 for 迴圈所使用，要注意的是它會使用掉呼叫它的東西 (也就是它是使用 <code>self</code> 轉移了所有權) ，以下範例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
// 這邊的 n 的型態是 i32
for n in v {
  println!(&quot;{}&quot;, n);
}
// 這邊沒辦法再使用 v
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 中的慣例是若方法的開頭為 <code>into_</code> 則代表它會消耗掉使用它的東西。</p>
</blockquote>
<h2 id="閉包-closure"><a class="header" href="#閉包-closure">閉包 (Closure)</a></h2>
<p>以上面的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|x| x * 2
<span class="boring">}
</span></code></pre></pre>
<p>宣告傳進來的參數 <code>|x|</code> ，在兩個 <code>|</code> 中放上參數的名字就好了，大多的情況下都不用加上型態宣告，這邊會自動推導，接下來放函式的主體，如果只有一行的話你可以不用加上大括號，或是加上大括號放進多行的程式。</p>
<p>閉包可以存到一個變數去：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x| x * 2;
println!(&quot;{}&quot;, f(10));
<span class="boring">}
</span></code></pre></pre>
<p>若你需要宣告型態的話：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x: i32| -&gt; i32 { x * 2 };
<span class="boring">}
</span></code></pre></pre>
<p>只是這邊就一定要加上大括號了。</p>
<p>閉包可以取得區域變數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 3;
let f = |x| x * n;
println!(&quot;{}&quot;, f(10));
<span class="boring">}
</span></code></pre></pre>
<p>預設閉包為用唯讀 borrow 來取得外部的變數，如果加上 <code>mut</code> 宣告，則閉包會用可寫的 borrow 取得外部的變數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 0;
let mut counter = || {
  n += 1;
  n
};
println!(&quot;{}&quot;, counter());
println!(&quot;{}&quot;, counter());
println!(&quot;{}&quot;, counter());
<span class="boring">}
</span></code></pre></pre>
<p>若要讓閉包取得外部的變數的所有權，可以加上 <code>move</code> 關鍵字：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let is_equal_v = move |a| v == a ;
println!(&quot;{}&quot;, is_equal_v(vec![1, 2, 3]));
println!(&quot;{}&quot;, is_equal_v(vec![4, 5, 6]));
// 這邊無法使用 v
<span class="boring">}
</span></code></pre></pre>
<p>至於要如何寫一個接受閉包的函式呢？</p>
<pre><pre class="playground"><code class="language-rust">fn call_closure&lt;F: Fn(i32) -&gt; i32&gt;(work: F) {
  println!(&quot;{}&quot;, work(10));
}

fn main() {
  call_closure(|x| x * 2);
}
</code></pre></pre>
<p>Rust 中有三個代表函式與閉包有關的 trait 分別是：</p>
<ul>
<li><code>FnOnce</code>: 這個代表它可能會消耗掉它取得的區域變數，所以它可能只能呼叫一次，這對應到上面使用了 <code>move</code> 的閉包</li>
<li><code>FnMut</code>： 這代表它會修改到它的環境，這對應了宣告 <code>mut</code> 的閉包</li>
<li><code>Fn</code>： 這是不會動到環境的閉包，對應到一般的閉包</li>
</ul>
<p>這讓你可以視你的需求選擇使用哪一個，此外，位在列表上面的 trait 也可以接受位在它以下的 trait ，所以 <code>FnOnce</code> 也接受 <code>FnMut</code> 與 <code>Fn</code> ，而 <code>FnMut</code> 接受 <code>Fn</code> ，而三個也都接受一般的函式。</p>
<p>Rust 中也可以讓你傳進一般的函式，所以可以有以下的用法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 為 None 時建一個空字串
println!(&quot;{:?}&quot;, None.unwrap_or_else(String::new));

// 為 None 時用預設值
// 其實這個有 unwrap_or_default 可以用
println!(&quot;{}&quot;, Option::&lt;i32&gt;::unwrap_or_else(None, Default::default));

// 全部包進 Some 裡面
// Rust 中可以把 tuple struct 當函式用
println!(&quot;{:?}&quot;, vec![1, 2, 3].into_iter().map(Some).collect::&lt;Vec&lt;_&gt;&gt;());
<span class="boring">}
</span></code></pre></pre>
<p>上面那些大概知道就好了，主要是一些讓你可以少建立一個閉包的寫法。</p>
<h1 id="智慧指標-smart-pointer-與集合型態-collection"><a class="header" href="#智慧指標-smart-pointer-與集合型態-collection">智慧指標 (Smart Pointer) 與集合型態 (Collection)</a></h1>
<h2 id="集合型態"><a class="header" href="#集合型態">集合型態</a></h2>
<p>這邊介紹的集合型態只會再介紹 HashMap 與 HashSet ，不過 Rust 實際上並不只這兩種而已，詳細建議看一下 <a href="https://doc.rust-lang.org/stable/std/collections/index.html"><code>std::collections</code></a> ，這邊的東西就是常見的資料結構的實作。</p>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>HashMap 是由鍵值 (Key-Value) 對應的一個型態，給定一個鍵就能找到一個值，這用在你需要查表之類的時候很好用。</p>
<p>建立 HashMap ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(String::from(&quot;key1&quot;), 1);
map.insert(String::from(&quot;key2&quot;), 2);
<span class="boring">}
</span></code></pre></pre>
<p>也可以從鍵值對建立：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map = vec![
  (String::from(&quot;key1&quot;), 1),
  (String::from(&quot;key2&quot;), 2),
].into_iter().collect::&lt;HashMap&lt;_, _&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>另外還有 <a href="https://github.com/bluss/maplit">maplit</a> 這個 crate 可以使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果要從 crate 引入 macro 要用 #[macro_use]
#[macro_use]
extern crate maplit;

let map = hashmap! {
  String::from(&quot;key1&quot;) =&gt; 1,
  String::from(&quot;key2&quot;) =&gt; 2,
};
<span class="boring">}
</span></code></pre></pre>
<p>如果要用鍵取得值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這邊的鍵要用 borrow 型態的，所以用 str 也是可以的
// 如果沒有這個鍵的話會 panic
println!(&quot;{}&quot;, map[&quot;key1&quot;]);
// 這個做法的話會回傳 Option
println!(&quot;{:?}&quot;, map.get(&quot;key2&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>更新值只要再 insert 就行了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>map.insert(String::from(&quot;key1&quot;), 3);
<span class="boring">}
</span></code></pre></pre>
<p>或是使用 entry 這個 API ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>map.entry(&quot;key1&quot;.to_owned()).and_modify(|v| { *v = 3 });
<span class="boring">}
</span></code></pre></pre>
<h2 id="hashset-1"><a class="header" href="#hashset-1">HashSet</a></h2>
<p>HashSet 就是數學上的集合，其中不會有重覆的值，很適合用來檢查一個值是否出現過。</p>
<p>建立一個 HashSet ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

let mut set = HashSet::new();
set.insert(&quot;foo&quot;.to_string());
set.insert(&quot;bar&quot;.to_string());
<span class="boring">}
</span></code></pre></pre>
<p>若用 maplit 的話：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let set = hashset! { &quot;foo&quot;.to_string(), &quot;bar&quot;.to_string() };
<span class="boring">}
</span></code></pre></pre>
<p>判斷是不是有這個值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set.contains(&quot;foo&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="智慧指標"><a class="header" href="#智慧指標">智慧指標</a></h2>
<p>智慧指標是一種會自動在建立時分配一塊記憶體，並在變數消失時自動釋放空間的容器，主要就只有 <code>Box</code> 與 <code>Rc</code> ，文件分別在 <a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code>std::boxed::Box</code></a> 與 <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>std::rc::Rc</code></a> 。</p>
<h2 id="box-2"><a class="header" href="#box-2">Box</a></h2>
<p><code>Box</code> 可以用來裝那些無法在編譯時知道大小的型態，同時它也有指標的特性，也能把大小推遲到執行時決定，如果有些情況實在是過不了 borrow checker 的話就用 <code>Box</code> 吧。</p>
<p>建立一個 <code>Box</code> 很簡單：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Box::new(42);
<span class="boring">}
</span></code></pre></pre>
<p>Rust 中其實有個有趣的問題，如果今天要建立一個連結串列 (linked-list) 要怎麼辦呢？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
  Cons(i32, List),
  Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p>上面這個拿去編譯會得到這個錯誤：</p>
<pre><code class="language-plain">error[E0072]: recursive type `List` has infinite size
 --&gt; src/lib.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |   Cons(i32, List),
  |             ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<p>因為編譯器必須在編譯時決定它的大小，可是 <code>Cons</code> 的大小因為會一直遞迴下去，所以無法決定，那我們改用 <code>Box</code> 看看：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
  Cons(i32, Box&lt;List&gt;),
  Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p>這次就能通過編譯了，也能使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
<span class="boring">}
</span></code></pre></pre>
<p><code>Box</code> 與 borrow 的差別：</p>
<ul>
<li><code>Box</code> 本身就擁有資料，所以不會有 lifetime 的問題</li>
<li><code>Box</code> 是分配在 heap ，而 borrow 的資料位置則不一定</li>
</ul>
<blockquote>
<p>電腦主要資料儲存都是在記憶體中，根據其特性還可以再細分，其中有 stack 為存放區域變數，在上面的資料會在函式結束時釋放， heap 則為一塊空間，可讓使用者手動分配記憶體，並可自行決定何時還回去，此處為 <code>Box</code> 所使用的位置，當然分配與歸還都由 <code>Box</code> 自動的管理了。</p>
</blockquote>
<h2 id="rc-2"><a class="header" href="#rc-2">Rc</a></h2>
<p><code>Rc</code> 是 reference counting 的意思， <code>Box</code> 的擁有者一次只能有一個人，然而 <code>Rc</code> 可以由多人同時持有，它像 <code>Box</code> 一樣會自動分配記憶體存放資料，並在最後一個人釋放掉 <code>Rc</code> 時將記憶體也釋放。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let a = Rc::new(42);
let b = Rc::clone(&amp;a);
<span class="boring">}
</span></code></pre></pre>
<p>以上的 a 與 b 同時持有同一份資料，通常還會搭配類似 <code>Cell</code> 的東西做使用，只是那不是這次的範圍，就先知道一下這個東西吧。</p>
<p>另外還有在 <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a> 的 <code>Arc</code> ，它可以讓多個執行緒同時持有同一份資料。</p>
<h2 id="weak"><a class="header" href="#weak">Weak</a></h2>
<p>若有兩個 <code>Rc</code> 互相持有對方的話，就會因為雙方都屬於有效的持有狀態，而無法正常釋放記憶體，所以就有 <code>Weak</code> ， <code>Weak</code> 不會增加 <code>Rc</code> 的持有人數。</p>
<p>下一篇要來介紹 <code>Cell</code> 與 <code>RefCell</code> ，它們可以讓 Rust 的變數沒有宣告 <code>mut</code> 也能改變，同時讓 borrow check 的規則延遲到執行時才判斷。</p>
<h1 id="cell-與-refcell"><a class="header" href="#cell-與-refcell">Cell 與 RefCell</a></h1>
<p><code>Cell</code> 與 <code>RefCell</code> 能讓變數沒宣告 <code>mut</code> 也能修改，因為有時你還是需要在有多個 borrow 的情況下能修改變數，它們的文件都在 <a href="https://doc.rust-lang.org/stable/std/cell/index.html"><code>std::cell</code></a> 底下。</p>
<h2 id="cell-1"><a class="header" href="#cell-1">Cell</a></h2>
<p><code>Cell</code> 使用在能 <code>Copy</code> 的型態，因為它是使用取值與設定值的，在取值時會發生複製，若型態無法複製的話就無法取值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

let num = Cell::new(42);
num.set(123);
assert_eq!(num.get(), 123);
<span class="boring">}
</span></code></pre></pre>
<h2 id="refcell-1"><a class="header" href="#refcell-1">RefCell</a></h2>
<p><code>RefCell</code> 則能使用 borrow 的方式取值，就可以使用在其它的型態上了，它依然會檢查 Rust 的那些 borrow 的規則，只是是在執行時檢查。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

let s = RefCell::new(String::from(&quot;Hello, &quot;));

// 以可寫的方式 borrow
s.borrow_mut().push_str(&quot;World&quot;);

// 唯讀的 borrow
println!(&quot;{}&quot;, s.borrow());
<span class="boring">}
</span></code></pre></pre>
<h1 id="搭配-rc"><a class="header" href="#搭配-rc">搭配 Rc</a></h1>
<p>用 <code>RefCell</code> 搭配 <code>Rc</code> 使用就能做出同時有多個參照，卻還能視情況修改值了，我們試著做一個 double linked-list 吧：</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
  data: i32,
  next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
  prev: Option&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

type Link = Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;;

#[derive(Debug, Default)]
struct DoubleList {
  head: Link,
}

impl DoubleList {
  fn new() -&gt; Self {
    Default::default()
  }

  fn push(&amp;mut self, val: i32) {
    match self.head {
      Some(ref head) =&gt; {
        let mut cursor = Rc::clone(head);
        let mut next = None;
        let mut prev = Weak::new();
        loop {
          match cursor.borrow().next {
            Some(ref node) =&gt; {
              // 先把下一個節點存起來
              next = Some(Rc::clone(node));
            }
            None =&gt; {
              // 存前一點節點
              prev = Rc::clone(&amp;cursor);
              break;
            }
          }
          // 這邊 cursor 的 borrow 才結束，我們才能修改 cursor 的值
          cursor = next.unwrap();
        }
      cursor.borrow_mut().next = Some(Rc::new(RefCell::new(Node {
        data: val,
        next: None,
        prev: Some(prev),
      })));
      },
      None =&gt; {
        self.head = Some(Rc::new(RefCell::new(Node {
          data: val,
          next: None,
          prev: None,
        })));
      }
    }
  }
}

fn main() {
  let mut list = DoubleList::new();
  list.push(1);
  list.push(2);
  println!(&quot;{:?}&quot;, list);
}
</code></pre></pre>
<h1 id="程序與執行緒"><a class="header" href="#程序與執行緒">程序與執行緒</a></h1>
<p>偶爾我們要呼叫外部的程式來幫我們處理一些東西，這個時候就是 <a href="https://doc.rust-lang.org/stable/std/process/index.html"><code>std::process</code></a> 下的東西登場的時候了。</p>
<h2 id="command"><a class="header" href="#command">Command</a></h2>
<p><code>Command</code> 可以讓我們呼叫外部的程式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::process::Command;

let mut cmd = Command::new(&quot;ls&quot;).spawn().expect(&quot;Fail to spawn&quot;);
cmd.wait().expect(&quot;Fail to wait&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>這會呼叫 <code>ls</code> 列出目前目錄下的檔案，並等待子程序結束。</p>
<blockquote>
<p>如果你想要像 C 或其它語言的 <code>system</code> 一樣，你需要呼叫 shell 。</p>
</blockquote>
<h2 id="執行緒-thread"><a class="header" href="#執行緒-thread">執行緒 (Thread)</a></h2>
<p>現在的電腦大多是多核心的，如果建立執行緒，讓多個執行緒一起處理資料的話理論上就能加快速度了：</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
  // 建立執行緒
  let handle = thread::spawn(move || {
    let half_sec = Duration::from_millis(500);
    for _ in 0..10 {
      println!(&quot;Thread&quot;);
      // 休息半秒
      thread::sleep(half_sec);
    }
  });
  let one_sec = Duration::from_secs(1);
  for _ in 0..5 {
    println!(&quot;Main&quot;);
    // 休息 1 秒
    thread::sleep(one_sec);
  }
  // 等待子執行緒結束
  handle.join().unwrap();
}
</code></pre></pre>
<p>這個與接下來的範例都請在自己的電腦上執行，這邊你應該會看到它們兩個以不同的速度在輸出。</p>
<h2 id="arc-與-mutex"><a class="header" href="#arc-與-mutex">Arc 與 Mutex</a></h2>
<p>還記得之前介紹 <code>Rc</code> 時提過 <code>Arc</code> 嗎？ <code>Rc</code> 與 <code>Arc</code> 很像，只是 <code>Arc</code> 能跨執行緒的共享資料，在使用多執行緒時我們必須要使用 <code>Arc</code> ，而 <code>Mutex</code> 是什麼？ <code>Mutex</code> 中文為互斥鎖，功能是保護資料不會因為多個執行緒修改而發生資料競爭 (data racing) 或是其它競爭情況，這邊並不詳細解釋，有興趣可以看一下<a href="https://en.wikipedia.org/wiki/Race_condition#Example">維基</a>的說明， Rust 中跟其它語言不同，一個有趣的地方是 <code>Mutex</code> 也是個容器，讓你直接包裝需要保護的資料：</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

fn main() {
  // 這邊使用 Arc 來包裝 Mutex 這樣才能在執行緒間共享同一個 Mutex
  let data = Arc::new(Mutex::new(0));
  let mut children = Vec::new();
  let one_sec = Duration::from_secs(1);
  // 開 4 個執行緒，因為我的電腦是 4 核的，你可以自己決定要不要修改
  // 另外你也可以把數字改成 1 ，這樣就跟沒有平行化是一樣的，你可以比較一下速度的差別
  for i in 0..4 {
    // 使用 clone 來共享 Arc
    let data = data.clone();
    children.push(thread::spawn(move || loop {
      {
        // 鎖定資料
        let mut guard = data.lock().unwrap();
        // 如果大於 10 就結束
        if *guard &gt;= 10 {
          println!(&quot;Thread[{}] exit&quot;, i);
          break;
        } else {
          // 處理資料
          *guard += 1;
        }
        println!(&quot;Thread[{}] data: {}&quot;, i, *guard);
        // 離開 scope 時會自動解鎖 Mutex
      }
      // 模擬處理的耗時
      thread::sleep(one_sec);
    }));
  }
  // 等所有執行緒結束
  for child in children {
    child.join().unwrap();
  }
}
</code></pre></pre>
<blockquote>
<p>一般都會盡可能減少鎖定資料的範圍，這樣才能盡量的平行化。</p>
</blockquote>
<h2 id="rayon-1"><a class="header" href="#rayon-1">rayon</a></h2>
<p><a href="https://github.com/rayon-rs/rayon">rayon</a> 是個很方便的平行化的 crate ，它可以讓原本迭代器做的事情變成平行化處理，而且使用非常簡單：</p>
<pre><pre class="playground"><code class="language-rust">extern crate rayon;

// 引入必要的東西
use rayon::prelude::*;

fn main() {
    let mut data = Vec::new();
    for i in 1..=1000000 {
        data.push(i);
    }
    // 只要在原本的 iter 前加上 par_ 就行了
    data.par_iter_mut().for_each(|x| *x *= 2);
}
</code></pre></pre>
<h1 id="更多的執行緒-atomic--channel-與-crossbeam"><a class="header" href="#更多的執行緒-atomic--channel-與-crossbeam">更多的執行緒： Atomic 、 Channel 與 Crossbeam</a></h1>
<p>今天要來介紹 Atomic 與 Channel ，另外還會介紹 crossbeam 這個 crate 。</p>
<blockquote>
<p>這篇的範例也都請在自己的電腦上測試。</p>
</blockquote>
<h2 id="atomic"><a class="header" href="#atomic">Atomic</a></h2>
<p>還記得我們在上一篇時使用了 mutex 來保護我們的數字的讀寫嗎？今天要介紹的是 atomic ，它保證操作不會因為多執行緒中斷，所以可以安全的讀寫，而不需要 mutex ，它的文件在 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a> ，我們把昨天的範例用 atomic 重寫一份看看：</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
use std::time::Duration;

fn main() {
  let data = Arc::new(AtomicUsize::new(0));
  let mut children = Vec::new();
  let one_sec = Duration::from_secs(1);
  for i in 0..4 {
    let data = data.clone();
    children.push(thread::spawn(move || loop {
      let n = data.fetch_add(1, Ordering::SeqCst);
      // 如果大於 10 就結束
      if n &gt;= 10 {
        println!(&quot;Thread[{}] exit&quot;, i);
        break;
      }
      println!(&quot;Thread[{}] data: {}&quot;, i, n);
      // 模擬處理的耗時
      thread::sleep(one_sec);
    }));
  }
  // 等所有執行緒結束
  for child in children {
    child.join().unwrap();
  }
}
</code></pre></pre>
<p>這個範例其實和昨天的執行結果不太一樣，首先，我們資料的值是有可能超過 10 的，再來它不會像昨天的一樣照著順序了，因為昨天的輸出也在 mutex 的保護範圍內，但這次有保證的只有數值的增加而已，輸出的順序是沒有任何保證的，關於 atomic 的 ordering 建議可以自己再上網找相關的資料，畢竟這個還挺複雜的，怕用錯的話還是用 mutex 就好了。</p>
<h2 id="channel-1"><a class="header" href="#channel-1">Channel</a></h2>
<p>Channel 可以跨執行緒傳遞資料，大多的用途是主執行緒用來分配工作給子執行緒，文件在 <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code></a> ， Rust 中內建的 channel 是支援多個發送端，但只能有單個接收端：</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    io::{stdin, BufRead},
    sync::mpsc::channel,
    thread,
};

fn main() {
  // tx 是發送端， rx 是接收端
  let (tx, rx) = channel();
  let handle = thread::spawn(move || loop {
    match rx.recv() {
      Ok(val) =&gt; {
        println!(&quot;收到 {:?}&quot;, val);
      }
      // 出錯時離開迴圈
      Err(_) =&gt; break,
    }
  });
  for line in stdin().lock().lines() {
    let line = line.unwrap();
    // 把輸入送過去
    tx.send(line).unwrap();
  }
  // 關掉發送端，這會讓接收端的 recv 得到 Err
  drop(tx);
  // 等待子執行緒結束
  handle.join().unwrap();
}
</code></pre></pre>
<blockquote>
<p>如果你有用過 Go 的話你應該知道 Go 內建的 channel ， Rust 的跟 Go 的 channel 的也挺像的，只是並不像 Go 的一樣可以有多個接收端，所以用 mutex 保護接收端也是有的。</p>
</blockquote>
<p>Channel 在多執行緒上非常的方便，可是 Rust 的標準函式庫所提供的 channel 只能支援單個接收端，也不支援同時處理多個接收端，看哪個的訊息先到 (目前這個功能還沒穩定) ，所以就有人做了 crossbeam 這個 crate ，它提供很多多執行緒下會使用到的東西，可以說是補足了 Rust 標準函式庫不足的部份。</p>
<h2 id="crossbeam"><a class="header" href="#crossbeam">crossbeam</a></h2>
<p>crossbeam 實際上不只是一個 crate ，其底下還分成 <code>crossbeam-epoch</code> 、 <code>crossbeam-deque</code> 、 <code>crossbeam-channel</code> 、 <code>crossbeam-utils</code> ，這次主要要介紹的東西在 <code>crossbeam-channel</code> 與 <code>crossbeam-utils</code> ，不過為了方便，我們還是使用 <code>crossbeam</code> 這個 crate 吧。</p>
<blockquote>
<p>以下的程式使用的是 crossbeam <code>0.5</code></p>
</blockquote>
<h2 id="crossbeam-channel"><a class="header" href="#crossbeam-channel">crossbeam channel</a></h2>
<pre><pre class="playground"><code class="language-rust">extern crate crossbeam;

use std::{
  io::{stdin, BufRead},
  thread,
};
use crossbeam::channel::unbounded;

fn main() {
  // 建一個沒有大小限制的 channel
  let (tx, rx) = unbounded();
  let mut children = Vec::new();
  // 這次建立了 4 個執行緒來展示 crossbeam 能支援多個接收端
  for i in  0..4 {
    let rx = rx.clone();
    children.push(thread::spawn(move || loop {
      match rx.recv() {
        Ok(val) =&gt; {
          println!(&quot;Thread[{}]: 收到 {:?}&quot;, i, val);
        }
        Err(_) =&gt; break,
      }
    }));
  }
  let stdin = stdin();
  for line in stdin.lock().lines() {
    let line = line.unwrap();
    tx.send(line).unwrap();
  }
  drop(tx);
  for handle in children {
    handle.join().unwrap();
  }
}
</code></pre></pre>
<p>crossbeam 的 channel 比起標準函式庫裡的要強大的多了。</p>
<blockquote>
<p>如果你用過 Go 的話， crossbeam 的 channel 比較像 Go 的 channel 。</p>
</blockquote>
<h2 id="scoped-thread"><a class="header" href="#scoped-thread">Scoped Thread</a></h2>
<p>一般而言 thread 可以在背景執行，只要主執行緒沒有結束，子執行緒也可以繼續執行下去，在 Rust 裡要是弄丟了 JoinHandle (<code>thread::spawn</code> 的傳回值) ， 執行緒就會脫離掌握了，除非主執行緒結束不然是不會停止的，也代表 Rust 的執行緒可以離開建立它的函式繼續執行，因此 Rust 中的執行緒若要使用 borrow 就必須要有 <code>'static</code> 的 lifetime ，若要使用函式中的 borrow 就要用到 <code>Box</code> 或 <code>Arc</code> 來確保子執行緒能拿到合法的 borrow ，或著，如果有種執行緒能夠保證在函式結束時一起結束，而能拿到函式中的 borrow 就好了。</p>
<pre><pre class="playground"><code class="language-rust">extern crate crossbeam;

use std::io::{stdin, BufRead};
use crossbeam::{thread, channel::unbounded};

fn main() {
  let (tx, rx) = unbounded();
  thread::scope(|scope| {
    for i in  0..4 {
      let rx = rx.clone();
      // 改呼叫 scope 上的 spawn
      scope.spawn(move |_| loop {
        match rx.recv() {
          Ok(val) =&gt; {
            println!(&quot;Thread[{}]: 收到 {:?}&quot;, i, val);
          }
          Err(_) =&gt; break,
        }
      });
    }
    // 要把外面的讀 stdin 移進來，不然不會被執行到而導致程式卡住
    for line in stdin().lock().lines() {
      let line = line.unwrap();
      tx.send(line).unwrap();
    }
    drop(tx);
    // 所有的 thread 會在離開 scope 時 join
    // 所以 lifetime 只需要在這個範圍有效就行了
  }).unwrap();
}
</code></pre></pre>
<p>這兩章的內容需要你對執行緒有點基本的瞭解，希望你還能夠理解，這已經是第 17 篇了， Rust 做為一門系統程式語言，接觸到一些電腦、作業系統的基本概念也是不可免的，雖然這兩章的內容對初學程式來說並不是那麼的必要，到這邊我有點好奇各位為什麼想學習 Rust 這門程式語言，如果你完全沒有電腦的基礎概念就來學這門語言我想應該會很辛苦，如果你單純用過 C/C++ 這類的程式語言的話或許會好一點，不知道各位在讀這兩章之前，知不知道 data racing 是什麼呢？</p>
<p>下一篇我們來講所謂「不安全」的 Rust ，在保證安全的 Rust 中為了安全總是犧牲掉了點彈性，而我們要來使用那些不安全的功能，當然，使用了這些功能 Rust 就沒辦法保證你的程式是安全不會有記憶體錯誤，就跟你拆開保固中的東西一樣，要自己負責。</p>
<h1 id="不安全的-rust"><a class="header" href="#不安全的-rust">「不安全」的 Rust</a></h1>
<p>Rust 透過編譯器的檢查來保證記憶體的安全，然而這些檢查並不是完美的，總是有誤判的時候，所以 Rust 也提供了這些被標記為不安全的功能，讓使用者可以直接存取底層的東西，相對的編譯器無法對這個部份提供任何保證。</p>
<p>只要使用 <code>unsafe</code> 這個關鍵字就能使用這些不安全的功能，這些功能有：</p>
<ul>
<li>直接存取指標</li>
<li>修改全域變數</li>
<li>被標記為不安全的方法與 trait</li>
</ul>
<p><code>unsafe</code> 實際上並沒有關掉 borrow checker ，也不代表裡面的程式碼就一定是不安全的，只是若使用到了這些功能的話，使用者要自己負責保證安全性而已。</p>
<h2 id="指標-1"><a class="header" href="#指標-1">指標</a></h2>
<p>指標代表的是記憶體位置，直接操作指標意謂著直接對記憶體操作，同時指標並不受到 Rust 的 borrow checker 的規則所限制，使用者可以自由的修改它所指向的值，也可以有 null 所以使用者要自己做檢查：</p>
<blockquote>
<p>如果你有寫過 C/C++ 的話，這邊的指標跟它們的是一樣的。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::ptr;

fn main() {
  unsafe {
    // 取得一個可變的 null 指標，一般而言 null 是指向 0 的位置
    // 這邊還是要加 mut 不然 p 會是唯讀的，之後會無法修改 p 本身
    let mut p: *mut i32 = ptr::null_mut();
    // :p 可以用來印出指標本身
    println!(&quot;p: {:p}&quot;, p);
    // 分配一個存數字的空間後轉換成指標，這邊改了 p 本身，所以需要 mut
    // 這像是 C 裡的 malloc
    p = Box::into_raw(Box::new(42));
    println!(&quot;p: {:p}&quot;, p);
    // 直接修改指標指向的值
    *p = 123;
    // 指標不受 borrow checker 的限制，同時這邊沒有加 mut
    let q = p;
    println!(&quot;q: {:p}&quot;, q);
    let val = Box::from_raw(p);
    println!(&quot;val: {}&quot;, val);
    // 這個指標依然指向 val 的位置，所以可以修改，同時這邊沒有 mut 也能修改
    *q = 42;
    println!(&quot;val: {}&quot;, val);
  }
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=12969560020c938240b570f3998ffe55"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<p>指標的型態有兩種 <code>*mut</code> 與 <code>*const</code> ，後面則要再加上指向的型態名稱，比如 <code>*mut i32</code> ， <code>*mut</code> 所指向的內容可以修改， <code>*const</code> 則不行，另外 <code>*mut</code> 可以直接轉型為 <code>*const</code> ，但 <code>*const</code> 則要用 <code>as</code> 明確的轉型，然而它們都不受 borrow checker 的限制，所以你可以有多個 <code>*mut</code> 指向同一個位置也是可以的。</p>
<p>另外也可以直接把 borrow 轉型成 pointer ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = 42;
let p = &amp;val as *const _;
<span class="boring">}
</span></code></pre></pre>
<h2 id="unsafe-method"><a class="header" href="#unsafe-method">Unsafe Method</a></h2>
<pre><pre class="playground"><code class="language-rust">// 在函式前加上 unsafe 就可以標記這個函式是不安全的
unsafe fn foo () {}

fn main() {
  unsafe {
    // 如果不在 unsafe 裡呼叫的話就會編譯錯誤
    foo();
  }
}
</code></pre></pre>
<p>不安全的函式或方法通常代表它們需要額外的檢查才能確保它們的使用是安全的，比如像 <code>Vec::set_len</code> 這個方法可以直接修改 <code>Vec</code> 內容的長度：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果用 new 的話 Vec 是不會分配空間的
let vec = Vec::&lt;i32&gt;::with_capacity(1);
unsafe {
  vec.set_len(100);
}

// 這邊可以看到 vec 所分配的大小實際上還是隻有 1
println!(&quot;{}&quot;, vec.capacity());
// 然而因為長度已經被設定成 100 了，所以可以看這邊印出了 100 個元素
println!(&quot;{:?}&quot;, vec);
<span class="boring">}
</span></code></pre></pre>
<p>上面這個範例平常可別模仿，這其實已經存取到不該存取的記憶體了，當然這也就是 unsafe 的威力。</p>
<h2 id="extern"><a class="header" href="#extern">extern</a></h2>
<p>Rust 中可以很方便的呼叫 C 語言，之後會再來詳細的講解這部份的，不過在 Rust 中因為並不確定這些外部的函式的安全性，所以這些函式都會是 unsafe 的。</p>
<pre><pre class="playground"><code class="language-rust">// 直接像這樣宣告外部的函式就好了
extern &quot;C&quot; {
  // atoi 是 C 的標準函式庫中把字串轉換成數字的函式
  fn atoi(s: *const u8) -&gt; i32;
}

fn main() {
  let num = unsafe {
    // C 的字串必須以 0 結尾，同時這邊做轉型成指標
    atoi(&quot;42\0&quot;.as_bytes().as_ptr())
  };
  println!(&quot;{}&quot;, num);
}
</code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=7e22c1d946dcb77cce1524b25ab72a69"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<h2 id="全域變數"><a class="header" href="#全域變數">全域變數</a></h2>
<p>因為修改與讀取可修改的全域變數可能會有 data racing 等等的問題，所以 Rust 中將這個視為一個不安全的操作：</p>
<pre><pre class="playground"><code class="language-rust">// 定義全域的變數或常數時一定要加上型態
// 全域變數使用全大寫的名稱是個慣例
static mut VAL: i32 = 42;

fn main() {
  unsafe {
    VAL = 123;
  }
  println!(&quot;{}&quot;, unsafe { VAL });
}
</code></pre></pre>
<p>順帶介紹個 crate 叫 <code>lazy_static</code> ，之後用到時會再做詳細的介紹的，它的功能是建立一個靜態且延遲初始化的變數，也就是像全域變數一樣，但只會在第一次使用時才做初始化，它的 github 在 https://github.com/rust-lang-nursery/lazy-static.rs 。</p>
<p>下一篇我們要來介紹 Rust 2018 有什麼新東西，然後 Rust 的基礎大致上就介紹到這邊了，再接下就進入應用篇，我會開始介紹一些實用的 crate 與實作幾個專案，如果有什麼想要我做的也歡迎提出來。</p>
<h1 id="rust-2018"><a class="header" href="#rust-2018">Rust 2018</a></h1>
<p>Rust 2018 是在今年底預計發佈的 <code>1.31</code> 版本，同時也會有些語法上的改變，如果你想在自己的電腦上使用你必須安裝 beta 或 nightly 版本的 Rust ，使用 rustup 安裝請輸入底下指令：</p>
<pre><code class="language-shell">$ rustup toolchain install nightly
</code></pre>
<p>如果你想直接用 <code>rustc</code> 編譯 Rust 2018 的話你需要像這樣：</p>
<pre><code class="language-shell">$ rustc --edition 2018 main.rs
</code></pre>
<p>加上 <code>--edition 2018</code> ，若是要讓專案使用 Rust 2018 的話則要在 <code>Cargo.toml</code> 的 <code>[package]</code> 中加上 <code>edition = &quot;2018&quot;</code> 。</p>
<p>若你想要在 Playground 中使用 Rust 2018 的話，在上排的選單中可以選擇版本：</p>
<p><img src="rust/30%E5%A4%A9%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BARust%E7%B3%BB%E5%88%97/../images/sm9zh9G.png" alt="Image" /></p>
<h1 id="nll"><a class="header" href="#nll">NLL</a></h1>
<p>這是 Rust 新的 borrow checker ，它讓你可以編譯像這樣的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [0, 1];
let a = &amp;mut array[0];
*a = 2;
let b = &amp;mut array[1];
*b = 3;
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=beta&amp;mode=debug&amp;edition=2018&amp;gist=d623a58cc4afadad5672328ecc57ae8e"><img src="https://i.imgur.com/7F0C6a1.png" alt="Playground" /></a></p>
<p>這在現在的版本是無法通過編譯的，你可以在 Playground 中使用 Rust 2015 編譯看看，同時 NLL 也提供更好的錯誤訊息。</p>
<h2 id="module-path"><a class="header" href="#module-path">Module Path</a></h2>
<p>在 Rust 2018 中 module 的路徑都必須要以 crate 的名稱或 <code>crate</code> 、 <code>super</code> 、 <code>self</code> 其中一個開頭，其中 <code>crate</code> 代表著目前的專案，原先可以直接使用在同一層的模組的，所以若原本的模組是像這樣：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
  fn foo() {}
}
mod b {
  fn bar() {}
}

// 原本可以用

use a::foo;
use b::bar;

// Rust 2018 要用

use self::a::foo;
use self::b::bar;
<span class="boring">}
</span></code></pre></pre>
<h2 id="raw-identifier"><a class="header" href="#raw-identifier">Raw Identifier</a></h2>
<p>Rust 2018 中可以讓你拿原本的關鍵字來當變數名稱等等的了，只是使用起來有點不太一樣：</p>
<pre><pre class="playground"><code class="language-rust">fn r#match() {
}

fn main() {
  r#match();
}
</code></pre></pre>
<p>要加上 <code>r#</code> 還有是點麻煩。</p>
<h2 id="匿名-lifetime"><a class="header" href="#匿名-lifetime">匿名 lifetime</a></h2>
<p>現在可以使用 <code>'_</code> 在某些非得加上 lifetime 的地方，讓編譯器自動推導了，不過這個功能目前還很不穩定，很容易就把編譯器弄當了，雖然 Rust 的編譯器當掉也只是出現請你回報的錯誤訊息而已，不過會讓錯誤訊息都不顯示也挺麻煩的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
  a: &amp;'a i32,
}

// 原本要寫
impl&lt;'a&gt; Foo&lt;'a&gt; {
}

// 這邊可以用 '_ 讓編譯器去推導了
impl Foo&lt;'_&gt; {
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="dyn"><a class="header" href="#dyn">dyn</a></h2>
<p>原本若傳遞 trait 的 borrow 是寫成 <code>&amp;Trait</code> ，但在 Rust 2018 中要寫成 <code>&amp;dyn Trait</code> ，這基本上是個讓語法更清楚的改進，原本的寫法也還是可以接受的。</p>
<p>有些什麼樣的新功能也可以去看看 <a href="https://rust-lang-nursery.github.io/edition-guide/introduction.html">Edition Guide</a> ，這是個介紹 Rust 2018 的新功能的文件，另外有興趣也可以看看 <a href="https://doc.rust-lang.org/unstable-book/the-unstable-book.html">Unstable Book</a> 這邊列出了目前還不穩定的功能，雖然大部份都只有名稱跟連結而已，並沒有介紹。</p>
<p>接下來就要開始進入應用篇了，下一篇我要來介紹一些個人覺得常用或好用的 crate 。</p>
<h1 id="crates-與工具"><a class="header" href="#crates-與工具">Crates 與工具</a></h1>
<p>這篇主要是來介紹 Rust 的社群所提供的方便的工具與 crate ，為避免重覆，若之後有打算深入介紹的我就不在這邊做介紹了。</p>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<h2 id="clippy"><a class="header" href="#clippy">Clippy</a></h2>
<p>Clippy 是個 Rust 的 linter (程式碼的風格與錯誤檢查工具) ，可以直接用 <code>rustup</code> 安裝：</p>
<pre><code class="language-shell">$ rustup component add clippy-preview
</code></pre>
<p>使用也非常簡單，只要在專案裡用以下指令就會做檢查了：</p>
<pre><code class="language-shell">$ cargo clippy
</code></pre>
<p>你也可以在 Playground 的右上角找到這個工具：</p>
<p><img src="https://i.imgur.com/ntFJz2W.png" alt="Image" /></p>
<p>它能對像這樣的程式碼提示更好的寫法：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let arr = [1, 2, 3, 4];

  if arr.iter().find(|x| x == &amp;&amp;3).is_some() {
    println!(&quot;Found 3&quot;);
  }

  let mut iter = arr.iter();

  loop {
    match iter.next() {
      Some(x) =&gt; println!(&quot;{}&quot;, x),
      None =&gt; break,
    }
  }
}
</code></pre></pre>
<p>它會產生像這樣的提示：</p>
<pre><code class="language-plain">warning: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.
 --&gt; src/main.rs:4:8
  |
4 |     if arr.iter().find(|x| x == &amp;&amp;3).is_some() {
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(clippy::search_is_some)] on by default
  = note: replace `find(|x| x == &amp;&amp;3).is_some()` with `any(|x| x == &amp;&amp;3)`
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/v0.0.212/index.html#search_is_some

warning: this loop could be written as a `while let` loop
  --&gt; src/main.rs:10:5
   |
10 | /     loop {
11 | |         match iter.next() {
12 | |             Some(x) =&gt; println!(&quot;{}&quot;, x),
13 | |             None =&gt; break,
14 | |         }
15 | |     }
   | |_____^ help: try: `while let Some(x) = iter.next() { .. }`
   |
   = note: #[warn(clippy::while_let_loop)] on by default
   = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/v0.0.212/index.html#while_let_loop
</code></pre>
<p>它並不單單是檢查程式碼風格而已，若有更好或更快的寫法也會提供給使用者，是個很方便的工具。</p>
<h2 id="evcxr"><a class="header" href="#evcxr">evcxr</a></h2>
<p>evcxr 是個 Rust 的 REPL ，可以讓你方便的測試一些簡單的程式碼，它的 Github 在 https://github.com/google/evcxr ，如果要安裝的話用：</p>
<pre><code class="language-shell">$ cargo install evcxr_repl
</code></pre>
<p>然後就可以在終端機下輸入 <code>evcxr</code> 來使用了，不過它目前很陽春， <code>if</code> 之類的必須輸入在同一樣，也只能用 <code>Ctrl + D</code> 關掉 (Windows 下是 <code>Ctrl + Z</code> ，不過作者並沒有測試過) 。</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<p>先說一下可以去哪邊找 crate ，首先是 <a href="https://github.com/rust-unofficial/awesome-rust">awesome-rust</a> ，這邊收集了不少的 crate 並做好了分類，再來是 <a href="https://crates.io/crates/ergo">ergo</a> ，這個專案原本是想收集一些常用的 crate 後整合到一個 crate 裡，不過有段時間沒維護了，但還是可以去看看他收集了哪些，大多都挺好用的。</p>
<h2 id="log"><a class="header" href="#log">log</a></h2>
<p><code>log</code> 是個由社群提出的標準的 log 介面，它在 https://crates.io/crates/log ，其實它只有 API 而已，本身沒有 log 的功能，如果要使用的話要搭配有實作它的 logger ，最簡單的就是 <a href="https://crates.io/crates/env_logger">env_logger</a> ，它會根據環境變數決定要顯示哪些 log ，使用起來很簡單：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

fn main() {
  env_logger::init();

  info!(&quot;Hello&quot;);
}
</code></pre></pre>
<p>如果想要自訂性比較高的話可以參考看看 <a href="https://crates.io/crates/slog">slog</a> ，它提供了可以抽換的各個部份，也有更多的設定，顯示的 log 也比較好看，但相對的也比較複雜點。</p>
<h2 id="num"><a class="header" href="#num">num</a></h2>
<p>https://crates.io/crates/num</p>
<p>num 是多個 crate 所組成的，它補足了 Rust 中對數字所不支援的部份，比如大數、分數與複數等等的運算，另外還有 <code>num-iter</code> 提供了支援設定間隔的數字迭代器， <code>num-integer</code> 與 <code>num-trait</code> 提供了一些運算。</p>
<h2 id="regex-1"><a class="header" href="#regex-1">regex</a></h2>
<p>https://crates.io/crates/regex</p>
<p>regex 提供了正規表示法的支援，至於正規表示法本身可以上網找一下教學，用在字串處理非常的好用。</p>
<h2 id="lazy_static"><a class="header" href="#lazy_static">lazy_static</a></h2>
<p>https://crates.io/crates/lazy_static</p>
<p>lazy_static 在之前有提過，它提供的是延遲計算的變數，只要在使用到時才會初始化：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate lazy_static;

use std::collections::HashMap;

lazy_static! {
  // 一定要加 ref ，因為為了做到延遲初始化， lazy_static 會用另一個型態包裝
  // 總之記得要加就對了
  static ref MAP: HashMap&lt;&amp;'static str, i32&gt; = {
    // 初始化的程式碼可以不只一行
    let mut map = HashMap::new();
    map.insert(&quot;foo&quot;, 1);
    map.insert(&quot;bar&quot;, 2);
    map
  };
}

fn main() {
  lazy_static! {
    // 也可以建一個只能在 main 裡使用的變數
    static ref FOO: i32 = 1;
  }
  assert_eq!(MAP.get(&quot;foo&quot;).unwrap(), &amp;1);
}
</code></pre></pre>
<h2 id="lazycell"><a class="header" href="#lazycell">lazycell</a></h2>
<p>https://crates.io/crates/lazycell</p>
<p>提供讓你的型態擁有延遲初始化的欄位的功能：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate lazycell;

use lazycell::LazyCell;

struct Foo {
  lazy_field: LazyCell&lt;i32&gt;,
}

impl Foo {
  pub fn new() -&gt; Self {
    Self { lazy_field: LazyCell::new() }
  }

  pub fn get_lazy(&amp;self) -&gt; &amp;i32 {
    // 若還沒初始化才會執行閉包中的內容做初始化，之後會回傳 borrow
    self.lazy_field.borrow_with(|| {
      42
    })
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="derive_more"><a class="header" href="#derive_more">derive_more</a></h2>
<p>https://crates.io/crates/derive_more</p>
<p>提供更多可以用在 derive 的 trait 。</p>
<h2 id="nix-與-libc"><a class="header" href="#nix-與-libc">nix 與 libc</a></h2>
<p>https://crates.io/crates/nix
https://crates.io/crates/libc</p>
<p>libc 提供直接存取底層 API ，而 nix 則是在上面做一層包裝，讓程式碼更安全，不過它們主要都是提供 Linux 下的功能。</p>
<h1 id="用-rust-呼叫-c-的程式"><a class="header" href="#用-rust-呼叫-c-的程式">用 Rust 呼叫 C 的程式</a></h1>
<p>若是其它的函式庫等等的， crates.io 上可能已經有人提供與那個函式庫的綁定了，可以直接抓來用， Rust 的 crate 的命名慣例中有個若一個 crate 是以 <code>-sys</code> 結尾，代表它提供的是最基礎的綁定，通常它的 API 都是 unsafe 的，若要使用還要花點工夫，也可以找找有沒有高階一點的綁定的函式庫。</p>
<h2 id="綁定-c-函式庫"><a class="header" href="#綁定-c-函式庫">綁定 C 函式庫</a></h2>
<p>此篇教學的程式碼會在 https://github.com/DanSnow/rust-intro/tree/master/c-binding</p>
<p>假設我們用 C 寫了個函式庫：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void say_hello(const char *message) {
  printf(&quot;%s from C&quot;, message);
}
</code></pre>
<p>這個檔案我們放在 <code>lib/hello.c</code> 。</p>
<p>然後我們要在 Rust 的程式中呼叫：</p>
<pre><pre class="playground"><code class="language-rust">use std::{ffi::CString, os::raw::c_char};

extern &quot;C&quot; {
  // 宣告一個外部的函式，傳入一個 C 的 char 指標
  fn say_hello(message: *const c_char);
}

fn main() {
  // 建立一個 C 的字串，也就是由 \0 結尾的字串
  let msg = CString::new(&quot;Hello&quot;).unwrap();
  // 呼叫，並把字串轉換成指標傳入
  unsafe { say_hello(msg.as_ptr()) };
}
</code></pre></pre>
<p>字串的部份應該是連結 C 的函式庫時最麻煩的一塊了，建議可以看一下文件的 <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>std::ffi::CString</code></a> 與跟它搭配的 <code>CStr</code> ，它們就是 Rust 中的 <code>String</code> 與 <code>str</code> 的 C 的版本，通常就是用來傳給 C 的函式庫用的。</p>
<p>這邊我們先嘗試自己手動建置 C 的函式庫，與連結吧，為了簡化這個過程我把建置的過程全部寫成了一個 <code>Makefile</code> 不過這並不是本教學的重點，可以直接去看程式碼的 <code>Makefile</code> 怎麼寫的，也可以上網找找要怎麼寫。</p>
<p>假設我們已經把 C 的部份建置好了，並放在 <code>lib/libhello.a</code> ，接著我們要讓 cargo 知道我們的程式還要去連結這個函式庫才能編譯，我們需要在根目錄下建一個 <code>build.rs</code> ，然後在裡面寫進這樣的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  // 告訴 cargo 我們要連結一個靜態的叫 libhello.a 的函式庫
  println!(&quot;cargo:rustc-link-lib=static=hello&quot;);
  // 告訴 cargo 要加上這個搜尋函式庫的位置
  println!(
    &quot;cargo:rustc-link-search={}&quot;,
    // 這邊為了簡化直接使用 concat! 這個 macro 來做字串的連結
    // 正常應該是要用 std::path::PathBuf 之類的來處理不同系統下的不同分隔符號
    // 因為在 Linux 下的分隔符號是 / 但在 Windows 下是 \
    concat!(
      // 這個會是專案的目錄
      env!(&quot;CARGO_MANIFEST_DIR&quot;),
      // 我們的函式庫所在的位置
      &quot;/lib&quot;
    )
  );
}
</code></pre></pre>
<p>cargo 在建置時會執行 <code>build.rs</code> 並依照裡面的特殊的輸出來處理，詳細可以去看看 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">cargo 的文件</a> ，裡面有詳細寫出這些特殊的輸出的用法，此外 <code>build.rs</code> 也可以提供一些不同的功能，比如使用 <a href="https://github.com/rustyhorde/vergen">vergen</a> ，這個 crate 可以幫助我們把目前的版本號存到環境變數，然後我們就可以在編譯時從環境變數讀進目前的版本號一起編譯進程式裡。</p>
<p>不過這樣我們就要靠自己寫 <code>Makefile</code> 來先建置 C 的函式庫才有辦法編譯，有點麻煩，當然 Rust 的社群也想到了這個問題，於是就做了個叫 <a href="https://github.com/alexcrichton/cc-rs">cc</a> 的 crate ，它能讓我們在 <code>build.rs</code> 中指定要編譯與連結的 C 函式庫，首先我們要先把它加進我們的的 <code>Cargo.toml</code> ，我們可以用這個指令：</p>
<pre><code class="language-shell">$ cargo add cc --build
</code></pre>
<blockquote>
<p>這個指令要安裝 <code>cargo-edit</code> 才有喔，沒裝的話請去看本系列第三篇</p>
</blockquote>
<p>然後把我們的 <code>build.rs</code> 改成：</p>
<pre><pre class="playground"><code class="language-rust">extern crate cc;

fn main() {
  cc::Build::new().file(&quot;lib/hello.c&quot;).compile(&quot;hello&quot;);
}
</code></pre></pre>
<p>就這樣，超簡單的， <code>Makefile</code> 也不需要了， cargo 在建置的過程就會去呼叫 gcc 來幫忙編譯 C 的函式庫，並做連結了。</p>
<p>如果要連結系統中的函式庫可以看看 <a href="https://github.com/alexcrichton/pkg-config-rs">pkg-config</a> 這個 crate ，這應該是 Linux 系統下大部份都支援的一個方式，或是直接使用上面所提到 <code>build.rs</code> 的使用方式來連結系統的函式庫。</p>
<h2 id="bindgen"><a class="header" href="#bindgen">bindgen</a></h2>
<p>https://github.com/rust-lang-nursery/rust-bindgen</p>
<p>bindgen 是個由 Rust 寫成的工具，用途是從 C 或 C++ 的標頭檔自動產生 Rust 的綁定，原本這個工具是 Mozilla 所開發的，不過目前已經轉移給 Rust 的社群了，它有指令介面與用在 <code>build.rs</code> 兩種用法，先介紹指令介面，首先先來安裝：</p>
<pre><code class="language-shell">$ cargo install bindgen
</code></pre>
<p>接著我們幫剛剛的 <code>hello.c</code> 定義個標頭檔：</p>
<pre><code class="language-c">#ifndef HELLO_H_INCLUDE
#define HELLO_H_INCLUDE

void say_hello(const char *message);

#endif
</code></pre>
<p>使用指令：</p>
<pre><code class="language-shell">$ bindgen hello.h
</code></pre>
<p>應該會看到這樣的輸出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* automatically generated by rust-bindgen */

extern &quot;C&quot; {
  pub fn say_hello(message: *const ::std::os::raw::c_char);
}
<span class="boring">}
</span></code></pre></pre>
<p>其實這跟我們自己寫的沒什麼兩樣，不過因為是自動產生的，若要幫一些比較大的第三方函式庫做綁定時能自動產生就很方便，於是上面的程式碼就可以直接使用，然後像上面介紹的方法一樣去連結與建置了。</p>
<p>接下來我們用 <code>build.rs</code> 來產生綁定：</p>
<pre><pre class="playground"><code class="language-rust">extern crate bindgen;
extern crate cc;

use std::{env, path::PathBuf};

fn main() {
  // 剛剛的程式碼
  cc::Build::new().file(&quot;lib/hello.c&quot;).compile(&quot;hello&quot;);

  let bindings = bindgen::Builder::default()
    .header(&quot;lib/hello.h&quot;)
    .generate()
    .expect(&quot;Unable to generate bindings&quot;);

  // 這會寫到 Rust 所用的暫存資料夾
  let out_dir = PathBuf::from(env::var(&quot;OUT_DIR&quot;).unwrap());
  bindings
    .write_to_file(out_dir.join(&quot;bindings.rs&quot;))
    .expect(&quot;Couldn't write bindings!&quot;);
}
</code></pre></pre>
<p>然後我們讓原本的程式碼改成引入自動產生的綁定：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/bindings.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>再建置一次，應該會成功，不過時間會花的比較久，因為 bindgen 有點大。</p>
<h1 id="從-c-呼叫-rust"><a class="header" href="#從-c-呼叫-rust">從 C 呼叫 Rust</a></h1>
<p>這次的程式碼在 https://github.com/DanSnow/rust-intro/tree/master/clib</p>
<h2 id="建立可以給-c-使用的函式庫"><a class="header" href="#建立可以給-c-使用的函式庫">建立可以給 C 使用的函式庫</a></h2>
<p>Rust 跟 C 真的是個很合的語言，要從 C 呼叫 Rust 的程式也很簡單，這次我們來建立一個之前都沒有使用過的函式庫專案：</p>
<pre><code class="language-shell">$ cargo init --lib clib
</code></pre>
<p>然後修改 <code>Cargo.toml</code> 加上一段：</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>這代表我們要 cargo 建置出可以用來做靜態連結的函式庫，接著來準備個給 C 使用的函式吧，打開 <code>lib.rs</code> 輸入：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{ffi::CStr, os::raw::c_char};

// 讓編譯器不要修改函式的名稱
#[no_mangle]
// 為了讓函式能夠被 C 呼叫，這邊要加上 extern &quot;C&quot;
pub extern &quot;C&quot; fn say_hello(message: *const c_char) {
  // 包裝 C 的字串成 Rust 的 CStr ，這樣才方便被 Rust 處理
  let message = unsafe { CStr::from_ptr(message) };
  // to_str 會轉換 CStr 成 str ，但如果字串不是合法的 utf-8 編碼就會回傳 Err
  println!(&quot;{} from Rust&quot;, message.to_str().unwrap());
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 的編譯器會修改函式名稱，加上模組等資訊來避免出現重覆的名稱，另外 Rust 的調用約定 (calling convention) 也與 C 不同，因此必須加上 <code>extern &quot;C&quot;</code> 讓 Rust 使用 C 的調用約定，這樣我們才能直接在 C 使用這些函式。</p>
</blockquote>
<p>接著我們來寫 C 的程式吧：</p>
<pre><code class="language-c">void say_hello(const char *message);

int main() {
  say_hello(&quot;Hello&quot;);
}
</code></pre>
<p>這次我們一樣為了簡化編譯的過程把這部份寫成了一個 <code>Makefile</code> ，可以自己打開來看看，執行的話應該會看到：</p>
<pre><code class="language-plain">Hello from Rust
</code></pre>
<h2 id="傳遞-struct"><a class="header" href="#傳遞-struct">傳遞 struct</a></h2>
<p>若要把 Rust 的 struct 給 C 使用的話：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 加上 repr(C) 可以讓 Rust 的型態具有跟 C 一樣的記憶體結構
#[repr(C)]
pub struct Point {
  x: i32,
  y: i32,
}

#[no_mangle]
pub extern &quot;C&quot; fn create_point(x: i32, y: i32) -&gt; Point {
  Point { x, y }
}
<span class="boring">}
</span></code></pre></pre>
<p>C 這邊若要使用：</p>
<pre><code class="language-c">typedef struct _Point {
  int x;
  int y;
} Point;

Point create_point(int x, int y);

create_point(10, 20);
</code></pre>
<h2 id="分配記憶體"><a class="header" href="#分配記憶體">分配記憶體</a></h2>
<p>如果要在 Rust 裡分配個記憶體並傳給 C 用的話我們可以使用 <code>Box</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn alloc_memory() -&gt; *mut i32 {
  // 將 Box 轉換成 C 的指標
  Box::into_raw(Box::new(42))
}

#[no_mangle]
pub extern &quot;C&quot; fn free_memory(x: *mut i32) {
  // 從指標建立回 Box ，這樣才能讓 Rust 知道怎麼回收這塊記憶體
  // 這邊使用 drop 明確的清掉這個 Box
  // 不過 Rust 其實也會在 Box 離開有效範圍時自動清掉，所以也不一定要這樣做
  drop(unsafe { Box::from_raw(x) });
}
<span class="boring">}
</span></code></pre></pre>
<p>C 的部份：</p>
<pre><code class="language-c">// 補充一個 C 語言的小知識，若函式的宣告中沒放東西代表的是傳什麼都可以
// 所以我都會習慣在沒有參數時放 void
int *alloc_memory(void);
void free_memory(int *x);

int *x = alloc_memory();
// 這邊可以使用這個變數
*x = 123;
// 記得把空間交回給 Rust 清除
free_memory(x);
</code></pre>
<blockquote>
<p>務必讓 Rust 清理記憶體， Rust 預設並不是使用 malloc 與 free ，若用 free 來清理是會出問題的，再者，只有 Rust 知道那個型態有沒有其它需要釋放的資源。</p>
</blockquote>
<h2 id="傳-vec"><a class="header" href="#傳-vec">傳 Vec</a></h2>
<p>Rust 的 <code>Vec</code> 真的很方便，可以自動的成長，做為陣列使用就不用擔心空間不夠的問題 (除非你的環境的記憶體很珍貴) ，如果要傳遞給 C 使用的話要怎麼辦呢：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

#[no_mangle]
// 這邊多使用了一個參數，用來回傳長度
pub extern &quot;C&quot; fn create_vec(size: *mut usize) -&gt; *mut i32 {
  let mut vec = Vec::new();
  // 假設做了些工作來產生這個 Vec
  vec.push(1);
  vec.push(2);
  vec.push(3);

  // 讓 Vec 的容量與實際大小一樣
  vec.shrink_to_fit();
  // 一般來說都會一樣，不過這並沒有保證，詳細可以看一下文件
  // 這邊用 assert 確保這種情況不會出現
  assert!(vec.capacity() == vec.len());
  // 回傳大小
  unsafe { *size = vec.len() };
  // 取得指標
  let p = vec.as_mut_ptr();
  // 這讓 vec 不會被 Rust 清除
  mem::forget(vec);
  p
}

#[no_mangle]
pub extern &quot;C&quot; fn free_vec(vec: *mut i32, size: i32) {
  drop(unsafe { Vec::from_raw_parts(vec, size, size) });
}
<span class="boring">}
</span></code></pre></pre>
<p>在 C 中使用：</p>
<pre><code class="language-c">int *create_vec(size_t *size);
void free_vec(int *vec, size_t size);

size_t size;
int *vec = create_vec(&amp;size);
for (size_t i = 0; i &lt; size; ++i) {
  printf(&quot;%d &quot;, vec[i]);
}
// 換行
puts(&quot;&quot;);
free_vec(vec, size);
</code></pre>
<h2 id="自動產生-c-的標頭檔"><a class="header" href="#自動產生-c-的標頭檔">自動產生 C 的標頭檔</a></h2>
<p>前面我們都自己宣告 C 的函式，這次讓程式來自動幫我們產生標頭檔吧，首先加上 <code>cbindgen</code> ：</p>
<pre><code class="language-shell">$ cargo add cbindgen --build
</code></pre>
<p>然後同樣的我們需要 <code>build.rs</code> ：</p>
<pre><pre class="playground"><code class="language-rust">extern crate cbindgen;

use std::env;

fn main() {
    let crate_dir = env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap();

    cbindgen::generate(crate_dir)
        .expect(&quot;Unable to generate bindings&quot;)
        // 寫到 bindings.h 這個檔案
        .write_to_file(&quot;bindings.h&quot;);
}
</code></pre></pre>
<p>接著我們需要一個設定檔：</p>
<pre><code class="language-toml"># 不設定的話預設會是 C++
language = &quot;C&quot;
# 設定 C 的 struct 要不要加 typedef
style = &quot;Both&quot;
# 設定 include guard
include_guard = &quot;INCLUDE_BINDINGS_H&quot;
</code></pre>
<p>再跑一次 <code>cargo build</code> 應該就會看到它產生一份這樣的標頭檔了：</p>
<pre><code class="language-c">#ifndef INCLUDE_BINDINGS_H
#define INCLUDE_BINDINGS_H

#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef struct Point {
  int32_t x;
  int32_t y;
} Point;

int32_t *alloc_memory(void);

Point create_point(int32_t x, int32_t y);

int32_t *create_vec(uintptr_t *size);

void free_memory(int32_t *x);

void free_vec(int32_t *vec, uintptr_t size);

void say_hello(const char *message);

#endif /* INCLUDE_BINDINGS_H */
</code></pre>
<p>這樣產生宣告的部份就自動化了，我們的 C 的部份只要負責呼叫就好了，可喜可賀。</p>
<h1 id="實作-python-的原生擴充與條件編譯"><a class="header" href="#實作-python-的原生擴充與條件編譯">實作 Python 的原生擴充與條件編譯</a></h1>
<p>Python 是個廣泛使用的腳本語言，想必或多或少都有聽過這個名字吧，人工智慧、科學計算、統計、應用程式、爬蟲等等的領域無不存在，非常的實用，如果想學個腳本語言的話非常推薦，雖然我個人是 Ruby 派的。</p>
<p>在這方便的程式語言中若偶爾碰到了需要對底層的東西做操作又找不到相關的函式庫時，就只好自己來寫綁定啦，或是有某部份需要加速等等的， Rust 的社群提供了一個很棒的 Python 綁定： <a href="https://github.com/PyO3/pyo3">PyO3</a></p>
<p>本次的程式碼在 https://github.com/DanSnow/rust-intro/tree/master/python-binding</p>
<p>PyO3 需要使用到 nightly 版本的 Rust ，因為它目前使用到了一個還未穩定的功能 <code>specialization</code> ，中文翻譯叫「特化」，它可以讓你為特定的型態提供不同的 trait 的實作，實際上標準函式庫中也有因為效能原因而為 <code>&amp;str</code> 提供特化的 <code>to_string</code> 實作。</p>
<blockquote>
<p>Rust 只有 nightly 的編譯器支援開啟這些不穩定的功能，但是為了要編譯標準函式庫， Rust 的編譯器使用了個特殊的環境變數允許在穩定版開啟這些功能。</p>
</blockquote>
<p>我們先來設定我們的專案與安裝 PyO3 吧，這次比較特別點，我們必須手動修改 <code>Cargo.toml</code> ，在 <code>[dependencies]</code> 後加上：</p>
<pre><code class="language-toml">pyo3 = { version = &quot;0.4.1&quot;, features = [&quot;extension-module&quot;] }
</code></pre>
<p><code>features</code> 是代表我們需要的功能， Rust 支援使用者在程式裡設定一些只在某些功能開啟或關閉的情況下才編譯的程式碼，而我們這邊需要開啟 <code>extension-module</code> 這個功能才有辦法把 Rust 的程式編譯成 Python 的擴充模組。</p>
<blockquote>
<p>這有點像在 C 裡使用 <code>define</code> 定義常數加上 <code>ifdef</code> 等等來開關功能。</p>
</blockquote>
<p>接著我們再加入一段設定：</p>
<pre><code class="language-toml">[lib]
name = &quot;binding&quot;
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>這邊是設定編譯完的輸出檔名與我們要編譯成動態函式庫，這樣才能讓 Python 載入。</p>
<p>總之先像往常一樣寫個 Hello world ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 開啟 specialization 這個功能，這只能在 nightly 版才能使用
#![feature(specialization)]

#[macro_use]
extern crate pyo3;

// 直接引入 prelude
use pyo3::prelude::*;

// 標記這是個給 python 的函式，這是 PyO3 提供的功能
// 這些函式必須回傳 PyResult
#[pyfunction]
fn hello() -&gt; PyResult&lt;()&gt; {
  println!(&quot;Hello from Rust&quot;);
  Ok(())
}

// 標記這是 python 模組初始化用的函式
#[pymodinit]
fn binding(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
  // 將我們的函式匯出給 python 使用
  m.add_function(wrap_function!(hello))?;

  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>然後我們編譯我們的函式庫：</p>
<pre><code class="language-shell">$ cargo build
</code></pre>
<blockquote>
<p>如果你編譯失敗的話你會需要安裝 <code>python3-dev</code></p>
</blockquote>
<p>編譯完後你應該看到我們編譯好的檔案在 <code>target/debug/libbinding.so</code> (如果你是用 Windows 的話會是 <code>binding.dll</code> ， Mac 會是 <code>libbinding.dylib</code>) ，我們把它複製出來，然後改名成 <code>binding.so</code> (Mac 也一樣， Windows 要改成 <code>binding.pyd</code>) ，接著你可以在終端機下輸入 <code>python3</code> (或 <code>python</code>) 來打開 Python 的 repl ，或你也可以選擇使用 <code>ipython</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; import binding
&gt;&gt;&gt; binding.hello()
Hello from Rust
</code></pre>
<blockquote>
<p><code>&gt;&gt;&gt;</code> 是 Python 的提示字元，後面的內容是你要輸入的。</p>
</blockquote>
<p>這次我們來計算 π (PI) 吧，也就是圓周率，我們用的是蒙地卡羅的計算方法，總之大概就是正方型與其內切圓的面積為 4:PI ，所以我們隨機的打點，然後計算落在圓中的次數來反算 PI ，用 Python 是這樣的：</p>
<pre><code class="language-python">from random import random

TIMES = 1000_0000


def calculate_pi():
    hit = 0

    for _i in range(0, TIMES):
        x = random()
        y = random()
        if x * x + y * y &lt;= 1.0:
            hit += 1
    return hit * 4 / TIMES
</code></pre>
<p>在上面隨機的產生了 1 千萬次的點，然後最後回傳算出 PI 的近似值，接著我們用 timeit 這個 Python 的 module 來算耗時：</p>
<pre><code class="language-python">print(&quot;Python:&quot;, timeit.timeit(&quot;calculate_pi()&quot;, number=3, globals=globals()))
</code></pre>
<p>重覆執行三次算平均，在我的電腦上大概花了 4 秒。</p>
<p>接著我們用 Rust 實現同樣的演算法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyfunction]
fn calculate_pi() -&gt; PyResult&lt;f64&gt; {
  let mut hit = 0;
  for _ in 0..TIMES {
    let x = rand::random::&lt;f64&gt;();
    let y = rand::random::&lt;f64&gt;();
    if x * x + y * y &lt;= 1.0 {
      hit += 1;
    }
  }
  Ok(f64::from(hit * 4) / f64::from(TIMES))
}
<span class="boring">}
</span></code></pre></pre>
<p>一樣在 Python 用 timeit 計算時間，這次只花了 0.7 秒，快了大約 5 倍啊。</p>
<p>最後若我們搭配之前介紹的 rayon 做平行化：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyfunction]
fn calculate_pi_parallel(py: Python) -&gt; PyResult&lt;f64&gt; {
  let hit: i32 = py.allow_threads(|| {
    (0..TIMES)
      .into_par_iter()
      .map(|_| {
        let x = rand::random::&lt;f64&gt;();
        let y = rand::random::&lt;f64&gt;();
        if x * x + y * y &lt;= 1.0 {
          1
        } else {
          0
        }
      })
      .sum()
  });
  Ok(f64::from(hit * 4) / f64::from(TIMES))
}
<span class="boring">}
</span></code></pre></pre>
<p>使用到執行緒的部份必須包在 <code>py.allow_threads</code> 裡，不然會出問題，這次只花了 0.3 秒，底下是在我電腦上執行的完整結果：</p>
<pre><code class="language-plain">Python: 4.45852969000407
Rust: 0.7022144030052004
Rust parallel: 0.30857402100082254
</code></pre>
<p>PyO3 雖然需要使用到 nightly 版的 Rust ，但它真的很方便，實際上 PyO3 的 macro 幫我們產生了很多在 Rust 與 Python 之間轉換資料型態的程式碼，我們才能這麼簡單的寫與 Python 的綁定，如果有興趣的話有另一個 crate 叫 cpython ，它是 PyO3 的前身，但它並沒有提供這些自動產生的程式碼，所以可以看到這中間做了哪些轉換。</p>
<h2 id="條件編譯"><a class="header" href="#條件編譯">條件編譯</a></h2>
<p>因為上面正好提到了，就順便來講一下，條件編譯不只可以做出可以開關的功能，也能在不同系統或架構下提供不同的功能。</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(unix)]
fn print_os() {
  println!(&quot;你在使用類 Unix 的系統&quot;);
}

#[cfg(windows)]
fn print_os() {
  println!(&quot;你在使用 Windows 系統&quot;);
}

fn main() {
  print_os();
}
</code></pre></pre>
<p>上面的程式在 Windows 下與 Linux 下會印出不同的東西，因為 Rust 的編譯器會根據不同的作業系統而選擇編譯不同的程式，這也不只可以用在函式上而已，還可以用在模組的引入：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(unix)]
mod unix_imp;
#[cfg(unix)]
use unix_imp as imp;

// Use imp::...
<span class="boring">}
</span></code></pre></pre>
<p>這很類似在標準函式庫中提供在不同系統下不同實作的方法。</p>
<p>另外也可以在 <code>Cargo.toml</code> 中宣告 <code>[features]</code> ：</p>
<pre><code class="language-toml">[features]
default = [] # 預設開啟的功能
foo = [] # 一個叫 foo 的功能，後面可以放相依的功能或是支援這個功能所額外需要的 crate
</code></pre>
<p>然後在程式碼中使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;foo&quot;)]
fn foo() {
  // 實作 foo 功能等等
}
<span class="boring">}
</span></code></pre></pre>
<p>這篇展示了怎麼建立 Python 的綁定，大部份的腳本語言都有支援用 C 擴充它的功能 (但像 Node.js 是用 C++) ，這使得這些腳本語言能透過這些原生的擴充模組存取系統底層或是加速，而只要能夠支援 C 就能透過 Rust 實作，有著接近 C 的速度，卻有如此大量的社群套件支援，用 Rust 來實作這些原生套件真的不失一個選擇。</p>
<h1 id="指令列工具與-http-client"><a class="header" href="#指令列工具與-http-client">指令列工具與 HTTP Client</a></h1>
<p>本次的程式碼在 https://github.com/DanSnow/rust-intro/tree/master/hastebin-client</p>
<p>這次來寫個在指令列下使用的小工具吧，各位知道 <a href="https://hastebin.com/about.md">hastebin</a> 嗎？是個開源，而且很陽春的 pastebin ，今天的目標是來寫個它的用戶端，首先先建立專案並安裝幾個相依套件吧：</p>
<pre><code class="language-shell">$ cargo init hastebin-client
$ cd hastebin-client
$ cargo add atty clap reqwest serde serde_derive
</code></pre>
<p>那幾個 crate 功能分別是：</p>
<ul>
<li><a href="https://github.com/softprops/atty">atty</a>： 偵測是不是終端機</li>
<li><a href="https://github.com/clap-rs/clap">clap</a>： 分析指令列的參數</li>
<li><a href="https://github.com/seanmonstar/reqwest">reqwest</a>： Http 的用戶端</li>
<li><a href="https://github.com/serde-rs/serde">serde</a> 與 serde_derive ： 序列化與反序列化的函式庫，這在 Rust 的生態系中很常用</li>
</ul>
<p>我們先試著用 reqwest 送出一份文件吧：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate serde_derive;
extern crate reqwest;
extern crate serde;

use reqwest::{Client, Url};

const URL: &amp;str = &quot;https://hastebin.com&quot;;
// 這邊會把我們的程式碼以字串的型式引入進來
const SOURCE: &amp;str = include_str!(&quot;main.rs&quot;);

// Deserialize 是 serde 提供的，只要加上去就能從資料反序列化回 Rust 的這個型態
#[derive(Clone, Debug, Deserialize)]
struct Data {
    key: String,
    // 因為這個欄位不一定會有，所以讓 serde 在沒有這個欄位時用預設值
    #[serde(default)]
    message: Option&lt;String&gt;,
}

fn main() -&gt; reqwest::Result&lt;()&gt; {
  // 把網址 parse 成 Url 的型態
  let base = Url::parse(URL).unwrap();
  // 建一個 reqwest 的用戶端
  let client = Client::new();
  let res = client
    // 建立 post 的請求，並在網址後附上 documents
    // 完整的網址就變成 https://hastebin.com/documents 這正是 hastebin 的 api
    .post(base.join(&quot;documents&quot;).unwrap())
    // body 為我們的原始碼
    .body(SOURCE)
    // 送出請求
    .send()?
    // 將回傳的資料做為 json 反序列化為 data
    .json::&lt;Data&gt;()?;
  // 印出來
  println!(&quot;{:?}&quot;, res);
  Ok(())
}
</code></pre></pre>
<p>實際執行一次會看到這樣的輸出：</p>
<pre><code class="language-plain">Data { key: &quot;avamicupez&quot;, message: None }
</code></pre>
<p>這邊的 key 是文件的代碼，你的應該不會跟我的一樣，這代表我們的文件在 https://hastebin.com/avamicupez 。</p>
<p>接著我們來加上更多功能吧，我希望這個程式可以讓我接上檔名就可以上傳該文件，若沒有接上檔名時則從標準輸入讀進來，還要顯示上傳後的網址，底下只有大概列一下改變的部份：</p>
<pre><pre class="playground"><code class="language-rust">// ...
extern crate clap;

use clap::{App, Arg};
use reqwest::{Body, Client, Url};
use std::{
    fs::File,
    io::{stdin, Read},
    process,
};

// ...

fn main() -&gt; reqwest::Result&lt;()&gt; {
  // 設定 clap
  let matches = App::new(&quot;haste-client&quot;)
    .author(&quot;DanSnow&quot;)
    .version(&quot;0.1.0&quot;)
    // 定義一個可選的位置的參數
    .arg(Arg::with_name(&quot;FILE&quot;).index(1))
    // 取得 parse 的結果
    .get_matches();
  // 決定要怎麼取得 body ，在有給檔名時使用檔名
  let body = if let Some(file) = matches.value_of(&quot;FILE&quot;) {
    // 開檔
    match File::open(file) {
      // 轉換成 Body
      Ok(f) =&gt; Body::from(f),
      Err(err) =&gt; {
        eprintln!(&quot;開啟檔案失敗： {}&quot;, err);
        process::exit(1);
      }
    }
  } else {
    // 這邊是讀標準輸入
    let mut buf = String::new();
    stdin()
      .lock()
      .read_to_string(&amp;mut buf)
      .expect(&quot;讀輸入失敗&quot;);
    Body::from(buf)
  };
  // ...
  let res = client
    .post(base.join(&quot;documents&quot;).unwrap())
    .body(body)
    .send()?
    .json::&lt;Data&gt;()?;
  println!(&quot;{}&quot;, base.join(&amp;res.key).unwrap());
  Ok(())
}
</code></pre></pre>
<p>到這邊就完成了一個很陽春的用戶端了，很簡單吧，我們再多加一點功能好了，如果加上參數 <code>--raw</code> 就顯示另一個 <code>raw</code> 版本的網址，如果標準輸入是終端機的話就打開 vim (Linux 中在終端機下的一個老牌的文字編輯器)，讓使用者編輯檔案，編輯完再上傳，同樣的，這次只列出修改的部份：</p>
<pre><pre class="playground"><code class="language-rust">// ...
extern crate atty;

use atty::Stream;
use std::{
  env,
  fs::{self, File},
  io::{stdin, Read},
  process::{self, Command},
};

// ...

fn main() -&gt; reqwest::Result&lt;()&gt; {
  let matches = App::new(&quot;haste-client&quot;)
    .author(&quot;DanSnow&quot;)
    .version(&quot;0.1.0&quot;)
    // 增加 RAW 這個參數，設定參數使用的是 --raw
    .arg(Arg::with_name(&quot;RAW&quot;).long(&quot;raw&quot;))
    .arg(Arg::with_name(&quot;FILE&quot;).index(1))
    .get_matches();
  let body = if let Some(file) = matches.value_of(&quot;FILE&quot;) {
    // ...
    // 判斷是不是終端機
  } else if atty::is(Stream::Stdin) {
    // 建個放暫存檔的位置
    let path = env::temp_dir().join(&quot;haste-client-tempfile&quot;);
    // 啟動 vim 打開這個暫存檔
    let mut child = Command::new(&quot;vim&quot;)
      .arg(path.as_os_str())
      .spawn()
      .expect(&quot;開啟 vim 失敗&quot;);
    child.wait().expect(&quot;等待 vim 結束失敗&quot;);
    // 開啟暫存檔
    let file = File::open(&amp;path).expect(&quot;開啟暫存檔失敗&quot;);
    // 刪除暫存檔，在 Linux 就算刪除檔案，已經開啟的人還是可以正常讀寫檔案
    // 這招在 Windows 下不適用
    fs::remove_file(path).expect(&quot;刪除暫存檔失敗&quot;);
    Body::from(file)
  } else {
    // ...
  };
  // 檢查有沒有 RAW 參數，若有則在網址加上 raw
  let mut url = base;
  if matches.is_present(&quot;RAW&quot;) {
      url = url.join(&quot;raw/&quot;).unwrap();
  }
  println!(&quot;{}&quot;, url.join(&amp;res.key).unwrap());
  Ok(())
}
</code></pre></pre>
<p>這樣子已經挺好用的了，不過我們再加個參數好了，因為 hastebin 可以自己架設，所以我們加個 <code>--host</code> 的參數讓使用者決定要不要用自己的伺服器，同時也讀取 <code>HASTE_SERVER</code> 這個環境變數來找伺服器，順序是 <code>--host</code> &gt; <code>HASTE_SERVER</code> &gt; 預設值，以下是程式碼：</p>
<pre><pre class="playground"><code class="language-rust">// ...
fn main() -&gt; reqwest::Result&lt;()&gt; {
  let matches = App::new(&quot;haste-client&quot;)
    .author(&quot;DanSnow&quot;)
    .version(&quot;0.1.0&quot;)
    .arg(
      // 定義一個叫 HOST 的參數，它需要值，這次支援使用 -h 或 --host
      Arg::with_name(&quot;HOST&quot;)
        .short(&quot;h&quot;)
        .long(&quot;host&quot;)
        .takes_value(true),
    )
    .arg(Arg::with_name(&quot;RAW&quot;).long(&quot;raw&quot;))
    .arg(Arg::with_name(&quot;FILE&quot;).index(1))
    .get_matches();
  // ...
  let base = Url::parse(
    // 先嘗試取得 HOST 的內容並轉換成 String
    &amp;matches
      .value_of(&quot;HOST&quot;)
      .map(ToOwned::to_owned)
      // 取得環境變數的值，並用 ok 將 Result 轉換成 Option
      .or(env::var(&quot;HASTE_SERVER&quot;).ok())
      // unwrap ，若沒有值則用預設值
      .unwrap_or_else(|| URL.to_owned()),
  )
  .unwrap();
  // ...
}
</code></pre></pre>
<p>另外你也可以對這個程式使用 <code>--help</code> 或 <code>--version</code> 看看，這兩個是 clap 自動幫我們加上去的 clap 還有其它的使用方法，有興趣可以去看文件，還有 serde 系列的還有個叫 serde_json 的函式庫，可以把 Rust 的值轉換成 json 或是從 json 轉換回來，也建議參考看看。</p>
<p>這次實作的 hastebin 的用戶端，我覺得做起來還挺簡單的，你覺得呢？ Rust 的社群提供了這些強大的 crate 讓這些功能的實作都變的很容易，雖然同樣的功能用 Python 等等的腳本語言做起來肯定更簡單，但 Rust 的程式碼我並沒有覺得有複雜到哪裡去，而且執行速度又快又是原生的程式，如果你會寫 Go 的話要不要試著寫一個來比較看看呢？</p>
<p>這次的用戶端其實也還有些可以改進的地方，比如：</p>
<ul>
<li>錯誤處理的部份，像 <code>--host</code> 亂輸入</li>
<li>使用 <code>EDITOR</code> 環境變數來打開使用者偏好的編輯器</li>
</ul>
<p>或許你也可以想想看有什麼地方能改進的。</p>
<h1 id="diesel-rust-的-orm"><a class="header" href="#diesel-rust-的-orm">Diesel： Rust 的 ORM</a></h1>
<p>在開始之前，我有個想講的東西，不過你也可以跳過這段直接看底下的正文。</p>
<p>昨天的程式碼中的第 68 行所出現的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;matches
  .value_of(&quot;HOST&quot;)
  .map(ToOwned::to_owned)
  .or(env::var(&quot;HASTE_SERVER&quot;).ok())
  .unwrap_or_else(|| URL.to_owned())
<span class="boring">}
</span></code></pre></pre>
<p>老實說，後來想想我不太喜歡這個部份，昨天因為 <code>env::var</code> 回傳的是 <code>String</code> ，而另外兩個是 <code>&amp;str</code> ，為了通過 Rust 的編譯所以必須讓型態統一，而我的做法是把全部都轉成 <code>String</code> ，雖然是在有值的時候才轉換，但傳入網址的地方所要的只是 <code>&amp;str</code> 而已，也就是若建了 <code>String</code> 也只是存活到這個函式呼叫結束而已，如果可以我想讓 <code>&amp;str</code> 保持 <code>&amp;str</code> 就好，但這有可能嗎？有的，這時候就是 <a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> 出場了。</p>
<p><code>Cow</code> 也算是個智慧指標，不知道各位有沒有聽過「寫入時複製 (copy on write)」，簡單來說就是個在發生修改時將內容複製一份來避免修改到原本的內容，同時又可以減少資源的消耗 (若沒發生寫入就沒必要複製)，而 <code>Cow</code> 正是這個功能在 Rust 中的實現，你可以把一個唯讀的 borrow 給它，然後在有必要修改時呼叫 <code>to_mut</code> ， <code>Cow</code> 會把 borrow 的值複製一份讓你修改，但若已經複製過了，那就不需要再複製了。</p>
<p>不過這有什麼關係呢？有的， <code>Cow</code> 是個列舉，它有兩個 variant 分別是 <code>Borrowed</code> 與 <code>Owned</code> ，各別代表借來的資料與自己擁有的資料，注意到了嗎？它幫 borrow 的資料與擁有的資料提供了一個統一的介面啊，於是我們把上面那份程式碼中的字串們都用 <code>Cow</code> 包裝起來：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;matches
  .value_of(&quot;HOST&quot;)
  .map(Cow::from)
  .or(env::var(&quot;HASTE_SERVER&quot;).ok().map(Cow::from))
  .unwrap_or(Cow::from(URL))
<span class="boring">}
</span></code></pre></pre>
<p>這樣感覺好多了， <code>&amp;str</code> 轉換成 <code>String</code> 必須要把字串的內容複製一份，而 <code>Cow</code> 只會多出一點點的空間耗用就可以同時相容 <code>&amp;str</code> 與 <code>String</code> 了，寫這種系統程式語言就實在是會忍不住去在意這種消耗記憶體的事啊，此外這邊的程式碼已經更新上去了。</p>
<h2 id="diesel"><a class="header" href="#diesel">Diesel</a></h2>
<p>這次的程式碼在： https://github.com/DanSnow/rust-intro/tree/master/message-board</p>
<p>今天要介紹的是 <a href="http://diesel.rs/">Diesel</a> ，這是個 Rust 的 ORM 與 Query Builder ，它支援 pgsql 、 mysql 與 sqlite ，並能在編譯時就檢查出部份的語法錯誤 (比如使用到了該資料庫不支援的功能)。</p>
<blockquote>
<p>ORM 的中文翻釋是「物件關聯對應」，原本是指將不同系統中的資料對應到程式語言中的物件，不過現在很多都已經變成指這種能連接資料庫，並把查詢結果變成物件的函式庫了。</p>
</blockquote>
<p>在開始使用前要先安裝 Diesel 的工具，請輸入以下指令：</p>
<pre><code class="language-shell">$ cargo install diesel_cli
</code></pre>
<blockquote>
<p>預設它會開啟所有能支援的資料庫，若你只需要它支援部份的資料庫可以用以下指令</p>
</blockquote>
<pre><code class="language-shell">$ cargo install diesel_cli --no-default-features --features sqlite
</code></pre>
<blockquote>
<p>本篇教學只會使用到 sqlite ，若你還想要支援 mysql 可以用逗號隔開 <code>--features sqlite,mysql</code> ，另外也有 <code>postgres</code> ，此外安裝時還會需要對應的系統函式庫，比如若要支援 sqlite 在 Ubuntu 下就要安裝 <code>libsqlite3-dev</code> 。</p>
</blockquote>
<h2 id="設定專案"><a class="header" href="#設定專案">設定專案</a></h2>
<p>然後來建立一下專案，這次我們來做一個留言板，不過今天只是先介紹資料庫的使用部份：</p>
<pre><code class="language-shell">$ cargo new message-board
$ cd message-board
$ cargo add dotenv diesel
</code></pre>
<p>接著我們需要修改一下 <code>Cargo.toml</code> ，把 diesel 的那行改成如下，開啟 sqlite 的支援：</p>
<pre><code class="language-toml">diesel = { version = &quot;1.3.3&quot;, features = [&quot;sqlite&quot;] }
</code></pre>
<p>接下來設定資料庫的位置，建一個叫 <code>.env</code> 的檔案後加入一行：</p>
<pre><code class="language-shell">DATABASE_URL=db.sqlite
</code></pre>
<p>之後執行：</p>
<pre><code class="language-shell">$ diesel setup
</code></pre>
<p>到這邊我們應該會看到 diesel 已經幫我們建好了資料庫的檔案 <code>db.sqlite</code> 與一個資料夾 <code>migrations</code> 還有一個設定檔 <code>diesel.toml</code> ， <code>migrations</code> 這個資料夾是用來放建立與修改資料表的檔案用的。</p>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<p>我們先建一個存貼文的表格吧：</p>
<pre><code class="language-shell">$ diesel migration generate create_posts
</code></pre>
<p>它會在 <code>migrations</code> 的資料夾下建立一個以日期、一組號碼與 <code>create_post</code> 命名的資料夾，在底下會有兩個檔案， <code>up.sql</code> 與 <code>down.sql</code> 分別為建立的 SQL 與撤消的 SQL ，我們先在 <code>up.sql</code> 中寫入建立資料表的指令：</p>
<pre><code class="language-sql">CREATE TABLE posts (
  id INTEGER NOT NULL PRIMARY KEY,
  author VARCHAR NOT NULL,
  title VARCHAR NOT NULL,
  body TEXT NOT NULL
);
</code></pre>
<p>然後在 <code>down.sql</code> 中寫入刪除資料表的指令：</p>
<pre><code class="language-sql">DROP TABLE posts;
</code></pre>
<p>接著執行：</p>
<pre><code class="language-shell">$ diesel migration run
</code></pre>
<p>它會執行剛剛寫好的 SQL ，同時也會更新 <code>src/schema.rs</code> 這個檔案，你可以打開來，應該會看到以下內容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
  posts (id) {
    id -&gt; Integer,
    author -&gt; Text,
    title -&gt; Text,
    body -&gt; Text,
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>這個檔案是記錄目前的資料表結構， diesel 指令會幫你維護這個檔案，在編譯時會靠這個檔案來建立關於資料庫的查詢、新增、修改等等的程式碼，我們先在 <code>src/main.rs</code> 裡把它引入吧：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate diesel;

mod schema;

fn main() {}
</code></pre></pre>
<p>到這邊程式應該可以編譯執行，雖然會有一堆警告，不過那沒關係。</p>
<h2 id="連線資料庫"><a class="header" href="#連線資料庫">連線資料庫</a></h2>
<p>使用資料庫的第一步當然是跟資料庫做連線，不過其實我們用的是 sqlite ，只是要開個檔案而已：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate diesel;
extern crate dotenv;

use diesel::{prelude::*, sqlite::SqliteConnection};
use dotenv::dotenv;
use std::env;

mod schema;

fn establish_connection() -&gt; SqliteConnection {
  let url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;找不到資料庫位置&quot;);
  SqliteConnection::establish(&amp;url).expect(&quot;連線失敗&quot;)
}

fn main() {
  dotenv().ok();
  establish_connection();
}
</code></pre></pre>
<p>使用 diesel 建立連線很簡單，只要呼叫對應的連線物件的 <code>establish</code> 並傳入資料庫的位置就行了。</p>
<h2 id="建立-model"><a class="header" href="#建立-model">建立 Model</a></h2>
<p>所謂的 ORM 就是把資料庫的資料與這些被稱為 model 的物件對應，我們要來建立兩個 model ，一個查詢用，一個新增用，建一個 <code>src/models.rs</code> 檔案然後輸入以下內容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Insertable 產生的程式碼會使用到，所以必須要引入
use super::schema::posts;

// 一個可以用來查詢的 struct
#[derive(Queryable, Debug)]
pub struct Post {
  pub id: i32,
  pub author: String,
  pub title: String,
  pub body: String,
}

// 新增用的 struct ，唯一的差別是沒有 id 的欄位，以及使用的是 str
#[derive(Insertable)]
// 這邊要指定資料表的名稱，不然 diesel 會嘗試用 struct 的名稱
#[table_name = &quot;posts&quot;]
pub struct NewPost&lt;'a&gt; {
  pub author: &amp;'a str,
  pub title: &amp;'a str,
  pub body: &amp;'a str,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="新增資料"><a class="header" href="#新增資料">新增資料</a></h2>
<p>我們先來新增資料，這樣等下才有資料可以查詢，修改 <code>main.rs</code> ，把剛剛建好的 model 引入，接著像這樣輸入 (以下程式碼省略了部份) ：</p>
<pre><pre class="playground"><code class="language-rust">// ...
mod models;

use models::NewPost;

// ...

fn create_post(conn: &amp;SqliteConnection, author: &amp;str, title: &amp;str, body: &amp;str) {
  // 引入我們的資料表
  use self::schema::posts;

  // 建立要準備新增的資料的 struct
  let new_post = NewPost {
    author,
    title,
    body,
  };

  // 指明要新增的表與新的值
  diesel::insert_into(posts::table)
    .values(&amp;new_post)
    // 執行
    .execute(conn)
    .expect(&quot;新增貼文失敗&quot;);
}

fn main() {
  dotenv().ok();
  let conn = establish_connection();
  // 呼叫 create_post 建立貼文
  create_post(&amp;conn, &quot;Anonymous&quot;, &quot;Hello&quot;, &quot;Hello world&quot;);
}
</code></pre></pre>
<p>在執行後你可以找個能打開 sqlite 資料庫的軟體看一下，資料已經確實的新增進去了：</p>
<p><img src="https://i.imgur.com/7gx4dxO.png" alt="Image" /></p>
<h2 id="列出資料"><a class="header" href="#列出資料">列出資料</a></h2>
<p>我們使用以下程式碼來列出貼文：</p>
<pre><pre class="playground"><code class="language-rust">// ...

fn list_posts(conn: &amp;SqliteConnection) -&gt; Vec&lt;Post&gt; {
  // 引入資料表的所有東西
  use self::schema::posts::dsl::*;

  // 載入所有的貼文
  posts.load::&lt;Post&gt;(conn).expect(&quot;取得貼文列表失敗&quot;)
}

fn main() {
  dotenv().ok();
  let conn = establish_connection();
  println!(&quot;{:?}&quot;, list_posts(&amp;conn));
}
</code></pre></pre>
<p>執行後你應該會看到這樣的結果：</p>
<pre><code class="language-plain">[Post { id: 1, author: &quot;Anonymous&quot;, title: &quot;Hello&quot;, body: &quot;Hello world&quot; }]
</code></pre>
<p>正是我們剛剛新增的貼文。</p>
<h2 id="用主鍵查詢資料"><a class="header" href="#用主鍵查詢資料">用主鍵查詢資料</a></h2>
<pre><pre class="playground"><code class="language-rust">// ...
fn get_post(conn: &amp;SqliteConnection, id: i32) -&gt; Post {
  use self::schema::posts::dsl::*;

  // 取得指定 id 的貼文
  posts.find(id).first(conn).expect(&quot;取得貼文失敗&quot;)
}

fn main() {
  dotenv().ok();
  let conn = establish_connection();
  println!(&quot;{:?}&quot;, get_post(&amp;conn, 1));
}
</code></pre></pre>
<h2 id="刪除貼文"><a class="header" href="#刪除貼文">刪除貼文</a></h2>
<pre><pre class="playground"><code class="language-rust">// ...
fn delete_post(conn: &amp;SqliteConnection, id: i32) {
  use self::schema::posts::dsl::*;

  // 不知道你有沒有注意到，除了查詢外的操作都在 diesel 下
  diesel::delete(posts.find(id))
    .execute(conn)
    .expect(&quot;刪除貼文失敗&quot;);
}

fn main() {
  dotenv().ok();
  let conn = establish_connection();
  delete_post(&amp;conn, 1);
}
</code></pre></pre>
<p>大概的使用就這樣，這些應該夠我們建一個留言板了，先把 <code>main</code> 函式清空吧，明天我們再來繼續建立留言板的後端。</p>
<h1 id="用-rust-做個留言板"><a class="header" href="#用-rust-做個留言板">用 Rust 做個留言板</a></h1>
<p>這次的程式碼一樣在： https://github.com/DanSnow/rust-intro/tree/master/message-board</p>
<p>今天要來把昨天說好的留言板完成，昨天我們已經建立好了那些用來從資料庫建立、查詢、刪除資料的函式，今天要把它變成網頁後端，請打開昨天的專案，這次要安裝的東西有點多：</p>
<pre><code class="language-shell">$ cargo add serde serde_derive serde_json futures tokio tower-web
</code></pre>
<ul>
<li><a href="https://github.com/rust-lang-nursery/futures-rs">futures</a>: 提供非同步操作的一個介面</li>
<li><a href="https://github.com/tokio-rs/tokio">tokio</a>： 實作非同步 IO 的函式庫</li>
<li><a href="https://github.com/carllerche/tower-web">tower-web</a>： 這次要使用的網頁後端框架，它是建立在 tokio 之上的，其實這套是個比較新的框架，在 Rust 的生態系中比較有名的是 <a href="https://rocket.rs/">rocket</a> ，不過它一定要用到 nightly 的功能，加上我覺得 tower 設計的也挺不錯的。</li>
</ul>
<p>我們先讓這個後端能送出我們前端的 HTML 吧，你說那個 HTML 嗎？我已經先寫好了，大概的用 <a href="https://bulma.io/">bulma</a> 排一下版面而已，沒說很好看，也沒用 React 或 Vue 是用 Vanilla JS 寫，總之你就複製一份到 <code>static/index.html</code> 吧。</p>
<p>總之我們需要一個 struct ，並幫它加上我們的路由：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[macro_use]
extern crate tower_web;
extern crate futures;
extern crate tokio;
use futures::Future;
use std::{env, io, path::PathBuf};
use tokio::fs::File;
// ...
// Clone 是必要的
#[derive(Clone, Copy, Debug)]
struct Service;

// 我們必須把 impl 包在 impl_web 這個 macro 裡
// 這樣 tower-web 才會幫我們產生必要程式碼
impl_web! {
  impl Service {
    // 這代表 get 根目錄的路由
    #[get(&quot;/&quot;)]
    // 回傳的是 html
    #[content_type(&quot;html&quot;)]
    // 傳回值是個 Future ，這是由 futures 提供的介面
    // 你可以想像它是個非同步的 Result
    // 所謂的非同步就是程式能先去做別的事，等到這邊好了再回來執行
    // 至於這詳細要怎麼處理，現在不需要去擔心
    fn index(&amp;self) -&gt; impl Future&lt;Item = File, Error = io::Error&gt; + Send {
      // 取專案的根目錄
      let mut path = PathBuf::from(env!(&quot;CARGO_MANIFEST_DIR&quot;));
      // 加上我們的路徑 static/index.html
      path.push(&quot;static&quot;);
      path.push(&quot;index.html&quot;);
      // 打開檔案，這邊使用的是 tokio 提供的 File 不是內建的，要注意喔
      File::open(path)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然後修改 main 讓它執行：</p>
<pre><pre class="playground"><code class="language-rust">use tower_web::ServiceBuilder;

fn main() {
  dotenv().ok();

  let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
  println!(&quot;Listen on {}&quot;, addr);
  ServiceBuilder::new()
    // 這邊加上剛剛建立的 Service
    .resource(Service)
    .run(&amp;addr)
    .expect(&quot;啟動 Server 失敗&quot;);
}
</code></pre></pre>
<p>編譯執行，在瀏覽器打開 <a href="http://localhost:8080/">http://localhost:8080</a> ，應該可以看到網頁顯示出來了，雖然網頁的 console 會顯示錯誤，因為我們還沒實作 API ，如果要關掉 Server 就直接按 Ctrl + C。</p>
<p>接著先來實作取得貼文列表：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
// 做為回應的型態需要加上 Response
#[derive(Response, Debug)]
struct PostsResponse {
  // 我們的文章列表
  posts: Vec&lt;Post&gt;,
}

impl_web! {
  impl Service {
    // ...
    // 這次是 get /api/posts
    #[get(&quot;/api/posts&quot;)]
    // 回傳的資料是 json
    #[content_type(&quot;json&quot;)]
    // 回傳是個 Result ，因為我們沒做錯誤處理
    // 所以 Err 的型態就直接用 () 了
    fn list_posts(&amp;self) -&gt; Result&lt;PostsResponse, ()&gt; {
      // 建立資料庫連線，正常其實不該這樣
      let conn = establish_connection();
      // 取得文章列表後回傳
      Ok(PostsResponse {
        posts: list_posts(&amp;conn)
      })
    }
  }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>編譯後跑跑看，糟糕，出錯了，我們到 <code>models.rs</code> ，幫我們的 <code>Post</code> 加上 <code>Serialize</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Queryable, Serialize, Debug)]
pub struct Post {
    pub id: i32,
    pub author: String,
    pub title: String,
    pub body: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>再編譯，這次應該沒錯了，重整網頁應該也不會有錯誤訊息了。</p>
<p>接著來實作新增貼文的 API：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
// 從用戶端取得資料的 struct 都要實作 Extract
// 另外實作 Extract 的型態裡不能有 borrow
// 這是目前比較可惜的部份
#[derive(Extract, Debug)]
struct CreatePostRequest {
  author: String,
  title: String,
  body: String,
}

#[derive(Response, Debug)]
// 這個是設定當回傳這個型態時 http status code 用 201
#[web(status = &quot;201&quot;)]
struct CreatePostResponse {
  ok: bool,
}

impl_web! {
  impl Service {
    // ...

    #[post(&quot;/api/posts/create&quot;)]
    #[content_type(&quot;json&quot;)]
    // body 是從 post body 取得的
    // 另外也可以把變數取名叫 query_string 就可以從 query string 拿到資料
    // 當然這都是 impl_web 這個 macro 提供的功能
    fn create_post(&amp;self, body: CreatePostRequest) -&gt; Result&lt;CreatePostResponse, ()&gt; {
      let conn = establish_connection();
      create_post(&amp;conn, &amp;body.author, &amp;body.title, &amp;body.body);
      Ok(CreatePostResponse { ok: true })
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>重新編譯執行，我們應該要能發佈貼文了，同時發佈後貼文就會更新，到這邊就完成了一個不能修改也不能刪除的留言板了，我們再來把剩下的 CRUD (Create、Retrieve、Update、Delete 建立、取得、更新、刪除) …，沒有 U ，來給完成吧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate serde_json;
// ...
#[derive(Response, Debug)]
struct PostResponse {
    post: Post,
}

impl_web! {
  impl Service {
    // ...
    // 網址中的變數是使用 : 來宣告的
    #[get(&quot;/api/posts/:id&quot;)]
    #[content_type(&quot;json&quot;)]
    // 這邊的變數要跟上面的同名
    fn get_post(&amp;self, id: i32) -&gt; Result&lt;PostResponse, ()&gt;{
      let conn = establish_connection();
      Ok(PostResponse { post: get_post(&amp;conn, id) })
    }

    #[delete(&quot;/api/posts/:id&quot;)]
    // 回傳的是 json 型態，如果回傳的是 serde_json::Value
    // 就會自動用 json 回傳了
    fn delete_post(&amp;self, id: i32) -&gt; Result&lt;serde_json::Value, ()&gt;{
      let conn = establish_connection();
      delete_post(&amp;conn, id);
      // serde_json 有提供 json 這個 macro 來建立 json
      // 只是用這個方法沒辦法自訂 http status code
      Ok(json!({
        &quot;ok&quot;: true
      }))
    }
  }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>好了，然後前端再加個刪除的按鈕就行了，但是那個我就不做了，用 Rust 寫網頁後端最大的好處應該就是執行速度快了，每次修改都要編譯再執行其實挺麻煩的，如果不是真的有很嚴重的效能問題不然還是用其它的語言寫比較方便，這個就當一個嘗試吧。</p>
<p>明天就來介紹一下 tokio 與 futures 是怎麼一回事。</p>
<p>不知不覺得這個系列已經到第 26 篇了，如果有什麼覺得有趣的東西想知道怎麼用 Rust 做的歡迎提出來喔，或是有哪個東西希望我介紹的，因為老實說，我快沒點子了。</p>
<h1 id="非同步-io--futures-與-tokio"><a class="header" href="#非同步-io--futures-與-tokio">非同步 IO ： Futures 與 Tokio</a></h1>
<h2 id="async-io"><a class="header" href="#async-io">Async IO</a></h2>
<p>在開始之前要先來介紹一下非同步的 IO 是怎麼回事，如果你有碰過比較底層的系統程式，你可能會知道在 Linux 下用來開啟檔案的 <a href="http://man7.org/linux/man-pages/man2/open.2.html"><code>open</code></a> 有個選項是 <code>O_NONBLOCK</code> ，它會做什麼？它做的事就是當你讀取資料時，若資料還沒準備好，讀取的操作就會直接以失敗返回，而不會在那邊等到有資料，於是在這段時間內程式就能去做其它的事，晚點再回來試著讀看看，而且這並不只可以用在檔案上， Linux 系統把非常多的東西都視為檔案去操作，這包含網路連線，與硬體的溝通等等，當然 Windows 下也有類似的機制。</p>
<p>當然，盲目的嘗試其實很沒效率，所以作業系統也提供了方法可以讓我們偵測是不是可以讀取了，我們可以開啟多個檔案、連線或裝置，等到系統通知我們其中有某個已經準備好能讀取了再去處理，這就是所謂的事件驅動 (event driven) ，同時也是像 Nodejs 內部的處理方式。</p>
<p>這樣的方式能以單一的執行緒處理所有的讀寫操作，比起原本的同步 IO 必須使用多個執行緒或處理序省下了切換行程等等的成本，但相對的會讓程式的設計變得複雜，不過理想上這些處理非同步 IO 的框架可以幫我們把程式碼變的像同步一樣。</p>
<h2 id="futures"><a class="header" href="#futures">Futures</a></h2>
<p><a href="https://rust-lang-nursery.github.io/futures-rs/">futures</a> 是 Rust 社群所提出的一個統一非同步操作的一個介面，大家可以實作一個統一的介面去描述一個尚未完成的事物，之前也有說過它像非同步的 <code>Result</code> ，它用起來像這樣：</p>
<pre><pre class="playground"><code class="language-rust">extern crate futures;

use futures::{future, Future};

fn main() {
  // future::ok 會直接建一個完成，並且有結果的 Future
  let fut = future::ok::&lt;i32, ()&gt;(111).map(|x| x * 3);
  // wait 會執行一個 Future ，並等到它完成
  assert_eq!(fut.wait().unwrap(), 333);
}
</code></pre></pre>
<blockquote>
<p>如果你用過 Javascript 你可以想像 <code>future::ok</code> 就是 <code>Promise.resolve</code> ，不過它還有附很多操作的方法</p>
</blockquote>
<p>其實目前在網站上看到的會是 0.3 的 alpha 版，但常用的卻是 0.1 版的，目前 futures 將會有部份整合進 Rust 的標準函式庫中，而之後 Rust 預計要支援 async 與 await ， 0.3 版的則是要跟 async 與 await 搭配使用的，若支援的話就能把非同步的程式碼寫的像同步的一樣：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(async_await, await_macro)]
extern crate futures;

use futures::future;
use futures::executor::block_on;

fn main() {
  block_on(async {
    let n = await!(future::ok::&lt;i32, ()&gt;(111)).unwrap();
    assert_eq!(n, 111);
  });
}
</code></pre></pre>
<p>這邊要使用的 futures 是 <code>futures-preview = &quot;0.3.0-alpha.4&quot;</code> 。</p>
<p>你可以在 <a href="https://doc.rust-lang.org/stable/std/future/index.html"><code>std::future</code></a> 與 <a href="https://doc.rust-lang.org/stable/std/pin/index.html"><code>std::pin</code></a> 找到那些整合進來的 API ，當然目前都還是不穩定的。</p>
<h2 id="tokio"><a class="header" href="#tokio">Tokio</a></h2>
<p>Tokio 則是實作了非同步 IO 的框架，它提供了經過包裝的非同步的檔案與網路操作，同時還提供了執行 <code>Future</code> 的功能。</p>
<p>說來執行 <code>Future</code> 是怎麼一回事，事實上 <code>Future</code> 的實作就是透過輪詢 (poll) 來確定 <code>Future</code> 完成了沒，若還沒就讓它繼續跑，好了的話就把結果拿出來，所以若要自己來做這個工作就會變成：</p>
<pre><pre class="playground"><code class="language-rust">extern crate futures;

use futures::{future, Async, Future};

fn main() {
    let mut fut = future::ok::&lt;i32, ()&gt;(111).map(|x| x * 3);

    loop {
      match fut.poll() {
        Ok(Async::Ready(res)) =&gt; {
          println!(&quot;{}&quot;, res);
          break;
        }
        Ok(Async::NotReady) =&gt; {
          println!(&quot;Not ready&quot;);
        }
        Err(e) =&gt; panic!(e),
      }
    }
}
</code></pre></pre>
<blockquote>
<p>記得把 futures 換回原本的 0.1 版</p>
</blockquote>
<p>不要懷疑，這個是可以跑的，當然上面這個情況不可能會出現 <code>Not ready</code> 就是了。</p>
<p>所以事實上如果要執行一個 <code>Future</code> 問題就變成了，如果遇到了 <code>Async::NotReady</code> 程式是不是可以等一下，等到有結果了再做一次輪詢，而這個等一下又要等多久，而 tokio 的解決辦法就是使用系統底層的 API 實作 IO 的通知機制，若 futures 是從 IO 操作建立的就向系統註冊需要取得狀態改變的通知，而在有通知時再做一次輪詢。</p>
<blockquote>
<p>這部份可能比較不好懂，但我想避免直接講到系統底層的 API ，如果有興趣可以看看 Linux 下的 <a href="https://zh.wikipedia.org/zh-tw/Epoll"><code>epoll</code></a>，還有 Rust 的 <a href="https://github.com/carllerche/mio">mio</a> ， mio 正是 tokio 的核心， tokio 使用 mio 來包裝這些底層 API ，而 mio 則在 Linux 下使用 epoll 實作通知機制</p>
</blockquote>
<p>若我們用 tokio 寫一個 echo server 的話會像這樣：</p>
<pre><pre class="playground"><code class="language-rust">extern crate futures;
extern crate tokio;

use futures::{Future, Stream};
use std::net::SocketAddr;
use tokio::{
    io::{self, AsyncRead},
    net::TcpListener,
    runtime::current_thread::Runtime,
};

fn main() {
  let mut runtime = Runtime::new().unwrap();
  let handle = runtime.handle();
  let listener = TcpListener::bind(&amp;SocketAddr::new(&quot;127.0.0.1&quot;.parse().unwrap(), 1234)).unwrap();
  let fut = listener
    .incoming()
    .for_each(|stream| {
      let (read, write) = stream.split();
      // 若要用 tokio::run 這邊要換成 tokio::spawn
      handle
        .spawn(
          io::copy(read, write)
            .map(|_| ())
            .map_err(|e| println!(&quot;{:?}&quot;, e)),
        )
        .unwrap();
      Ok(())
    })
    .map_err(|e| println!(&quot;{:?}&quot;, e));
  runtime.block_on(fut).unwrap();
  // 這邊其實使用 tokio 讓它用預設的方法執行 Future 會比較方便
  // 只是預設的方法會產生一些 thread ，我希望這邊可以用單執行緒完成
  // tokio::run(fut);
}
</code></pre></pre>
<p>在 Linux 下你可以用 nc ， Windows 下可以用 telnet 來連線到 localhost:1234 ，你輸入什麼伺服器就會回應你什麼，這樣程式看起來其實不難，底層也變成使用事件驅動的方式執行。</p>
<p>上面的程式碼我放在： https://github.com/DanSnow/rust-intro/tree/master/echo-server</p>
<p>我個人是認為 tokio 與 futures 它們的 API 都很抽像，老實說不好理解，不過也有很多建立在這兩個函式庫上的東西幫它們做了很好的包裝，讓你可以解決特定領域的問題，比如像昨天所介紹的 tower-web ，它就讓你不需要去碰到 tokio 的細節部份。</p>
<p>另外如果想了解更多關於 tokio 與 mio 的底層的人可以參考這篇翻譯文章： <a href="https://blog.techbridge.cc/2018/01/05/tokio-internal/">【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架
</a>。</p>
<h1 id="webassembly-用-rust-寫出高效能的網頁程式"><a class="header" href="#webassembly-用-rust-寫出高效能的網頁程式">WebAssembly： 用 Rust 寫出高效能的網頁程式</a></h1>
<h2 id="什麼是-webassembly"><a class="header" href="#什麼是-webassembly">什麼是 WebAssembly</a></h2>
<p>WebAssembly 是個實驗性的 Web 標準，其是由其它程式語言如 C/C++ ，目前 Go 也支援了，當然還有我們的 Rust ，由這些語言來編譯成位元組碼 (bytecode) 來執行，並提供比 js 還要來的更快的，接近原生程式的效能。</p>
<h2 id="rust-與-webassembly"><a class="header" href="#rust-與-webassembly">Rust 與 WebAssembly</a></h2>
<p>Rust 原生支援編譯成 WebAssembly，你只需要底下這行指令就能安裝這項功能：</p>
<pre><code class="language-shell">$ rustup target add wasm32-unknown-unknown
</code></pre>
<p>接著我們來安裝 <code>wasm-bindgen</code> 這個工具：</p>
<pre><code class="language-shell">$ cargo install wasm-bindgen-cli
</code></pre>
<p>這個工具是之後來幫我們最佳化編譯出來的 <code>wasm</code> 檔與產生對應的 js 包裝用的。</p>
<p>這次的專案在： https://github.com/DanSnow/rust-intro/tree/master/wasm-demo</p>
<p>我們可以來開個小專案測試一下了：</p>
<pre><code class="language-shell">$ cargo init --lib wasm-demo
$ cd wasm-demo
$ cargo add wasm-bindgen web-sys
</code></pre>
<ul>
<li><a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>： 自動產生 JS 與 Rust 的綁定</li>
<li>js-sys： js 的基本型態等等，這邊並沒有用到</li>
<li>web-sys： 網頁的 API 綁定</li>
</ul>
<p>然後我們需要編輯一下 <code>Cargo.toml</code> ，首先加上這段：</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>然後編輯 <code>web-sys</code> 的相依性：</p>
<pre><code class="language-toml">web-sys = { version = &quot;0.3.2&quot;, features = [&quot;Window&quot;, &quot;Document&quot;, &quot;Node&quot;, &quot;HtmlElement&quot;, &quot;Element&quot;] }
</code></pre>
<p>這個有點長啊，我建議你改寫成這個型式：</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3.2&quot;
features = [&quot;Window&quot;, &quot;Document&quot;, &quot;Node&quot;, &quot;HtmlElement&quot;, &quot;Element&quot;]
</code></pre>
<p><code>web-sys</code> 為了避免編譯不需要的功能，所以用了一大堆的 <code>feature</code> ，使用的時候最好看一下 <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/index.html">文件</a> 確定一下自己要的功能要開啟哪個 <code>feature</code> 。</p>
<p>之後還要加上一個設定檔在 <code>.cargo/config</code> 內容是：</p>
<pre><code class="language-toml">[build]
target = &quot;wasm32-unknown-unknown&quot;
</code></pre>
<p>這讓 cargo 預設把這個專案編譯成 WebAssembly 。</p>
<p>接著我們會需要 webpack 來幫我們打包 wasm 與 js 的 code ，所以這邊就假設你已經有 Node.js 的環境了，如果沒有的話要去安裝。</p>
<pre><code class="language-shell">$ npm init --yes
$ npm install --dev webpack webpack-cli webpack-dev-server html-webpack-plugin shelljs
</code></pre>
<p>或是像我一樣使用 yarn 也行：</p>
<pre><code class="language-shell">$ yarn init --yes
$ yarn add -D webpack webpack-cli webpack-dev-server html-webpack-plugin shelljs
</code></pre>
<p>我們先開始寫程式碼吧，修改 <code>src/lib.rs</code> 如下：</p>
<pre><pre class="playground"><code class="language-rust">extern crate wasm_bindgen;
extern crate web_sys;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn main() -&gt; Result&lt;(), JsValue&gt; {
  // 取得 window 物件
  let window = web_sys::window().unwrap();
  // 取得 document 物件，以下類推
  let document = window.document().unwrap();
  let body = document.body().unwrap();
  // 建立 HTML 元素
  let el = document.create_element(&quot;p&quot;)?;
  // 設定裡面的字
  el.set_inner_html(&quot;Hello from Rust&quot;);
  // 這邊必須要使用 AsRef::&lt;web_sys::Node&gt;::as_ref(&amp;body) 這種寫法
  // 因為這邊還沒辦法很好的做型態的轉換
  // 轉成 Node 型態才有 append_child 能用
  // 而 el.as_ref() 也是在做型態轉換，只是這邊就能自動推導
  AsRef::&lt;web_sys::Node&gt;::as_ref(&amp;body).append_child(el.as_ref())?;
  Ok(())
}
</code></pre></pre>
<p>然後再寫個 <code>index.js</code> ：</p>
<pre><code class="language-js">// wasm 的模組不允許同步的載入，所以要用 import()
const wasm = import('./wasm_demo')

wasm
  .then(m =&gt; {
    // 執行上面的 main
    m.main()
  })
  .catch(console.error)
</code></pre>
<p>然後接下來就是需要編譯與打包了，編譯的指令如下：</p>
<pre><code class="language-shell">$ cargo build --release
$ wasm-bindgen target/wasm32-unknown-unknown/release/wasm_demo.wasm --out-dir .
</code></pre>
<p>在 build 完後你會發現檔案是被放在 <code>wasm32-unknown-unknown/release</code> 下，這是因為我們設定編譯成 wasm ，而因為這並不是預設的就被放到別的資料夾了。</p>
<p>接著的 <code>wasm-bindgen</code> 指令幫我們最佳化 wasm 檔案並產生一份 js 檔，輸出到現在的資料夾下。</p>
<p>我也把這個步驟寫成了 <code>build.js</code> ，你可以使用 <code>node build.js</code> 執行。</p>
<p>之後就是要打包了，請你直接把 <code>webpack.config.js</code> 複製過去，然後執行：</p>
<pre><code class="language-shell">$ npm run webpack-dev-server
</code></pre>
<p>或用 <code>yarn</code> ：</p>
<pre><code class="language-shell">$ yarn webpack-dev-server
</code></pre>
<p>這會開啟開發用的伺服器，你可以打開瀏覽器連上 <code>http://localhost:8080</code> 應該會看到 <code>Hello from Rust</code> 。</p>
<h2 id="port-message-board-到-webassembly"><a class="header" href="#port-message-board-到-webassembly">Port message-board 到 WebAssembly</a></h2>
<p>這個專案在： https://github.com/DanSnow/rust-intro/tree/master/message-board-wasm</p>
<p>再來個比較複雜點的專案，這次挑戰把之前的留言板的 js 部份全部用 Rust 改寫，先開個新專案：</p>
<pre><code class="language-shell">$ cargo init --lib message-board-wasm
$ cd message-board-wasm
$ cargo add wasm-bindgen web-sys js-sys
</code></pre>
<p>一些細部的設定與重覆的部份我就省略了，底下我也只挑重點節錄，有興趣自己開專案來看：</p>
<pre><pre class="playground"><code class="language-rust">// ...
fn render_posts(posts: Posts) -&gt; Result&lt;JsValue, JsValue&gt; {
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
    let fragment = document.create_document_fragment();
    let frag_node = AsRef::&lt;web_sys::Node&gt;::as_ref(&amp;fragment);
    for post in posts.posts.iter().rev() {
        let card = document.create_element(&quot;div&quot;).unwrap();
        card.set_class_name(&quot;card&quot;);
        card.set_inner_html(&amp;format!(
            r#&quot;&lt;div class=&quot;card-content&quot;&gt;
            &lt;p class=&quot;title is-5&quot;&gt;{}&lt;/p&gt;
            &lt;p class=&quot;subtitle is-5&quot;&gt;{}&lt;/p&gt;
            &lt;div class=&quot;content&quot;&gt;
              {}
            &lt;/div&gt;
          &lt;/div&gt;&quot;#,
            post.title, post.author, post.body
        ));
        frag_node.append_child(card.as_ref())?;
    }
    let container = document.query_selector(&quot;.posts&quot;)?.unwrap();
    container.set_inner_html(&quot;&quot;);
    AsRef::&lt;web_sys::Node&gt;::as_ref(&amp;container).append_child(fragment.as_ref())?;
    Ok(JsValue::UNDEFINED)
}

fn fetch_posts(window: &amp;web_sys::Window) {
  // JsFuture 會把 Promise 轉成 Future
  // future_to_promise 則是做相反的事
  future_to_promise(
    JsFuture::from(window.fetch_with_str(&quot;/api/posts&quot;))
      .and_then(|res: JsValue| res.dyn_into::&lt;web_sys::Response&gt;().unwrap().json())
      // 這邊要再轉換 json 所回傳的 Promise
      .and_then(|json: js_sys::Promise| JsFuture::from(json))
      // parse json 後顯示
      .and_then(|json| render_posts(json.into_serde::&lt;Posts&gt;().unwrap())),
  );
}

fn handle_submit(event: web_sys::Event) {
  // 前面都在取表單的值
  // ...
  let data = JsValue::from_serde(&amp;Post {
    author,
    title,
    body,
  })
  .unwrap();
  web_sys::console::log_1(&amp;data);
  let req = web_sys::Request::new_with_str_and_init(
    &quot;/api/posts/create&quot;,
    web_sys::RequestInit::new()
      // 或許這邊用 serde_json 會比較好點
      .body(Some(js_sys::JSON::stringify(&amp;data).unwrap().as_ref()))
      .method(&quot;POST&quot;),
  )
  .unwrap();
  req.headers()
    .set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    .unwrap();
  let window = web_sys::window().unwrap();
  let cb = Closure::wrap(Box::new(|_| {
    let window = web_sys::window().unwrap();
    fetch_posts(&amp;window);
  }) as Box&lt;FnMut(_)&gt;);
  window.fetch_with_request(&amp;req).then(&amp;cb);
  // 同下
  cb.forget();
}

#[wasm_bindgen]
pub fn main() -&gt; Result&lt;(), JsValue&gt; {
  // 這個會讓 debug 方便點，它讓 panic 時印出 stack trace
  console_error_panic_hook::set_once();
  let window = web_sys::window().unwrap();
  let document = window.document().unwrap();
  let create_post = document.query_selector(&quot;#create-post&quot;)?.unwrap();
  // 這是 console.log
  web_sys::console::log_1(create_post.as_ref());

  // 這邊一定要做轉型， Closure::wrap 要的是一個內部的型態
  let handler = Closure::wrap(Box::new(handle_submit) as Box&lt;Fn(_)&gt;);
  AsRef::&lt;web_sys::EventTarget&gt;::as_ref(&amp;create_post)
    // 這邊要做兩次轉型，一次 as_ref 一次 unchecked_ref 才能拿到 js_sys::Function
    .add_event_listener_with_callback(&quot;submit&quot;, handler.as_ref().unchecked_ref())?;
  // 一定要呼叫 Closure 的 forget ，或是把它回傳，不然 Rust 這邊會把它釋放掉
  handler.forget();
  fetch_posts(&amp;window);
  Ok(())
}
</code></pre></pre>
<p>這樣就完成了一個前端是 Rust 後端還是 Rust 的網站了，可惜的是我還沒找到方法讓之前做的後端能夠送出正確的 mime 的方法，而 Chrome 會因為 mime 不對而拒絕執行 wasm ，所以我是用 <a href="https://www.npmjs.com/package/http-server">http-server</a> 當伺服器的部份， API 的部份則用 Proxy 轉發給原本的後端處理。</p>
<h2 id="raw-string"><a class="header" href="#raw-string">Raw String</a></h2>
<p>上面使用到了一個語法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>r#&quot;有 &quot;&quot; 也沒問題&quot;#
<span class="boring">}
</span></code></pre></pre>
<p>這是 Rust 裡的 raw string ，它的語法是 <code>r</code> 後跟著 1 個以上的 <code>#</code> 再接 <code>&quot;</code> ，之後若不是碰到 <code>&quot;</code> 後接著同樣數量的 <code>#</code> 都不會當做結束，這中間出現 <code>&quot;</code> 也沒問題，所以底下的也是可以的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>r##&quot; 這次出現 #&quot;&quot;# 也行&quot;##
<span class="boring">}
</span></code></pre></pre>
<p>使用者可以根據情況調整 <code>#</code> 的數量。</p>
<h2 id="後記"><a class="header" href="#後記">後記</a></h2>
<p>事實上像留言板的程式改寫成 WebAssembly 不一定會比較快，我個人是覺得 WebAssembly 目前應該著重於運算量大的，或是像 js 所不擅長處理的 64 位元整數，目前的 WebAssembly 其實很多東西都沒辦法直接操作，這中間靠了很多 webpack 與 wasm-bindgen 的處理把 js 與 wasm 整合起來，不然正常情況下 wasm 這邊是沒辦法直接處理 dom 的，這次算一個挑戰，除錯到很崩潰，差點要放棄，我一開始並沒有用 console error 的那個 crate ，結果沒想到真的遇到了 panic ，後來查了才發現，我把型態記錯了，我把 HtmlTextAreaElement 轉型成 HtmlInputElement，不過還是順利的把這篇文章生出來了。</p>
<h1 id="用-rust--gtk-做個井字棋"><a class="header" href="#用-rust--gtk-做個井字棋">用 Rust + GTK 做個井字棋</a></h1>
<p>前幾天有看到別人鐵人賽在做井字棋，我也來做一個吧，用 Rust ，加上 GTK ，做成原生的視窗程式。</p>
<p>但在開始前 Rust 最近發佈了 <code>1.30</code> 版，這版裡有些有趣的功能像 <code>procedural macro</code> ，它是讓你可以用 Rust 的程式處理 Rust 的抽像語法樹 (AST) ，然後去改變或產生程式，這其實已經不是 macro 了，而是 meta programming 了，然後還有 crate 的 macro 可以用 <code>use</code> 載入了，而不用 <code>#[macro_use]</code> (意思是自己寫的還是要)， Rust 2018 的功能開始出現了，下一版就會是第一版的 Rust 2018 了，想看詳細內容可以去看 <a href="https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html">官方 blog</a>。</p>
<h2 id="gtk-是什麼"><a class="header" href="#gtk-是什麼">GTK 是什麼</a></h2>
<p>GTK 是個在類 Unix 系統下的一個主流的圖形介面程式開發的函式庫，可以讓你做出有視窗的程式，而不是終端機那黑黑的畫面，雖然它是用 C 寫的，但非常的 OOP ，而提供 Rust 綁定的函式庫： <a href="http://gtk-rs.org/">gtk-rs</a> ，也很好的把原本的繼承關係等等的用 Rust 的 trait 實作出來了。</p>
<p>它實際上由數個部份組成：</p>
<ul>
<li>gtk： 最上層的函式庫，提供圖形的元件</li>
<li>gdk： gtk 的繪圖函式庫，也處理字型、遊標等等</li>
<li>gio： 處理 IO 與檔案等等的操作</li>
<li>glib： 最低層的函式庫，提供資料結構、常用函式與物件系統</li>
</ul>
<p>另外還有 cario 與 pango 等。</p>
<h2 id="建立專案"><a class="header" href="#建立專案">建立專案</a></h2>
<p>這次的專案在： https://github.com/DanSnow/rust-intro/tree/master/gtk-tic-tac-toe</p>
<p>不多說了：</p>
<pre><code class="language-shell">$ cargo init gtk-tic-tac-toe
$ cd gtk-tic-tac-toe
$ cargo add gtk gio gdk
</code></pre>
<p>然後我們要修改一下 <code>Cargo.toml</code>：</p>
<pre><code class="language-toml">gtk = { version = &quot;0.5.0&quot;, features = [&quot;v3_22&quot;] }
</code></pre>
<p>後面的 <code>v3_22</code> 要配合電腦上有的 gtk 函式庫的版本調整，我所使用的是 3.22 ，另外電腦上也要裝 gtk 的開發用函式庫， Ubuntu 下套件的名字是 <code>libgtk-3-dev</code> 。</p>
<h2 id="hello-in-gtk"><a class="header" href="#hello-in-gtk">Hello in GTK</a></h2>
<p>修改 <code>src/main.rs</code>：</p>
<pre><pre class="playground"><code class="language-rust">extern crate gdk;
extern crate gio;
extern crate gtk;

use gio::prelude::*;
use gtk::prelude::*;

fn main() {
  let application = gtk::Application::new(
    // 這邊要放個 id
    &quot;io.github.dansnow.tic-tac-toe&quot;,
    // 不需要什麼選項
    gio::ApplicationFlags::empty(),
  )
  .expect(&quot;建立 APP 失敗&quot;);
  // 設定程式啟動時的動作，這邊的 app 實際上是 application 的 borrow
  application.connect_startup(|app| {
    // 建立視窗
    let window = gtk::ApplicationWindow::new(app);
    // 設定標題
    window.set_title(&quot;Tic Tac Toe&quot;);
    // 預設視窗大小
    window.set_default_size(300, 200);
    // 設定按叉叉時的動作
    window.connect_delete_event(move |win, _| {
      // 關掉視窗
      win.destroy();
      Inhibit(false)
    });
    let label = gtk::Label::new(&quot;Hello&quot;);
    window.add(&amp;label);
    // 顯示視窗
    window.show_all();
  });
  application.connect_activate(|_| {});
  // 程式啟動
  application.run(&amp;args().collect::&lt;Vec&lt;_&gt;&gt;());
}
</code></pre></pre>
<p>執行看看，應該會有個視窗出現，想當初第一次接觸視窗程式，第一次脫離那黑色的視窗時有多感動 (然後我就寫了個全螢幕但沒有離開的方法的程式丟在別人的電腦上) 。</p>
<h2 id="建立程式畫面"><a class="header" href="#建立程式畫面">建立程式畫面</a></h2>
<p>這次的目標長這樣：</p>
<p><img src="rust/30%E5%A4%A9%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BARust%E7%B3%BB%E5%88%97/../images/V0DAyi0.png" alt="Image" /></p>
<p>其實沒很好看，我盡力了。</p>
<p>盤面的部份每個都是一個按鈕，用的是 <code>GtkToggleButton</code>，三個包進一個橫的 <code>GtkBox</code> (這是 GTK 裡很常用的一個排版元件) ，最上面是 <code>GtkToolbar</code> ，最後再全部包進一個直的 <code>GtkBox</code>，總之程式碼是這樣子的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_ui(app: &amp;gtk::Application) {
  // 建立 window
  // ...

  // 這是遊戲的邏輯部份，等下再講
  let game = Rc::new(RefCell::new(Game::new()));
  // 最外層的 Box
  let outer_box = gtk::Box::new(gtk::Orientation::Vertical, 0);
  // 按鈕的圖示
  let icon = gtk::Image::new_from_icon_name(&quot;restart&quot;, 16);
  // 工具列
  let toolbar = gtk::Toolbar::new();
  // 工具列的按鈕
  let tool_button = gtk::ToolButton::new(Some(&amp;icon), None);
  // 把按鈕加到工具列
  toolbar.insert(&amp;tool_button, 0);
  {
    let game = game.clone();
    // 設定重置按鍵按下時重置遊戲
    tool_button.connect_clicked(move |_| {
        game.borrow_mut().reset();
    });
  }
  // 把 Toolbar 加進去 outer_box
  outer_box.pack_start(&amp;toolbar, true, false, 0);
  for y in 0..3 {
    let inner_box = gtk::Box::new(gtk::Orientation::Horizontal, 0);
    for x in 0..3 {
      let button = gtk::ToggleButton::new();
      // 我們之後需要重置這些按鈕的狀態，所以把它存起來
      game.borrow_mut().push_button(button.clone());
      // 這是自訂的 macro
      clone!(game, window);
      // 設定按鈕狀態改變時的動作
      button.connect_toggled(move |btn| {
        // 因為重置按鈕時也會觸發，所以要檢查
        if !btn.get_active() {
          return;
        }
        // 停用按鈕，這樣使用者就不能再按了
        btn.set_sensitive(false);
        let p = game.borrow().player;
        // 插入 O 或 X 的符號
        let label = gtk::Label::new(None);
        label.set_markup(p.markup());
        btn.add(&amp;label);
        label.show();
        // 放棋與檢查
        if game.borrow_mut().place_and_check((x, y)) {
          show_message(&amp;window, p.label());
        }
      });
      // 把按鈕加建 box
      inner_box.pack_start(&amp;button, true, true, 0);
    }
    outer_box.pack_start(&amp;inner_box, true, true, 0);
  }
  window.add(&amp;outer_box);
  window.show_all();
}
<span class="boring">}
</span></code></pre></pre>
<p>建立 UI 就是這麼麻煩，雖然有個工具叫 <a href="https://glade.gnome.org/">Glade</a> 可以用拉的，不過這次我並沒有使用。</p>
<h2 id="修改元件的外觀"><a class="header" href="#修改元件的外觀">修改元件的外觀</a></h2>
<p>如果程式碼是像上面那樣，那建出來的畫面會是：</p>
<p><img src="rust/30%E5%A4%A9%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BARust%E7%B3%BB%E5%88%97/../images/d6J6vlg.png" alt="Image" /></p>
<p>這配色是我電腦的主題，平常很好看，但在這邊不適合，所以我們來寫點 CSS 修改它，建一個 <code>src/style.css</code>：</p>
<pre><code class="language-css">.toggle {
  background-color: lightseagreen;
  background-image: none;
}

.toggle label {
  color: black;
  font-size: 1.5em;
}
</code></pre>
<p>對，別懷疑，就是寫網頁用的 CSS ， GTK 的主題設定是使用 CSS 的，順帶一提，你可以用以下指令：</p>
<pre><code class="language-shell">$ GTK_DEBUG=interactive cargo run
</code></pre>
<p>程式打開始還會開啟一個圖形介面用的除錯器：</p>
<p><img src="rust/30%E5%A4%A9%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BARust%E7%B3%BB%E5%88%97/../images/euWmHej.png" alt="Image" /></p>
<p>就像 Chrome 的 F12 一樣，而且 <code>GTK_DEBUG=interactive</code> 可以用在所有使用 gtk3 的程式上。</p>
<blockquote>
<p>準確來說 gtk3 的主題才是使用 CSS ， gtk2 是使用自訂的語言，另外比較早的 gtk3 版本是使用元件名稱當成 css selector 的，像 <code>GtkButton</code> ，現在則是改用跟網頁元素類似的名稱，或是使用 class 了，像 <code>button.toggle</code> 就是指 <code>GtkToggleButton</code></p>
</blockquote>
<p>接著我們要載入 CSS ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// include_bytes! 可以把相對於原始碼目錄的檔案以 &amp;[u8] 載入，並編譯到程式裡
// 另外還有個 include_str! 則是載入成字串
const STYLE: &amp;[u8] = include_bytes!(&quot;style.css&quot;);

fn setup_ui(app: &amp;gtk::Application) {
  let screen = gdk::Screen::get_default().unwrap();
  let provider = gtk::CssProvider::new();
  provider.load_from_data(STYLE).expect(&quot;載入 css 失敗&quot;);
  gtk::StyleContext::add_provider_for_screen(
    &amp;screen,
    &amp;provider,
    gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
  );
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="顯示訊息"><a class="header" href="#顯示訊息">顯示訊息</a></h2>
<p>這邊很簡單的顯示了個對話框做為輸贏的提示：</p>
<p><img src="rust/30%E5%A4%A9%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BARust%E7%B3%BB%E5%88%97/../images/azJQmD1.png" alt="Image" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn show_message(window: &amp;gtk::ApplicationWindow, winner: &amp;str) {
  let dialog = gtk::MessageDialog::new(
    Some(window),
    // 對話框選項
    gtk::DialogFlags::MODAL | gtk::DialogFlags::DESTROY_WITH_PARENT,
    // 對話框類型
    gtk::MessageType::Info,
    // 對話框上的按鈕
    gtk::ButtonsType::Close,
    // 格式化訊息
    &amp;format!(&quot;{} Win&quot;, winner),
  );
  // 這邊設定按下按鈕後做的動作
  dialog.connect_response(|dialog, _| {
    dialog.destroy();
  });
  dialog.show_all();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="遊戲邏輯"><a class="header" href="#遊戲邏輯">遊戲邏輯</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PartialEq 與 Eq 是讓它可以判斷是否相等
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum Player {
  // 圈
  Circle,
  // 叉
  Cross,
}

impl Player {
  // 取得對手
  fn opponent(&amp;self) -&gt; Self {
    match self {
      Player::Circle =&gt; Player::Cross,
      Player::Cross =&gt; Player::Circle,
    }
  }

  // 取得文字的表示
  fn label(&amp;self) -&gt; &amp;'static str {
    match self {
      Player::Circle =&gt; &quot;O&quot;,
      Player::Cross =&gt; &quot;X&quot;,
    }
  }

  // 給 Label 用的
  fn markup(&amp;self) -&gt; &amp;'static str {
    match self {
      Player::Circle =&gt; r#&quot;&lt;span color=&quot;white&quot;&gt;O&lt;/span&gt;&quot;#,
      Player::Cross =&gt; &quot;X&quot;,
    }
  }
}

// 一開始從圈圈開始
impl Default for Player {
    fn default() -&gt; Self {
        Player::Circle
    }
}

#[derive(Default, Debug)]
struct Game {
    pub player: Player,
    board: [[Option&lt;Player&gt;; 3]; 3],
    buttons: Vec&lt;gtk::ToggleButton&gt;,
}

impl Game {
  // ...

  // 檢查輸贏的函式，只需要檢查放棋的點的上下左右與鈄的就行了
  fn check(&amp;self, target: (i32, i32)) -&gt; bool {
    let (px, py) = target;
    let (px, py) = (px as usize, py as usize);
    // 檢查直的
    if self.board[0][px] == self.board[1][px] &amp;&amp; self.board[0][px] == self.board[2][px] {
      return true;
    }
    // 橫的
    if self.board[py][0] == self.board[py][1] &amp;&amp; self.board[py][0] == self.board[py][2] {
      return true;
    }
    // 中間沒放就不會有鈄的情況了
    if self.board[1][1].is_none() {
      return false;
    }
    // 左上到右下鈄
    if self.board[0][0] == self.board[1][1] &amp;&amp; self.board[0][0] == self.board[2][2] {
      return true;
    }
    // 右上到左下鈄
    if self.board[0][2] == self.board[1][1] &amp;&amp; self.board[0][2] == self.board[2][0] {
      return true;
    }
    false
  }

  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>你說沒有 AI 嗎？對，這是個單機雙人遊戲，你可以找朋友一起玩，或是自己跟自己玩。</p>
<p>說來寫到這段時我真的覺得 Rust 能幫列舉加上方法的這個功能真的很好用。</p>
<h2 id="macro"><a class="header" href="#macro">macro</a></h2>
<p>這次用了個自訂的 macro：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! clone {
  ($($name:ident),*) =&gt; {
    $(
      let $name = $name.clone();
    )*
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>這個 macro 會把傳進去的變數都 clone 一份後再賦值給同名的變數， macro 的詳細的寫法請讓我留到明天再講，我有記得我說過要講解這個喔，絕對沒忘喔。</p>
<h1 id="macro--proc-macro-與尾聲"><a class="header" href="#macro--proc-macro-與尾聲">macro 、 proc macro 與尾聲</a></h1>
<p>這是最後一篇了，這篇我會補一些之前沒講到的東西，內容會比較雜一點。</p>
<p>目錄：</p>
<ul>
<li>macro</li>
<li>Procedural Macro (進階)</li>
<li>權限修飾</li>
<li>Rust 心得</li>
<li>鐵人賽後記</li>
</ul>
<h2 id="macro-1"><a class="header" href="#macro-1">macro</a></h2>
<p>Rust 的 macro 同樣也是基於模式比對的，如果你發現了類似結構的程式碼重覆了，說不定你可以把它寫成 macro 來減少你的程式碼，比如像昨天使用的 <code>clone!</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! clone {
  ($($name:ident),*) =&gt; {
    $(
      let $name = $name.clone();
    )*
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>定義一個 macro 你需要使用 <code>macro_rules!</code> 接著你想要的 macro 名稱，名稱的規則跟變數一樣，這邊使用的是 <code>clone</code> ，之後你的 macro 就會變 <code>clone!</code> 。</p>
<p>接下來則是分成兩個部份，模式定義的部份與產生的程式碼，兩邊都必須使用成對的括號包住，中間使用 <code>=&gt;</code> 分隔，最後則要用 <code>;</code> 結束 (只有一個定義時可以不用)，左邊的模式幾乎可以隨便定義，只是還是有些規則在，主要是不能造成編譯器出現岐義的情況，也就是同一段程式碼能有兩種不同的解釋，像 macro 中能用 <code>expr</code> 去比對運算式，但是運算式後就規定不能出現運算子 (+ 、 - 、 * 、 / 等等) 。</p>
<p>上面的 <code>$name:ident</code> 代表的是比對一個識別字 (變數或 struct 的名字等等)，前面的 <code>$name</code> 是 macro 中使用的變數，在展開後 <code>$name</code> 會被代換成傳入的東西，後面的 <code>ident</code> 則代表是要比對識別字，可以比對的東西有這些：</p>
<ul>
<li>item： 各式各樣的完整定義與宣告都是 item ，比如一個 struct 的定義</li>
<li>block： 一個程式碼區塊，就是由一對 <code>{</code> 和 <code>}</code> 包起來的區塊</li>
<li>stmt： 一個程式敘述，就是一行有加 <code>;</code> 的程式碼</li>
<li>pat： 一個模式比對用的模式，如 <code>Point { x, y }</code></li>
<li>expr： 一個運算式，基本上就是一行沒加括號有回傳值的程式，這個挺常用的</li>
<li>ty： 一個型態</li>
<li>ident： 一個識別字，或一個關鍵字也行，這個也是常用的</li>
<li>path： 比如像 <code>std::vec::Vec</code> 這樣的</li>
<li>meta： <code>#[]</code> 中的內容</li>
<li>lifetime： 就是 lifetime</li>
<li>vis： 像 <code>pub</code> 這樣的設定可見性的東西</li>
<li>tt： 可以 match 任何東西，通常是用來收集還沒比對到的部份用的</li>
</ul>
<p>比如我可以定義：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($left:ident =&gt;____&lt;= $right:expr) =&gt; {
    println!(&quot;{} =&gt;____&lt;= {}&quot;, stringify!($left), $right);
  };
}

// 使用：

foo!(bar =&gt;____&lt;= 123);
// 會印出： &quot;bar =&gt;____&lt;= 123&quot;
<span class="boring">}
</span></code></pre></pre>
<p>其中 <code>stringify!</code> 是個內建的 macro ，可以把傳進去的東西原封不動的轉成字串，沒錯， macro 可以遞迴展開。</p>
<p>如果要重覆的比對的話就要用 <code>$()*</code> 或 <code>$()+</code> 了， <code>+</code> 是比對 1 個以上，而 <code>*</code> 則是可以為 0 個，如果我們把上面的範例加上 <code>$()*</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($($left:ident =&gt;____&lt;= $right:expr)*) =&gt; {
    $(
      println!(&quot;{} =&gt;____&lt;= {}&quot;, stringify!($left), $right);
    )*
  };
}

// 使用：

foo!(bar =&gt;____&lt;= 123 baz =&gt;____&lt;= 456);
// 會印出：
// bar =&gt;____&lt;= 123
// baz =&gt;____&lt;= 456
<span class="boring">}
</span></code></pre></pre>
<p>用哪種重覆的方式就要用哪種去展開，在結尾的 <code>*</code> 或 <code>+</code> 前可以放上分隔用的符號，通常用會 <code>,</code> 或 <code>;</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($($left:ident =&gt;____&lt;= $right:expr),*) =&gt; {
    $(
      println!(&quot;{} =&gt;____&lt;= {}&quot;, stringify!($left), $right);
    )*
  };
}

// 使用：

foo!(bar =&gt;____&lt;= 123, baz =&gt;____&lt;= 456);
// 會印出：
// bar =&gt;____&lt;= 123
// baz =&gt;____&lt;= 456
<span class="boring">}
</span></code></pre></pre>
<p>Rust 的 macro 很強大，又能遞迴展開，使用的好能做出各式各樣的效果，比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  // 遞迴的終止條件
  ($left:ident -&gt; $right:expr) =&gt; {
    println!(&quot;{} -&gt; {}&quot;, stringify!($left), $right);
  };

  // 遞迴的終止條件
  ($left:ident =&gt; $right:expr) =&gt; {
    println!(&quot;{} =&gt; {}&quot;, stringify!($left), $right);
  };

  ($left:ident -&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!(&quot;{} -&gt; {}&quot;, stringify!($left), $right);
    foo!($($rest)+);
  };

  ($left:ident =&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!(&quot;{} =&gt; {}&quot;, stringify!($left), $right);
    foo!($($rest)+);
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>這樣就能支援兩種不同的分隔。</p>
<p>也有人在 macro 裡做出狀態機：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($left:ident =&gt; $right:expr) =&gt; {
    foo!(@end $left =&gt; $right);
  };

  ($left:ident =&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!(&quot;{} =&gt; {}&quot;, stringify!($left), $right);
    foo!(@second $($rest)+);
  };

  (@second $left:ident =&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!(&quot;{} =&gt; {}&quot;, stringify!($left), $right);
    foo!(@end $($rest)+);
  };
  
  (@end $left:ident =&gt; $right:expr) =&gt; {
    println!(&quot;{} =&gt; {}&quot;, stringify!($left), $right);
  };

  (@end $left:ident =&gt; $right:expr, $($rest:tt)*) =&gt; {
    println!(&quot;{} =&gt; {}&quot;, stringify!($left), $right);
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>這會讓只能比對到 1 組或 3 組以上，而且超過第 3 組後都會被忽略，至於使用 <code>@</code> 只是個慣例，加上基本上程式裡不會出現。</p>
<p>另外還可以搭配 trait 來實作一些針對型態的特化等等的。</p>
<h2 id="procedural-macro-進階"><a class="header" href="#procedural-macro-進階">Procedural Macro (進階)</a></h2>
<p>這個功能就是像 <code>derive</code> 所使用的 trait ，或是可以自訂屬性 (像 <code>#[foo]</code>) ，社群有提供兩個很好用的 crate 可以幫忙實作，分別是 <a href="https://github.com/dtolnay/syn"><code>syn</code></a> 與 <a href="https://github.com/dtolnay/quote"><code>quote</code></a>。</p>
<p>這個專案在： https://github.com/DanSnow/rust-intro/tree/master/proc-macro-demo</p>
<p>假設我們有個 trait 是定義一個函式回傳 struct 的名字：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Name {
  fn name() -&gt; &amp;'static str;
}
<span class="boring">}
</span></code></pre></pre>
<p>然後我們把它變成可以 derive 的，於是我們必須建一個額外的函式庫專案，並在 <code>Cargo.toml</code> 中加上：</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>這樣編譯器才會知道這個 crate 是 proc macro 然後實作的程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate quote;
extern crate proc_macro;
extern crate proc_macro2;
extern crate syn;

use self::proc_macro::TokenStream;

// 定義一個 derive 名稱為 Name
#[proc_macro_derive(Name)]
// 這個函式的輸入輸出是規定的
pub fn name_derive(input: TokenStream) -&gt; TokenStream {
    let ast = syn::parse(input).unwrap();
    impl_name(&amp;ast).into()
}

fn impl_name(ast: &amp;syn::DeriveInput) -&gt; proc_macro2::TokenStream {
  // 取得 struct 的名稱
  let name = &amp;ast.ident;
  // 轉成字串，這樣才會在 quote 裡是 &quot;&lt;名稱&gt;&quot; 的型式
  let name_str = name.to_string();
  quote! {
    impl ::name::Name for #name {
      fn name() -&gt; &amp;'static str {
<span class="boring">        name_str
</span>      }
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用像這樣：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate name_derive;
extern crate name;

use name::Name;

#[derive(Name)]
struct Foo;

fn main() {
  println!(&quot;{}&quot;, Foo::name());
}
</code></pre></pre>
<h2 id="權限修飾"><a class="header" href="#權限修飾">權限修飾</a></h2>
<p>之前提過用 <code>pub</code> 可以公開模組中的東西，事實上並不單只有這樣的用法：</p>
<ul>
<li><code>pub(crate)</code>： 讓這個東西能在這個 crate 中使用，但離開這個 crate 就不能</li>
<li><code>pub(in &lt;模組路徑&gt;)</code>： 只再開放給指定的模組，路徑也可以用 <code>self</code> 與 <code>super</code></li>
</ul>
<p>此外也可以把 <code>pub(in super)</code> 寫成 <code>pub(super)</code> ， <code>self</code> 也同樣，不過其實寫 <code>pub(self)</code> 就相當於是預設的，還有路徑只能是上層的路徑，下層的原本就都可以存取的。</p>
<h2 id="使用-rust-的心得"><a class="header" href="#使用-rust-的心得">使用 Rust 的心得</a></h2>
<p>當初知道 Rust 這個語言是因為火狐說要用這個語言重寫他們的引擎，那時就去查了一下，記得那個時候的第一印像是：「這什麼鬼， struct 跟 impl 的定義是分開的？！」，不過後來嘗試後慢慢發現，這個語言雖然是個系統程式語言，但寫起來卻很方便，我在那之前主要使用的是 C++ ，接觸 Rust 後我最喜歡的是它的型態推導 (這在 C++ 裡可以用 auto)，跟它的模式比對 (這遠遠超過了 C++ 的 switch 了)，還有一些 FP 的特性，這是在 C++ 中比較缺乏，最重要的是 Rust 有強大的社群支援，還有 cargo 這個套件管理工具， C++ 若想用一些第三方的東西真的會比較麻煩，而且在 Rust 中大量的使用了 RAII ，我可以不用擔心忘記釋放任何東西 (反倒要擔心東西不小心被釋放了，但「基本上」也不會發生) ，雖然剛開始被 lifetime 搞的很頭痛，但習慣後效率真的很高。</p>
<h2 id="鐵人賽後記"><a class="header" href="#鐵人賽後記">鐵人賽後記</a></h2>
<p>之前就一直想參加鐵人賽了，但是要寫什麼好呢？一直拿不定主意，介紹前端的 React 與 Vue 已經一堆了，競爭感覺很激烈，雖然我對於自己對這兩個東西的熟悉程度有自信，包含對它們底層的實作多多少少都有了解，我不只對新的東西感興趣，還對它們背後怎麼實現的感興趣，所以我覺得開源程式真是個好東西，多虧了開源，我去翻了 Vue 的 observer 的實作，去翻了 React 怎麼處理 event ，去翻了 ptrace 怎麼 trace system call 之類的，稍微扯遠了，但我對寫好文章沒什麼自信，我沒什麼寫文章的習慣的，那就挑個冷門點的題目吧， Rust 這個語言也急速的在發展，或許以後會有不少人來用它寫些需要速度，或是偏底層的程式吧。</p>
<p>第一篇文章出來後，如果有編輯紀錄你應該會看到我反覆修了好幾次，那時貼出第一篇後拿給我朋友看，朋友：「我還以為你會先排版再貼上去」，於是我反覆修正了排版與用詞，雖然我從一開始就知道我的文章不適合初學者當教材了，我自己是覺得我的我文章像 Rust By Examples ，之前有位教授這樣說：「學生總是很困惑，老師在講什麼怎麼都聽不懂。老師也很困惑，學生到底為什麼不懂。」，一旦學會了什麼東西就會覺得很簡單，要再來教人就不容易了，雖然我也挺喜歡教人的，但有時我不知道自己的教法是不是正確的。</p>
<p>鐵人賽真的給了我個不錯的機會，有理由讓自己去寫文章，而且到後面還每天寫個專案(X ，其實除了網頁後端與資料庫那兩篇的專案都有事先準備外，其它的專案都是當天或前一天開始趕工做出來的，至於文章除了前幾篇外也都是當天新鮮的，所以那天如果到 10 點以後才發文大概是我那之前在除錯，這週花在鐵人賽的文章與相關的專案上的時數接近完整的 1 天啊，這次鐵人賽也讓我接觸到了兩樣之前沒碰過的，一個是 WebAssembly ，另一個是用 Rust 寫 GTK 程式 (之前只有用 C 寫過)。</p>
<p>最後一篇好像大多數人都會直接寫心得了，不過我還是有附上一點教學，因為理論上我的心得通常不會寫太多字，不過這個後記居然有將近 800 字其實我也是有點驚訝，要是我以前寫讀書心得也能寫的這麼順就好了。</p>
<p>總之謝謝正在看文章的你，以及之前提供我建議的讀者，拿 GTK 做井字棋可說完全是因為那則留言而產生的。</p>
<p>對了，原本我還想在這篇示範怎麼發佈個 crate ，然後把之前寫的那個 hastebin-client 發上去的，不過我還是先把程式碼整理一下吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="變數的所有權與借出變數-move-borrow--ownership"><a class="header" href="#變數的所有權與借出變數-move-borrow--ownership">變數的所有權與借出變數 Move, Borrow &amp; Ownership</a></h1>
<p>這篇與下一篇要介紹 Rust 中可說是最複雜，卻也是最重要的一個觀念，變數的所有權 (ownership) ，在 Rust 中每個變數都有其所屬的範圍 (scope) ，在變數的有效的範圍中，可以選擇將變數「借 (borrow)」給其它的 scope ，也可以將所有權整個轉移 (move) 出去，送給別人喔，當然，送出去的東西如果別人不還你的話是拿不回來的，但借出去的就只是暫時的給別人使用而已。</p>
<h2 id="move-2"><a class="header" href="#move-2">Move</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let message = String::from(&quot;Hello&quot;);
    {
        message;
    }
    println!(&quot;{}&quot;, message);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn greet(message: String) {
    println!(&quot;{}&quot;, message);
}

fn main() {
    let message = String::from(&quot;Hello&quot;);
    greet(message);
    println!(&quot;{}&quot;, message);
}
</code></pre></pre>
<p>猜看看上面的兩段程式碼的執行結果是什麼，猜到了嗎，答案都是無法編譯，編譯器會出現：</p>
<pre><code class="language-plain">error[E0382]: use of moved value: `message`
</code></pre>
<p>意思是使用了已經送給別人的變數，在 Rust 中一個程式碼的區塊， 也就是由 <code>{</code> 與 <code>}</code> 包圍的區域都是一個 scope ，這也包含了函式、迴圈的括號等等，只要你把變數傳給了其它區塊，都會把變數送出去，所以在上面的範例中， <code>message</code> 這個變數已經送出去，並且在接下來的 <code>println!</code> 無法使用了，另外在底下的情況也會送出變數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = String::from(&quot;a&quot;);
let b = a;
println!(&quot;{}&quot;, a); // 這邊也同樣不能編譯
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>或許你已經注意到了，這邊使用的都是 <code>String::from</code> ，都是在建立字串，如果把上面的例子都換成數字的話，你會發現不會出現任何錯誤，而能順利的執行，因為數字可以 <strong>複製</strong> ，字串不能複製嗎？也可以，只是字串的大小並不固定，有可能是很長的一篇文章，也有可能是一個空字串， Rust 並不允許在沒有明確的說要複製的情況下複製這種不知道會花費多少成本的型態，如果要改寫上面的範例，複製一個字串的話，可以使用 <code>clone</code>：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = String::from(&quot;a&quot;);
let b = a.clone();
println!(&quot;{}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>數字的大小則是固定的，於是在發生把變數送出去的情況時， Rust 會使用複製一份的方式給別人，所以就變成了兩個人都擁有，不會發生錯誤的情況。</p>
<blockquote>
<p>如果你想知道哪個型態可以被複製，可以參考文件的 <a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html"><code>std::marker::Copy</code></a> ，你會在底下看到如 <code>impl Copy for i32</code> 這就代表 <code>i32</code> 可以被複製</p>
</blockquote>
</blockquote>
<p>拿走的東西主動的還回去也是可以的：</p>
<pre><pre class="playground"><code class="language-rust">// 我要拿走整個 message 變數
fn greet(message: String) -&gt; String {
    println!(&quot;{}&quot;, message);
    message // 之後再還回去
}

fn main() {
    let message = String::from(&quot;Hello&quot;);

    // 這邊變數被拿走了，但是又還了回來，於是我們需要一個變數代表它
    // 當然你也可以使用同樣的名稱 message
    let msg = greet(message);

    println!(&quot;{}&quot;, msg); // 又拿回來了，於是可以使用
}
</code></pre></pre>
<h2 id="borrow-1"><a class="header" href="#borrow-1">Borrow</a></h2>
<p>Rust 中把出借變數直接稱為 borrow ， Rust 中使用在變數前面加一個 <code>&amp;</code> 來代表出借變數，borrow 的用途是當你不想把變數送出去時，你就可以把你的變數 <strong>借</strong> 出去，但還有個前提是對方要 <strong>願意跟你借</strong> ，底下是個借出變數給函式的範例：</p>
<pre><pre class="playground"><code class="language-rust">// 這邊在 String 的前面加上了 &amp; 代表我可以跟別人用借的
fn greet(message: &amp;String) {
  println!(&quot;{}&quot;, message);
}

fn main() {
  let message = String::from(&quot;Hello&quot;);
  greet(&amp;message); // 這邊加上了 &amp; 來表示借出去
  println!(&quot;{}&quot;, message); // 借出去的東西只是暫時給別人而已，自己還可以使用
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 這邊沒有加上 &amp; 代表我想要整個拿走
fn greet(message: String) {
  println!(&quot;{}&quot;, message);
}

fn main() {
  let message = String::from(&quot;Hello&quot;);
  // greet(&amp;message); // 這邊就算加上了 &amp; 也沒辦法把變數用借的借出去
  greet(message); // 一定要整個給它
  // println!(&quot;{}&quot;, message); // 因為被整個拿走了，所以這邊已經沒辦法使用了
}
</code></pre></pre>
<p>Rust 預設借給別人的東西別人必須原封不動的還回來，也就是借出去的變數是沒辦法被修改的，如果你想允許別人修改的話，你就必須使用 <code>&amp;mut</code> 對方也必須明確的使用 <code>&amp;mut</code> 來代表我要借到一個可以修改的變數：</p>
<pre><pre class="playground"><code class="language-rust">fn combine_string(target: &amp;mut String, source: &amp;String) {
  // push_str 會把傳進去的字串接到字串的後面
  target.push_str(source);
}

fn main() {
  // 這邊一定要加 mut ，因為這個變數會被修改，就算不是你自己改的也一樣
  let mut message = String::from(&quot;Hello, &quot;);
  let world = String::from(&quot;World&quot;);
  // 借給 combine_string 一個可以改的變數 message ，與一個不能改的 world
  combine_string(&amp;mut message, &amp;world);
  println!(&quot;{}&quot;, message); // 這邊就會印出 Hello, World
}
</code></pre></pre>
<blockquote>
<p>還記得前一篇的猜數字裡有 <code>stdin().read_line(&amp;mut input)</code> 嗎？</p>
</blockquote>
<h2 id="borrow-的規則-1"><a class="header" href="#borrow-的規則-1">Borrow 的規則</a></h2>
<p>Rust 的出借變數是有其規則在的：</p>
<ol>
<li>所有的變數一次都只能用可以修改的方式 (<code>&amp;mut</code>) 出借一次</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 42;
let a = &amp;mut n;
let b = &amp;mut n; // 這裡用可以修改的方式總共借出去兩次了，這是不可以的
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>可以無限的用唯讀的方式借出去</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 42;
let a = &amp;n;
let b = &amp;n;
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>一旦用可以修改的方式 (<code>&amp;mut</code>) 出借，那你就不能用任何其它的方式存取變數了</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 42;
{
  let a = &amp;mut n;
  // println!(&quot;{}&quot;, n); // 你不可以使用原本的 n
  // let b = &amp;n; // 你也不可以再用任何方式借走 n
}
println!(&quot;{}&quot;, n); // 我們離開了 a 借走 n 的範圍了，於是 n 又可以用了
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>一旦你用唯讀的方式借出了變數，你就不可以修改變數</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 42;
{
  let a = &amp;n;
  // n = 123; // 又不可以了，有夠煩的(X
}
n = 123; // 這邊才可以修改
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>這些規則是用來確保多執行緒時不會有資料競爭用的，也就是同時有兩個人修改了同一個變數，於是一次只允許有一個變數的擁有者能修改變數的值，同時一但借出了變數就不能隨意修改，因為別人不一定會知道變數被修改了。雖然有點麻煩 (也真的很麻煩) ，但往好處想，變數不再會被隨意的修改了。</p>
</blockquote>
<p>有點可惜的是目前的 <code>borrow checker</code> ，也就是檢查，並執行上面這些規則的功能，它並不是很完善，比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [123, 456];
let a = &amp;mut array[0];
let b = &amp;mut array[1];
<span class="boring">}
</span></code></pre></pre>
<p>兩個變數分別借走了不相干的兩個部份，但這沒辦法通過檢查，不過這在 Rust 2018 將會有所改善，敬請期待。</p>
<blockquote>
<p>Q： Rust 2018 是什麼？
A： 在今年的年底 Rust 將要推出 2018 年版，版本號會是 1.30 ，將會有不少的改進以及部份的語法的變更。
Q： 什麼！那我現在學的這些東西到年底就都沒辦法用了？
A： 放心好了，大部份的是功能的增強與新的語法，只有一小部份的修改，之後會有一篇來討論這些修改，與看看有哪些新功能。
Q： 那我不想更新可以嗎？
A： 可以，你可以設定使用現在的語法版本，也就是 Rust 2015 版。
Q： 那我要怎麼設定？
A： 這個之後再說。</p>
</blockquote>
<h2 id="string--str-array--slice-1"><a class="header" href="#string--str-array--slice-1">String &amp; str, Array &amp; Slice</a></h2>
<p>我們之前應該有提到過 Rust 有兩種字串 <code>String</code> 與 <code>str</code> ，可是一直沒有詳細說明這兩個的差別，這邊我們要提到 Rust 的一個東西「切片 (slice)」，切片可以理解為一次出借如陣列或字串這類的連續的資料型態的一部份：</p>
<blockquote>
<p>如果你有寫過 Python 你可能知道 Python 的切片 <code>array[1:3]</code> ，只是這邊把 <code>:</code> 換成了 <code>..</code> 而已。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [0, 1, 2, 3, 4, 5];
{ // 建立一個區塊，不然我們等下沒辦法使用原本的 array
  let slice: &amp;mut [i32] = &amp;mut array[1..3]; // 這邊一次的借走了 array 的第 2 跟第 3 個元素

  // 然後我們修改了切片的第 1 個元素，對應到原本的 array 則是第二個元素
  slice[0] = 42;

  println!(&quot;{:?}&quot;, slice); // 會印出 [42, 2]
}
println!(&quot;{:?}&quot;, array); // 印出 [0, 42, 2, 3, 4, 5]
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust 的切片會知道自己借走了多少長度的東西，而且跟原本的變數 <strong>會共用同一塊空間</strong> ，建立切片是不會複製任何資料的。</p>
</blockquote>
<p>你可以看到這邊的印出來的結果很明顯的修改了原本的資料，同時很重要的一點，切片 <strong>只能有 borrow 的型態</strong> ，因為切片的本質就是出借資料，切片能把資料出借一小段，而使用者可以把這段資料當成像陣列一樣使用。</p>
<blockquote>
<p><code>{:?}</code> 是把資料以 debug 的方式印出來，內建的型態不一定能直接印出來，但大部份都能用這種方式印出來，如果不能使用 <code>{}</code> 印出來時 <code>{:?}</code> 通常能派上用場。</p>
</blockquote>
<p>上面的 <code>slice</code> 的型態是 <code>&amp;mut [i32]</code> ，這就是切片型態的寫法，一般如果需要借走一個陣列都會使用切片型態，這樣可以給予使用者更大的彈性，比如決定要不要把整個陣列都借出去，或是隻借出一部份。</p>
<p>那終於可以來講 <code>str</code> 了， <code>str</code> 事實上就是字串的切片，而 <code>String</code> 則是一個可以在執行時改變大小的字串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 直接使用雙引號 (&quot;) 的字串都是字串的切片，它們都被 Rust 放在某個地方並且借給使用者使用而已
let hello: &amp;str = &quot;Hello&quot;;
// 建立一個 String
let string: String = String::from(hello);
// 借走字串的一部份，產生一個字串切片
let part_of_string: &amp;str = &amp;string[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>同樣的 <code>str</code> 也只能有 borrow 的型態。</p>
<p>下一篇要來介紹一下 borrow 的存活時間 (lifetime) 同樣也是重要觀念，這兩篇都是在講觀念可能比較無聊，不過接下來我們就會繼續介紹程式的語法了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime-borrow-的存活時間-1"><a class="header" href="#lifetime-borrow-的存活時間-1">Lifetime： Borrow 的存活時間</a></h1>
<p>Rust 有個重要的功能叫 borrow checker ，它除了檢查在上一篇提到的規則外，還檢查使用者會不會使用到懸空參照 (dangling reference) ，懸空參照是在電腦世界中一種現象： 如果你今天把一個變數借給別人，實際上借走的人只是知道我可以去哪裡找到這個別人借我的東西而已，那個東西的擁有者還是你本人，以現實世界做比喻的話，這像是借別人東西只是把放那個東西的儲物櫃位置，以及鑰匙暫時的交給別人而已，送別人東西則是直接把儲物櫃的擁有者變成他。</p>
<p>所以如果今天發生了一種情況，你把東西借給別人後，管理每個儲物櫃擁有者的系統馬上把你的使用權收回去呢？會發生什麼事，這沒人說的準，可能儲物櫃還沒被清空，你還是可以拿到借來的東西，或是馬上又換了主人，你已經不是拿到原本的東西了，就像以下的程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; &amp;i32 {
    // 這個變數在離開這個範圍後就消失了
    let a = 42;
    // 但是這邊卻回傳了 borrow
    &amp;a
}
<span class="boring">}
</span></code></pre></pre>
<p>上面這段 code 是無法編譯的。</p>
<p>為瞭解決這樣的一個問題， Rust 提出來的就是 lifetime 的觀念，只要函式的參數或回傳值有 borrow 出現，使用者就要幫 borrow 標上 lifetime ，標記後讓編譯器可以去追蹤每個變數借出去與釋放掉的情況，確保不會有釋放掉已經出借的變數的可能性。</p>
<p>Rust 使用 <code>'a</code> 一個單引號加上一個識別字當作 lifetime 的標記，所以這些都是可以的 <code>'b</code>, <code>'foo</code>, <code>'_bar</code> ，此外有兩個保留用作特殊用途的 lifetime: <code>'static</code> 和 <code>'_</code>：</p>
<ul>
<li><code>'static</code>： 這代表這是個整個程式都有效的 borrow 比如字串常數 <code>&quot;foo&quot;</code> 它的 lifetime 就是 <code>'static</code></li>
<li><code>'_</code>：這是保留給 Rust 2018 使用的，這裡先不提它的功能</li>
</ul>
<p>這邊是個加上 lifetime 標記後的範例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(a: &amp;'a i32) -&gt; &amp;'a i32 {
    a
}
<span class="boring">}
</span></code></pre></pre>
<p>其中我們必須在函式名稱後加上 <code>&lt;&gt;</code> 並在其中宣告我們的 lifetime ，接著把 borrow 的 <code>&amp;</code> 後都加上我們的 lifetime 標記，但事實上在上一篇文章中，我們完全沒用使用到 lifetime ， Rust 可以在某些情況下自動推導出正確的 lifetime ，使得實際上需要手動標註的情況並不多，最有可能遇到的情況是一個函式同時使用了兩個 borrow ：</p>
<pre><pre class="playground"><code class="language-rust">fn max&lt;'a&gt;(a: &amp;'a i32, b: &amp;'a i32) -&gt; &amp;'a i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}

fn main() {
    let a = 3;
    let m = &amp;a;
    {
        let b = 2;
        let n = &amp;b;
        // 對於 max 來說， m 與 n 同時存活的這個範圍就是 'a ，
        // 而回傳值也可以在這個範圍內使用
        println!(&quot;{}&quot;, max(m, n));
    } // b 與 n 會在這邊消失
} // a 與 m 會在這邊消失
</code></pre></pre>
<p>這種情況編譯器因為看到了兩個 borrow ，於是沒辦法猜出來回傳的值應該要跟哪個 lifetime 一樣，這邊的作法就是全部都標記一樣的 lifetime ，讓 Rust 知道說我們的變數都會存活在同一個範圍內，同時回傳值也可以在同樣的範圍存活。</p>
<p>大部份的情況下編譯器都能自動的推導，所以需要手動標註的情況其實不多，通常是先嘗試讓編譯器做推導，如果編譯器報錯了才來想辦法標註。</p>
<p>lifetime 還有個用途是用來限制使用者傳入的參數必須是常數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_message(message: &amp;'static str) {
  println!(&quot;{}&quot;, message);
}
<span class="boring">}
</span></code></pre></pre>
<p>這個函式就只能接受如 <code>&quot;Hello&quot;</code> 這樣的常數了，雖說只是偶爾會有這樣的需求。</p>
<h2 id="lifetime-elision-lifetime-省略規則-進階-2"><a class="header" href="#lifetime-elision-lifetime-省略規則-進階-2">Lifetime Elision (Lifetime 省略規則) (進階)</a></h2>
<p>這部份大概的瞭解一下就好了</p>
<ol>
<li>所有的 borrow 都會自動的分配一個 lifetime</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: &amp;i32, b: &amp;i32);
fn foo&lt;'a, 'b&gt;(a: &amp;'a i32, b: &amp;'b i32); // 推導結果
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>如果函式只有一個 borrow 的參數，則它的 lifetime 會自動被應用到回傳值上</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: &amp;i32);
fn foo&lt;'a&gt;(a: &amp;'a i32) -&gt; &amp;'a i32; // 推導結果
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>如果有多個 borrow ，但其中一個是 <code>self</code> ，則 <code>self</code> 的 lifetime 會被應用在回傳值</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
    fn method(&amp;self, a: &amp;i32) -&gt; &amp;Self {}
}

// 推導結果
impl Foo {
    fn method&lt;'a, 'b&gt;(&amp;'a self, b: &amp;'b i32) -&gt; &amp;'a Self {}
}
<span class="boring">}
</span></code></pre></pre>
<p>若不符合上面任一條規則，則必須要標註型態。</p>
<p>如果我們把以上的規則套用在上面的範例 <code>max</code> 上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: &amp;i32, b: &amp;i32) -&gt; &amp;i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>套用規則 1 ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;'a, 'b&gt;(a: &amp;'a, i32, b: &amp;'b i32) -&gt; &amp;i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>到這邊結束，編譯器已經沒有可用的規則了，但是回傳值的 lifetime 依然是未知，於是就編譯失敗。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">GO</a></h1>
<ul>
<li><a href="https://willh.gitbook.io/build-web-application-with-golang-zhtw/">使用Golang 打造Web 應用程式</a></li>
<li><a href="https://github.com/rubyhan1314/Golang-100-Days">Golang - 100天從新手到大師</a></li>
<li><a href="https://gobyexample-cn.github.io/">Go by Example</a></li>
<li><a href="https://pjchender.dev/golang/variables/"></a></li>
</ul>
<h2 id="go-標準套件安裝"><a class="header" href="#go-標準套件安裝">Go 標準套件安裝</a></h2>
<p>http://golang.org/dl/</p>
<pre><code class="language-sh">export GOROOT=$HOME/go
export GOPATH=$HOME/gopath
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
</code></pre>
<h2 id="go-modules-指令介紹"><a class="header" href="#go-modules-指令介紹">Go Modules 指令介紹</a></h2>
<pre><code>Usage:go mod &lt;command&gt; [arguments]The commands are:download    // 將依賴全部下載到本機中，位置為 $GOPATH/pkg/mod/cache
edit        // 編輯 go.mod 例如鎖定某個依賴的版本
graph       // 列出專案中哪一個部分使用了某個依賴
init        // 建立 go.mod
tidy        // 增加遺失的依賴，移除未使用的依賴
vendor      // 將既有的 go.mod 依賴全部存在 /vendor 底下
verify      // 驗證本地依賴依然符合 go.sum 
why         // 解釋某個依賴為何存在在 go.mod 中，誰使用了它
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang-note"><a class="header" href="#golang-note">Golang Note</a></h1>
<h2 id="modules-and-packages"><a class="header" href="#modules-and-packages">Modules and Packages</a></h2>
<p>不論是 module 或 package，都可以在本地匯入，不一定要發到遠端 repository。</p>
<pre><code class="language-go"># 在 hello 資料夾中
$ go mod init example.com/user/hello        # 宣告 module_path，通常會和該 repository 的 url 位置一致
$ go install .                      # 編譯該 module 並將執行檔放到 GOBIN，因此在 GOBIN 資料夾中會出現 hello 的執行檔

$ go mod tidy             # 移除沒用到的套件
$ go clean -modcache            # 移除所有下載第三方套件的內容
</code></pre>
<p>💡 安裝到 <code>GOBIN</code> 資料夾的檔案名稱，會是在 <code>go.mod</code> /案中第一行定義 <code>module path</code> 中路徑的最後一個。因此若 module_path 是 <code>example.com/user/hello</code> 則在 GOBIN 中的檔名會是 <code>hello</code>；若 module_path 是 <code>example/user</code> 則在 GOBIN 資料夾中的檔名會是 <code>user</code>。</p>
<p>若我們在 go module 中有使用其他的遠端（第三方）套件，當執行 <code>go install</code>、<code>go build</code> 或 <code>go run</code> 時，go 會自動下載該 remote module，並記錄在 <code>go.mod</code> 檔案中。這些遠端套件會自動下載到 <code>$GOPATH/pkg/mod</code> 的資料夾中。當有不同的 module 之間需要使用相同版本的第三方套件時，會共用這些下載的內容，因此這些內容會是「唯讀」。若想要刪除這些第三方套件的內容，可以輸入 <code>go clean -modcache</code>。</p>
<h3 id="設定-gopath"><a class="header" href="#設定-gopath">設定 GOPATH</a></h3>
<pre><code class="language-shell"># ~/.zshrc
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
<h3 id="packages"><a class="header" href="#packages">Packages</a></h3>
<ul>
<li>
<p>Go 的程式碼都是以 <code>package</code> 的方式在組織，一個 package 就是在同一資料夾中的許多 GO 檔案。</p>
</li>
<li>
<p><strong>同一個 package 的所有 Go 檔案會放在同一個資料夾內；而這個資料夾內的所有檔案也都會屬於同一個 package，有相同的 package 名稱</strong>。</p>
</li>
<li>
<p>如果套件是在 module 中，go import package 的路徑會是 <code>module path</code> 加上 <code>subdirectory</code>。</p>
</li>
<li>
<p>通常 package 的名稱會跟著 folder 的名稱，舉例來說，若檔案放在 <code>math/rand</code> 資料夾中，則該套件會稱作 <code>rand</code>。</p>
</li>
<li>
<p>package scope</p>
<p>：</p>
<ul>
<li>在 Go 語言中，並沒有區分 <code>public</code>、<code>private</code> 或 <code>protected</code>，而是根據變數名稱的第一個字母大小寫來判斷能否被外部引用。</li>
<li>在同一個 package 中變數、函式、常數和 type，都隸屬於同一個 package scope，因此雖然可能在不同支檔案內，但只要隸屬於同一個 package，都可以使用（visible）。</li>
<li>如果需要讓 package 內的變數或函式等能夠在 package 外部被使用，則<strong>該變數的第一個字母要大寫才能讓外部引用（Exported names），否則的話會無法使用</strong></li>
</ul>
</li>
<li>
<p>有兩種不同類型的 package：</p>
<ul>
<li><strong>executable package</strong>：是用來產生我們可以執行的檔案，一定會包含 <code>package main</code> 並且帶有名為 <code>main</code> 的函式，只有這個檔案可以被執行（run）和編譯（build），並且不能被其他檔案給匯入。</li>
<li><strong>reusable package(library package)</strong>：類似 &quot;<strong>helpers</strong>&quot; 或常稱作 <strong>library / dependency</strong>，目的是可以放入可重複使用的程式邏輯，它是不能被直接執行的，可以使用任何的名稱。</li>
</ul>
</li>
</ul>
<p>在 Go 裡面要區別這兩種 Package 的主要方式就是利用「<strong>package 名稱</strong>」，當使用 <code>main</code> 當做 package 名稱時，就會被當作 executable package，因此接著執行 <code>go build &lt;fileName&gt;</code> 時，<strong>會產生一支執行檔</strong>；但是當使用 main 以外的名稱是，都會被當作是 reusable package，因此當使用 <code>go build</code> 指令時，<strong>不會產生任何檔案</strong>。</p>
<p>要匯入 reusable package 只需要：</p>
<pre><code class="language-go">// 匯入單一個 package
import &quot;fmt&quot;

// 匯入多個 packages（不用逗號）
import (
  &quot;fmt&quot;
  &quot;strings&quot;
)
</code></pre>
<pre><code class="language-go">// go-hello-world/main.go
package main

import (
    &quot;fmt&quot;

    // 把 foo 這個 package 的方法都放到這隻檔案中，如此不用使用 foo.HelloWorld（不建議）
    . &quot;go-hello-world/foo&quot;

    // 將模組轉換為別名，可以使用 bar.HelloWorld
    bar &quot;go-hello-world/foo&quot;

    // 沒有用到這個 package，但要 init 它
    _ &quot;go-hello-world/foo&quot;
)

func main() {
    fmt.Println(bar.HelloWorld())
    fmt.Println(&quot;Hello main&quot;)
}
</code></pre>
<pre><code class="language-go">// go-hello-world/foo/helloworld.go

package foo

import &quot;fmt&quot;

func init() {
    fmt.Println(&quot;This is init of helloworld&quot;)
}

// HelloWorld ...
func HelloWorld() string {
    return &quot;Hello World&quot;
}
</code></pre>
<h3 id="package-name-coding-style-and-convention"><a class="header" href="#package-name-coding-style-and-convention">package name: coding style and convention</a></h3>
<blockquote>
<ul>
<li>👍 <a href="https://blog.golang.org/package-names">package name</a> @ golang blog</li>
<li><a href="https://golang.org/doc/effective_go.html#package-names">package name</a> @ effective go</li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments#package-names">package name</a> @ golang wiki &gt; code review comments</li>
</ul>
</blockquote>
<p>在 Go 中，package 的名稱應該是短而清楚，<strong>以小寫（lower case）命名，同時不包含底線（under_scores）或小寫駝峰（mixedCaps），並且通常會是名詞（noun）</strong>，例如 <code>time</code>、<code>list</code>、或 <code>http</code>。</p>
<blockquote>
<p>在幫 package 命名的時候，試想自己就是使用該 pkg 的開發者，用這種角度來替自己的 pkg 命名。</p>
</blockquote>
<p>另外，由於使用者在匯入該 package，假設引入的 使用時，一定會需要使用該 package 的 name 作為前綴，因此在 package 中的變數名稱盡可能不要和 package name 重複：</p>
<ul>
<li>
<p>在 <code>http</code> package 中如果要使用 Server，不需要使用 <code>http.HTTPServer</code>，而是可以直接使用 <code>http.Server</code></p>
</li>
<li>
<p>當在</p>
<p>uuid</p>
<p>的 package 要產生一組</p>
<pre><code>uuid.UUID
</code></pre>
<p>時，不需要使用</p>
<pre><code>uuid.NewUUID()
</code></pre>
<p>的方法，而是可以直接使用</p>
<pre><code>uuid.New()
</code></pre>
<p>，也就是說如果回傳的型別名稱（</p>
<pre><code>UUID
</code></pre>
<p>）和該 pkg 的名稱相同時，可以直接將該方法命名成</p>
<pre><code>New
</code></pre>
<p>，而不用是</p>
<pre><code>NewOOO
</code></pre>
<ul>
<li><code>time.Now()</code> 會回傳 <code>time.Time</code></li>
</ul>
</li>
<li>
<p>如果 pkg 會回傳的 struct 名稱不同於 package 本身的名稱時，則可以使用</p>
<pre><code>NewOOO
</code></pre>
<ul>
<li><code>time.NewTicker()</code></li>
<li><code>uuid.NewRandom()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 雖然 pkg 中 variable name 的前綴會盡量不和 package name 重複，但很常見的情況是在該 pkg 中有其同名的 struct，例如 time pkg 中有名為 <code>Time</code> 的 struct，因此型別會是 <code>time.Time</code>，</p>
</blockquote>
<p>不好的用法：</p>
<ul>
<li>盡可能不要使用 <code>util</code>, <code>common</code>, <code>misc</code> 這類的名稱作為 package name，因為這對使用者來說是沒有意義的名字，而是去想使用者這如果要用這些方法的話，最有可能使用到的關鍵字是什麼。</li>
<li>見範例「<a href="https://blog.golang.org/package-names">Break up generic packages</a>」</li>
</ul>
<h3 id="go-tool-找-package-的邏輯"><a class="header" href="#go-tool-找-package-的邏輯">go tool 找 package 的邏輯</a></h3>
<p>go tool 會使用 <code>$GOPATH</code> 來找對應的 package，假設引入的 package 路徑是 <code>&quot;github.com/user/hello&quot;</code>，那麼 go tool 就會去找 <code>$GOPATH/src/github.com/user/hello</code>。</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<pre><code class="language-sh"># 初始化 Go Module
$ export GO111MODULE=on  # 在 GOPATH 外要使用 module 需要啟動

# go mod init [module_path]
$ go mod init example.com/user/hello        # 宣告 module path
$ go mod tidy        # 移除沒用到的 library
$ go mod download    # 下載套件（go build 和 go test 也會自動下載）

$ go get [library]   # 新增或更新 package 到 Module 內
$ go get -u ./...    # 等同於，go get -u=patch ./...
$ go get foo@master. # 下載特定版本的 go package

$ go list -m all      # 印出 module 正在使用的所有套件
$ go list -m -versions [package]   # 列出所有此套件可下載的版本
$ go list -u -m all   # 檢視有無任何 minor 或 patch 的更新
</code></pre>
<blockquote>
<ul>
<li><a href="https://github.com/golang/go/wiki/Modules">Modules</a> @ Golang Wiki</li>
<li><a href="https://blog.golang.org/using-go-modules">Using Go Modules</a> @ golang blog</li>
</ul>
</blockquote>
<ul>
<li>在一個專案中通常只會有一個 module（但也可以有多個），並且放在專案的根目錄，module 裡面會集合所有相關聯的 Go packages。在 <code>go.mod</code> 中會宣告 <code>module path</code>，這是用來匯入所有在此 module 中的路徑的前綴（path prefix），同時它也讓 go 的工具知道要去哪裡下載它。</li>
<li>透過 Modules 可以準確紀錄相依的套件，讓程式能再次被編譯。</li>
<li>總結來說：
<ul>
<li>一個 repository 會包含一個或以上的 Go modules</li>
<li>每個 module 會包含一個或以上的 Go packages</li>
<li>每個 package 會包含一個或以上的檔案在單一資料夾中</li>
</ul>
</li>
<li>在執行 <code>go build</code> 或 <code>go test</code> 時，會根據 imports 的內容自動添加套件，並更新 <code>go.mod</code>。</li>
<li>當需要的時候，可以直接在 <code>go.mod</code> 指定特定的版本，或使用 <code>go get</code>，例如 <code>go get foo@v1.2.3</code>, <code>go get foo@master</code>, <code>go get foo@e3702bed2</code></li>
</ul>
<h3 id="gomod"><a class="header" href="#gomod">go.mod</a></h3>
<p>在 root directory 中會透過 <code>go.mod</code> 來定義 Module，而 Module 的原始碼可以放在 GOPATH 外，有四種指令 <code>module</code>, <code>require</code>, <code>replace</code>, <code>exclude</code> 可以使用：</p>
<pre><code class="language-go">// go.mod
// go.mod
module github.com/my/thing

require (
    github.com/some/dependency v1.2.3
    github.com/another/dependency/v4 v4.0.0
)
</code></pre>
<h3 id="module-2"><a class="header" href="#module-2">module</a></h3>
<p>用來宣告 Module 的身份，並帶入 module 的路徑。在這個 module 中所有匯入的路徑都會以這個 module path 當作前綴（prefix）。透過 module 的路徑，以及 go.mod 到 package's 資料夾的相對路徑，會共同決定 import package's 時要使用的路徑。</p>
<h4 id="replace-and-execute"><a class="header" href="#replace-and-execute">replace and execute</a></h4>
<p>這兩個命令都只能用在當前模組（即， <code>main</code>），否則將會在編譯時被忽略。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<ul>
<li>階層關係上：Module &gt; Package &gt; Directory</li>
</ul>
<h3 id="跨檔案引用函式"><a class="header" href="#跨檔案引用函式">跨檔案引用函式</a></h3>
<p>從下面的例子中可以看到，雖然 <code>main.go</code> 裡面有一個函式是定義在 <code>state.go</code> 的檔案中，但因為它們屬於同一個 package，所以當從 Terminal 執行 <code>go run main.go state.go</code> 時，程式可以正確執行。</p>
<p>或者也可以輸入 <code>go run *.go</code>：</p>
<pre><code class="language-go">// main.go
package main

func main() {
  printState()
}
</code></pre>
<pre><code class="language-go">// state.go
package main

import &quot;fmt&quot;

func printState() {
  fmt.Println(&quot;California&quot;)
}
</code></pre>
<h3 id="套件載入的流程"><a class="header" href="#套件載入的流程">套件載入的流程</a></h3>
<p>在 golang 中，使用某一個套件時，go 會先去 GOROOT 找看看是不是內建的函式庫，如果找不到的話，會去 GOPATH 內找，如果都找不到的話，就無法使用。</p>
<h2 id="變數宣告variables"><a class="header" href="#變數宣告variables">變數宣告（variables）</a></h2>
<p>Go 屬於強型別（Static Types）的語言，其中常見的基本型別包含 <code>bool</code>, <code>string</code>, <code>int</code>, <code>float64</code>, <code>map</code>。</p>
<h3 id="第一種宣告方式最常用short-declaration"><a class="header" href="#第一種宣告方式最常用short-declaration">第一種宣告方式（最常用）：short declaration</a></h3>
<p>使用 <code>:=</code> 宣告，表示之前沒有進行宣告過。這是在 go 中最常使用的變數宣告的方式，因為它很簡潔。但因為在 package scope 的變數都是以 keyword 作為開頭，因此不能使用縮寫的方式定義變數（<code>foo := bar</code>），只能在 function 中使用，具有區域性（local variable）：</p>
<pre><code class="language-go">// 第一種宣告方式
function main() {
    foo := &quot;Hello&quot;
    bar := 100

  // 也可以簡寫成
  foo, bar := &quot;Hello&quot;, 100
}

// 等同於
function main() {
    var foo string
    foo = &quot;Hello&quot;
}
</code></pre>
<h3 id="第二種宣告方式variable-declaration"><a class="header" href="#第二種宣告方式variable-declaration">第二種宣告方式：variable declaration</a></h3>
<p>使用時機主要是：</p>
<ul>
<li>當你不知道變數的起始值</li>
<li>需要在 package scope 宣告變數</li>
<li>當為了程式的閱讀性，將變數組織在一起時</li>
</ul>
<blockquote>
<p>⚠️ 留意：在 package scope 宣告的變數會一直保存在記憶體中，直到程式結束才被釋放，因此應該減少在 package scopes 宣告變數</p>
</blockquote>
<pre><code class="language-go">// 第二種宣告方式，在 main 外面宣告（全域變數），並在 main 內賦值
var foo string
var bar int

// 可以簡寫成
var (
    foo string
    bar int
)

function main() {
  foo = &quot;Hello&quot;
    bar = 100
}
</code></pre>
<blockquote>
<p><strong>不建議把變數宣告在全域環境</strong></p>
</blockquote>
<p>如果變數型別一樣的話，也可以簡寫成這樣：</p>
<pre><code class="language-go">func main() {
    var c, python, java bool
    fmt.Println(c, python, java)
}
</code></pre>
<h3 id="第三種宣告方式"><a class="header" href="#第三種宣告方式">第三種宣告方式</a></h3>
<p>直接宣告並賦值：</p>
<pre><code class="language-go">// 第三種宣告方式，直接賦值
var (
  foo string = &quot;Hello&quot;
    bar int = 100
)
</code></pre>
<h3 id="三種方式是一樣的"><a class="header" href="#三種方式是一樣的">三種方式是一樣的</a></h3>
<p>下面這兩種寫法是完全一樣的：</p>
<pre><code class="language-go">var &lt;name&gt; &lt;type&gt; = &lt;value&gt;
var &lt;name&gt; := &lt;value&gt;
</code></pre>
<pre><code class="language-go">// var card string = &quot;Ace of Spades&quot;
card := &quot;Ace of Spades&quot;
</code></pre>
<pre><code class="language-go">// var pi float = 3.14
pi := 3.14
</code></pre>
<p><strong>只有在宣告變數的時候可以使用 <code>:=</code> 的寫法，如果要重新賦值的話只需要使用 <code>=</code>。</strong></p>
<h2 id="注意事項"><a class="header" href="#注意事項">注意事項</a></h2>
<h4 id="錯誤重複宣告變數"><a class="header" href="#錯誤重複宣告變數">錯誤：重複宣告變數</a></h4>
<pre><code class="language-go">// 錯誤：重複宣告變數
paperColor := &quot;Green&quot;
paperColor := &quot;Blue&quot;
</code></pre>
<h4 id="正確我們可以在-main-函式外宣告變數但無法在-main-函式外賦值"><a class="header" href="#正確我們可以在-main-函式外宣告變數但無法在-main-函式外賦值">正確：我們可以在 main 函式外宣告變數，但無法在 main 函式外賦值</a></h4>
<pre><code class="language-go">// 正確：我們可以在 main 函式外宣告變數，但無法在 main 函式外賦值
package main

import &quot;fmt&quot;

var deckSize int

func main() {
  deckSize = 50
  fmt.Println(deckSize)
}
</code></pre>
<h4 id="錯誤無法在-main-函式外賦值"><a class="header" href="#錯誤無法在-main-函式外賦值">錯誤：無法在 main 函式外賦值</a></h4>
<pre><code class="language-go">// 錯誤：但無法在 main 函式外賦值
package main

import &quot;fmt&quot;

// syntax error: non-declaration statement outside function body
deckSize := 20

func main() {
  fmt.Println(deckSize)
}
</code></pre>
<h4 id="錯誤變數需要先宣告完才能使用"><a class="header" href="#錯誤變數需要先宣告完才能使用">錯誤：變數需要先宣告完才能使用</a></h4>
<pre><code class="language-go">// 錯誤：變數需要先宣告完才能使用
package main

import &quot;fmt&quot;

func main() {
  deckSize = 52            // undefined: deckSize
  fmt.Println(deckSize)    // undefined: deckSize
}
</code></pre>
<h2 id="常數constant"><a class="header" href="#常數constant">常數（constant）</a></h2>
<h5 id="keywords-iota"><a class="header" href="#keywords-iota">keywords: <code>iota</code></a></h5>
<p>使用 <code>:=</code> 或 <code>var</code> 所宣告的會是變數，若需要宣告常數，需要使用 <code>const</code>：</p>
<pre><code class="language-go">const (
    Monday = 1
    Tuesday = 2
    Wednesday = 3
  // ...
)

// 可以簡寫成
// iota 預設從 0 開始，後面的變數自動加一
const (
    Monday = iota + 1
    Tuesday
    Wednesday
  // ...
)
</code></pre>
<p>Go 語言裡面定義變數有多種方式。</p>
<p>使用 <code>var</code> 關鍵字是 Go 最基本的定義變數方式，與 C 語言不同的是 Go 把變數型別放在變數名後面：</p>
<pre><code class="language-go">//定義一個名稱為“variableName”，型別為&quot;type&quot;的變數
var variableName type
</code></pre>
<p>定義變數並初始化值</p>
<pre><code class="language-go">//初始化“variableName”的變數為“value”值，型別是“type”
var variableName type = value
</code></pre>
<p>同時初始化多個變數</p>
<pre><code class="language-go">/*
    定義三個型別都是&quot;type&quot;的變數，並且分別初始化為相應的值
    vname1 為 v1，vname2 為 v2，vname3 為 v3
*/
var vname1, vname2, vname3 type= v1, v2, v3
</code></pre>
<p>你是不是覺得上面這樣的定義有點繁瑣？沒關係，因為 Go 語言的設計者也發現了，有一種寫法可以讓它變得簡單一點。我們可以直接忽略型別宣告，那麼上面的程式碼變成這樣了：</p>
<pre><code class="language-go">/*
    定義三個變數，它們分別初始化為相應的值
    vname1 為 v1，vname2 為 v2，vname3 為 v3
    然後 Go 會根據其相應值的型別來幫你初始化它們
*/
var vname1, vname2, vname3 = v1, v2, v3
</code></pre>
<p>現在是不是看上去非常簡潔了？<code>:=</code>這個符號直接取代了 <code>var</code> 和<code>type</code>，這種形式叫做簡短宣告。不過它有一個限制，那就是它只能用在函式內部；在函式外部使用則會無法編譯透過，所以一般用 <code>var</code> 方式來定義全域性變數。</p>
<pre><code class="language-go">/*
    定義三個變數，它們分別初始化為相應的值
    vname1 為 v1，vname2 為 v2，vname3 為 v3
    編譯器會根據初始化的值自動推匯出相應的型別
*/
vname1, vname2, vname3 := v1, v2, v3
</code></pre>
<h2 id="常數"><a class="header" href="#常數">常數</a></h2>
<p>所謂常數，也就是在程式編譯階段就確定下來的值，而程式在執行時無法改變該值。在 Go 程式中，常數可定義為數值、布林值或字串等型別。</p>
<pre><code class="language-go">const constantName = value
//如果需要，也可以明確指定常數的型別：
const Pi float32 = 3.1415926
</code></pre>
<p>下面是一些常數宣告的例子：</p>
<pre><code class="language-go">const Pi = 3.1415926
const i = 10000
const MaxThread = 10
const prefix = &quot;astaxie_&quot;
</code></pre>
<p>Go 常數和一般程式語言不同的是，可以指定相當多的小數位數(例如 200 位)， 若指定給 float32 自動縮短為 32bit，指定給 float64 自動縮短為 64bit，詳情參考 <a href="http://golang.org/ref/spec#Constants"> 連結</a></p>
<h2 id="數值型別"><a class="header" href="#數值型別">數值型別</a></h2>
<p>整數型別有無符號和帶符號兩種。Go 同時支援 <code>int</code> 和<code>uint</code>，這兩種型別的長度相同，但具體長度取決於不同編譯器的實現。Go 裡面也有直接定義好位數的型別：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中 <code>rune</code> 是<code>int32</code>的別稱，<code>byte</code>是 <code>uint8</code> 的別稱。</p>
<blockquote>
<p>需要注意的一點是，這些型別的變數之間不允許互相賦值或操作，不然會在編譯時引起編譯器報錯。</p>
<p>如下的程式碼會產生錯誤：invalid operation: a + b (mismatched types int8 and int32)</p>
<blockquote>
<p>var a int8</p>
<p>var b int32</p>
<p>c:=a + b</p>
</blockquote>
<p>另外，儘管 int 的長度是 32 bit, 但 int 與 int32 並不可以互用。</p>
</blockquote>
<p>浮點數的型別有 <code>float32</code> 和<code>float64</code>兩種（沒有 <code>float</code> 型別），預設是<code>float64</code>。</p>
<p>這就是全部嗎？No！Go 還支援複數。它的預設型別是<code>complex128</code>（64 位實數+64 位虛數）。如果需要小一些的，也有<code>complex64</code>(32 位實數+32 位虛數)。複數的形式為<code>RE + IMi</code>，其中 <code>RE</code> 是實數部分，<code>IM</code>是虛數部分，而最後的 <code>i</code> 是虛數單位。下面是一個使用複數的例子：</p>
<pre><code class="language-go">var c complex64 = 5+5i
//output: (5+5i)
fmt.Printf(&quot;Value is: %v&quot;, c)
</code></pre>
<h2 id="字串"><a class="header" href="#字串">字串</a></h2>
<p>我們在上一節中講過，Go 中的字串都是採用<code>UTF-8</code>字符集編碼。字串是用一對雙引號（<code>&quot;&quot;</code>）或反引號（<code>`</code> <code>）括起來定義，它的型別是</code>string`。</p>
<p>實際在 Go 中，字串是由唯讀的 UTF-8 編碼位元組所組成。</p>
<pre><code class="language-go">//範例程式碼
var frenchHello string  // 宣告變數為字串的一般方法
var emptyString string = &quot;&quot;  // 宣告了一個字串變數，初始化為空字串
func test() {
    no, yes, maybe := &quot;no&quot;, &quot;yes&quot;, &quot;maybe&quot;  // 簡短宣告，同時宣告多個變數
    japaneseHello := &quot;Konichiwa&quot;  // 同上
    frenchHello = &quot;Bonjour&quot;  // 常規賦值
}
</code></pre>
<p>在 Go 中字串是不可變的，例如下面的程式碼編譯時會報錯：cannot assign to s[0]</p>
<pre><code class="language-go">var s string = &quot;hello&quot;
s[0] = 'c'
</code></pre>
<p>但如果真的想要修改怎麼辦呢？下面的程式碼可以實現：</p>
<pre><code class="language-go">s := &quot;hello&quot;
c := []byte(s)  // 將字串 s 轉換為 []byte 型別
c[0] = 'c'
s2 := string(c)  // 再轉換回 string 型別
fmt.Printf(&quot;%s\n&quot;, s2)
</code></pre>
<p>Go 中可以使用<code>+</code>運算子來連線兩個字串：</p>
<pre><code class="language-go">s := &quot;hello,&quot;
m := &quot; world&quot;
a := s + m
fmt.Printf(&quot;%s\n&quot;, a)
</code></pre>
<p>修改字串也可寫為：</p>
<pre><code class="language-go">s := &quot;hello&quot;
s = &quot;c&quot; + s[1:] // 字串雖不能更改，但可進行切片(slice)操作
fmt.Printf(&quot;%s\n&quot;, s)
</code></pre>
<p>如果要宣告一個多行的字串怎麼辦？可以透過`` `來宣告：</p>
<pre><code class="language-go">m := `hello
    world`
</code></pre>
<p>`` ` 括起的字串為 Raw 字串，即字串在程式碼中的形式就是列印時的形式，它沒有字元轉義，換行也將原樣輸出。例如本例中會輸出：</p>
<pre><code class="language-go">hello
    world
</code></pre>
<h2 id="錯誤型別"><a class="header" href="#錯誤型別">錯誤型別</a></h2>
<p>Go 內建有一個 <code>error</code> 型別，專門用來處理錯誤資訊，Go 的 <code>package</code> 裡面還專門有一個套件 <code>errors</code> 來處理錯誤：</p>
<pre><code class="language-go">err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {
    fmt.Print(err)
}
</code></pre>
<h2 id="映射-map"><a class="header" href="#映射-map">映射 Map</a></h2>
<p><code>map</code>有很多種翻譯，名詞叫作<code>地圖</code>，動詞有<code>映射</code>、<code>對應</code>、<code>對照</code>的意思 ，在一些程式語言中則有<code>Key-Value</code>一個關鍵字對應一個值的用法。</p>
<p><strong>var Variable = map[Type]Type{}</strong></p>
<blockquote>
<p>var a = map[int]string{}</p>
</blockquote>
<p>可以像這樣<code>bool</code>對應到任何<code>string</code></p>
<pre><code class="language-go">var Male = map[bool]string{
	true:  &quot;公&quot;,
	false: &quot;母&quot;,
}
</code></pre>
<p>或是設定<code>string</code>對應到<code>int</code></p>
<pre><code class="language-go">var Number = map[string]int{
	&quot;零&quot;: 0,
	&quot;壹&quot;: 1,
	&quot;貳&quot;: 2,
}
Number[&quot;參&quot;] = 3
</code></pre>
<p><code>string</code>對應到<code>string</code>也可以，</p>
<pre><code class="language-go">var Size = map[string]string{
	&quot;big&quot;:    &quot;大&quot;,
	&quot;medium&quot;: &quot;中&quot;,
	&quot;small&quot;:  &quot;小&quot;,
}
</code></pre>
<p>只要任兩種型態設定好、對應好之後就能用哩，</p>
<p><code>string</code>的前後要加雙引號<code>&quot; &quot;</code>，來試試效果吧！</p>
<h4 id="取map"><a class="header" href="#取map">取map</a></h4>
<pre><code class="language-go">fmt.Print(Male[true],Number[&quot;參&quot;])
/* result:
公3
*/
</code></pre>
<h3 id="for-迭代遍歷"><a class="header" href="#for-迭代遍歷">【for 迭代遍歷】</a></h3>
<p>透過<code>for range</code>關鍵字，遍歷造訪結構內的每個元素</p>
<pre><code class="language-go">for key, value := range Size {
	fmt.Println(key, value)
}
/* result:
big 大
medium 中
small 小
*/
</code></pre>
<h2 id="結構-struct"><a class="header" href="#結構-struct">結構 Struct</a></h2>
<h4 id="struct-1"><a class="header" href="#struct-1">【struct】</a></h4>
<p>結構裡面可以放多個變數（<code>int</code>、<code>string</code>、<code>slice</code>、<code>map</code>等等）、物件、甚至是結構。
宣告結構<code>Struct</code>的幾種方式：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Res struct {
	Status string     `json:&quot;status&quot;`
	Msg string        `json:&quot;msg&quot;`
}

func main()  {
	res1 := new(Res)

	var res2 = new(Res)

	var res3 *Res

	res4 := &amp;Res{
		Status: &quot;failed&quot;,
	}

	fmt.Println(res1, res2, res3, res4)
	fmt.Printf(&quot;%+v %+v %+v %+v&quot;,res1, res2, res3, res4)
}

/* result:
&amp;{ } &amp;{ } &lt;nil&gt; &amp;{failed }
&amp;{Status: Msg:} &amp;{Status: Msg:} &lt;nil&gt; &amp;{Status:failed Msg:}
*/
</code></pre>
<h4 id="nested-structure巢狀結構"><a class="header" href="#nested-structure巢狀結構">【Nested Structure】巢狀結構</a></h4>
<p><code>結構中的結構的結構</code>、大腸包小腸再包小小腸</p>
<pre><code class="language-go">type Wallet struct {
	Blue1000 int // 藍色小朋友
	Red100   int // 紅色國父
	Card     string
}

type PencilBox struct {
	Pencil string
	Pen    string
}

type Bag struct {
	Wallet    // 直接放入結構就好
	PencilBox // 直接放入結構就好
	Books     string
}

type Person struct {
	Bag
	Name string
}

func main() {
	var bag = Bag{
		Wallet{Card: &quot;世華泰國信用無底洞卡&quot;, Red100: 5},
		PencilBox{Pen: &quot;Cross&quot;, Pencil: &quot;Pentel&quot;},
		&quot;Go繁不及備載&quot;, // Books
	}

	var Tommy = Person{}
	Tommy.Name = &quot;Tommy&quot;
	Tommy.Bag = bag

	fmt.Printf(&quot;%+v&quot;, Tommy)
}

/* result:
{Bag:{Wallet:{Blue1000:0 Red100:5 Card:世華泰國信用無底洞卡} PencilBox:{Pencil:Pentel Pen:Cross} Books:Go繁不及備載} Name:Tommy}
*/
</code></pre>
<h2 id="指標結構位址"><a class="header" href="#指標結構位址">【指標、結構、位址】</a></h2>
<p>這裡將上面的例子取一部分出來修改，</p>
<p>如果將<code>main()</code>裡的<code>var Bag</code>敘述改成 <code>&amp;Bag</code>：</p>
<pre><code class="language-go">type Person struct {
	Bag  // 放Bag這個物件
	Name string
}

func main() {
	var bag = &amp;Bag{
		Wallet{Card: &quot;世華泰國信用無底洞卡&quot;, Red100: 5},
		PencilBox{Pen: &quot;Cross&quot;, Pencil: &quot;Pentel&quot;},
		&quot;Go繁不及備載&quot;,
	}

	var Tommy = Person{}
	Tommy.Name = &quot;Tommy&quot;
	Tommy.Bag = *bag // 透過`取值`來取出bag位址裡面的東西

	fmt.Printf(&quot;%+v&quot;, Tommy)
}
/* result:
{Bag:{Wallet:{Blue1000:0 Red100:5 Card:世華泰國信用無底洞卡} PencilBox:{Pencil:Pentel Pen:Cross} Books:Go繁不及備載} Name:Tommy}
*/
</code></pre>
<p>印出bag 就要透過<code>*</code>來取值</p>
<hr />
<p>如果將<code>Person</code>裡的<code>Bag</code>改成 <code>*Bag</code>：</p>
<pre><code class="language-go">type Person struct {
	*Bag // 放指標
	Name string
}

func main() {
	var bag = &amp;Bag{ // 指到位址
		Wallet{Card: &quot;世華泰國信用無底洞卡&quot;, Red100: 5},
		PencilBox{Pen: &quot;Cross&quot;, Pencil: &quot;Pentel&quot;},
		&quot;Go繁不及備載&quot;,
	}

	var Tommy = Person{}
	Tommy.Name = &quot;Tommy&quot;
	Tommy.Bag = bag // 這裡就印出bag位址

	fmt.Printf(&quot;%+v&quot;, Tommy)
}
/* result:
{Bag:0xc000048050 Name:Tommy}
*/
</code></pre>
<p>這樣子就會印出<code>bag</code>的位址</p>
<hr />
<p>雖然有點<strong>違反物理法則及常識</strong>，但</p>
<h4 id="小坑如果bag裡面有pencilboxpencilbox裡面又有bag"><a class="header" href="#小坑如果bag裡面有pencilboxpencilbox裡面又有bag">【小坑】如果Bag裡面有PencilBox，PencilBox裡面又有Bag</a></h4>
<p>會怎麼樣呢？
答案是出現 <code>invalid recursive type</code> 的錯誤。</p>
<p>https://play.golang.org/p/KS5IvIgF1BQ</p>
<pre><code class="language-go">type PencilBox struct {
	Pencil string
	Pen    string
	Bag           // 你中有我 我中有你
}

type Bag struct {
	Wallet
	PencilBox
	Books     string
}
</code></pre>
<p>雖然放物件會出現錯誤，但是 <code>放指針</code>不會</p>
<p>https://play.golang.org/p/mXbp60WDXtR</p>
<pre><code class="language-go">type PencilBox struct {
	Pencil string
	Pen    string
	*Bag           // 你中有針
}

type Bag struct {
	Wallet
	PencilBox
	Books     string
}

func main() {
	var bag = Bag{
		Wallet{Card: &quot;世華泰國信用無底洞卡&quot;, Red100: 5},
		PencilBox{Pen: &quot;Cross&quot;, Pencil: &quot;Pentel&quot;},
		&quot;Go繁不及備載&quot;,
	}
	bag.PencilBox.Bag = &amp;bag // 包包裡放針

	fmt.Printf(&quot;%+v&quot;, *bag.PencilBox.Bag)
}

/* result:
{Wallet:{Blue1000:0 Red100:5 Card:世華泰國信用無底洞卡} PencilBox:{Pencil:Pentel Pen:Cross Bag:0xc000046060} Books:Go繁不及備載}
*/
</code></pre>
<h2 id="基於結構定義新型態"><a class="header" href="#基於結構定義新型態">基於結構定義新型態</a></h2>
<p>你可以使用 <code>type</code> 基於 <code>struct</code> 來定義新型態，例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

func main() {
    point1 := Point{10, 20}
    fmt.Println(point1) // {10 20}

    point2 := Point{Y: 20, X: 30}
    fmt.Println(point2) // {30 20}
} 
</code></pre>
<p>在上面基於結構定義了新型態 <code>Point</code>，留意到名稱開頭的大小寫，<strong>若是大寫的話，就可以在其他套件中存取，這點對於結構的值域也是成立，大寫名稱的值域，才可以在其他套件中存取</strong>。在範例中也可以看到，建立並指定結構的值域時，可以直接指定值域名稱，而不一定要按照定義時的順序。</p>
<h3 id="名稱相同的方法"><a class="header" href="#名稱相同的方法">名稱相同的方法</a></h3>
<p>Go 語言中不允許方法重載（Overload），因此，對於以下的程式，是會發生 <code>String</code> 重複宣告的編譯錯誤：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Account struct {
    id      string
    name    string
    balance float64
}

func String(account *Account) string {
    return fmt.Sprintf(&quot;Account{%s %s %.2f}&quot;,
        account.id, account.name, account.balance)
}

type Point struct {
    x, y int
}

func String(point *Point) string { // String redeclared in this block 的編譯錯誤
    return fmt.Sprintf(&quot;Point{%d %d}&quot;, point.x, point.y)
}

func main() {
    account := &amp;Account{&quot;1234-5678&quot;, &quot;Justin Lin&quot;, 1000}
    point := &amp;Point{10, 20}
    fmt.Println(account.String())
    fmt.Println(point.String())
}
</code></pre>
<p>然而，<strong>若是將函式定義為方法，就不會有這個問題，Go 可以從方法的接收者辨別，該使用哪個 <code>String</code> 方法</strong>：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) String() string {
    return fmt.Sprintf(&quot;Account{%s %s %.2f}&quot;,
        ac.id, ac.name, ac.balance)
}

type Point struct {
    x, y int
}

func (p *Point) String() string {
    return fmt.Sprintf(&quot;Point{%d %d}&quot;, p.x, p.y)
}

func main() {
    account := &amp;Account{&quot;1234-5678&quot;, &quot;Justin Lin&quot;, 1000}
    point := &amp;Point{10, 20}
    fmt.Println(account.String()) // Account{1234-5678 Justin Lin 1000.00}
    fmt.Println(point.String())   // Point{10 20}
}
</code></pre>
<ul>
<li>使用 <strong>new syntax</strong>：第二種和第三種寫法是一樣的</li>
</ul>
<pre><code class="language-go">var user1 *Person       // nil
user2 := &amp;Person{}      // {}，user2.firstName 會是 &quot;&quot;
user3 := new(Person)    // {}，user3.firstName 會是 &quot;&quot;
</code></pre>
<pre><code class="language-go">// STEP 1：建立一個 person 型別，它本質上是 struct
type Person struct {
    firstName string
    lastName  string
}

// 等同於
type Person struct {
  firstName, lastName string
}
</code></pre>
<p>有幾種不同的方式可以根據 struct 來建立變數的：</p>
<pre><code class="language-go">func main() {
    // 方法一：根據資料輸入的順序決定誰是 firstName 和 lastName
  alex := Person{&quot;Alex&quot;, &quot;Anderson&quot;}

  // 直接取得 struct 的 pointer
  alex := &amp;Person{&quot;Alex&quot;, &quot;Anderson&quot;}

    // 方法二（建議）
    alex := Person{
        firstName: &quot;Alex&quot;,
        lastName:  &quot;Anderson&quot;,
    }

  // 方法三：先宣告再賦值
  var alex Person
    alex.firstName = &quot;Alex&quot;
    alex.lastName = &quot;Anderson&quot;
}
</code></pre>
<h3 id="定義匿名的-structanonymous-struct"><a class="header" href="#定義匿名的-structanonymous-struct">定義匿名的 struct（anonymous struct）</a></h3>
<p>也可以不先宣告 struct 直接建立個 struct：</p>
<pre><code class="language-go">foo := struct {
  Hello string
}{
  Hello: &quot;World&quot;,
}
</code></pre>
<h3 id="當-pointer-指稱到的是-struct-時"><a class="header" href="#當-pointer-指稱到的是-struct-時">當 pointer 指稱到的是 struct 時</a></h3>
<p><strong>當 pointer 指稱到的是 struct 時，可以直接使用這個 pointer 來對該 struct 進行設值和取值</strong>。在 golang 中可以直接使用 pointer 來修改 struct 中的欄位。一般來說，若想要透過 struct pointer（<code>&amp;v</code>）來修改該 struct 中的屬性，需要先解出其值（<code>*p</code>）後使用 <code>(*p).X = 10</code>，但這樣做太麻煩了，因此在 golang 中允許開發者直接使用 <code>p.X</code> 的方式來修改：</p>
<pre><code class="language-go">type Person struct {
    name string
    age  int32
}

func main() {
    p := &amp;Person{
        name: &quot;Aaron&quot;,
    }

  // golang 中允許開發者直接使用 `p.age` 的方式來設值與取值
    p.age = 10  // 原本應該要寫 (*p).X = 10
    fmt.Printf(&quot;%+v&quot;, p) // {name:Aaron age:10}

</code></pre>
<p>另外，使用 struct pointer 時才可以修改到原本的物件，否則會複製一個新的：</p>
<pre><code class="language-go">func main() {
    r1 := rectangle{&quot;Green&quot;}

    // 複製新的，指稱到不同位置
    r2 := r1
    r2.color = &quot;Pink&quot;
    fmt.Println(r2) // Pink
    fmt.Println(r1) // Green

    // 指稱到相同位置
    r3 := &amp;r1
    r3.color = &quot;Red&quot;
    fmt.Println(r3) // Red
    fmt.Println(r1) // Red
}
</code></pre>
<h2 id="建立類別-class-和物件-object"><a class="header" href="#建立類別-class-和物件-object">建立類別 (Class) 和物件 (Object)</a></h2>
<h3 id="建立物件-object"><a class="header" href="#建立物件-object">建立物件 (Object)</a></h3>
<pre><code class="language-go">package main                                  /*  1 */

import (                                      /*  2 */
        &quot;log&quot;                                 /*  3 */
)                                             /*  4 */

// `X` and `Y` are public fields.             /*  5 */
type Point struct {                           /*  6 */
        X float64                             /*  7 */
        Y float64                             /*  8 */
}                                             /*  9 */

// Use an ordinary function as constructor    /* 10 */
func NewPoint(x float64, y float64) *Point {  /* 11 */
        p := new(Point)                       /* 12 */

        p.X = x                               /* 13 */
        p.Y = y                               /* 14 */

        return p                              /* 15 */
}                                             /* 16 */

func main() {                                 /* 17 */
        p := NewPoint(3, 4)                   /* 18 */

        if !(p.X == 3.0) {                    /* 19 */
                log.Fatal(&quot;Wrong value&quot;)      /* 20 */
        }                                     /* 21 */

        if !(p.Y == 4.0) {                    /* 22 */
                log.Fatal(&quot;Wrong value&quot;)      /* 23 */
        }                                     /* 24 */
}  
</code></pre>
<p>第 6 行至第 9 行的部分是形態宣告。Golang 沿用結構體為類別的型態，而沒有用新的保留字。</p>
<p>第 11 行至第 16 行的部分是建構函式。在一些程式語言中，會有為了建立物件使用特定的建構子 (constructor)，而 Golang 沒有引入額外的新語法，直接以一般的函式充當建構函式來建立物件即可。</p>
<p>第 17 行至第 25 行為外部程式。在我們的 Point 物件 <code>p</code> 中，我們直接存取 <code>p</code> 的屬性 <code>X</code> 和 <code>Y</code>，這在物件導向上不是好的習慣，因為我們無法控管屬性，物件可能會產生預期外的行為，比較好的方法，是將屬性隱藏在物件內部，由公開方法去存取。我們在後文中會討論。</p>
<h3 id="類別宣告不限定於結構體"><a class="header" href="#類別宣告不限定於結構體">類別宣告不限定於結構體</a></h3>
<p>雖然大部分的 Golang 類別都使用結構體，但其實 Golang 類別內部可用其他的型別，如下例：</p>
<pre><code class="language-go">type Vector []float64                     /*  1 */

func NewVector(args ...float64) Vector {  /*  2 */
        return args                       /*  3 */
}                                         /*  4 */

func WithSize(s int) Vector {             /*  5 */
        v := make([]float64, s)           /*  6 */

        return v                          /*  7 */
}      
</code></pre>
<p>在第 1 行中，我們宣告 <code>Vector</code> 型態，該型態內部不是使用結構體，而是使用陣列。</p>
<p>我們在第 2 行至第 4 行間及第 5 行至第 8 間宣告了兩個建構函式。由此例可知，Go 不限定建構函式的數量，我們可以視需求使用多個不同的建構函式。</p>
<h3 id="撰寫方法-method"><a class="header" href="#撰寫方法-method">撰寫方法 (Method)</a></h3>
<p>在物件導向程式中，我們很少直接操作屬性 (field)，通常會將屬性私有化，再加入相對應的公開方法 (method)。我們將先前的 Point 物件改寫如下：</p>
<pre><code class="language-go">package main                                  /*  1 */

import (                                      /*  2 */
        &quot;log&quot;                                 /*  3 */
)                                             /*  4 */

// `x` and `y` are private fields.            /*  5 */
type Point struct {                           /*  6 */
        x float64                             /*  7 */
        y float64                             /*  8 */
}                                             /*  9 */

func NewPoint(x float64, y float64) *Point {  /* 10 */
        p := new(Point)                       /* 11 */

        p.SetX(x)                             /* 12 */
        p.SetY(y)                             /* 13 */

        return p                              /* 14 */
}                                             /* 15 */

// The getter of x                            /* 16 */
func (p *Point) X() float64 {                 /* 17 */
        return p.x                            /* 18 */
}                                             /* 19 */

// The getter of y                            /* 20 */
func (p *Point) Y() float64 {                 /* 21 */
        return p.y                            /* 22 */
}                                             /* 23 */

// The setter of x                            /* 24 */
func (p *Point) SetX(x float64) {             /* 25 */
        p.x = x                               /* 26 */
}                                             /* 27 */

// The setter of y                            /* 28 */
func (p *Point) SetY(y float64) {             /* 29 */
        p.y = y                               /* 30 */
}                                             /* 31 */

func main() {                                 /* 32 */
        p := NewPoint(0, 0)                   /* 33 */

        if !(p.X() == 0) {                    /* 34 */
                log.Fatal(&quot;Wrong value&quot;)      /* 35 */
        }                                     /* 36 */

        if !(p.Y() == 0) {                    /* 37 */
                log.Fatal(&quot;Wrong value&quot;)      /* 38 */
        }                                     /* 39 */

        p.SetX(3)                             /* 40 */
        p.SetY(4)                             /* 41 */

        if !(p.X() == 3.0) {                  /* 42 */
                log.Fatal(&quot;Wrong value&quot;)      /* 43 */
        }                                     /* 44 */

        if !(p.Y() == 4.0) {                  /* 45 */
                log.Fatal(&quot;Wrong value&quot;)      /* 46 */
        }                                     /* 47 */
}  
</code></pre>
<p>第 6 行至第 9 行是類別宣告的部分。在這個版本的宣告中，我們將 <code>x</code> 和 <code>y</code> 改為小寫，代表該屬性是私有屬性，其可視度僅限於同一 package 中。</p>
<p>第 10 行至第 15 行是 <code>Point</code> 類別的建構函式。請注意我們刻意在第 12 行及第 13 行用該類別的 setters 來初始化屬性，這是刻意的動作。因為我們要確保在設置屬性時的行為保持一致。</p>
<p>第 16 行至第 31 行是 <code>Point</code> 類別的 getters 和 setters。所謂的 getters 和 setters 是用來存取內部屬性的 method。比起直接暴露屬性，使用 getters 和 setters 會有比較好的控制權。日後要修改 getters 或 setters 的實作時，也只要修改同一個地方即可。</p>
<p>在本例中，getters 和 setters 都是公開 method。但 getters 或 setters 不一定必為公開 method。例如，我們想做唯讀的 <code>Point</code> 物件時，就可以把 setters 的部分設為私有 method，留給類別內部使用。</p>
<p>在 Go 語言中，沒有 <code>this</code> 或 <code>self</code> 這種代表物件的關鍵字，而是由程式設計者自訂代表物件的變數，在本例中，我們用 <code>p</code> 表示物件本身。透過這種帶有物件的函式宣告後，函式會和物件連動；在物件導向中，將這種和物件連動的函式稱為方法 (method)。</p>
<p>雖然在這個例子中，暫時無法直接看出使用方法的好處，比起直接操作屬性，透過私有屬性搭配公開方法帶來許多的益處。例如，如果我們希望 Point 在建立之後是唯讀的，我們只要將 <code>SetX</code> 和 <code>SetY</code> 改為私有方法即可。或者，我們希望限定 Point 所在的範圍為 0.0 至 1000.0，我們可以在 <code>SetX</code> 和 <code>SetY</code> 中檢查參數是否符合我們的要求。</p>
<h3 id="靜態方法-static-method"><a class="header" href="#靜態方法-static-method">靜態方法 (Static Method)</a></h3>
<p>有些讀者學過 Java 或 C#，可能有聽過過靜態方法 (static method)。這是因為 Java 和 C# 直接將物件導向的概念融入其語法中，然而，為了要讓某些方法在不建立物件時即可使用，所使用的一種補償性的語法機制。由於 Go 語言沒有將物件導向的概念直接加在語法中，不需要用這種語法，直接用頂層函式即可。</p>
<p>例如：我們撰寫一個計算兩點間長度的函式：</p>
<pre><code class="language-go">package main                                   /*  1 */

import (                                       /*  2 */
        &quot;log&quot;                                  /*  3 */
        &quot;math&quot;                                 /*  4 */
)                                              /*  5 */

type Point struct {                            /*  6 */
        x float64                              /*  7 */
        y float64                              /*  8 */
}                                              /*  9 */

func NewPoint(x float64, y float64) *Point {   /* 10 */
        p := new(Point)                        /* 11 */

        p.SetX(x)                              /* 12 */
        p.SetY(y)                              /* 13 */

        return p                               /* 14 */
}                                              /* 15 */

func (p *Point) X() float64 {                  /* 16 */
        return p.x                             /* 17 */
}                                              /* 18 */

func (p *Point) Y() float64 {                  /* 19 */
        return p.y                             /* 20 */
}                                              /* 21 */

func (p *Point) SetX(x float64) {              /* 22 */
        p.x = x                                /* 23 */
}                                              /* 24 */

func (p *Point) SetY(y float64) {              /* 25 */
        p.y = y                                /* 26 */
}                                              /* 27 */

// Use an ordinary function as static method.  /* 28 */
func Dist(p1 *Point, p2 *Point) float64 {      /* 29 */
        xSqr := math.Pow(p1.X()-p2.X(), 2)     /* 30 */
        ySqr := math.Pow(p1.Y()-p2.Y(), 2)     /* 31 */

        return math.Sqrt(xSqr + ySqr)          /* 32 */
}                                              /* 33 */

func main() {                                  /* 34 */
        p1 := NewPoint(0, 0)                   /* 35 */
        p2 := NewPoint(3.0, 4.0)               /* 36 */

        if !(Dist(p1, p2) == 5.0) {            /* 37 */
                log.Fatal(&quot;Wrong value&quot;)       /* 38 */
        }                                      /* 39 */
}   
</code></pre>
<p>本範例和前一節的範例大同小異。主要的差別在於第 29 行至第 33 間多了一個用來計算距離的函式。該函式不綁定特定的物件，相當於 Java 的靜態函式。</p>
<p>因為 Golang 不是 Java 這種純物件導向語言，而是混合命令式和物件式兩種語法，所以不需要使用特定的語法來實踐靜態函式，使用一般的函式即可。</p>
<p>或許有讀者會擔心，使用過多的頂層函式會造成全域空間的汙染和衝突；實際上不需擔心，雖然我們目前將物件和主程式寫在一起，實務上，物件會寫在獨立的package 中，藉由 package 即可大幅減低命名空間衝突的議題。</p>
<h3 id="使用嵌入-embedding-取代繼承-inheritance"><a class="header" href="#使用嵌入-embedding-取代繼承-inheritance">使用嵌入 (Embedding) 取代繼承 (Inheritance)</a></h3>
<p>繼承 (inheritance) 是一種重用程式碼的方式，透過從父類別 (parent class) 繼承程式碼，子類別 (child class) 可以少寫一些程式碼。此外，對於靜態型別語言來說，繼承也是實現多型 (polymorphism) 的方式。然而，Go 語言卻刻意地拿掉繼承，這是出自於其他語言的經驗。</p>
<p>繼承雖然好用，但也引起許多的問題。像是 C++ 相對自由，可以直接使用多重繼承，但這項特性會引來菱型繼承 (diamond inheritance) 的議題，Java 和 C# 刻意把這個機制去掉，改以介面 (interface) 進行有限制的多重繼承。從過往經驗可知過度地使用繼承，會增加程式碼的複雜度，使得專案難以維護。出自於工程上的考量，Go 捨去繼承這個語法特性。</p>
<p>為了補償沒有繼承的缺失，Go 加入了嵌入 (embedding) 這個新的語法特性，透過嵌入，也可以達到程式碼共享的功能。</p>
<p>例如，我們擴展 Point 類別至三維空間：</p>
<pre><code class="language-go">package main                                                 /*  1 */

import (                                                     /*  2 */
        &quot;log&quot;                                                /*  3 */
)                                                            /*  4 */

type Point struct {                                          /*  5 */
        x float64                                            /*  6 */
        y float64                                            /*  7 */
}                                                            /*  8 */

func NewPoint(x float64, y float64) *Point {                 /*  9 */
        p := new(Point)                                      /* 10 */

        p.SetX(x)                                            /* 11 */
        p.SetY(y)                                            /* 12 */

        return p                                             /* 13 */
}                                                            /* 14 */

func (p *Point) X() float64 {                                /* 15 */
        return p.x                                           /* 16 */
}                                                            /* 17 */

func (p *Point) Y() float64 {                                /* 18 */
        return p.y                                           /* 19 */
}                                                            /* 20 */

func (p *Point) SetX(x float64) {                            /* 21 */
        p.x = x                                              /* 22 */
}                                                            /* 23 */

func (p *Point) SetY(y float64) {                            /* 24 */
        p.y = y                                              /* 25 */
}                                                            /* 26 */

type Point3D struct {                                        /* 27 */
        // Point is embedded                                 /* 28 */
        Point                                                /* 29 */
        z float64                                            /* 30 */
}                                                            /* 31 */

func NewPoint3D(x float64, y float64, z float64) *Point3D {  /* 32 */
        p := new(Point3D)                                    /* 33 */

        p.SetX(x)                                            /* 34 */
        p.SetY(y)                                            /* 35 */
        p.SetZ(z)                                            /* 36 */

        return p                                             /* 37 */
}                                                            /* 38 */

func (p *Point3D) Z() float64 {                              /* 39 */
        return p.z                                           /* 40 */
}                                                            /* 41 */

func (p *Point3D) SetZ(z float64) {                          /* 42 */
        p.z = z                                              /* 43 */
}                                                            /* 44 */

func main() {                                                /* 45 */
        p := NewPoint3D(1, 2, 3)                             /* 46 */

        // GetX method is from Point                         /* 47 */
        if !(p.X() == 1) {                                   /* 48 */
                log.Fatal(&quot;Wrong value&quot;)                     /* 49 */
        }                                                    /* 50 */

        // GetY method is from Point                         /* 51 */
        if !(p.Y() == 2) {                                   /* 52 */
                log.Fatal(&quot;Wrong value&quot;)                     /* 53 */
        }                                                    /* 54 */

        // GetZ method is from Point3D                       /* 55 */
        if !(p.Z() == 3) {                                   /* 56 */
                log.Fatal(&quot;Wrong value&quot;)                     /* 57 */
        }                                                    /* 58 */
}     
</code></pre>
<p>第 5 行至第 26 行是原本的 <code>Point</code> 類別，這和先前的實作是雷同的，不多做說明。</p>
<p>第 27 行至第 44 行是 <code>Point3D</code> 類別，我們來看一下這個類別。</p>
<p>第 27 行至第 31 行是 <code>Point3D</code> 的類別宣告。請注意我們在第 29 行嵌入了 <code>Point</code> 類別。</p>
<p>第 32 行至第 38 行是 <code>Point3d</code> 的建構函式。雖然我們沒有為 <code>Point3D</code> 宣告 <code>SetX()</code> 及 <code>SetY()</code> method，但我們有嵌入 <code>Point</code> 類別，所以我們在第 34 行及第 35 行可以直接使用這些 method。</p>
<p>第 45 行至第 59 行是外部程式的部分。由於我們的 <code>Point3D</code> 內嵌了 <code>Point</code>，雖然 <code>Point3D</code> 沒有自己實作 <code>X()</code> 和 <code>Y()</code> method，我們在第 48 行及第 52 行可直接呼叫這些 method。</p>
<p>在本例中，我們重用了 <code>Point</code> 的方法，再加入 <code>Point3D</code> 特有的方法。實際上的效果等同於繼承。</p>
<p>然而，<code>Point</code> 和 <code>Point3D</code> 兩者在類別關係上卻是不相干的獨立物件。在以下例子中，我們想將 <code>Point3D</code> 加入 <code>Point</code> 物件組成的切片，而引發程式的錯誤：</p>
<pre><code class="language-go">// Declare Point and Point3D as above.
 
func main() {
    points := make([]*Point, 0)
 
    p1 := NewPoint(3, 4)
    p2 := NewPoint3D(1, 2, 3)
 
    // Error!
    points = append(points, p1, p2)
}
</code></pre>
<p>在 Go 語言中，需要使用介面 (interface) 來解決這個議題，這就是我們下一篇文章所要探討的主題。</p>
<h3 id="嵌入指標"><a class="header" href="#嵌入指標">嵌入指標</a></h3>
<p>除了嵌入其他結構外，結構也可以嵌入指標。我們將上例改寫如下：</p>
<pre><code class="language-go">package main
 
import (
    &quot;log&quot;
)
 
type Point struct {
    x float64
    y float64
}
 
func NewPoint(x float64, y float64) *Point {
    p := new(Point)
 
    p.SetX(x)
    p.SetY(y)
 
    return p
}
 
func (p *Point) X() float64 {
    return p.x
}
 
func (p *Point) Y() float64 {
    return p.y
}
 
func (p *Point) SetX(x float64) {
    p.x = x
}
 
func (p *Point) SetY(y float64) {
    p.y = y
}
 
type Point3D struct {
    // Point is embedded as a pointer
    *Point
    z float64
}
 
func NewPoint3D(x float64, y float64, z float64) *Point3D {
    p := new(Point3D)
 
    // Forward promotion
    p.Point = NewPoint(x, y)
 
    // Forward promotion
    p.Point.SetX(x)
    p.Point.SetY(y)
 
    p.SetZ(z)
 
    return p
}
 
func (p *Point3D) Z() float64 {
    return p.z
}
 
func (p *Point3D) SetZ(z float64) {
    p.z = z
}
 
func main() {
    p := NewPoint3D(1, 2, 3)
 
    // GetX method is from Point
    if !(p.X() == 1) {
        log.Fatal(&quot;Wrong value&quot;)
    }
 
    // GetY method is from Point
    if !(p.Y() == 2) {
        log.Fatal(&quot;Wrong value&quot;)
    }
 
    // GetZ method is from Point3D
    if !(p.Z() == 3) {
        log.Fatal(&quot;Wrong value&quot;)
    }
}
</code></pre>
<p>同樣地，仍然不能透過嵌入指楆讓型別直接互通，而需要透過介面 (interface)。</p>
<h2 id="array和slice的區別"><a class="header" href="#array和slice的區別">Array和Slice的區別</a></h2>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<p>Go語言中的Array即為資料的一種集合，需要在宣告時指定容量和初值，且一旦宣告就<strong>長度固定</strong>了，訪問時按照索引進行訪問。通過內建函式<code>len</code>可以獲取陣列中的元素個數。</p>
<p>陣列在初始化時必須指定大小和初值，不過Go語言為我們提供了一些更為靈活的方式進行初始化。例如：使用<code>...</code>來自動獲取長度；未指定值時，用0賦予初值；指定指定元素的初值等。下面給出一些陣列初始化的方式示例。</p>
<pre><code class="language-go">var arr [5]int	//聲明瞭一個大小為5的陣列，預設初始化值為[0,0,0,0,0]
arr := [5]int{1}	//宣告並初始化了一個大小為5的陣列的第一個元素，初始化後值為[1,0,0,0,0]
arr := [...]int{1,2,3}	//通過...自動獲取陣列長度，根據初始化的值的數量將大小初始化為3，初始化後值為[1,2,3]
arr := [...]int{4:1}	//指定序號為4的元素的值為1，通過...自動獲取長度為5，初始化後值為[0,0,0,0,1]
</code></pre>
<h4 id="函式引數"><a class="header" href="#函式引數">函式引數</a></h4>
<p>Go語言陣列作為函式引數時，必須指定引數陣列的大小，且傳入的陣列大小必須與指定的大小一致，陣列為<strong>按值傳遞</strong>的，函式內對陣列的值的改變不影響初始陣列:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

//PrintArray print the value of array
func PrintArray(arr [5]int) {
    arr[0] = 5
	fmt.Println(arr)
}

func main() {
	a := [...]int{4:1}
	PrintArray(a)	// [5,0,0,0,1]
    fmt.Println(a)	// [0,0,0,0,1]
}
</code></pre>
<h3 id="slice"><a class="header" href="#slice">Slice</a></h3>
<p>切片是Go語言中極為重要的一種資料型別，可以理解為<strong>動態長度</strong>的陣列（雖然實際上Slice結構內包含了一個數組），訪問時可以按照陣列的方式訪問，也可以通過<code>切片</code>操作訪問。Slice有三個屬性：指標、長度和容量。指標即Slice名，指向的為陣列中第一個可以由Slice訪問的元素；長度指當前slice中的元素個數，不能超過slice的容量；容量為slice能包含的最大元素數量，但實際上當容量不足時，會自動擴充為原來的兩倍。通過內建函式<code>len</code>和<code>cap</code>可以獲取slice的長度和容量。</p>
<p>Slice在初始化時需要初始化指標，長度和容量，容量未指定時將自動初始化為長度的大小。可以通過直接獲取陣列的引用、獲取陣列/slice的切片構建或是make函式初始化陣列。下面給出一些slice初始化的方式示例。</p>
<pre><code class="language-go">s := []int{1,2,3}	//通過陣列的引用初始化，值為[1,2,3],長度和容量為3

arr := [5]int{1,2,3,4,5}
s := arr[0:3]	//通過陣列的切片初始化，值為[1,2,3]，長度為3，容量為5

s := make([]int, 3)	//通過make函式初始化，值為[0,0,0]，長度和容量為3

s := make([]int, 3, 5)	//通過make函式初始化，值為[0,0,0]，長度為3，容量為5
</code></pre>
<p>其中特別需要注意的是通過切片方式初始化。若是通過對slice的切片進行初始化，實際上初始化之後的結構如下圖所示：</p>
<p><img src="go/images/a0eca91a66cd494d966e8882b1817243_tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<p>此時x的值為[2,3,5,7,11]，y的值為[3,5,7]，且兩個slice的指標指向的是<strong>同一個陣列</strong>，也即x中的元素的值的改變將會導致y中的值也一起改變。</p>
<blockquote>
<p><em>這樣的初始化方式可能會導致記憶體被<strong>過度佔用</strong>，如只需要使用一個極大的陣列中的幾個元素，但是由於需要指向整個陣列，所以整個陣列在GC時都無法被釋放，一直佔用記憶體空間。故使用切片操作進行初始化時，最好使用<code>append</code>函式將切片出來的資料複製到一個新的slice中，從而避免記憶體佔用陷阱。</em></p>
</blockquote>
<h4 id="函式引數-1"><a class="header" href="#函式引數-1">函式引數</a></h4>
<p>Go語言Slice作為函式引數傳遞時為<strong>按引用傳遞</strong>的，函式內對slice內元素的修改將導致函式外的值也發生改變，不過由於傳入函式的是一個指標的副本，所以對該指標的修改不會導致原來的指標的變化（例如append函式不會改變原來的slice的值）。具體可以根據下面的程式碼進行理解：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

//PrintSlice print the value of slice
func PrintSlice(s []int) {
	s = append(s, 4)
	s[0] = -1
	fmt.Println(s)
}

func main() {
	s := []int{1,2,3,4,5}
	s1 := s[0:3]

    fmt.Println(&quot;s:&quot;,s)	//s: [1,2,3,4,5]
    fmt.Println(&quot;s1:&quot;,s1)	//s1: [1,2,3]
	PrintSlice(s1)	//[-1,2,3,4]
	fmt.Println(&quot;s:&quot;,s)	//[-1,2,3,4,5]
	fmt.Println(&quot;s1:&quot;,s1)	//[-1,2,3]
}
</code></pre>
<h4 id="總結-4"><a class="header" href="#總結-4">總結</a></h4>
<ul>
<li>陣列長度不能改變，初始化後長度就是固定的；切片的長度是不固定的，可以追加元素，在追加時可能使切片的容量增大。</li>
<li>結構不同，陣列是一串固定資料，切片描述的是擷取陣列的一部分資料，從概念上說是一個結構體。</li>
<li>初始化方式不同，如上。另外在宣告時的時候：宣告陣列時，方括號內寫明瞭陣列的長度或使用<code>...</code>自動計算長度，而宣告<code>slice</code>時，方括號內沒有任何字元。</li>
<li>unsafe.sizeof的取值不同，unsafe.sizeof(slice)返回的大小是切片的描述符，不管slice裡的元素有多少，返回的資料都是24位元組。unsafe.sizeof(arr)的值是在隨著arr的元素的個數的增加而增加，是陣列所儲存的資料記憶體的大小。</li>
<li>函式呼叫時的傳遞方式不同，陣列按值傳遞，slice按引用傳遞。</li>
</ul>
<h2 id="指標-2"><a class="header" href="#指標-2">指標</a></h2>
<p>Go 語言中有指標（Pointer），你可以在宣告變數時於型態前加上 <code>*</code>，這表示建立一個指標，例如：</p>
<pre><code class="language-go">var i *int
</code></pre>
<p>這時 <code>i</code> 是個空指標，也就是值為 <code>nil</code>，上頭等同於 <code>var i *int = nil</code>，目前並沒有儲存任何位址，如果想讓它儲存另一個變數的記憶體位址，可以使用 <code>&amp;</code> 取得變數位址並指定給 <code>i</code>，例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var i *int
    j := 1

    i = &amp;j
    fmt.Println(i)  // 0x104382e0 之類的值
    fmt.Println(*i) // 1

    j = 10
    fmt.Println(*i) // 10

    *i = 20
    fmt.Println(j) // 20
}
</code></pre>
<p><code>j</code> 的位置儲存了 1，那麼具體來說，<code>j</code> 的位置到底是在哪？這就是 <code>&amp;</code> 取址運算的目的，<code>&amp;j</code> 具體取得了 <code>j</code> 的位置，然後指定給 <code>i</code>。</p>
<p>如上所示，如果想存取指標位址處的變數儲存的值，可以使用 <code>*</code>，因而，你改變 <code>j</code> 的值，<code>*i</code> 取得的就是改變後的值，透過 <code>*i</code> 改變值，從 <code>j</code> 取得的也會是改變後的值。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func add1To(n *int) {
	*n = *n + 1
}

func main() {
	number := 1
	add1To(&amp;number)
	fmt.Println(number) // 2
}
</code></pre>
<h2 id="打印型態"><a class="header" href="#打印型態">打印型態</a></h2>
<ul>
<li>使用reflect的TypeOf方法</li>
<li>使用Printf中的 %T</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	x := 10
	p := &amp;x
	fmt.Printf(&quot;%T\n&quot;, p)
	fmt.Println(reflect.TypeOf(p))

}
</code></pre>
<h2 id="結構與指標"><a class="header" href="#結構與指標">結構與指標</a></h2>
<p>如果你建立了一個結構的實例，並將之指定給另一個結構變數，那麼會進行值域的複製。例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

func main() {  
    point1 := Point{X: 10, Y: 20}
    point2 := point1

    point1.X = 20

    fmt.Println(point1)  // {20, 20}
    fmt.Println(point2)  // {10 20}
}
</code></pre>
<p>這對於函式的參數傳遞也是一樣的：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

func changeX(point Point) {
    point.X = 20
    fmt.Println(point)
}

func main() {
    point := Point{X: 10, Y: 20}

    changeX(point)     // {20 20}
    fmt.Println(point) // {10 20}
}
</code></pre>
<p><code>point</code> 的位置開始儲存了結構，可以對 <code>point</code> 使用 <code>&amp;</code> 取值，將位址值指定給指標，因此若指定或傳遞結構時，不是想要複製值域，可以使用指標。例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

func main() {
    point1 := Point{X: 10, Y: 20}
    point2 := &amp;point1

    point1.X = 20

    fmt.Println(point1) // {20, 20}
    fmt.Println(point2) // &amp;{20 20}
}
</code></pre>
<p>注意到 <code>point2 := &amp;point1</code> 多了個 <code>&amp;</code>，這取得了 <code>point1</code> 實例的指標值，並傳遞給 <code>point2</code>，<code>point2</code> 的型態是 <code>*Point</code>，也就是相當於 <code>var point2 *Point = &amp;point1</code>，因此，當你透過 <code>point1.X</code> 改變了值，透過 <code>point2</code> 就能取得對應的改變。</p>
<p>類似地，也可以在傳遞參數給函式時使用指標：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

func changeX(point *Point) {
    point.X = 20
    fmt.Printf(&quot;&amp;{%d %d}\n&quot;, point.X, point.Y)
}

func main() {
    point := Point{X: 10, Y: 20}

    changeX(&amp;point)    // &amp;{20 20}
    fmt.Println(point) // {20 20}
}
</code></pre>
<p>可以看到在 Go 語言中，即使是指標，也可以直接透過點運算子來存取值域，這是 Go 提供的語法糖，<code>point.X</code> 在編譯過後，會被轉換為 <code>(*point).X</code>。</p>
<p>你也可以透過 <code>new</code> 來建立結構實例，這會傳回結構實例的位址：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

func default_point() *Point {
    point := new(Point)
    point.X = 10
    point.Y = 10
    return point
}

func main() {
    point := default_point()
    fmt.Println(point) // &amp;{10 10}
}
</code></pre>
<p>在這邊，<code>point</code> 是個指標，也就是 <code>*Point</code> 型態，儲存了結構實例的位址。</p>
<p>結構的值域也可以是指標型態，也可以是結構自身型態之指標，因此可實現鏈狀參考，例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
    X, Y int
}

type Node struct {
    point *Point
    next  *Node
}

func main() {
    node := new(Node)

    node.point = &amp;Point{10, 20}
    node.next = new(Node)

    node.next.point = &amp;Point{10, 30}

    fmt.Println(node.point)      // &amp;{10 20}
    fmt.Println(node.next.point) // &amp;{10 30}
}
</code></pre>
<p><code>$T{}</code> 的寫法與 <code>new(T)</code> 是等效的，使用 <code>&amp;Point{10, 20}</code> 這類的寫法，可以同時指定結構的值域。</p>
<h2 id="json"><a class="header" href="#json">Json</a></h2>
<p>go 的 json.Unmarshal 可以把 json 字串轉成 struct，而 json.Marshal 可以將 struct 轉成 json 字串．</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

type Person struct {
	Id   int    `json:&quot;id&quot;`
	Name string `json:name`
}

func main() {
	data := []byte(`{&quot;id&quot; : 1 , &quot;name&quot; : &quot;Daniel&quot;}`)
	var person Person
	json.Unmarshal(data, &amp;person)
	fmt.Println(person)
	jsondata, _ := json.Marshal(person)
	fmt.Println(string(jsondata))
}
</code></pre>
<h2 id="協程同步的三個方法"><a class="header" href="#協程同步的三個方法">協程同步的三個方法</a></h2>
<h3 id="mutex-1"><a class="header" href="#mutex-1">Mutex</a></h3>
<p>互斥鎖，可以創建為其他結構體的字段；零值為解鎖 狀態，Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。</p>
<h3 id="channel-2"><a class="header" href="#channel-2">Channel</a></h3>
<p>使用Go語言的channel</p>
<h3 id="waitgroup"><a class="header" href="#waitgroup">WaitGroup</a></h3>
<p>它能夠阻塞主線程的執行，直到所有的goroutine執行完畢。要注意goroutine的執行結果是亂序的，調度器無法保証goroutine執行順序，且進程結束時不會等待goroutine退出。</p>
<h3 id="waitgroup使用詳解"><a class="header" href="#waitgroup使用詳解">WaitGroup使用詳解</a></h3>
<p>WaitGroup總共有三個方法：</p>
<ul>
<li>Add(delta int) : 計數器增加delta</li>
<li>Done() : 計數器-1，相當於Add(-1)</li>
<li>Wait() : 阻塞直到所有的WaitGroup數量變為零，即計數器變為0</li>
</ul>
<p>sync.WaitGroup實現了一個類似Que的資料結構，我們可以不斷地向Que添加並發任務，每添加一個任務，就將計數器的值增加1，若我們啟動了 N 個並發任務時時，就需要把計數器增加 N 。每個任務完成時通過呼叫 Done()方法將計數器減1，並且從Que中刪除。如果隊例中的任務尚未執行完畢，我們通過調用 Wait() 來發出阻塞， 直到計數器歸零時，表示所有並發協程已經完成。</p>
<pre><code class="language-go">var wg sync.WaitGroup //宣告全域的WaitGroup
var count int32

func AddOne() { //定義函數，每次調用時count加1
	defer wg.Done()
	count++
}

func main()  {
	wg.Add(3) //往WaitGroup裡添加3個goroutine
	go AddOne()
	go AddOne()
	go AddOne()
	wg.Wait()
	fmt.Printf(&quot;Count: %d&quot;, count ) //執行結束，輸出Count: 3
}
</code></pre>
<p>WaitGroup的特點是可以調用Wait()來阻塞隊列，直到隊列中的並發任務執行完畢才解除阻塞，不用sleep固定時間來等待。缺點是無法指定goroutine的並發協程數目。</p>
<h3 id="waitgroup源碼閱讀"><a class="header" href="#waitgroup源碼閱讀">WaitGroup源碼閱讀</a></h3>
<h4 id="信號量"><a class="header" href="#信號量">信號量</a></h4>
<p>信號量是Unix系統提供的一種共享資源的保護機制，用於防止多個線程同時訪問某個資源。</p>
<p>當信號量&gt;0時，表示資源可用。
當信號量==0時，表示資源暫不可用。</p>
<p>線程獲取資源時，系統將信號量減1。當信號量為0時，當前線程會進入睡眠，直到信號量為正時線程會被喚醒。</p>
<h4 id="資料結構"><a class="header" href="#資料結構">資料結構</a></h4>
<p>源碼包src/sync/waitgroup.go:WaitGroup的結構體定義如下：</p>
<pre><code class="language-go">type WaitGroup struct {
	state1 [3]uint32
}
</code></pre>
<p>state1 是一個長度為3的array，包含了兩組計數器和一個信號量。</p>
<ul>
<li>counter : 當前還未執行結束的goroutine計數器</li>
<li>waiter count : 等待goroutine-group結束的goroutine數量，即等候者的數量</li>
<li>semaphore : 信號量</li>
</ul>
<p><img src="go/images/20120698CUTVP4tIWL.png" alt="" /></p>
<p>WaitGroup對外提供三個接口，Add(delta int)，Wait()和Done()，下面介紹這三個函數的實現細節。</p>
<h3 id="adddelta-int"><a class="header" href="#adddelta-int">Add(delta int)</a></h3>
<p>Add()的功能有兩個，第一個是將delta值加到counter裡頭，因為delta可以為負值，所以counter有可能變成0或負值。Add()的第二個功能就是判斷counter的值，當其為0時，根據 waiter 數值釋放等量的信號量，把等待的goroutine全部喚醒，如果counter變為負值，則panic。</p>
<pre><code class="language-go">func (wg *WaitGroup) Add(delta int) {
    statep, semap := wg.state() //獲取state和semphore的指針
    
    state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32) //把delta值加到counter
    v := int32(state &gt;&gt; 32) //獲取counter值
    w := uint32(state)      //獲取waiter值
    
    if v &lt; 0 {              //如果counter值為負數，則panic
        panic(&quot;sync: negative WaitGroup counter&quot;)
    }

    //如果counter大於零，或是waiter為零(沒有等待者)，則直接退出
    if v &gt; 0 || w == 0 {
        return
    }

    //當counter等於0時，waiter一定大於零(內部維護waiter數目，不會出現小於等於零的情況)
    //先把counter歸零，再釋放waiter個數的信號量
    *statep = 0
    for ; w != 0; w-- {
        runtime_Semrelease(semap, false)
    }
}
</code></pre>
<h3 id="wait"><a class="header" href="#wait">Wait()</a></h3>
<p>Wait()的功能為累加waiter以及阻塞等待信號量</p>
<pre><code class="language-go">func (wg *WaitGroup) Wait() {
    statep, semap := wg.state() //獲取state和semaphore的指針
    for {
        state := atomic.LoadUint64(statep) //獲取state值
        v := int32(state &gt;&gt; 32)            //獲取counter值
        w := uint32(state)                 //獲取waiter值
        if v == 0 {                        //當counter為0，代表所有的goroutine都結束了，直接退出
            return
        }
        
        // 使用CAS函數累加waiter，保証有多個goroutine同時執行Wait()時也能正確累加waiter
        if atomic.CompareAndSwapUint64(statep, state, state+1) {
            runtime_Semacquire(semap) 
            return
        }
    }
}
</code></pre>
<h3 id="done"><a class="header" href="#done">Done()</a></h3>
<p>Done()等同於Add(-1)，也就是把counter減1。</p>
<pre><code class="language-go">func (wg *WaitGroup) Done() {
	wg.Add(-1)
}
</code></pre>
<h3 id="waitgroup的坑"><a class="header" href="#waitgroup的坑">WaitGroup的坑</a></h3>
<ul>
<li>
<p>Add()操作必須早於Wait()，否則會panic</p>
</li>
<li>
<p>Add()設置的值必須與實際等待的goroutine數量一致，否則會panic</p>
</li>
</ul>
<h2 id="deferpanicrecover"><a class="header" href="#deferpanicrecover">defer、panic、recover</a></h2>
<h3 id="defer-延遲執行"><a class="header" href="#defer-延遲執行">defer 延遲執行</a></h3>
<p>在 Go 語言中，可以使用 <code>defer</code> 指定某個函式延遲執行，那麼延遲到哪個時機？簡單來說，在函式 <code>return</code> 之前，例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func deferredFunc() {
    fmt.Println(&quot;deferredFunc&quot;)    
}

func main() {
    defer deferredFunc()
    fmt.Println(&quot;Hello, 世界&quot;)    
}
</code></pre>
<p>這個範例執行時，<code>deferredFunc()</code> 前加上了 <code>defer</code>，因此，會在 <code>main()</code> 函式 <code>return</code> 前執行，結果就是先顯示了 <code>&quot;Hello, 世界&quot;</code>，才顯示 <code>&quot;deferredFunc&quot;</code>。</p>
<p>如果有多個函式被 <code>defer</code>，那麼在函式 <code>return</code> 前，會依 <code>defer</code> 的相反順序執行，也就是 LIFO，例如：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func deferredFunc1() {
    fmt.Println(&quot;deferredFunc1&quot;)
}

func deferredFunc2() {
    fmt.Println(&quot;deferredFunc2&quot;)
}

func main() {
    defer deferredFunc1()
    defer deferredFunc2()
    fmt.Println(&quot;Hello, 世界&quot;)
}
</code></pre>
<p>由於先 <code>defer</code> 了 <code>deferredFunc1()</code>，才 <code>defer</code> 了 <code>deferredFunc2()</code>，因此執行結果會是 <code>&quot;Hello, 世界&quot;</code>、<code>&quot;deferredFunc2&quot;</code>、<code>&quot;deferredFunc1&quot;</code> 的顯示順序。</p>
<h4 id="使用-defer-清除資源"><a class="header" href="#使用-defer-清除資源">使用 defer 清除資源</a></h4>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    f, err := os.Open(&quot;/tmp/dat&quot;)
    if err != nil {
        fmt.Println(err)
        return;
    }

    defer func() { // 延遲執行，而且函式 return 前一定會執行
        if f != nil {
            f.Close()
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    if err != nil {
        fmt.Printf(&quot;%d bytes: %s\n&quot;, n1, string(b1))
        // 處理讀取的內容....
    }
}
</code></pre>
<p>這麼一來，若 <code>Read</code> 發生錯誤，最後一定會執行被 <code>defer</code> 的函式，從而保證了 <code>f.Close()</code> 一定會關閉檔案。</p>
<p>（就某些意義來說，<code>defer</code> 的角色類似於例外處理機制中 <code>finally</code> 的機制，將資源清除的函式，藉由 <code>defer</code> 來處理，一方面大概也是為了在程式碼閱讀上，強調出資源清除的重要性吧！）</p>
<h3 id="panic-恐慌中斷"><a class="header" href="#panic-恐慌中斷">panic 恐慌中斷</a></h3>
<p>方才稍微提過，如果在函式中執行 <code>panic</code>，那麼函式的流程就會中斷，若 A 函式呼叫了 B 函式，而 B 函式中呼叫了 <code>panic</code>，那麼 B 函式會從呼叫了 <code>panic</code> 的地方中斷，而 A 函式也會從呼叫了 B 函式的地方中斷，若有更深層的呼叫鏈，<code>panic</code> 的效應也會一路往回傳播。</p>
<p>（如果你有例外處理的經驗，這就相當於被拋出的例外都沒有處理的情況。）</p>
<p>可以將方才的範例改寫為以下：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func check(err error) {
    if err != nil {
        panic(err)
    }
}

func main() {
    f, err := os.Open(&quot;/tmp/dat&quot;)
    check(err)

    defer func() {
        if f != nil {
            f.Close()
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    check(err)

    fmt.Printf(&quot;%d bytes: %s\n&quot;, n1, string(b1))
}
</code></pre>
<p>如果在開啟檔案時，就發生了錯誤，假設這是在一個很深的呼叫層次中發生，若你直接想撰寫程式，將 <code>os.Open</code> 的 <code>error</code> 逐層傳回，那會是一件很麻煩的事，此時直接發出 <code>panic</code>，就可以達到想要的目的。</p>
<h3 id="recover-恢復流程"><a class="header" href="#recover-恢復流程">recover 恢復流程</a></h3>
<p>如果發生了 <code>panic</code>，而你必須做一些處理，可以使用 <code>recover</code>，這個函式必須在被 <code>defer</code> 的函式中執行才有效果，若在被 <code>defer</code> 的函式外執行，<code>recover</code> 一定是傳回 <code>nil</code>。</p>
<p>如果有設置 <code>defer</code> 函式，在發生了 <code>panic</code> 的情況下，被 <code>defer</code> 的函式一定會被執行，若當中執行了 <code>recover</code>，那麼 <code>panic</code> 就會被捕捉並作為 <code>recover</code> 的傳回值，那麼 <code>panic</code> 就不會一路往回傳播，除非你又呼叫了 <code>panic</code>。</p>
<p>因此，雖然 Go 語言中沒有例外處理機制，也可使用 <code>defer</code>、<code>panic</code> 與 <code>recover</code> 來進行類似的錯誤處理。例如，將上頭的範例，再修改為：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func check(err error) {
    if err != nil {
        panic(err)
    }
}

func main() {
    f, err := os.Open(&quot;/tmp/dat&quot;)
    check(err)

    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err) // 這已經是頂層的 UI 介面了，想以自己的方式呈現錯誤
        }

        if f != nil {
            if err := f.Close(); err != nil {
                panic(err) // 示範再拋出 panic
            }
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    check(err)

    fmt.Printf(&quot;%d bytes: %s\n&quot;, n1, string(b1))
}
</code></pre>
<p>在這個例子中，假設已經是最頂層的 UI 介面了，因此使用 <code>recover</code> 嘗試捕捉 <code>panic</code>，並以自己的方式呈現錯誤，附帶一題的是，關閉檔案也有可能發生錯誤，程式中也檢查了 <code>f.Close()</code>，視需求而定，你可以像這邊重新拋出 <code>panic</code>，或者也可以單純地設計一個 UI 介面來呈現錯誤。</p>
<p>什麼時候該用 <code>error</code>？什麼時候該用 <code>panic</code>？在 Go 的慣例中，鼓勵你使用 <code>error</code>，明確地進行錯誤檢查，然而，就如方才所言，巢狀且深層的呼叫時，使用 <code>panic</code> 會比較便於傳播錯誤，就 Go 的慣例來說，是以套件為界限，於套件之中，必要時可以使用 <code>panic</code>，而套件公開的函式，建議以 <code>error</code> 來回報錯誤，若套件公開的函式可能會收到 <code>panic</code>，建議使用 <code>recover</code> 捕捉，並轉換為 <code>error</code>。</p>
<h2 id="結構與方法"><a class="header" href="#結構與方法">結構與方法</a></h2>
<h1 id="建立方法"><a class="header" href="#建立方法">建立方法</a></h1>
<p>假設可能原本有如下的程式內容，負責銀行帳戶的建立、存款與提款：</p>
<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

type Account struct {
    id      string
    name    string
    balance float64
}

func Deposit(account *Account, amount float64) {
    if amount &lt;= 0 {
        panic(&quot;必須存入正數&quot;)
    }
    account.balance += amount
}

func Withdraw(account *Account, amount float64) error {
    if amount &gt; account.balance {
        return errors.New(&quot;餘額不足&quot;)
    }
    account.balance -= amount
    return nil
}

func String(account *Account) string {
    return fmt.Sprintf(&quot;Account{%s %s %.2f}&quot;,
        account.id, account.name, account.balance)
}

func main() {
    account := &amp;Account{&quot;1234-5678&quot;, &quot;Justin Lin&quot;, 1000}
    Deposit(account, 500)
    Withdraw(account, 200)
    fmt.Println(String(account)) // Account{1234-5678 Justin Lin 1300.00}
}
</code></pre>
<p>實際上，<code>Desposit</code>、<code>Withdraw</code>、<code>String</code> 的函式操作，都是與傳入的 <code>Account</code> 實例有關，何不將它們組織在一起呢？這樣比較容易使用些，在 Go 語言中，你可以重新修改函式如下：</p>
<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic(&quot;必須存入正數&quot;)
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New(&quot;餘額不足&quot;)
    }
    ac.balance -= amount
    return nil
}

func (ac *Account) String() string {
    return fmt.Sprintf(&quot;Account{%s %s %.2f}&quot;,
        ac.id, ac.name, ac.balance)
}

func main() {
    account := &amp;Account{&quot;1234-5678&quot;, &quot;Justin Lin&quot;, 1000}
    account.Deposit(500)
    account.Withdraw(200)
    fmt.Println(account.String()) // Account{1234-5678 Justin Lin 1300.00}
}
</code></pre>
<p>簡單來說，只是將函式的第一個參數，移至方法名稱之前成為函式呼叫的接收者（Receiver），這麼一來，就可以使用 <code>account.Deposit(500)</code>、<code>account.Withdraw(200)</code>、<code>account.String()</code> 這樣的方式來呼叫函式，就像是物件導向程式語言中的方法（Method）。</p>
<p>注意到，在這邊使用的是 <code>(ac *Account)</code>，也就是指標，如果你是如下使用 <code>(ac Account)</code>：</p>
<pre><code class="language-go">func (ac Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic(&quot;必須存入正數&quot;)
    }
    ac.balance += amount
}
</code></pre>
<p><strong>那麼執行像是 <code>account.Deposit(500)</code>，就像是以 <code>Deposit(*account, 500)</code> 呼叫以下函式：</strong></p>
<pre><code class="language-go">func Deposit(account Account, amount float64) {
    if amount &lt;= 0 {
        panic(&quot;必須存入正數&quot;)
    }
    account.balance += amount
}
</code></pre>
<p>也就是，相當於將 <code>Account</code> 實例以傳值方式複製給 <code>Deposit</code> 函式的參數。</p>
<p>某些程度上，可以將接收者想成是其他語言中的 <code>this</code> 或 <code>self</code>，<a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-names">Go 建議為接收者適當命名</a>，而不是用 <code>this</code>、<code>self</code> 之類的名稱。接收者並沒有文件上記載的作用，命名時不用其他參數具有一定的描述性，只要能表達程式意圖就可以了，Go 建議是個一或兩個字母的名稱（某些程度上，也可以用來與其他參數區別）。</p>
<h2 id="channel-3"><a class="header" href="#channel-3">Channel</a></h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	var test = make(chan int)
	go func() { test &lt;- 123 }() // 如果傳遞值到 channel 時不在 go func 內程式會卡住
	msg := &lt;-test               // channel 是一個地址，要賦予給一個變數後才能讀出
	fmt.Println(test)
	fmt.Println(msg)
}
</code></pre>
<h2 id="go-gorilla的ping-pong"><a class="header" href="#go-gorilla的ping-pong">go-gorilla的ping pong</a></h2>
<p>業務需求，ping每隔60秒執行一次，ping兩次後，沒有得到pong的消息，自動切斷client。</p>
<pre><code class="language-go">pongTime=180 * time.Second
pingTime=60 * time.Second

readPump()
c.conn.SetReadDeadline(time.Now().Add(pongTime))
	c.conn.SetPongHandler(func(string) error {
		c.conn.SetReadDeadline(time.Now().Add(pongTime))
		return nil
	})

readPump()
ticker := time.NewTicker(pingTime)
c.conn.WriteMessage(websocket.PingMessage, []byte{})
</code></pre>
<p>關於ping/pong，一般瀏覽器接收到ping之後會自動返回pong.
但是用nodejs,go等編寫的客戶端，可能會需要明文編寫 pong返回信息，
這個需要根據自己的環境是否支持自動返信。
因為我用nodejs做的客戶端接收到ping以後沒有明文返回pong消息，但是在服務器端可以自動接收到pong的消息。</p>
<h2 id="new-跟-make-使用時機"><a class="header" href="#new-跟-make-使用時機">new 跟 make 使用時機</a></h2>
<p>https://blog.wu-boy.com/2021/06/what-is-different-between-new-and-make-in-golang/</p>
<p>大家接觸 Go 語言肯定對 <code>new</code> 跟 <code>make</code> 不陌生，但是什麼時候要使用 <code>new</code> 什麼時候用 <code>make</code>，也許是很多剛入門的開發者比較不懂，本篇就簡單筆記 <code>new</code> 跟 <code>make</code> 的差異及使用時機。</p>
<h3 id="使用-new-關鍵字"><a class="header" href="#使用-new-關鍵字">使用 new 關鍵字</a></h3>
<p>Go 提供兩種方式來分配記憶體，一個是 <code>new</code> 另一個是 <code>make</code>，這兩個關鍵字做的事情不同，應用的類型也不同，可能會造成剛入門的朋友一些混淆，但是這兩個關鍵字使用的規則卻很簡單，先來看看如何使用 <code>new</code> 關鍵字。<code>new(T)</code> 宣告會直接拿到儲存位置，並且配置 Zero Value (初始化)，也就是數字型態為 <code>0</code>，字串型態就是 <code>&quot;&quot;</code>。底下是<a href="https://play.golang.org/p/4e933UXThtK">範例程式</a></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
  foo := new(int)
  fmt.Println(foo)
  fmt.Println(*foo)
  fmt.Printf(&quot;%#v&quot;, foo)
}
</code></pre>
<p>執行後可以看到底下結果</p>
<pre><code class="language-go">$ go run main.go 
0xc00001a110
0
(*int)(0xc00001a110)
</code></pre>
<p>上面的做法比較少人用，比較多人用在 <code>struct</code> 上面，由於 <code>new</code> 的特性，直接可以用在 <code>struct</code> 做初始化，底下是<a href="https://play.golang.org/p/xM1k5zi6OJ1">範例程式</a></p>
<pre><code class="language-go">package main

import (
  &quot;bytes&quot;
  &quot;fmt&quot;
  &quot;sync&quot;
)

type SyncedBuffer struct {
  lock   sync.Mutex
  buffer bytes.Buffer
  foo    int
  bar    string
}

func main() {
  p := new(SyncedBuffer)
  fmt.Println(&quot;foo:&quot;, p.foo)
  fmt.Println(&quot;bar:&quot;, p.bar)
  fmt.Printf(&quot;%#v\n&quot;, p)
}
</code></pre>
<p>上面可以看到透過 <code>new</code> 快速的達到初始化，但是有個不方便的地方就是，如果開發者要塞入特定的初始化值，透過 <code>new</code> 是沒辦法做到的，所以大多數的寫法會改成如下，<a href="https://play.golang.org/p/tLyY-TKsloc">範例連結</a></p>
<pre><code class="language-go">package main

import (
  &quot;bytes&quot;
  &quot;fmt&quot;
  &quot;sync&quot;
)

type SyncedBuffer struct {
  lock   sync.Mutex
  buffer bytes.Buffer
  foo    int
  bar    string
}

func main() {
  p := &amp;SyncedBuffer{
    foo: 100,
    bar: &quot;foobar&quot;,
  }
  fmt.Println(&quot;foo:&quot;, p.foo)
  fmt.Println(&quot;bar:&quot;, p.bar)
  fmt.Printf(&quot;%#v\n&quot;, p)
}
</code></pre>
<p>或者是大部分會寫一個新的 Func 做初始化設定，<a href="https://play.golang.org/p/hgEWKNdiwqC">範例程式</a>如下</p>
<pre><code class="language-go">package main

import (
  &quot;bytes&quot;
  &quot;fmt&quot;
  &quot;sync&quot;
)

type SyncedBuffer struct {
  lock   sync.Mutex
  buffer bytes.Buffer
  foo    int
  bar    string
}

func NewSynced(foo int, bar string) *SyncedBuffer {
  return &amp;SyncedBuffer{
    foo: foo,
    bar: bar,
  }
}

func main() {
  p := NewSynced(100, &quot;foobar&quot;)
  fmt.Println(&quot;foo:&quot;, p.foo)
  fmt.Println(&quot;bar:&quot;, p.bar)
  fmt.Printf(&quot;%#v\n&quot;, p)
}
</code></pre>
<p>但是 <code>new</code> 如果使用在 <code>slice</code>, <code>map</code> 及 <code>channel</code> 身上的話，其初始的 Value 會是 <code>nil</code>，請看底下<a href="https://play.golang.org/p/EAEIPcKKWjJ">範例</a>：</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
)

func main() {
  p := new(map[string]string)
  test := *p
  test[&quot;foo&quot;] = &quot;bar&quot;
  fmt.Println(test)
}
</code></pre>
<p>底下結果看到 panic</p>
<pre><code class="language-go">$ go run main.go 
panic: assignment to entry in nil map

goroutine 1 [running]:
main.main()
        /app/main.go:10 +0x4f
exit status 2
</code></pre>
<p>初始化 <code>map</code> 拿到的會是 <code>nil</code>，故通常在宣告 <code>slice</code>, <code>map</code> 及 <code>channel</code> 則會使用 Go 提供的另一個宣告方式 <code>make</code>。</p>
<h3 id="使用-make-關鍵字"><a class="header" href="#使用-make-關鍵字">使用 make 關鍵字</a></h3>
<p><code>make</code> 與 <code>new</code> 不同的地方在於，new 回傳指標，而 <code>make</code> 不是，<code>make</code> 通常只用於在宣告三個地方，分別是 <code>slice</code>, <code>map</code> 及 <code>channel</code>，如果真的想要拿到指標，建議還是用 <code>new</code> 方式。底下拿 <a href="https://play.golang.org/p/_ITcvotyjn1">map 當作範例</a></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
  var p *map[string]string
  // new
  p = new(map[string]string)
  *p = map[string]string{
    &quot;bar&quot;: &quot;foo&quot;,
  }
  people := *p
  people[&quot;foo&quot;] = &quot;bar&quot;

  fmt.Println(people)
  fmt.Println(p)

  // make
  foobar := make(map[string]string)
  foobar[&quot;foo&quot;] = &quot;bar&quot;
  foobar[&quot;bar&quot;] = &quot;foo&quot;
  fmt.Println(foobar)
}
</code></pre>
<p>上面例子可以看到 p 宣告為 map 指標，new 初始化 map 後則需要獨立寫成 <code>map[string]string{}</code>，才可以正常運作，如果是透過 <code>make</code> 方式就可以快速宣告完成。通常是這樣，我自己在開發，幾乎很少用到 <code>new</code>，反到是在宣告 <code>slice</code>, <code>map</code> 及 <code>channel</code> 時一定會使用到 <code>make</code>。記住，用 <code>make</code> 回傳的不會是指標，真的要拿到指標，請使用 <code>new</code> 的方式，但是程式碼就會變得比較複雜些。</p>
<h3 id="心得"><a class="header" href="#心得">心得</a></h3>
<p>總結底下 <code>make</code> 跟 <code>new</code> 的區別</p>
<ul>
<li><code>make</code> 能夠分配並且初始化所需要的記憶體空間跟結構，而 <code>new</code> 只能回傳指標位置</li>
<li><code>make</code> 只能用在三種類型 <code>slice</code>, <code>map</code> 及 <code>channel</code></li>
<li><code>make</code> 可以初始化上述三種格式的長度跟容量以便提供效率跟減少開銷</li>
</ul>
<h2 id="內嵌"><a class="header" href="#內嵌">內嵌</a></h2>
<p>在物件導向程式中，通常會用繼承來共享上層元件的程式碼。然而，go語言沒有繼承的特性，但我們能用組合的方式來共享程式碼。不僅如此，go語言還提供一種優於組合的語法特性，稱作內嵌。</p>
<h3 id="組合composition"><a class="header" href="#組合composition">組合(composition)</a></h3>
<p>先來談談我所知道的組合，大部分的文章會講到組合是聚合(aggregation)的一種，而它們都是源自於UML的產物，實際上UML定義的定義很模糊也很難理解。因此，我要講的是它們最基本的一面，也就是 <code>Is-A</code> 和 <code>Has-A</code> 關係:</p>
<ul>
<li>Is-A: 繼承關係，表示一個物件也是另一個物件。</li>
<li>Has-A: 組合關係，表示一個物件擁有另一個物件。</li>
</ul>
<p>很多文章和書都建議我們要多用<strong>組合少用繼承</strong>，這是因為繼承會對物件造成巨大的依賴關係。我們用一個範例來說明組合:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

// 定義一個英雄結構，包含了正常人結構
type Hero struct {
	Person   *Person
	HeroName string
	HerkRank int
}

// 定義一個正常人結構
type Person struct {
	Name string
}

func main() {
	var tony = &amp;Hero{&amp;Person{&quot;Tony Stark&quot;}, &quot;Iron Man&quot;, 1}
	fmt.Printf(&quot;Hero=%+v\n&quot;, *tony)
	fmt.Printf(&quot;Person=%+v\n&quot;, *(tony.Person))
}
</code></pre>
<p>執行結果:</p>
<pre><code class="language-bash">Hero={Person:0xc0000841e0 HeroName:Iron Man HerkRank:1}
Person={Name:Tony Stark}
</code></pre>
<p>上面範例中，我們看到了所謂的組合就是結構再包結構的概念，透過這樣的方式共享結構資料或方法。</p>
<h3 id="內嵌embedding"><a class="header" href="#內嵌embedding">內嵌(Embedding)</a></h3>
<p>再來談談go語言的內嵌特性，這個特性並沒有寫在<strong>A Tour of Go</strong>，而是在<strong>Effective Go</strong>裡頭。</p>
<p>Go語言的內嵌其實就是組合的概念，只是它更加簡潔及強大。內嵌允許我們在結構內組合其他結構時，不需要定義欄位名稱，並且能直接透過該結構叫用欄位或方法。我們將上面的範例改成使用內嵌，如下:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

// 定義一個英雄結構
type Hero struct {
	*Person  // 不需要欄位名稱
	HeroName string
	HerkRank int
}

// 定義一個正常人結構
type Person struct {
	Name string
}

func main() {
	var tony = &amp;Hero{
		&amp;Person{&quot;Tony Stark&quot;},
		&quot;Iron Man&quot;,
		1}

	fmt.Printf(&quot;%s\n&quot;, tony.Name) // 直接叫用內部結構資料
	// 等於 fmt.Printf(&quot;%s\n&quot;, tony.Person.Name)
}
</code></pre>
<p>實際上，內嵌的結構欄位還是會有名稱，就是和結構本身的名稱同名。</p>
<p>另外，上面範例是用匿名初始化，也可以使用具名初始化，差別在於初始化參數的數量和順序是可以被調整的:</p>
<pre><code class="language-go">var tony = &amp;Hero{
		Person:   &amp;Person{&quot;Tony Stark&quot;},
		HeroName: &quot;Iron Man&quot;,
		HeroRank: 1}
</code></pre>
<h3 id="內嵌與方法"><a class="header" href="#內嵌與方法">內嵌與方法</a></h3>
<p>上面看到的範例都是內嵌結構資料，現在我們來試試看內嵌結構方法，修改同一個範例如下:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

// 定義一個英雄結構
type Hero struct {
	*Person
	HeroName string
	HeroRank int
}

// 英雄都會飛
func (*Hero) Fly() {
	fmt.Println(&quot;I can fly.&quot;)
}

// 定義一個正常人結構
type Person struct {
	Name string
}

// 正常人會走路
func (p *Person) Walk() {
	fmt.Println(&quot;I can walk.&quot;)
	fmt.Println(p.Name)
}

func main() {
	var tony = &amp;Hero{
		Person:   &amp;Person{&quot;Tony Stark&quot;},
		HeroName: &quot;Iron Man&quot;,
		HeroRank: 1}

	tony.Walk() // 等於 tony.Person.Walk()
	tony.Fly()
}
</code></pre>
<h3 id="內嵌結構欄位同名"><a class="header" href="#內嵌結構欄位同名">內嵌結構欄位同名</a></h3>
<p>當有多個內嵌結構時，就有可能發生欄位同名的問題。我們稍微修改一下範例，超級英雄也會想養一隻寵物，這很合理的。因此，我們就加入一個寵物結構:</p>
<pre><code class="language-go">// 定義一個英雄結構
type Hero struct {
	*Person
	*Pet
	HeroName string
	HeroRank int
}

// 定義一個正常人結構
type Person struct {
	Name string
}

// 定義一個寵物結構
type Pet struct {
	Name string
}

func main() {
	var tony = &amp;Hero{
		Person:   &amp;Person{&quot;Tony Stark&quot;},
		Pet:   &amp;Pet{&quot;Pepper&quot;},
		HeroName: &quot;Iron Man&quot;,
		HeroRank: 1}

	fmt.Printf(&quot;%s\n&quot;, tony.Name)
}
</code></pre>
<p>由於 Person 和 Parner 都有 Name 這個欄位，直接叫用 tony.Name 就會產生衝突，編譯器會顯示錯誤訊息:</p>
<pre><code>./main.go:40:25: ambiguous selector tony.Name
</code></pre>
<h3 id="內嵌其他型別"><a class="header" href="#內嵌其他型別">內嵌其他型別</a></h3>
<p>事實上，可以被內嵌的型別不只有結構，也可以是基本型別，範例如下:</p>
<pre><code class="language-go">type Data struct {
	int
	string
	float32
	bool
}

func main() {
	var data = &amp;Data{1, &quot;Iron Man&quot;, 1.2, true}
	fmt.Println(*data)
	fmt.Printf(&quot;%+v \n&quot;, *data)
}
</code></pre>
<h2 id="interface的使用要滿足2個條件才有意義"><a class="header" href="#interface的使用要滿足2個條件才有意義">interface的使用要滿足2個條件才有意義：</a></h2>
<ol>
<li>實現了interface的幾個struct是相似關系（比如docker和kvm都是虛擬機）、平級的，並且輸入輸出參數完全一致。（這點是interface的本質，能實現interface的肯定是滿足這個條件）</li>
<li>在業務邏輯上，調用實現interface的struct是不確定的，是通過某種方式傳遞進來，而不是順序的業務邏輯，比如structA、structB、structC如果是有順序的則是錯誤的，下面這樣是錯誤的：</li>
</ol>
<pre><code class="language-go">func main() {
    var i interfaceX
    i = &amp;structA{...}
    i.Add()
    i = &amp;structB{...}
    i.Add()
    i = &amp;structC{...}
    i.Add()
}
</code></pre>
<p>這樣邏輯是正確的：</p>
<pre><code class="language-go">var i interfaceX
switch opt {
case &quot;A&quot;:
    i = &amp;structA{}
case &quot;B&quot;:
    i = &amp;structB{}
case &quot;C&quot;:
    i = &amp;structC{}
}
i.Add()
i.Del()
</code></pre>
<p>就是說調用者對於實現interface的struct是根據某個參數（通過API傳遞過來，或者配置文件傳遞過來，或者etcd傳遞過來）來選擇某個struct，這種邏輯才適用interface。而如果程序邏輯是被調用者依次執行，則不適用interface。</p>
<p>總結適用interface的調用者業務邏輯（偽代碼）：</p>
<pre><code class="language-go">type I interface {
    ...
}

var i I
switch opt {    //opt通過某種方式傳遞進來，而不是寫死
case &quot;A&quot;:
    i = &amp;structA{...}
case &quot;B&quot;:
    i = &amp;structB{...}
case &quot;C&quot;:
    i = &amp;structC{...}
default:
    errors.New(&quot;not support&quot;)
</code></pre>
<p>interface使用起來有無數種變形方式，但無論是那種，都要符合上面說的平行選一的業務邏輯。</p>
<h2 id="go-interface使用場景"><a class="header" href="#go-interface使用場景"><strong>go interface使用場景</strong></a></h2>
<p>什麼是go 接口呢？學習過C++，一定知道C++ 的多態實現，而Golang 中 多態特性主要是通過接口來體現的。接口是由兩部分組成：一個方法集合，以及一個類型。首先我們將關注點集中到方法集合上。</p>
<ul>
<li>interface{} 接口不是任何類型：它是一個 interface{} 類型</li>
</ul>
<p>interface 類型可以定義一組方法，但是這些不需要實現。
interface 不能包含任何變量。
到某個自定義類型(比如結構體 Phone)要使用的時候,在根據具體情況把這些方法寫出來(實現)。</p>
<pre><code class="language-go">type  接口名 interface {
	method1（參數列表） 返回值列表
	method2（參數列表） 返回值列表
	...
}

type animal interface {
    Speak（） string
}
</code></pre>
<p>定義一個animal 接口，供不同類型的animal 調用，不同的animal可以進行再次的實現</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Animal interface {
	Speak() string
}

type Dog struct {
}

func (d Dog) Speak() string {
	return &quot;Dog ：汪汪汪，在看就吃了你&quot;
}

type Cat struct {
}

func (c Cat) Speak() string {
	return &quot;Cat ：喵星人， 不想理你，走開！！！&quot;
}

type Fish struct {
}

func (f Fish) Speak() string {
	return &quot;Fish ：雖在水裡，但選擇逆流而上，絕不隨波逐流&quot;
}

type Bird struct {
}

func (b Bird) Speak() string {
	return &quot;Bird： 當我像鳥飛往你的山， 打破原有的束縛，創造新的機遇&quot;
}

func main() {
	animals := []Animal{Dog{}, Cat{}, Fish{}, Bird{}}
	for _, animal := range animals {
		fmt.Println(animal.Speak())
	}
}
</code></pre>
<h2 id="difference-between-users-and-users-in-golang"><a class="header" href="#difference-between-users-and-users-in-golang">Difference between []*Users and *[]Users in Golang?</a></h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type Users struct {
	ID   int
	Name string
}

var (
	userList []Users
)

func main() {
	//Make the slice of Users
	userList = []Users{Users{ID: 43215, Name: &quot;Billy&quot;}}

	//Then pass the slice as a reference to some function
	myFunc(&amp;userList)

	fmt.Println(userList) // Outputs: [{1337 Bobby}]
}

//Now the function gets a pointer *[]Users that when changed, will affect the global variable &quot;userList&quot;
func myFunc(input *[]Users) {
	*input = []Users{Users{ID: 1337, Name: &quot;Bobby&quot;}}
}

</code></pre>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type Users struct {
	ID   int
	Name string
}

var (
	user1 Users
	user2 Users
)

func main() {
	//Make a couple Users:
	user1 = Users{ID: 43215, Name: &quot;Billy&quot;}
	user2 = Users{ID: 84632, Name: &quot;Bobby&quot;}

	//Then make a list of pointers to those Users:
	var userList []*Users = []*Users{&amp;user1, &amp;user2}

	//Now you can change an individual Users in that list.
	//This changes the variable user2:
	*userList[1] = Users{ID: 1337, Name: &quot;Larry&quot;}

	fmt.Println(user1) // Outputs: {43215 Billy}
	fmt.Println(user2) // Outputs: {1337 Larry}
}
</code></pre>
<h2 id="在-go-看-control-flow-的輔助函式"><a class="header" href="#在-go-看-control-flow-的輔助函式">在 Go 看 control flow 的輔助函式</a></h2>
<p>出處: https://medium.com/@fcamel/%E5%9C%A8-go-%E7%9C%8B-control-flow-%E7%9A%84%E8%BC%94%E5%8A%A9%E5%87%BD%E5%BC%8F-7dfc07e88b86</p>
<p>看 C/C++ code 的時候，我習慣輸出 <code>__FILE__</code>, <code>__LINE__</code>, <code>__FUNCTION__</code> 幫助看 control flow。透過 C 的巨集，很容易寫出高效率的輔助函式。</p>
<p>我在 Go 寫了類似的函式 <a href="https://github.com/fcamel/golang-practice/blob/master/utils/debug.go">Trace()</a>。作法是取 runtime info，效率比 C/C++ 版本差，內容如下:</p>
<pre><code class="language-go">func Trace(format string, a ...interface{}) { 
  function, file, line, _ := runtime.Caller(1) 
  info := fmt.Sprintf(&quot;DEBUG&gt; %s:%d %s:&quot;, path.Base(file), line,
                       runtime.FuncForPC(function).Name()) 
  msg := fmt.Sprintf(format, a...) 
  fmt.Println(info, msg)
}
</code></pre>
<pre><code class="language-go">package main

import (
	&quot;github.com/fcamel/golang-practice/utils&quot;
)

type myType struct {
}

func (t myType) hello() {
	utils.Trace(&quot;&quot;)
}

func foo() {
	utils.Trace(&quot;begin&quot;)
	defer utils.Trace(&quot;end&quot;)
	bar()
}

func bar() {
	utils.Trace(&quot;Hello %d&quot;, 101)
	var t myType
	t.hello()
}

func main() {
	foo()
}

</code></pre>
<p>執行結果:</p>
<pre><code class="language-sh">$ go run cmd/trace/main.go
DEBUG&gt; main.go:15 main.foo: begin
DEBUG&gt; main.go:21 main.bar: Hello 101
DEBUG&gt; main.go:11 main.myType.hello:
DEBUG&gt; main.go:18 main.foo: end
</code></pre>
<p>美中不足的是，從 method 呼叫 Trace() 的時候，無法自動補上 object 的 address。要自己手動寫，像是這樣:</p>
<pre><code class="language-sh">func (t myType) hello() {
  utils.Trace(&quot;%p&quot;, &amp;t)
}
</code></pre>
<p>有多個 objects 呼叫一樣函式的時候，會不太方便。或許多研究一下 <a href="https://golang.org/pkg/runtime/">runtime</a> 的功能，有機會作到？等受不了的時候，再研究看看。</p>
<pre><code class="language-sh">find . -name '*.go' -exec sed -i '/import/a\&quot;github.com/fcamel/golang-practice/utils&quot;' {} \;

find . -name '*.go' -exec gofmt -l -w {} \;

go mod tidy
</code></pre>
<hr />
<h1 id="golang學習筆記"><a class="header" href="#golang學習筆記">Golang學習筆記</a></h1>
<p>出處: https://hackmd.io/Ku4_3XGMSAuRcFGxy8qTlA?both</p>
<h6 id="tags-rd1"><a class="header" href="#tags-rd1">tags: <code>RD1</code></a></h6>
<p>:::spoiler 目錄
[TOC]
:::</p>
<h2 id="golang特點"><a class="header" href="#golang特點">Golang特點</a></h2>
<p>為什麼 Golang 適合做為網頁後端程式的語言呢？</p>
<p>由於 Golang 有以下的優點：</p>
<ul>
<li>Golang 易學易用：Golang 基本上是強化版的 C 語言，都以核心語法短小精要著稱</li>
<li>Golang 是靜態型別語言：很多程式的錯誤在編譯期就會挑出來，相對易於除錯</li>
<li>Golang 編譯速度很快：帶動整個開發的流程更快速</li>
<li>Golang 支援垃圾回收：網頁程式較接近應用程式，而非系統程式，垃圾回收在這個情境下不算缺點；此外，使用垃圾回收可簡化程式碼</li>
<li>Golang 內建共時性的語法：goroutine 比起傳統的執行緒 (thread) 來說輕量得多，在高負載時所需開銷更少</li>
<li>Golang 是跨平臺的：只要程式中不碰到 C 函式庫，在 Windows (或 Mac) 寫好的 Golang 網頁程式，可以不經修改就直接發布在 GNU/Linux 伺服器上</li>
<li>Golang 的專案不需額外的設定檔：在專案中，只要放 Golang 程式碼和一些 assets 即可運作，所需的工具皆內建在 Golang 主程式中，省去學習專案設罝的功夫</li>
<li>Golang 沒有死硬的程式架構：用 Golang 寫網頁程式思維上接近微框架 (micro-framework)，只要少數樣板程式碼就可以寫出網頁程式，也不限定可用的第三方函式庫</li>
</ul>
<p>但 Golang 並非完美無缺，以下是要考量的點：</p>
<ul>
<li>Golang 並非完整的物件導向 (object-oriented) 語言，頂多是基於物件的 (object-based) 語言</li>
<li>Golang 的語言特性相對少：這是 Golang 時常被攻擊的點，這只能靠自己調整寫程式的習慣</li>
<li>在一些情境下，Golang 程式碼相對笨拙冗餘，像是排序 (sorting)</li>
</ul>
<h2 id="開始一個專案"><a class="header" href="#開始一個專案">開始一個專案</a></h2>
<ol>
<li>安裝好 go 以及設定 $GOPATH 環境</li>
<li><a href="https://maiyang.me/post/2018-09-14-tips-vscode/">VSCode設置</a></li>
<li>目錄結構</li>
</ol>
<pre><code>--src 放置專案的原始碼檔案
--pkg 放置編譯後生成的包 / 庫檔案
--bin 放置編譯後生成的可執行檔案
</code></pre>
<ol start="3">
<li>mod</li>
</ol>
<pre><code>go mod init 初始化
go mod tidy 整理模組
</code></pre>
<ol start="4">
<li>測試囉(Gin、Mysql)</li>
</ol>
<pre><code>go get github.com/gin-gonic/gin
go get github.com/go-sql-driver/mysql
</code></pre>
<p>main.go</p>
<pre><code class="language-go">package main

import (
	&quot;github.com/gin-gonic/gin&quot;
)

func main() {
	r := gin.Default()
	r.GET(&quot;/ping&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;pong&quot;,
		})
	})

	r.Run(&quot;:8000&quot;)
}
</code></pre>
<p>mysql.go</p>
<pre><code class="language-go">package main

import (
	&quot;database/sql&quot;
	_ &quot;github.com/go-sql-driver/mysql&quot;  //只引用該套件的init函數
)

func main() {
	db, err := sql.Open(&quot;mysql&quot;, &quot;root:root@tcp(mysql)/test?charset=utf8&quot;)
	defer db.Close()

	//插入資料,使用預處理避免發生injection
	stmt, err := db.Prepare(&quot;INSERT userinfo SET username=?,department=?,created=?&quot;)
	checkErr(err)

	_, err = stmt.Exec(&quot;astaxie&quot;, &quot;研發部門&quot;, &quot;2012-12-09&quot;)
	checkErr(err)
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
</code></pre>
<blockquote>
<p>兩者都為 package main 代表他們本質上是一隻程式 只是分為不同檔案
不同的package之間需分為不同資料夾，並互相引用： &quot;module_name/floder_name&quot; ex.import router(別名) &quot;main/routes&quot;
<a href="https://medium.com/skyler-record/go-%E5%AF%A6%E4%BD%9C-restful-api-2a32210adeaf">Go 實作 Restful API</a></p>
</blockquote>
<h2 id="go的資料型態"><a class="header" href="#go的資料型態">Go的資料型態</a></h2>
<p>Go的資料類別一共分為四大類:</p>
<ol>
<li>基本型別(Basic type): 數字、字串、布林值</li>
<li>聚合型別(Aggregate type): 陣列、結構</li>
<li>參照型別(Reference type): 指標、slice、map、function、channel</li>
<li>介面型別(Interface type)</li>
</ol>
<h3 id="變數宣告-2"><a class="header" href="#變數宣告-2">變數宣告</a></h3>
<pre><code class="language-go">var a          // 不定型別的變數
var a int      // 宣告成 int
var msg string // 宣告成 string
var a int = 10 // 初始化同時宣告
var a = 10     // 會自動幫你判定為整數型別
var a, b int   // a 跟 b 都是 intvar a, b = 0
var a int , b string
var a, b, c int = 1, 2, 3
var a, b, c = 1, 2, 3
var(
    a bool = false // 記得要不同行，不然會錯
    b int
    c = &quot;hello&quot;
)

// 在函數中，「:=」 簡潔賦值語句在明確類型的地方，可以替代 var 定義。
//「:=」 結構不能使用在函數外，函數外的每個語法都必須以關鍵字開始。
// := 只能用在宣告
var msg = &quot;Hello World&quot;

等於

msg := &quot;Hello World&quot; //自動判定型態

a := 0
a, b, c := 0, true, &quot;tacolin&quot; // 這樣就可以不同型別寫在同一行

_, b := 34, 35 // _（下劃線）是個特殊的變數名，任何賦予它的值都會被丟棄。

</code></pre>
<h3 id="布林值"><a class="header" href="#布林值">布林值</a></h3>
<p>在Go中
bool 與 int 不能直接轉換，<code>true</code>,<code>false</code> 不直接等於 1 與 0</p>
<h3 id="整數-1"><a class="header" href="#整數-1">整數</a></h3>
<table><thead><tr><th>型態</th><th>描述</th></tr></thead><tbody>
<tr><td>int8</td><td>8-bit signed integer</td></tr>
<tr><td>int16</td><td>16-bit signed integer</td></tr>
<tr><td>int32</td><td>32-bit signed integer</td></tr>
<tr><td>int64</td><td>64-bit signed integer</td></tr>
<tr><td>uint8</td><td>8-bit unsigned integer</td></tr>
<tr><td>uint16</td><td>16-bit unsigned integer</td></tr>
<tr><td>uint32</td><td>32-bit unsigned integer</td></tr>
<tr><td>uint64</td><td>64-bit unsigned integer</td></tr>
<tr><td>int</td><td>Both in and uint contain same size, either 32 or 64 bit.</td></tr>
<tr><td>uint</td><td>Both in and uint contain same size, either 32 or 64 bit.</td></tr>
<tr><td>rune</td><td>等價 unit32 ，表示一個Unicode字符</td></tr>
<tr><td>byte</td><td>等價 uint8 ，表示一個ASCII字符</td></tr>
<tr><td>uintptr</td><td>It is an unsigned integer type. Its width is not defined, but its can hold all the bits of a pointer value.</td></tr>
</tbody></table>
<h3 id="浮點數-2"><a class="header" href="#浮點數-2">浮點數</a></h3>
<table><thead><tr><th>型態</th><th>描述</th></tr></thead><tbody>
<tr><td>float32</td><td>32-bit IEEE 754 floating-point number</td></tr>
<tr><td>float64</td><td>64-bit IEEE 754 floating-point number</td></tr>
</tbody></table>
<h3 id="複數"><a class="header" href="#複數">複數</a></h3>
<table><thead><tr><th>型態</th><th>描述</th></tr></thead><tbody>
<tr><td>complex64</td><td>Complex numbers which contain float32 as a real and imaginary component.</td></tr>
<tr><td>complex128</td><td>Complex numbers which contain float64 as a real and imaginary component.</td></tr>
</tbody></table>
<h3 id="字串-1"><a class="header" href="#字串-1">字串</a></h3>
<pre><code class="language-go">var mystr01 string = &quot;\\r\\n&quot;
等於
var mystr02 string = `\r\n`

輸出：\r\n
</code></pre>
<p><code>``</code> 表示一個多行的字串</p>
<h3 id="陣列"><a class="header" href="#陣列">陣列</a></h3>
<h4 id="陣列-1"><a class="header" href="#陣列-1">陣列</a></h4>
<pre><code class="language-go">// 第一種方法
var arr = [3]int{1,2,3} //%T = [3]int

// 第二種方法
arr := [3]int{1,2,3}

// 第三種方法
arr := [...]int{1,2,3} // 可以省略長度而採用`...`的方式，Go 會自動根據元素個數來計算長度

//注意類型為字串時
var arr = [3]string{
    &quot;first&quot;,
    &quot;second&quot;,
    &quot;third&quot;, //最後這裡要有逗號
}
</code></pre>
<h4 id="切片-1"><a class="header" href="#切片-1">切片</a></h4>
<p>為一個左閉右開的結構</p>
<pre><code class="language-go">//宣告一個空的切片
var arr []int    //默認值為nil
</code></pre>
<p>運用<code>make( []Type, size, cap )</code>指定類型、長度、容量，
建立一個容量為10，目前長度為3的切片：</p>
<pre><code class="language-go">make([]int, 3, 10)    //make( []Type, size, cap )
</code></pre>
<ul>
<li>輸出</li>
</ul>
<pre><code class="language-go">arr[0:2] 
//--&gt;[1 2] 結尾索引不算在內
</code></pre>
<ul>
<li>append</li>
</ul>
<pre><code class="language-go">myarr := []int{1}
// 追加一個元素
myarr = append(myarr, 2)
// 追加多個元素
myarr = append(myarr, 3, 4)
// 追加一個切片, ... 表示解包，不能省略
myarr = append(myarr, []int{7, 8}...)
// 在開頭插入元素0
myarr = append([]int{0}, myarr[0:]...) //[0:]為開頭的話可省略
// 在中間插入一個切片(兩個元素)
myarr = append(myarr[:5], append([]int{5, 6}, myarr[5:]...)...)

fmt.Println(myarr) //--&gt; [0 1 2 3 4 7 8]
</code></pre>
<ul>
<li>copy</li>
</ul>
<pre><code class="language-go">slice1 := []int{1,2,3}
slice2 := make([]int, 2)
copy(slice2, slice1) 
fmt.Println(slice1, slice2)
// 由於slice2容量只有2所以只有slice1[0:2]被複製過去
// 輸出結果: [1 2 3] [1 2]
</code></pre>
<h3 id="字典"><a class="header" href="#字典">字典</a></h3>
<ul>
<li>宣告</li>
</ul>
<pre><code class="language-go">// 第一種方法
var scores map[string]int = map[string]int{&quot;english&quot;: 80, &quot;chinese&quot;: 85}

// 第二種方法
scores := map[string]int{&quot;english&quot;: 80, &quot;chinese&quot;: 85}

// 第三種方法
scores := make(map[string]int)
scores[&quot;english&quot;] = 80
scores[&quot;chinese&quot;] = 85
</code></pre>
<ul>
<li>新增 / 讀取 / 更新 / 刪除</li>
</ul>
<pre><code class="language-go">scores[&quot;math&quot;] = 95
scores[&quot;math&quot;] = 100 //若已存在，直接更新
delete( scores, &quot;math&quot; )
fmt.Println(scores[&quot;math&quot;]) //不存在則返回value-type的0值
//--&gt;100
</code></pre>
<ul>
<li>判斷是否存在字典裡</li>
</ul>
<pre><code class="language-go">elements := map[string]string{
    &quot;H&quot;: &quot;Hydrogen&quot;,
    &quot;He&quot;: &quot;Helium&quot;,
    &quot;Li&quot;: &quot;Lithium&quot;,
    &quot;Be&quot;: &quot;Beryllium&quot;
}

value, isExist := elements[&quot;H&quot;];
// value = Hydrogen, isExist = true

value, isExist := elements[&quot;A&quot;];
// value = &quot;&quot;, isExist = false
</code></pre>
<ul>
<li>巢狀字典</li>
</ul>
<pre><code class="language-go">elements := map[string]map[string]string{
    &quot;H&quot;: map[string]string{
        &quot;name&quot;:&quot;Hydrogen&quot;,
        &quot;state&quot;:&quot;gas&quot;,
    },
    &quot;He&quot;: map[string]string{
        &quot;name&quot;:&quot;Helium&quot;,
        &quot;state&quot;:&quot;gas&quot;,
    },
    &quot;Li&quot;: map[string]string{
        &quot;name&quot;:&quot;Lithium&quot;,
        &quot;state&quot;:&quot;solid&quot;,
    },
    &quot;Be&quot;: map[string]string{
        &quot;name&quot;:&quot;Beryllium&quot;,
        &quot;state&quot;:&quot;solid&quot;,
    },
    &quot;B&quot;:  map[string]string{
        &quot;name&quot;:&quot;Boron&quot;,
        &quot;state&quot;:&quot;solid&quot;,
    },
    &quot;C&quot;:  map[string]string{
        &quot;name&quot;:&quot;Carbon&quot;,
        &quot;state&quot;:&quot;solid&quot;,
    },
    &quot;N&quot;:  map[string]string{
        &quot;name&quot;:&quot;Nitrogen&quot;,
        &quot;state&quot;:&quot;gas&quot;,
    },
    &quot;O&quot;:  map[string]string{
        &quot;name&quot;:&quot;Oxygen&quot;,
        &quot;state&quot;:&quot;gas&quot;,
    },
    &quot;F&quot;:  map[string]string{
        &quot;name&quot;:&quot;Fluorine&quot;,
        &quot;state&quot;:&quot;gas&quot;,
    },
    &quot;Ne&quot;:  map[string]string{
        &quot;name&quot;:&quot;Neon&quot;,
        &quot;state&quot;:&quot;gas&quot;,
    },
}

if el, ok := elements[&quot;Li&quot;]; ok {
    fmt.Println(el[&quot;name&quot;], el[&quot;state&quot;])
}
</code></pre>
<h3 id="struct-2"><a class="header" href="#struct-2">Struct</a></h3>
<p>自定義型別，struct裡可以放struct型別的物件
<a href="https://ithelp.ithome.com.tw/articles/10188100">參考資料</a></p>
<pre><code class="language-go">type person struct {
    name string
    height int
}
</code></pre>
<h4 id="json--struct"><a class="header" href="#json--struct">json &amp; struct</a></h4>
<ul>
<li>宣告
Struct fields must start with upper case letter (exported) for the JSON package to see their value.</li>
</ul>
<pre><code class="language-go">type Message struct {
	Sender  string `json:&quot;sender&quot;`
	RoomId  string `json:&quot;roomId&quot;`
	Content string `json:&quot;content&quot;`
	Time    string `json:&quot;time&quot;`
}
</code></pre>
<ul>
<li>放入資料產生<code>[]byte</code> 格式的 json 資料</li>
</ul>
<pre><code class="language-go">jsonMessage, _ := json.Marshal(&amp;Message{Sender: c.id, RoomId: c.roomId, Content: string(message), Time: time})
</code></pre>
<ul>
<li>解回struct物件</li>
</ul>
<pre><code class="language-go">var msg Message
json.Unmarshal(message, &amp;msg)
</code></pre>
<h3 id="指標-3"><a class="header" href="#指標-3">指標</a></h3>
<p>跟C語言一樣，Go語言也有指標。</p>
<pre><code class="language-go">func zero( x *int ) {
    *x = 0
}

func main() {
    x := 5
    zero( &amp;x )
    fmt.Println( x )
}
</code></pre>
<h3 id="介面-interface"><a class="header" href="#介面-interface">介面 interface</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;
import &quot;math&quot;

type geometry interface {
    area() float64
    perimeter() float64
}

type square struct {
    width, height float64
}
type circle struct {
    radius float64
}

func (s square) area() float64 {
    return s.width * s.height
}
func (s square) perimeter() float64 {
    return 2*s.width + 2*s.height
}

func (c circle) area() float64 {
    return math.Pi * c.radius * c.radius
}
func (c circle) perimeter() float64 {
    return 2 * math.Pi * c.radius
}

func measure(g geometry) {
    fmt.Println(g)
    fmt.Println(g.area())
    fmt.Println(g.perimeter())
}

func main() {
    s := square{width: 3, height: 4}
    c := circle{radius: 5}

    measure(s)
    measure(c)
}
</code></pre>
<h2 id="控制語句"><a class="header" href="#控制語句">控制語句</a></h2>
<h3 id="迴圈-1"><a class="header" href="#迴圈-1">迴圈</a></h3>
<h4 id="for-1"><a class="header" href="#for-1">for</a></h4>
<p>Go只有一種迴圈關鍵字，就是for</p>
<pre><code class="language-go">func main() {
    sum := 0
    for i := 0; i &lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
</code></pre>
<p>跟 C 或者 Java 中一樣，可以讓前置、後置語句為空。</p>
<pre><code class="language-go">func main() {
    sum := 1
    for ; sum &lt; 1000; {
        sum += sum
    }
    fmt.Println(sum)
}
</code></pre>
<p>基於此可以省略分號：C 的 while 在 Go 中叫做 「for」。</p>
<pre><code class="language-go">func main() {
    sum := 1
    for sum &lt; 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
</code></pre>
<p>如果省略了迴圈條件，迴圈就不會結束，因此可以用更簡潔地形式表達無窮迴圈。</p>
<pre><code class="language-go">func main() {
    for {
        fmt.Println(&quot;Hello World&quot;)
    }
}
</code></pre>
<h4 id="陣列尋訪"><a class="header" href="#陣列尋訪">陣列尋訪</a></h4>
<p>可以這樣尋訪</p>
<pre><code class="language-go">var x [4]float64{ 23, 45, 33, 21 }
var total float64 = 0
for i := 0; i &lt; 4; i++ {
    total += x[i]
}
fmt.Println( total / float64(4))
</code></pre>
<p>使用<code>len</code>獲取陣列元素數量</p>
<pre><code class="language-go">var x [4]float64{ 23, 45, 33, 21 }
var total float64 = 0
for i := 0; i &lt; len(x); i++ {
    total += x[i]
}
fmt.Println( total / float64(len(x)))
</code></pre>
<p>更精簡一點</p>
<pre><code class="language-go">var x [4]float64{ 23, 45, 33, 21 }
var total float64 = 0

for i, value := range x {
    total += value
}
fmt.Println( total / float64(len(x)))
</code></pre>
<p>for迴圈前面的第一個變數意義為陣列索引(index),而後面變數代表該索引值所代表的陣列值。以上寫法會出錯，由於Go不允許沒有使用的變數出現在程式碼中,迴圈的i變數我們使用佔位符(_)替代。</p>
<pre><code class="language-go">func main() {
    var x [4]float64{ 23, 45, 33, 21 }
    var total float64 = 0

    for _, value := range x {
        total += value
    }
    fmt.Println( total / float64(len(x)))
}
</code></pre>
<h3 id="分支-breakcontinutegoto"><a class="header" href="#分支-breakcontinutegoto">分支 break、continute、goto</a></h3>
<h4 id="break"><a class="header" href="#break">break</a></h4>
<p>可以利用break提前退出循環。</p>
<pre><code class="language-go">func main() {
    for i := 0; i &lt; 10; i++ {
        if i &gt; 5 {
            break       
        }
        fmt.Println(i)
    }
}
</code></pre>
<p>如果有多重迴圈，可以指定要跳出哪一個迴圈，但需要指定標籤。</p>
<pre><code class="language-go">func main() {
outer: // 標籤在此
    for j := 0; j &lt; 5; j++ {
        for i := 0; i &lt; 10; i++ {
            if i &gt; 6 {
                break outer 
            }
            fmt.Println(i)
        }
    }
}
</code></pre>
<h4 id="continute"><a class="header" href="#continute">continute</a></h4>
<p>continue忽略之後的程式碼，直接執行下一次迭代。</p>
<pre><code class="language-go">func main() {
    for i := 1; i &lt;= 10; i++ {
        if i &lt; 6 {
            continue
        }
        fmt.Println(i)
    }
}
</code></pre>
<p>同樣的如果有多重迴圈，也可以指定標籤。</p>
<pre><code class="language-go">func main() {
outer: // 標籤在此
    for i := 1; i &lt; 10; i++ {
        for j := 1; j &lt; 10; j++ {
            if i == j {
                continue outer
            }
            fmt.Println( &quot;i: &quot;, i, &quot; j: &quot;, j );
        }
    }
}
</code></pre>
<h4 id="goto"><a class="header" href="#goto">goto</a></h4>
<p>Go 語言跟 C 語言一樣也有「 goto 」，但是不建議使用，會讓程式的結構變得很糟糕。</p>
<pre><code class="language-go">func main() {
    i := 0
HERE:
    fmt.Print(i)
    i++
    if i &lt; 10 {
        goto HERE
    }
}
</code></pre>
<h3 id="deferpanicrecover-1"><a class="header" href="#deferpanicrecover-1">defer、panic、recover</a></h3>
<blockquote>
<p>此範例文章取自<a href="https://openhome.cc/Gossip/Go/DeferPanicRecover.html">openhome.cc</a></p>
</blockquote>
<p>就許多現代語言而言，例外處理機制是基本特性之一，然而，例外處理是好是壞，一直以來存在著各種不同的意見，在 Go 語言中，沒有例外處理機制，取而代之的，是運用 defer、panic、recover 來滿足類似的處理需求。</p>
<h4 id="defer"><a class="header" href="#defer">defer</a></h4>
<p>在 Go 語言中，可以使用 defer 指定某個函式延遲執行，那麼延遲到哪個時機？簡單來說，在函式 return語句之後準備返回呼叫的函式之前，例如：</p>
<ul>
<li>延遲效果</li>
</ul>
<pre><code class="language-go">func myfunc() {
    fmt.Println(&quot;B&quot;)
}

func main() {
    defer myfunc()
    fmt.Println(&quot;A&quot;)
}
</code></pre>
<p>輸出</p>
<pre><code class="language-go">A
B
</code></pre>
<ul>
<li>可在返回之前修改返回值</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func Triple(n int) (r int) {
	defer func() {
		r += n // 修改返回值
	}()

	return n + n // &lt;=&gt; r = n + n; return
}

func main() {
	fmt.Println(Triple(5))
}
</code></pre>
<p>輸出</p>
<pre><code>15
</code></pre>
<ul>
<li>變數的快照</li>
</ul>
<pre><code class="language-go">func main() {
    name := &quot;go&quot;
    defer fmt.Println(name) // 變數name的值被記住了，所以會輸出go

    name = &quot;python&quot;
    fmt.Println(name)      // 輸出: python
}
</code></pre>
<p>輸出</p>
<pre><code>python
go
</code></pre>
<ul>
<li>應用</li>
</ul>
<ol>
<li>反序調用
如果有多個函式被 defer，那麼在函式 return 前，會依 defer 的相反順序執行，也就是 LIFO，例如：</li>
</ol>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func deferredFunc1() {
    fmt.Println(&quot;deferredFunc1&quot;)
}

func deferredFunc2() {
    fmt.Println(&quot;deferredFunc2&quot;)
}

func main() {
    defer deferredFunc1()
    defer deferredFunc2()
    fmt.Println(&quot;Hello, 世界&quot;)
}

// 輸出結果:
Hello, 世界
deferredFunc2
deferredFunc1
</code></pre>
<ol start="2">
<li>defer 與 return</li>
</ol>
<pre><code class="language-go">func f() {
    r := getResource()  //0，獲取資源
    ......
    if ... {
        r.release()  //1，釋放資源
        return
    }
    ......
    if ... {
        r.release()  //2，釋放資源
        return
    }
    ......
    r.release()  //3，釋放資源
    return


}
</code></pre>
<p>使用 defer 後，不論在哪 return 都會執行 defer 後方的函數，如此便不用在每個return前寫上<code>r.release()</code></p>
<pre><code class="language-go">func f() {
    r := getResource()  //0，獲取資源

    defer r.release()  //1，釋放資源
    ......
    if ... {
        ...
        return
    }
    ......
    if ... {
        ...
        return
    }
    ......
    return
}
</code></pre>
<p>以下是清除資源的範例:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    f, err := os.Open(&quot;/tmp/dat&quot;)
    if err != nil {
        fmt.Println(err)
        return;
    }

    defer func() { // 延遲執行，而且函式 return 後一定會執行
        if f != nil {
            f.Close()
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    if err != nil {
        fmt.Printf(&quot;%d bytes: %s\n&quot;, n1, string(b1))
        // 處理讀取的內容....
    }
}

</code></pre>
<h3 id="panic-恐慌中斷-1"><a class="header" href="#panic-恐慌中斷-1">panic 恐慌中斷</a></h3>
<p>如果在函式中執行 panic，那麼函式的流程就會中斷，若 A 函式呼叫了 B 函式，而 B 函式中呼叫了 panic，那麼 B 函式會從呼叫了 panic 的地方中斷，而 A 函式也會從呼叫了 B 函式的地方中斷，若有更深層的呼叫鏈，panic 的效應也會一路往回傳播。</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func check(err error) {
    if err != nil {
        panic(err)
    }
}

func main() {
    f, err := os.Open(&quot;/tmp/dat&quot;)
    check(err)

    defer func() {
        if f != nil {
            f.Close()
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    check(err)

    fmt.Printf(&quot;%d bytes: %s\n&quot;, n1, string(b1))
}
</code></pre>
<p>如果在開啟檔案時，就發生了錯誤，假設這是在一個很深的呼叫層次中發生，若你直接想撰寫程式，將 os.Open 的 error 逐層傳回，那會是一件很麻煩的事，此時直接發出 panic，就可以達到想要的目的。</p>
<h3 id="recover"><a class="header" href="#recover">recover</a></h3>
<p>如果發生了 panic，而你必須做一些處理，可以使用 recover，這個函式必須在被 defer 的函式中執行才有效果，若在被 defer 的函式外執行，recover 一定是傳回 nil。</p>
<p>如果有設置 defer 函式，在發生了 panic 的情況下，被 defer 的函式一定會被執行，若當中執行了 recover，那麼 panic 就會被捕捉並作為 recover 的傳回值，那麼 panic 就不會一路往回傳播，除非你又呼叫了 panic。</p>
<p>因此，雖然 Go 語言中沒有例外處理機制，也可使用 defer、panic 與 recover 來進行類似的錯誤處理。例如，將上頭的範例，再修改為：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func check(err error) {
    if err != nil {
        panic(err)
    }
}

func main() {
    f, err := os.Open(&quot;/tmp/dat&quot;)
    check(err)

    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err) // 這已經是頂層的 UI 介面了，想以自己的方式呈現錯誤
        }

        if f != nil {
            if err := f.Close(); err != nil {
                panic(err) // 示範再拋出 panic
            }
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    check(err)

    fmt.Printf(&quot;%d bytes: %s\n&quot;, n1, string(b1))
}

</code></pre>
<h3 id="條件判斷"><a class="header" href="#條件判斷">條件判斷</a></h3>
<h4 id="ifelseelse-if"><a class="header" href="#ifelseelse-if">if、else、else if</a></h4>
<pre><code class="language-go">if 條件一 {    
  分支一
} else if 條件二 {
  分支二
} else if 條件 ... {
  分支 ...
} else {
  分支 else
}

// { 必須與if..在同一行
</code></pre>
<p><code>&amp;&amp;</code> : 且
<code>||</code> : 或</p>
<p>在 if 裡允許先運行一個表達式，取得變數後再來做判斷：</p>
<pre><code class="language-go">func main() {
    if age := 20;age &gt; 18 {
        fmt.Println(&quot;已成年&quot;)
    }
}
</code></pre>
<h4 id="switch"><a class="header" href="#switch">switch</a></h4>
<p>與一般的switch宣告方法一樣，條件不能重複</p>
<ul>
<li>一個case多個條件</li>
</ul>
<pre><code class="language-go">import &quot;fmt&quot;

func main() {
    month := 2

    switch month {
    case 3, 4, 5:
        fmt.Println(&quot;春天&quot;)
    case 6, 7, 8:
        fmt.Println(&quot;夏天&quot;)
    case 9, 10, 11:
        fmt.Println(&quot;秋天&quot;)
    case 12, 1, 2:
        fmt.Println(&quot;冬天&quot;)
    default:
        fmt.Println(&quot;輸入有誤...&quot;)
    }
}
</code></pre>
<ul>
<li>switch 後可接函數</li>
</ul>
<pre><code class="language-go">import &quot;fmt&quot;

// 判斷一個同學是否有掛科記錄的函數
// 返回值是布爾類型
func getResult(args ...int) bool {
    for _, i := range args {
        if i &lt; 60 {
            return false
        }
    }
    return true
}

func main() {
    chinese := 80
    english := 50
    math := 100

    switch getResult(chinese, english, math) {
    // case 後也必須 是布爾類型
    case true:
        fmt.Println(&quot;該同學所有成績都合格&quot;)
    case false:
        fmt.Println(&quot;該同學有掛科記錄&quot;)
    }
}
</code></pre>
<ul>
<li>switch 後面不接東西時就相當於if-else</li>
<li>使用<code>fallthrough</code> 可以往下穿透一層，執行下一個case語句且<strong>不用判斷條件</strong>，但其必須為該case的最後一個語句，否則會錯誤</li>
</ul>
<h2 id="go-函式"><a class="header" href="#go-函式">Go 函式</a></h2>
<ol>
<li>一般用法</li>
</ol>
<pre><code class="language-go">func add( x int, y int ) int {
	return x + y
}

func main() {
	fmt.Println( add( 42, 13 ) )
}
</code></pre>
<p>當兩個或多個連續的函數命名參數是同一類型，則除了最後一個類型之外，其他都可以省略。
所以如果參數的型態都一樣的話，可以精簡為:</p>
<pre><code class="language-go">func add( x, y int ) int {  
    return x + y  
}  
 
func main() {  
    fmt.Println( add( 42, 13 ) )  
}  
</code></pre>
<ol start="2">
<li>多數值返回</li>
</ol>
<p>函數可以返回任意數量的返回值，這個函數返回了兩個字串。</p>
<pre><code class="language-go">func swap(x, y string) (string, string) {  
    return y, x  
}  
 
func main() {  
    a, b := swap(&quot;hello&quot;, &quot;world&quot;)  
    fmt.Println(a, b)  
}
// 輸出結果 world hello
</code></pre>
<ol start="3">
<li>命名返回值</li>
</ol>
<p>在 Go 中，函數可以返回多個「結果參數」，而不僅僅是一個值。它們可以像變數那樣命名和使用。
如果命名了返回值參數，一個沒有參數的 return 語句，會將當前的值作為返回值返回。以這個程式碼為例，sum int 表示宣告整數 sum ，將參數 17 放入 sum 中，x, y int 宣告整數 x,y 在下面使用，由於 return 沒有設定返回值，這邊程式就將 x,y 都回傳了，所以結果會出現 7 10。</p>
<pre><code class="language-go">func split(sum int) (x, y int) {  
    x = sum * 4 / 9  
    y = sum - x  
    return  
}  
 
func main() {  
    fmt.Println(split(17))  
}
</code></pre>
<h2 id="goroutine"><a class="header" href="#goroutine">Goroutine</a></h2>
<p>要使用Goroutine只要在呼叫的函數前面加一個go關鍵字即可</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;  
 
func f(n int) {  
    for i := 0; i &lt; 10; i++ {  
        fmt.Println(n, &quot;:&quot;, i)  
    }  
}  
 
func main() {  
    go f(0)  
} 
</code></pre>
<p>執行後會發現什麼東西都沒有印出，因為 goroutine 是平行處理的，
所以在還沒開始印 n 之前 main 這個主要的函式已經結束了。
使用內建的 time 函式讓 main 函式等 goroutine 先跑完。</p>
<pre><code class="language-go">package main  
 
import (  
    &quot;fmt&quot;  
    &quot;time&quot;  
)  
 
func f(n int) {  
    for i := 0; i &lt; 10; i++ {  
        fmt.Println(n, &quot;:&quot;, i)  
    }  
}  
 
func main() {  
    go f(0)  
    time.Sleep(time.Second * 1) // 暫停一秒鐘  
}  
</code></pre>
<h3 id="龜兔賽跑的範例"><a class="header" href="#龜兔賽跑的範例">龜兔賽跑的範例</a></h3>
<blockquote>
<p>此龜兔賽跑範例文章引用自<a href="https://openhome.cc/Gossip/Go/Goroutine.html">openhome.cc/Go/Goroutine</a></p>
</blockquote>
<p>先來看個沒有啟用 Goroutine，卻要寫個龜兔賽跑遊戲的例子，你可能是這麼寫的:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func main() {
    flags := [...]bool{true, false}
    totalStep := 10
    tortoiseStep := 0
    hareStep := 0
    fmt.Println(&quot;龜兔賽跑開始...&quot;)
    for tortoiseStep &lt; totalStep &amp;&amp; hareStep &lt; totalStep {
        tortoiseStep++
        fmt.Printf(&quot;烏龜跑了 %d 步...\n&quot;, tortoiseStep)
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println(&quot;兔子睡著了zzzz&quot;)
        } else {
            hareStep += 2
            fmt.Printf(&quot;兔子跑了 %d 步...\n&quot;, hareStep)
        }
    }
}
</code></pre>
<p>由於程式只有一個流程，所以只能將烏龜與兔子的行為混雜在這個流程中撰寫，而且為什麼每次都先遞增烏龜再遞增兔子步數呢？這樣對兔子很不公平啊！如果可以撰寫程式再啟動兩個流程，一個是烏龜流程，一個兔子流程，程式邏輯會比較清楚。</p>
<p>你可以將烏龜的流程與兔子的流程分別寫在一個函式中，並用 go 啟動執行：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
    &quot;time&quot;
)

func random( min, max int ) int {
	rand.Seed( time.Now().Unix() )
	return rand.Intn( max - min ) + min
}

func tortoise( totalStep int ) {
	for step := 1; step &lt;= totalStep; step++ {
		fmt.Printf( &quot;烏龜跑了 %d 步...\n&quot;, step )
	}
}

func hare(totalStep int) {
    flags := [...]bool{true, false}
    step := 0
    for step &lt; totalStep {
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println(&quot;兔子睡著了zzzz&quot;)
        } else {
            step += 2
            fmt.Printf(&quot;兔子跑了 %d 步...\n&quot;, step)
        }
    }
}

func main() {
    totalStep := 10

    go tortoise(totalStep)
    go hare(totalStep)

    time.Sleep(5 * time.Second) // 給予時間等待 Goroutine 完成
}
</code></pre>
<h4 id="使用syncwaitgroup等待烏龜與兔子跑完"><a class="header" href="#使用syncwaitgroup等待烏龜與兔子跑完">使用sync.WaitGroup等待烏龜與兔子跑完</a></h4>
<p>有沒有辦法知道 Goroutine 執行結束呢？實際上沒有任何方法可以得知，除非你主動設計一種機制，可以在 Goroutine 結束時執行通知，使用 Channel 是一種方式，這在之後的文件再說明，這邊先說明另一種方式，也就是使用 sync.WaitGroup。</p>
<p>sync.WaitGroup 可以用來等待一組 Goroutine 的完成，主流程中建立 sync.WaitGroup，並透過 Add 告知要等待的 Goroutine 數量，並使用 Wait 等待 Goroutine 結束，而每個 Goroutine 結束前，必須執行 sync.WaitGroup 的 Done 方法。</p>
<p>因此，我們可以使用 sync.WaitGroup 來改寫以上的範例：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
	&quot;sync&quot;
)

func random( min, max int ) int {
	rand.Seed( time.Now().Unix() )
	return rand.Intn( max - min ) + min
}

func tortoise( totalStep int, wg *sync.WaitGroup ) {
	defer wg.Done()

	for step := 1; step &lt;= totalStep; step++ {
		fmt.Printf( &quot;烏龜跑了 %d 步...\n&quot;, step )
	}
}

func hare(totalStep int, wg *sync.WaitGroup ) {
	defer wg.Done()

    flags := [...]bool{true, false}
    step := 0
    for step &lt; totalStep {
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println(&quot;兔子睡著了zzzz&quot;)
        } else {
            step += 2
            fmt.Printf(&quot;兔子跑了 %d 步...\n&quot;, step)
        }
    }
}

func main() {
	wg := new( sync.WaitGroup )
	wg.Add( 2 )

    totalStep := 10

    go tortoise( totalStep, wg )
    go hare( totalStep, wg )

    time.Sleep(5 * time.Second) // 給予時間等待 Goroutine 完成
}
</code></pre>
<h2 id="channel-4"><a class="header" href="#channel-4">Channel</a></h2>
<p>通過 Channel 可以讓 goroutine 之間通信</p>
<pre><code class="language-go">ch_name := make(chan &lt;TYPE&gt;{,NUM})    //類型與大小
</code></pre>
<h3 id="資料流向"><a class="header" href="#資料流向">資料流向</a></h3>
<ul>
<li>向Channel傳入：<code>Ch &lt;- DATA</code></li>
<li>從Channel讀取：<code>DATA := &lt;- Ch</code></li>
</ul>
<pre><code class="language-go">func main() {  
 
    messages := make(chan string)  
 
    go func() { messages &lt;- &quot;ping&quot; }()  
 
    msg := &lt;- messages  
    fmt.Println( msg )  
}  
</code></pre>
<ul>
<li>建立一個 channel(message) 用以傳輸字串</li>
<li>用 go 來 call goroutine 執行函式，傳 &quot;ping&quot; 到 messages 這個 channel 裡面</li>
<li>接著以 msg 負責接收 messages 的傳輸資料後印出</li>
</ul>
<p>透過這個方法就可以簡單的讓 Goroutine 可以溝通</p>
<h3 id="select"><a class="header" href="#select">select</a></h3>
<p>有一個類似 Switch 的流程控制「Select」，它只能應用於 Channel</p>
<pre><code class="language-go">package main

import &quot;time&quot;
import &quot;fmt&quot;

func main() {

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(time.Second * 1)
        c1 &lt;- &quot;one&quot;
    }()
    go func() {
        time.Sleep(time.Second * 2)
        c2 &lt;- &quot;two&quot;
    }()

    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println(&quot;received&quot;, msg1)
        case msg2 := &lt;-c2:
            fmt.Println(&quot;received&quot;, msg2)
        }
    }
}
</code></pre>
<h2 id="go-coding-style"><a class="header" href="#go-coding-style">Go Coding Style</a></h2>
<ol>
<li>
<p>強制編碼風格
Go語言為了讓團隊開發能夠更加的簡單，他統一了程式碼的風格，如果沒有遵照他的規範寫的話，你再如何編譯都不會成功。
以下為錯誤的程式碼風格</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main()
{
    i:= 1
    fmt.Println(&quot;Hello World&quot;, i)
}
</code></pre>
<p>如果你左右括弧的寫法是像上面那樣，你將會看到下列的錯誤訊息</p>
<pre><code>syntax error: unexpected semicolon or newline before {non-declaration 
statement outside function body syntax error: unexpected }
</code></pre>
<p>以下為正確的寫法</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
    i:= 1
    fmt.Println(&quot;Hello World&quot;, i)
}
</code></pre>
<p>為了保持程式碼的乾淨，你宣告了一個變數，但是卻沒有使用，Go 語言連編譯都不會讓你編譯。舉例來說，變數 i 並沒有被使用。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    i := 1
    fmt.Println(&quot;Hello World i&quot;)
}
</code></pre>
<p>你會出現下列錯誤訊息</p>
<pre><code># command-line-arguments
./test.go:6:2: i declared but not used
</code></pre>
</li>
<li>
<p>非強制性編譯風格建議
以下程式碼可以正常的編譯，但是很醜不好閱讀。</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main() { i:= 1
fmt.Println(&quot;Hello World&quot;, i)}
</code></pre>
<p>我們可以利用<code>go fmt</code>指令幫忙整理程式碼編譯格式。
用法
<code>go fmt &lt;filename&gt;.go # 整理某個檔案</code>
<code>go fmt *.go # 整理目錄下所有go檔案</code>
<code>go fmt # 同上</code></p>
<p>如果程式碼不需要調整他不會出現任何訊息，成功會出現你使用的程式檔名。
格式化工具幫你做到了下列事情：</p>
<ul>
<li>調整每一條語句的位置</li>
<li>重新擺放括弧的位置</li>
<li>以 tab 幫你縮排</li>
<li>添加空格</li>
</ul>
</li>
</ol>
<h2 id="套件"><a class="header" href="#套件">套件</a></h2>
<h4 id="go套件的一些規則"><a class="header" href="#go套件的一些規則">Go套件的一些規則</a></h4>
<p>Go之所以會那麼簡潔，是因為它有一些預設的行為：</p>
<ul>
<li>大寫字母開頭的變數是可匯出的，也就是其它套件可以讀取的，是公有變數；小寫字母開頭的就是不可匯出的，是私有變數。</li>
<li>大寫字母開頭的函式也是一樣，相當於 class 中的帶 public 關鍵詞的公有函式；小寫字母開頭的就是有 private 關鍵詞的私有函式。</li>
</ul>
<h2 id="grpc"><a class="header" href="#grpc">gRPC</a></h2>
<p><img src="https://www.grpc.io/img/landing-2.svg" alt="" /></p>
<h3 id="go-grpc"><a class="header" href="#go-grpc">GO gRPC</a></h3>
<p><a href="https://www.grpc.io/docs/languages/go/quickstart/">官方 - Quick start</a>
<a href="https://myapollo.com.tw/zh-tw/golang-grpc-tutorial-part-1/">範例 - Hello ,gRPC</a>
<a href="https://medium.com/pantomath/how-we-use-grpc-to-build-a-client-server-system-in-go-dd20045fa1c2">How we use gRPC to build a client/server system in Go</a>
<a href="https://yami.io/protobuf/">比起 JSON 更方便、更快速、更簡短的 Protobuf 格式</a>
<a href="https://yami.io/grpc/">API 文件就是你的伺服器，REST 的另一個選擇：gRPC</a></p>
<h3 id="grpc-and-http-apis"><a class="header" href="#grpc-and-http-apis">gRPC and HTTP APIs</a></h3>
<p><a href="https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-3.1">比較 gRPC 服務與 HTTP API</a>
<a href="https://segmentfault.com/a/1190000016601836">同時提供HTTP接口</a>
<a href="https://ithelp.ithome.com.tw/articles/10244296">gRPC-Web：envoy</a>
<a href="https://ithelp.ithome.com.tw/articles/10243864">如果兩邊都想要 - gRPC Gateway</a></p>
<h2 id="參考資料-3"><a class="header" href="#參考資料-3">參考資料</a></h2>
<p>[1] <a href="https://michaelchen.tech/blog/golang-as-backend-language-for-beginners/">Go (Golang) 適合初學者做為網頁後端程式嗎？</a>
[2] <a href="https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/golang-goroot-gopath-go-modules-%E4%B8%89%E8%80%85%E7%9A%84%E9%97%9C%E4%BF%82%E4%BB%8B%E7%B4%B9-d17481d7a655">Golang — GOROOT、GOPATH、Go-Modules-三者的關係介紹</a>
[3] <a href="https://www.geeksforgeeks.org/data-types-in-go/">GeeksforGeeks: Data Types in Go</a>
[4] <a href="https://ithelp.ithome.com.tw/users/20079210/ironman/721">初學Golang30天</a>
[5] <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/">Go 語言設計與實現 - make 和 new</a>
[6] <a href="https://openhome.cc/Gossip/Go/">Opencc Go</a>
[7] <a href="https://willh.gitbook.io/build-web-application-with-golang-zhtw/">使用 Golang 打造 Web 應用程式</a>
[8] <a href="https://zhuanlan.zhihu.com/p/34211611">五分鐘理解golang的init函數</a>
[9] <a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html">Go標準庫：Go template用法詳解</a>
[10] <a href="https://brokencode.io/how-to-use-local-go-modules-with-golang-with-examples/">How to use local go modules with golang with examples</a>
[11] <a href="https://zhuanlan.zhihu.com/p/66659719">Go併發編程模型：主動停止goroutine</a>
[12] <a href="https://www.tizi365.com/archives/244.html">Go gin框架入門教程</a>
[13] <a href="https://www.jianshu.com/p/9ba805f07a95">Golang 套件初始化流程</a>
[14] <a href="https://www.itread01.com/content/1546733197.html">Go語言變數的生命週期</a>
[15] <a href="https://blog.csdn.net/qq_43192269/article/details/103289623">使用golang的mysql無法插入emoji表情的問題</a>
[16] <a href="https://chai2010.cn/advanced-go-programming-book/">Go語言高級編程(Advanced Go Programming)</a>
[17] <a href="https://studygolang.com/articles/12958">Golang中range的使用方法及注意事項</a>
[18] <a href="https://gfw.go101.org/article/101.html">Go語言101</a></p>
<h2 id="範例補充資料"><a class="header" href="#範例補充資料">範例補充資料</a></h2>
<p><a href="https://github.com/gorilla/websocket/tree/master/examples/chat">gorilla/websocket - example:chat</a>
<a href="https://scotch.io/bar-talk/build-a-realtime-chat-server-with-go-and-websockets">Build a Realtime Chat Server With Go and WebSockets</a>
<a href="https://ithelp.ithome.com.tw/articles/10223666">Go Websocket 長連線</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pytago"><a class="header" href="#pytago">pytago</a></h1>
<h2 id="onlone"><a class="header" href="#onlone">onlone</a></h2>
<ul>
<li>https://pytago.dev/</li>
</ul>
<h2 id="running-pre-built-container"><a class="header" href="#running-pre-built-container">Running pre-built container</a></h2>
<ul>
<li>https://github.com/nottheswimmer/pytago</li>
</ul>
<pre><code>docker run -p 8080:8080 -e PORT=8080 -it nottheswimmer/pytago
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="學習筆記之第1章-go基礎入門"><a class="header" href="#學習筆記之第1章-go基礎入門">學習筆記之第1章 Go基礎入門</a></h2>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#1_Go_2">第1章 Go基礎入門</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#11_Go_3">1.1 安裝Go</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#12_Go_7">1.2 第一個Go程序</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#13_Go_71">1.3 Go基礎語法與使用</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#131__72">1.3.1 基礎語法</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#132__126">1.3.2 變量</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#133__244">1.3.3 常量</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#134__325">1.3.4 運算符</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#135__359">1.3.5 流程控制語句</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#14_Go_611">1.4 Go數據類型</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#141__619">1.4.1 布爾型</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#142__650">1.4.2 數字類型</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#143__653">1.4.3 字符串類型</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#144__752">1.4.4 指針類型</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#145__854">1.4.5 復合類型</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#15__1043">1.5 函數</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#151__1045">1.5.1 聲明函數</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#152__1109">1.5.2 函數參數</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#153__1173">1.5.3 匿名函數</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#154_defer_1244">1.5.4 defer延遲語句</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#16_Go_1341">1.6 Go面向對象編程</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#161__1342">1.6.1 封裝</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#162__1430">1.6.2 繼承</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#163__1449">1.6.3 多態</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#17__1491">1.7 接口</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#171__1493">1.7.1 接口定義</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#172__1539">1.7.2 接口賦值</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#173__1667">1.7.3 接口查詢</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#174__1707">1.7.4 接口組合</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#175__1725">1.7.5 接口應用</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#18__1796">1.8 反射</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#181__1797">1.8.1 反射的定義</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#182__1809">1.8.2 反射的三大法則</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#19_goroutine_1936">1.9 goroutine簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#110_go_test_1962">1.10 單元測試（go test）</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#111_Go_2006">1.11 Go編譯與工具</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#1111_go_build_2007">1.11.1 編譯（go build）</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#1112_go_run_2103">1.11.2 編譯後運行（go run）</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#1113_go_install_2120">1.11.3 編譯並安裝（go install）</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/119815145#1114_go_get_2153">1.11.4 獲取代碼（go get）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第1章-go基礎入門"><a class="header" href="#第1章-go基礎入門">第1章 Go基礎入門</a></h1>
<h2 id="11-安裝go"><a class="header" href="#11-安裝go">1.1 安裝Go</a></h2>
<p>https://golang.google.cn/dl/</p>
<h2 id="12-第一個go程序"><a class="header" href="#12-第一個go程序">1.2 第一個Go程序</a></h2>
<pre><code>package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello World～&quot;)
}
</code></pre>
<ol>
<li>包聲明</li>
</ol>
<p>包管理單位。</p>
<pre><code class="language-go">package xxx
</code></pre>
<ul>
<li>目錄下同級文件屬於同一個包</li>
<li>包名與目錄名可以不同</li>
<li>有且僅有一個main包（入口包）</li>
</ul>
<ol>
<li>包導入</li>
</ol>
<p>調用其他包的變量或方法。</p>
<pre><code class="language-go">import &quot;package_name&quot;
import (
	&quot;os&quot;
	&quot;fmt&quot;
)
別名
import (
	alias1 &quot;os&quot;
	alias2 &quot;fmt&quot;
)
import (
	_ &quot;os&quot; //只初始化包(調用包中init函數)，不使用包中變量或函數。
	alias2 &quot;fmt&quot;
)
</code></pre>
<ol>
<li>main函數</li>
</ol>
<p>入口函數，只能聲明在main包中，有且僅有一個。</p>
<pre><code class="language-go">func 函數名(參數列表) (返回值列表) {
	函數體
}
</code></pre>
<h2 id="13-go基礎語法與使用"><a class="header" href="#13-go基礎語法與使用">1.3 Go基礎語法與使用</a></h2>
<h3 id="131-基礎語法"><a class="header" href="#131-基礎語法">1.3.1 基礎語法</a></h3>
<ol>
<li>Go語言標記</li>
</ol>
<p>Go程序由關鍵字、標識符、常量、字符串、符號等多種標記組成。</p>
<pre><code class="language-go">fmt . Println ( &quot;Hi&quot; )
</code></pre>
<ol>
<li>行分隔符</li>
</ol>
<p>一般一行一個語句，多個語句用；隔開。</p>
<ol>
<li>注釋</li>
</ol>
<p>//單行注釋
/*
多行注釋
多行注釋
*/</p>
<ol>
<li>標識符</li>
</ol>
<p>標識符通常用來對變量、類型等命名。[a-zA-Z0-9_]組成，不能以數字開始，不能是Go語言關鍵字。</p>
<ol>
<li>字符串連接</li>
</ol>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;hello&quot; + &quot; world&quot;)
}
</code></pre>
<ol>
<li>關鍵字</li>
</ol>
<table><thead><tr><th>continue</th><th>for</th><th>import</th><th>return</th><th>var</th></tr></thead><tbody>
<tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr>
<tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>swith</td></tr>
<tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr>
<tr><td>break</td><td>default</td><td>func</td><td>interface</td><td>select</td></tr>
</tbody></table>
<ul>
<li>常量相關預定義標識符：true、false、ioto、nil</li>
<li>類型相關預定義標識符：int、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64、uintptr、float32、float64、complex128、complex64、bool、byte、rune、string、error</li>
<li>函數相關預定義標識符：make、len、cap、new、append、copy、close、delete、complex、real、imag、panic、recover</li>
</ul>
<ol>
<li>Go語言空格</li>
</ol>
<p>var name string
name = “y” + “x”</p>
<h3 id="132-變量"><a class="header" href="#132-變量">1.3.2 變量</a></h3>
<p>變量（variable）是一段或多段用來存儲數據的內存，有明確類型。</p>
<pre><code class="language-go">var name type
var c, d *int
</code></pre>
<p>默認零值或空值，int為0，float為0.0，bool為false，string為&quot;&quot;，指針為nil。
建議駝峰命名法totalPrice或下劃線命名法total_price。</p>
<pre><code class="language-go">var (
	age int
	name string
	balance float32
)
</code></pre>
<p>名字 := 表達式
簡短模式（short variable declaration）限制：</p>
<ul>
<li>只用於定義變量，同時顯示初始化</li>
<li>表達式自動推導數據類型</li>
<li>用於函數內部，即不能聲明全局變量</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	//var 變量名 [類型] = 變量值
	var language1 string = &quot;Go&quot;
	fmt.Printf(&quot;language1=%s\n&quot;, language1)
	var language2 = &quot;Go&quot;
	fmt.Printf(&quot;language2=%s\n&quot;, language2)
	
	//變量名 := 變量值
	language3 := &quot;Go&quot;
	fmt.Printf(&quot;language3=%s\n&quot;, language3)
	
	/*
	var (
		變量名1 [變量類型1] = 變量值1
		變量名2 [變量類型2] = 變量值2
	)
	*/
	var (
		age1 int = 18
		name1 string = &quot;yx&quot;
		balance1 = 999.9
	)
	fmt.Printf(&quot;age1=%d, name1=%s, balance1=%f\n&quot;, age1, name1, balance1)
	
	//var 變量名1, 變量名2 = 變量值1, 變量值2
	var age2, name2, balance2 = 18, &quot;yx&quot;, 999.9
	fmt.Printf(&quot;age2=%d, name2=%s, balance2=%f\n&quot;, age2, name2, balance2)
	
	//變量名1, 變量名2 := 變量值1, 變量值2
	age3, name3, balance3 := 18, &quot;yx&quot;, 999.9
	fmt.Printf(&quot;age3=%d, name3=%s, balance3=%f\n&quot;, age3, name3, balance3)
	
	//變量交換值
	d, c := &quot;D&quot;, &quot;C&quot;
	fmt.Printf(&quot;d=%s, c=%s\n&quot;, d, c)
	c, d = d, c
	fmt.Printf(&quot;d=%s, c=%s\n&quot;, d, c)
}
</code></pre>
<p>局部變量，函數體內聲明的變量，參數和返回值變量都是局部變量。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var local1, local2, local3 int

	local1 = 8
	local2 = 10
	local3 = local1 + local2 
	
	fmt.Printf(&quot;local1=%d, local2=%d, local3=%d\n&quot;, local1, local2, local3)
}
</code></pre>
<p>全局變量，函數體外聲明的變量，可以在整個包甚至外部包（被導出）中使用，也可在任何函數中使用。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

var global int

func main() {
	var local1, local2 int

	local1 = 8
	local2 = 10
	global = local1 + local2 
	
	fmt.Printf(&quot;local1=%d, local2=%d, global=%d\n&quot;, local1, local2, global)
}
package main

import &quot;fmt&quot;

var global int = 8

func main() {
	var global int = 99
	fmt.Printf(&quot;global=%d\n&quot;, global)
}
</code></pre>
<h3 id="133-常量"><a class="header" href="#133-常量">1.3.3 常量</a></h3>
<p>const聲明，編譯時創建（聲明在函數內部也是），存儲不會改變的數據，只能是布爾型、數字型（整數、浮點和復數）和字符串型。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

//const 常量名 [類型] = 常量表達式
const PI float32 = 3.1415926

//itoa用於生成一組以相似規則初始化的常量。
type Direction int
const (
	North Direction = iota
	East
	South
	West
)

/*
常量間算術、邏輯、比較運算都是常量。
常量進行類型轉換，返回常量結果。
len()，cap()，real()，imag()，complex()和unsafe.Sizeof()等函數調用返回常量結果。
*/
const IPv4Len = 4
func paraseIPv4(s string) ([4]byte, error) {
	var p [IPv4Len]byte	
	return p, nil
}

func main() {
	const (
		e = 2.7182818
		pi = 3.1415926
	)

	fmt.Printf(&quot;PI=%v\n&quot;, PI)
	fmt.Printf(&quot;e=%v, pi=%v\n&quot;, e, pi)
	
	fmt.Printf(&quot;West=%v\n&quot;, West)

	if ip, err := paraseIPv4(&quot;192.168.1.1&quot;); err != nil {
		fmt.Printf(&quot;ip=%v\n&quot;, ip)
	}
}
</code></pre>
<p>6種未明確類型的常量類型：</p>
<ul>
<li>無類型的布爾型(true和false)</li>
<li>無類型的整數(0)</li>
<li>無類型的字符(\u0000)</li>
<li>無類型的浮點數(0.0)</li>
<li>無類型的復數(0i)</li>
<li>無類型的字符串(&quot;&quot;)</li>
</ul>
<p>延遲明確常量的具體類型，可以直接用於更多的表達式而不需要顯示的類型轉換。</p>
<pre><code class="language-go">package main

import (
	&quot;math&quot;
	&quot;fmt&quot;
)

func main() {
	var a float32 = math.Pi
	var b float64 = math.Pi
	var c complex128 = math.Pi
	fmt.Printf(&quot;a=%v, b=%v, c=%v\n&quot;, a, b, c)
	
	const Pi64 float64 = math.Pi
	a = float32(Pi64)
	b = Pi64
	c = complex128(Pi64)
	fmt.Printf(&quot;a=%v, b=%v, c=%v\n&quot;, a, b, c)
}
</code></pre>
<h3 id="134-運算符"><a class="header" href="#134-運算符">1.3.4 運算符</a></h3>
<p>運算符是用來在程序運行時執行數學運算或邏輯運算的符號。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	var a, b, c = 3, 6, 9
	d := a + b * c
	fmt.Printf(&quot;d=%v\n&quot;, d)
}
</code></pre>
<p>優先級是指，同一表達式中多個運算符，先執行哪一個。</p>
<table><thead><tr><th>優先級</th><th>分類</th><th>運算符</th><th>結合性</th></tr></thead><tbody>
<tr><td>1</td><td>逗號運算符</td><td>,</td><td>從左到右</td></tr>
<tr><td>2</td><td>賦值運算符</td><td>=、+=、-=、*=、/=、%=、&gt;=、&lt;&lt;=、&amp;=、^=、|=</td><td>從右到左</td></tr>
<tr><td>3</td><td>邏輯或</td><td>||</td><td>從左到右</td></tr>
<tr><td>4</td><td>邏輯與</td><td>&amp;&amp;</td><td>從左到右</td></tr>
<tr><td>5</td><td>按位或</td><td>|</td><td>從左到右</td></tr>
<tr><td>6</td><td>按位異或</td><td>^</td><td>從左到右</td></tr>
<tr><td>7</td><td>按位與</td><td>&amp;</td><td>從左到右</td></tr>
<tr><td>8</td><td>等不等</td><td>==、!=</td><td>從左到右</td></tr>
<tr><td>9</td><td>關系運算符</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>從左到右</td></tr>
<tr><td>10</td><td>位移運算符</td><td>&lt;&lt;、&gt;&gt;</td><td>從左到右</td></tr>
<tr><td>11</td><td>加減法</td><td>+、-</td><td>從左到右</td></tr>
<tr><td>12</td><td>乘除法取餘</td><td>*（乘號）、/、%</td><td>從左到右</td></tr>
<tr><td>13</td><td>單目運算符</td><td>!、*（指針）、&amp;（取址）、++、–、+（正號）、-（負號）</td><td>從右到左</td></tr>
<tr><td>14</td><td>後綴運算符</td><td>()、[]</td><td>從左到右</td></tr>
</tbody></table>
<h3 id="135-流程控制語句"><a class="header" href="#135-流程控制語句">1.3.5 流程控制語句</a></h3>
<pre><code>if-else
package main

import (
	&quot;fmt&quot;
)

func if_else_return(b int) int {
	if b &gt; 10 {
		return 1
	} else if b == 10 {
		return 2
	} else {
		return 3
	}
}

func main() {
	fmt.Println(if_else_return(10))
}
</code></pre>
<p><code>for</code>
Go不支持while和do while。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	product := 1
	for i := 1; i &lt; 5; i++ {
		product *= i
	}
	fmt.Println(product)

	i := 0
	for {
		if i &gt; 50 {
			break
		}
		i++
	}
	fmt.Println(i)

	j := 2
	for ; j &gt; 0; j-- {
		fmt.Println(j)
	}

JumpLoop:
	for i := 0; i &lt; 5; i++ {
		for j := 0; j &lt; 5; j++ {
			if i &gt; 2 {
				break JumpLoop
			}
			fmt.Println(i)
			if j == 2 {
				continue
			}
		}
	}
}
</code></pre>
<p><code>for-range</code>
可以遍歷數組、切片、字符串、map和channel。</p>
<pre><code class="language-go">for key, val := range 復合變量值 {
	//val對應索引值的復制值，只讀。
	//修改val值，不會影響原有集合中的值。
}
for position, runeChar := range str {
	//
}
package main

import (
	&quot;fmt&quot;
)

func main() {
	//遍歷數組、切片
	for key, value := range []int{0, 1, -1, -2} {
		fmt.Printf(&quot;key:%d value:%d\n&quot;, key, value)
	}

	//遍歷字符串
	var str = &quot;hi 加油&quot;
	for key, value := range str {
		fmt.Printf(&quot;key:%d value:0x%x\n&quot;, key, value)
	}

	//遍歷map
	m1 := map[string]int{
		&quot;go&quot;:  100,
		&quot;web&quot;: 100,
	}
	//輸出無序
	for key, value := range m1 {
		fmt.Printf(key, value)
	}

	//遍歷通道
	c := make(chan int)
	go func() {
		c &lt;- 7
		c &lt;- 8
		c &lt;- 9
		close(c)
	}()
	for v := range c {
		fmt.Println(v)
	}

	//_匿名變量，佔位符，不參與空間分配，也不佔用變量名字。
	m2 := map[string]int{
		&quot;go&quot;:  100,
		&quot;web&quot;: 100,
	}
	for _, v := range m2 {
		fmt.Println(v)
	}
	for key, _ := range []int{0, 1, -1, -2} {
		fmt.Printf(&quot;key:%d\n&quot;, key)
	}
}
</code></pre>
<p><code>swith-case</code>
表達式不必為常量，甚至整數，不需通過break跳出，各case中類型一致。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	var a = &quot;love&quot;
	switch a {
	default:
		fmt.Println(&quot;none&quot;)
	case &quot;love&quot;:
		fmt.Println(&quot;love&quot;)
	case &quot;programming&quot;:
		fmt.Println(&quot;programming&quot;)
	}
	switch a {
	default:
		fmt.Println(&quot;none&quot;)
	case &quot;love&quot;, &quot;programming&quot;:
		fmt.Println(&quot;find&quot;)
	}

	var r int = 6
	switch {
	case r &gt; 1 &amp;&amp; r &lt; 10:
		fmt.Println(r)
	}
}
goto
package main

import (
	&quot;fmt&quot;
)

func main() {
	var isBreak bool
	for x := 0; x &lt; 20; x++ {
		for y := 0; y &lt; 20; y++ {
			if y == 2 {
				isBreak = true
				break
			}
		}
		if isBreak {
			break
		}
	}
	fmt.Println(&quot;over&quot;)
}
package main

import (
	&quot;fmt&quot;
)

func main() {
	for x := 0; x &lt; 20; x++ {
		for y := 0; y &lt; 20; y++ {
			if y == 2 {
				goto breakTag
			}
		}
	}
breakTag:
	fmt.Println(&quot;over&quot;)
}
</code></pre>
<p>goto在<code>多錯誤處理</code>中優勢</p>
<pre><code class="language-go">func main() {
	err := getUserInfo()
	if err != nil {
		fmt.Println(err)
		exitProcess()
	}

	err = getEmail()
	if err != nil {
		fmt.Println(err)
		exitProcess()
	}
	
	fmt.Println(&quot;over&quot;)
}
func main() {
	err := getUserInfo()
	if err != nil {
		goto doExit
	}

	err = getEmail()
	if err != nil {
		goto doExit
	}
	
	fmt.Println(&quot;over&quot;)
	return

doExit:
	fmt.Println(err)
	exitProcess()
}
</code></pre>
<h2 id="14-go數據類型"><a class="header" href="#14-go數據類型">1.4 Go數據類型</a></h2>
<table><thead><tr><th>類型</th><th>說明</th></tr></thead><tbody>
<tr><td>布爾型</td><td>true或false</td></tr>
<tr><td>數字類型</td><td>uint8、uint16、uint32、uint64、int8、int16、int32、int64 、float32（IEEE-754）、float64（IEEE-754）、complex64、complex128、byte（uint8）、rune（int32）、uint（32或64）、int（32或64）、uintptr（存放指針）</td></tr>
<tr><td>字符串類型</td><td>一串固定長度的字符連接起來的字符序列，utf-8編碼</td></tr>
<tr><td>復合類型</td><td>數組、切片、map、結構體</td></tr>
</tbody></table>
<h3 id="141-布爾型"><a class="header" href="#141-布爾型">1.4.1 布爾型</a></h3>
<p>只有兩個相同類型的值才能比較：</p>
<ul>
<li>值的類型是接口（interface），兩者必須都實現了相同的接口。</li>
<li>一個是常量，另一個不是常量，類型必須和常量類型相同。</li>
<li>類型不同，必須轉換為相同類型，才能比較。</li>
</ul>
<p>&amp;&amp;優先級高於||，有短路現象。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func bool2int(b bool) int {
	if b {
		return 1
	} else {
		return 0
	}
}

func int2bool(i int) bool { return i != 0 }

func main() {
	fmt.Println(bool2int(true))
	fmt.Println(int2bool(0))
}
</code></pre>
<h3 id="142-數字類型"><a class="header" href="#142-數字類型">1.4.2 數字類型</a></h3>
<p>位運算採用補碼。int、uint和uintptr，長度由操作系統類型決定。</p>
<h3 id="143-字符串類型"><a class="header" href="#143-字符串類型">1.4.3 字符串類型</a></h3>
<p>由一串固定長度的字符連接起來的字符序列，utf-8編碼。值類型，字節的定長數組。</p>
<pre><code class="language-go">//聲明和初始化
str := &quot;string&quot;
</code></pre>
<p>字符串字面量用&quot;或`創建</p>
<ul>
<li>&quot;創建可解析的字符串，支持轉義，不能引用多行</li>
<li>`創建原生的字符串字面量，不支持轉義，可多行，不能包含反引號字符</li>
</ul>
<pre><code class="language-go">str1 := &quot;\&quot;hello\&quot;\nI love you&quot;
str2 := `&quot;hello&quot;
I love you
`
//字符串連接
str := &quot;I love&quot; + &quot; Go Web&quot;
str += &quot; programming&quot;
package main

import (
	&quot;fmt&quot;
	&quot;unicode/utf8&quot;
)

func main() {
	str := &quot;我喜歡Go Web&quot;
	fmt.Println(len(str))
	fmt.Println(utf8.RuneCountInString(str))
	fmt.Println(str[9])
	fmt.Println(string(str[9]))
	fmt.Println(str[:3])
	fmt.Println(string(str[:3]))
	fmt.Println(str[3:])
	fmt.Println([]rune(str))
}
package main

import (
	&quot;fmt&quot;
)

func main() {
	str := &quot;我喜歡Go Web&quot;
	chars := []rune(str)
	for ind, char := range chars {
		fmt.Printf(&quot;%d: %s\n&quot;, ind, string(char))
	}
	for ind, char := range str {
		fmt.Printf(&quot;%d: %s\n&quot;, ind, string(char))
	}
	for ind, char := range str {
		fmt.Printf(&quot;%d: %U %c\n&quot;, ind, char, char)
	}
}
var buffer bytes.Buffer
for {
	if piece, ok := getNextString(); ok {
		buffer.WriteString(piece)
	} else {
		break
	}
}
fmt.Println(buffer.String())
</code></pre>
<p>不能通過str[i]方式修改字符串中的字符。
只能將字符串內容復制到可寫變量（[]byte或[]rune），然後修改。轉換類型過程中會自動復制數據。</p>
<pre><code class="language-go">str := &quot;hi 世界&quot;
by := []byte(str)
by[2] = ','
fmt.Printf(&quot;%s\n&quot;, str)
fmt.Printf(&quot;%s\n&quot;, by)
fmt.Printf(&quot;%s\n&quot;, string(by))
str := &quot;hi 世界&quot;
by := []rune(str)
by[3] = '中'
by[4] = '國'
fmt.Println(str)
fmt.Println(by)
fmt.Println(string(by))
</code></pre>
<h3 id="144-指針類型"><a class="header" href="#144-指針類型">1.4.4 指針類型</a></h3>
<p>指針類型指存儲內存地址的變量類型。</p>
<pre><code class="language-go">var b int = 66
var p * int = &amp;b
package main

import (
	&quot;fmt&quot;
)

func main() {
	var score int = 100
	var name string = &quot;barry&quot;
	fmt.Printf(&quot;%p %p\n&quot;, &amp;score, &amp;name)
}
package main

import (
	&quot;fmt&quot;
)

func main() {
	var address string = &quot;hangzhou, China&quot;
	ptr := &amp;address
	
	fmt.Printf(&quot;address type: %T\n&quot;, address)
	fmt.Printf(&quot;address value: %v\n&quot;, address)
	fmt.Printf(&quot;address address: %p\n&quot;, &amp;address)
	
	fmt.Printf(&quot;ptr type: %T\n&quot;, ptr)
	fmt.Printf(&quot;ptr value: %v\n&quot;, ptr)
	fmt.Printf(&quot;ptr address: %p\n&quot;, &amp;ptr)
	fmt.Printf(&quot;point value of ptr : %v\n&quot;, *ptr)
}
package main

import (
	&quot;fmt&quot;
)

func exchange1(c, d int) {
	t := c
	c = d
	d = t
}

func exchange2(c, d int) {
	c, d = d, c
}

func exchange3(c, d *int) {
	t := *c
	*c = *d
	*d = t
}

func exchange4(c, d *int) {
	d, c = c, d
}

func exchange5(c, d *int) {
	*d, *c = *c, *d
}

func main() {
	x, y := 6, 8
	x, y = y, x
	fmt.Println(x, y)

	x, y = 6, 8
	exchange1(x, y)
	fmt.Println(x, y)
	
	x, y = 6, 8
	exchange2(x, y)
	fmt.Println(x, y)
	
	x, y = 6, 8
	exchange3(&amp;x, &amp;y)
	fmt.Println(x, y)
	
	x, y = 6, 8
	exchange4(&amp;x, &amp;y)
	fmt.Println(x, y)
	
	x, y = 6, 8
	exchange5(&amp;x, &amp;y)
	fmt.Println(x, y)
}
</code></pre>
<h3 id="145-復合類型"><a class="header" href="#145-復合類型">1.4.5 復合類型</a></h3>
<ol>
<li>數組類型</li>
</ol>
<p>數組是具有相同類型（整數、字符串、自定義類型等）的一組長度固定的數據項的序列。</p>
<pre><code class="language-go">var array [10]int
var numbers = [5]float32{100.0, 8.0, 9.4, 6.8, 30.1}
var numbers = [...]float32{100.0, 8.0, 9.4, 6.8, 30.1}
package main

import (
	&quot;fmt&quot;
)

func main() {
	var arr [6]int
	var i, j int
	for i = 0; i &lt; 6; i++ {
		arr[i] = i + 66
	}
	for j = 0; j &lt; 6; j++ {
		fmt.Printf(&quot;arr[%d] = %d\n&quot;, j, arr[j])
	}
}
</code></pre>
<ol>
<li>結構體類型</li>
</ol>
<p>結構體是由0或多個任意類型的數據構成的數據集合。</p>
<pre><code class="language-go">type 類型名 struct {
	字段1 類型1
	結構體成員2 類型2
}
type Pointer struct {
	A float32
	B float32
}

type Color struct {
	Red, Green, Blue byte
}

variable_name := struct_variable_type {value1, value2, ...}
variable_name := struct_variable_type {key2: value2, key1: value1, ...}
package main

import &quot;fmt&quot;

type Book struct {
	title string
	author string
	subject string
	press string
}

func main() {
	fmt.Println(Book{author: &quot;yx&quot;, title: &quot;學習 Go Web&quot;})
	
	var bookGo Books
	bookGo.title = &quot;學習 Go Web&quot;
	bookGo.author = &quot;yx&quot;
	bookGo.subject = &quot;Go&quot;
	bookGo.press = &quot;電力工業出版社&quot;
	fmt.Printf(&quot;bookGo.title: %s\n&quot;, bookGo.title)
	fmt.Printf(&quot;bookGo.author: %s\n&quot;, bookGo.author)
	fmt.Printf(&quot;bookGo.subject: %s\n&quot;, bookGo.subject)
	fmt.Printf(&quot;bookGo.press: %s\n&quot;, bookGo.press)
	printBook(bookGo)
	printBook(&amp;bookGo)
}

func printBook(book Books) {
	fmt.Printf(&quot;book.title: %s\n&quot;, book.title)
	fmt.Printf(&quot;book.author: %s\n&quot;, book.author)
	fmt.Printf(&quot;book.subject: %s\n&quot;, book.subject)
	fmt.Printf(&quot;book.press: %s\n&quot;, book.press)
}

func printBook2(book *Books) {
	fmt.Printf(&quot;book.title: %s\n&quot;, book.title)
	fmt.Printf(&quot;book.author: %s\n&quot;, book.author)
	fmt.Printf(&quot;book.subject: %s\n&quot;, book.subject)
	fmt.Printf(&quot;book.press: %s\n&quot;, book.press)
}
</code></pre>
<ol>
<li>切片類型</li>
</ol>
<p>slice是對數組或切片連續片段的引用。
切片內部結構包含內存地址pointer、大小len和容量cap。</p>
<pre><code class="language-go">//不含結束位置
slice[開始位置:結束位置]
var sliceBuilder [20]int
for i := 0; i &lt; 20; i++ {
	sliceBuilder[i] = i + 1
}
fmt.Println(sliceBuilder[5:15])
fmt.Println(sliceBuilder[15:])
fmt.Println(sliceBuilder[:2])
b := []int{6, 7, 8}
fmt.Println(b[:])
fmt.Println(b[0:0])
var sliceStr []string
var sliceNum []int
var emptySliceNum = []int{}
fmtp.Println(sliceStr, sliceNum, emptySliceNum)
fmtp.Println(len(sliceStr), len(sliceNum), (emptySliceNum))
fmtp.Println(sliceStr == nil, sliceNum == nil, emptySliceNum == nil)
slice1 := make([]int, 6)
slice2 := make([]int, 6, 10)
fmtp.Println(slice1, slice2)
fmtp.Println(len(slice1), len(slice2))
fmtp.Println(cap(slice1), cap(slice2))
</code></pre>
<ol>
<li>map類型</li>
</ol>
<p>關聯數組，字典，元素對（pair）的無序集合，引用類型。</p>
<pre><code class="language-go">var name map[key_type]value_type
var literalMap map[string]string
var assignedMap map[string]string
literalMap = map[string]string{&quot;first&quot;: &quot;go&quot;, &quot;second&quot;: &quot;web&quot;}
createdMap := make(map[string]float32)
assignedMap = literalMap	//引用
createdMap[&quot;k1&quot;] = 99
createdMap[&quot;k2&quot;] = 199
assignedMap[&quot;second&quot;] = &quot;program&quot;

fmt.Println(literalMap[&quot;first&quot;])
fmt.Println(literalMap[&quot;second&quot;])
fmt.Println(literalMap[&quot;third&quot;])
fmt.Println(createdMap[&quot;k2&quot;])
createdMap := new(map[string]float32)
//錯誤
//聲明瞭一個未初始化的變量並取了它的地址
//map到達容量上限，自動增1
make(map[key_type]value_type, cap)
map := make(map[string]float32, 100)

achievement := map[string]float32{
	&quot;zhang&quot;: 99.5, &quot;xiao&quot;: 88,
	&quot;wange&quot;: 96, &quot;ma&quot;: 100,
}
map1 := make(map[int][]int)
map2 := make(map[int]*[]int)
</code></pre>
<h2 id="15-函數"><a class="header" href="#15-函數">1.5 函數</a></h2>
<h3 id="151-聲明函數"><a class="header" href="#151-聲明函數">1.5.1 聲明函數</a></h3>
<pre><code class="language-go">func function_name([parameter list]) [return_types] {
	//bunction_body
}
package main

import &quot;fmt&quot;

func main() {
	array := []int{6, 8, 10}
	var ret int
	ret = min(array)
	fmt.Println(&quot;最小值是: %d\n&quot;, ret)
}

func min(arr []int) (m int) {
	m = arr[0]
	for _, v := range arr {
		if v &lt; m {
			m = v
		}
	}
	return
}
package main

import &quot;fmt&quot;

func compute(x, y int) (int, int) {
	return x+y, x*y
}
func main() {
	a, b := compute(6, 8)
	fmt.Println(a, b)
}
package main

import &quot;fmt&quot;

func change(a, b int) (x, y int) {
	x = a + 100
	y = b + 100
	return
	//return x, y
	//return y, x
}
func main() {
	a := 1
	b := 2
	c, d := compute(a, b)
	fmt.Println(c,d)
}
</code></pre>
<h3 id="152-函數參數"><a class="header" href="#152-函數參數">1.5.2 函數參數</a></h3>
<ol>
<li>參數使用</li>
</ol>
<ul>
<li>形參：定義函數時，用於接收外部傳入的數據。</li>
<li>實參：調用函數時，傳給形參的實際的數據。</li>
</ul>
<ol>
<li>可變參數</li>
</ol>
<pre><code class="language-go">func myFunc(arg ...string) {
	for _, v := range arg {
		fmt.Printf(&quot;the string is: %s\n&quot;, v)
	}
}
</code></pre>
<ol>
<li>參數傳遞</li>
</ol>
<ul>
<li>值傳遞</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func exchange(a, b int) {
	var tmp int
	tmp = a
	a = b
	b = tmp
}
func main() {
	a := 1
	b := 2
	fmt.Printf(&quot;交換前a=%d\n&quot;, a)
	fmt.Printf(&quot;交換前b=%d\n&quot;, b)
	exchange(a, b)
	fmt.Printf(&quot;交換後a=%d\n&quot;, a)
	fmt.Printf(&quot;交換後b=%d\n&quot;, b)
}
</code></pre>
<ul>
<li>引用傳遞</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func exchange(a, b *int) {
	var tmp int
	tmp = *a
	*a = *b
	*b = tmp
}
func main() {
	a := 1
	b := 2
	fmt.Printf(&quot;交換前a=%d\n&quot;, a)
	fmt.Printf(&quot;交換前b=%d\n&quot;, b)
	exchange(&amp;a, &amp;b)
	fmt.Printf(&quot;交換後a=%d\n&quot;, a)
	fmt.Printf(&quot;交換後b=%d\n&quot;, b)
}
</code></pre>
<h3 id="153-匿名函數"><a class="header" href="#153-匿名函數">1.5.3 匿名函數</a></h3>
<p>匿名函數（閉包），一類無須定義標識符（函數名）的函數或子程序。</p>
<ol>
<li>定義</li>
</ol>
<pre><code class="language-go">func (參數列表) (返回值列表) {
	//函數體
}
package main

import &quot;fmt&quot;

func main() {
	x, y := 6, 8
	defer func(a int) {
		fmt.Println(&quot;defer x, y = &quot;, a, y) //y為閉包引用
	}(x)
	x += 10
	y += 100
	fmt.Println(x, y)
}
/*
輸出
16 108
defer x,y = 6 108
*/
</code></pre>
<ol>
<li>調用</li>
</ol>
<ul>
<li>定義時調用</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	//定義匿名函數並賦值給f變量
	f := func(data int) {
		fmt.Println(&quot;closure&quot;, data)
	}
	f(6)

	//直接聲明並調用
	func(data int) {
		fmt.Println(&quot;closure, directly&quot;, data)
	}(8)
}
</code></pre>
<ul>
<li>回調函數（call then back）</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func visitPrint(list []int, f func(int)) {
	for _, value := range list {
		f(value)
	}
}

func main() {
	sli := []int{1, 6, 8}
	visitPrint(sli, func(value int) {
		fmt.Println(value)
	})
}
</code></pre>
<h3 id="154-defer延遲語句"><a class="header" href="#154-defer延遲語句">1.5.4 defer延遲語句</a></h3>
<p>defer用於函數結束（return或panic）前最後執行的動作，便於及時的釋放資源（數據庫連接、文件句柄、鎖等）。</p>
<p>defer語句執行邏輯：</p>
<ol>
<li>函數執行到defer時，將defer後的語句壓入專門存儲defer語句的棧中，然後繼續執行函數下一個語句。</li>
<li>函數執行完畢，從defer棧頂依次取出語句執行（先進後出，後進先出）。</li>
<li>defer語句放在defer棧時，相關值會復制入棧中。</li>
</ol>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	deferCall()
}

func deferCall() {
	defer func1()
	defer func2()
	defer func3()
}

func func1() {
	fmt.Println(&quot;A&quot;)
}

func func2() {
	fmt.Println(&quot;B&quot;)
}

func func3() {
	fmt.Println(&quot;C&quot;)
}

//輸出
//C
//B
//A
package main

import &quot;fmt&quot;

var name string = &quot;go&quot;

func myfunc() string {
	defer func() {
		name = &quot;python&quot;	//最後一個動作，修改全局變量name為&quot;python&quot;
	}()

	fmt.Printf(&quot;myfunc()函數裡的name: %s\n&quot;, name)//全局變量name（&quot;go&quot;）未修改
	return name	//倒數第二個動作，將全局變量name（&quot;go&quot;）賦值給myfunc函數返回值
}

func main() {
	myname := myfunc()
	fmt.Printf(&quot;main()函數裡的name: %s\n&quot;, name)
	fmt.Printf(&quot;main()函數裡的myname: %s\n&quot;, myname)
}

//輸出
//myfunc()函數裡的name: go
//main()函數裡的name: python
//main()函數裡的myname: go
</code></pre>
<p>defer常用應用場景：</p>
<ol>
<li>關閉資源。
創建資源（數據庫連接、文件句柄、鎖等）語句下一行，defer語句註冊關閉資源，避免忘記。</li>
<li>和recover()函數一起使用。
程序宕機或panic時，recover()函數恢復執行，而不報錯。</li>
</ol>
<pre><code class="language-go">func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()	//func()函數含recover，不可封裝成外部函數調用，必須defer func(){}()匿名函數調用
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}
</code></pre>
<h2 id="16-go面向對象編程"><a class="header" href="#16-go面向對象編程">1.6 Go面向對象編程</a></h2>
<h3 id="161-封裝"><a class="header" href="#161-封裝">1.6.1 封裝</a></h3>
<p>隱藏對象屬性和實現細節，僅公開訪問方式。
Go使用結構體封裝屬性。</p>
<pre><code class="language-go">type Triangle struct {
	Bottom float32
	Height float32
}
</code></pre>
<p>方法（Methods）是作用在接收者（receiver）（某種類型的變量）上的函數。</p>
<pre><code class="language-go">func (recv recv_type) methodName(parameter_list) (return_value_list) {...}
package main

import &quot;fmt&quot;

type Triangle struct {
	Bottom float32
	Height float32
}

func (t *Triangle) Area() float32 {
	return (t.Bottom * t.Height) / 2
}

func main() {
	t := Triangle(6, 8)
	fmt.Println(t.Area())
}
</code></pre>
<p>訪問權限指類屬性是公開還是私有的，Go通過首字母大小寫來控制可見性。
常量、變量、類型、接口、結構體、函數等若是大寫字母開頭，則能被其他包訪問或調用（public）；非大寫開頭則只能包內使用（private）。</p>
<pre><code class="language-go">package person
type Student struct {
	name string
	score float32
	Age int
}

package pkg
import (
	person
	&quot;fmt&quot;
)
s := new(person.Student)
s.name = &quot;yx&quot; //錯誤
s.Age = 22
fmt.Println(s.Age)
package person

type Student struct {
	name string
	score float32
}

func (s *Student) GetName() string {
	return s.name
}

func (s *Student) SetName(newName string) {
	s.name = newName
}

package main

import (
	person
	&quot;fmt&quot;
)

func main() {
	s := new(person.Student)
	s.SetName(&quot;yx&quot;)
	s.Age = 22
	fmt.Println(s.GetName())
}
</code></pre>
<h3 id="162-繼承"><a class="header" href="#162-繼承">1.6.2 繼承</a></h3>
<p>結構體中內嵌匿名類型的方法來實現繼承。</p>
<pre><code class="language-go">type Engine interface {
	Run()
	Stop()
}

type Bus struct {
	Engine
}

func (c *Bus) Working() {
	c.Run()
	c.Stop()
}
</code></pre>
<h3 id="163-多態"><a class="header" href="#163-多態">1.6.3 多態</a></h3>
<p>多態指不同對象中同種行為的不同實現方法，通過接口實現。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type Shape interface {
	Area() float32
}

type Square struct {
	sideLen float32
}

func (sq *Square) Area() float32 {
	return sq.sideLen * sq.sideLen
}

type Triangle struct {
	Bottom float32
	Height float32
}

func (t *Triangle) Area() float32 {
	return t.Bottom * t.Height
}

func main() {
	t := &amp;Tri8angle{6, 8}
	s := &amp;Square{}
	shapes := []Shape{t, s}
	for n, _ := range shapes {
		fmt.Println(&quot;圖形數據：&quot;, shapes[n])
		fmt.Println(&quot;面積：&quot;, shapes[n].Area())
	}
}
</code></pre>
<h2 id="17-接口"><a class="header" href="#17-接口">1.7 接口</a></h2>
<h3 id="171-接口定義"><a class="header" href="#171-接口定義">1.7.1 接口定義</a></h3>
<p>接口類型是對其他類型行為的概括與抽象，定義了零及以上個方法，但沒具體實現這些方法。
接口本質上是指針類型，可以實現多態。</p>
<pre><code class="language-go">//接口定義格式
type 接口名稱 interface {
	method1(參數列表) 返回值列表
	method2(參數列表) 返回值列表
	//...
	methodn(參數列表) 返回值列表
}
</code></pre>
<p>空接口（interface{}），無任何方法聲明，類似面向對象中的根類型，c中的void*，默認值nil。實現接口的類型支持相等運算，才能比較。</p>
<pre><code class="language-go">var var1, var2 interface{}
fmt.Println(var1 == nil, var1 == var2)
var1, var2 = 66, 88
fmt.Println(var1 == var2)
//比較map[string]interface{}
func CompareTwoMapInterface(data1 map[string]interface{}, data2 map[string]interface{}) bool {
	keySlice := make([]string, 0)
	dataSlice1 := make([]interface{}, 0)
	dataSlice2 := make([]interface{}, 0)
	for key, value := range data1 {
		keySlice = append(keySlice, key)
		dataSlice1 = append(dataSlice1, value)
	}
	for _, key := range keySlice {
		if data, ok := data2[key]; ok {
			dataSlice2 = append(dataSlice2, data)
		} else {
			return false
		}
	}
	dataStr1, _ := json.Marshal(dataSlice1)
	dataStr2, _ := json.Marshal(dataSlice2)

	return string(dataStr1) == string(dataStr2)
}
</code></pre>
<h3 id="172-接口賦值"><a class="header" href="#172-接口賦值">1.7.2 接口賦值</a></h3>
<p>接口不支持直接實例化，但支持賦值操作。</p>
<ol>
<li>實現接口的對象實例賦值給接口</li>
</ol>
<p>要求該對象實例實現了接口的所有方法。</p>
<pre><code class="language-go">type Num int

func (x Num) Equal(i Num) bool {
	return x == i
}

func (x Num) LessThan(i Num) bool {
	return x &lt; i
}

func (x Num) MoreThan(i Num) bool {
	return x &gt; i
}

func (x *Num) Multiple(i Num) {
	*x = *x * i
}

func (x *Num) Divide(i Num) {
	*x = *x / i
}

type NumI interface {
	Equal(i Num) bool
	LessThan(i Num) bool
	MoreThan(i Num) bool
	Multiple(i Num)
	Divide(i Num)
}

//&amp;Num實現NumI所有方法
//Num未實現NumI所有方法
var x Num = 8
var y NumI = &amp;x

/*
Go語言會根據非指針成員方法，自動生成對應的指針成員方法
func (x Num) Equal(i Num) bool
func (x *Num) Equal(i Num) bool
*/
</code></pre>
<ol>
<li>一個接口賦值給另一個接口</li>
</ol>
<p>兩個接口擁有相同的方法列表（與順序無關），則等同，可相互賦值。</p>
<pre><code class="language-go">package oop1

type NumInterface1 interface {
	Equal(i int) bool
	LessThan(i int) bool
	BiggerThan(i int) bool
}

package oop2

type NumInterface2 interface {
	Equal(i int) bool
	BiggerThan(i int) bool
	LessThan(i int) bool
}

type Num int

//int不能改為Num
func (x Num) Equal(i int) bool {
	return int(x) == i
}

func (x Num) LessThan(i int) bool {
	return int(x) &lt; i
}

func (x Num) BiggerThan(i int) bool {
	return int(x) &gt; i
}

var f1 Num = 6
var f2 oop1.NumInterface1 = f1
var f3 oop2.NumInterface2 = f2
</code></pre>
<p>若接口A的方法列表是接口B的方法列表的子集，則接口B可以直接賦值給接口A。</p>
<pre><code class="language-go">type NumInterface1 interface {
	Equal(i int) bool
	LessThan(i int) bool
	BiggerThan(i int) bool
}

type NumInterface2 interface {
	Equal(i int) bool
	BiggerThan(i int) bool
	LessThan(i int) bool
	Sum(i int)
}

type Num int

func (x Num) Equal(i int) bool {
	return int(x) == i
}

func (x Num) LessThan(i int) bool {
	return int(x) &lt; i
}

func (x Num) BiggerThan(i int) bool {
	return int(x) &gt; i
}

func (x *Num) Sum(i int) {
	*x = *x + Num(i)
}

var f1 Num = 6
var f2 NumInterface2 = &amp;f1
var f3 NumInterface1 = f2
</code></pre>
<h3 id="173-接口查詢"><a class="header" href="#173-接口查詢">1.7.3 接口查詢</a></h3>
<p>程序運行時，詢問接口指向的對像是否時某個類型。</p>
<pre><code class="language-go">var filewriter Write = ...
if filew, ok := filewriter.(*File); ok {
	//...
}
slice := make([]int, 0)
slice = append(slice, 6, 7, 8)
var I interface{} = slice
if res, ok := I.([]int); ok {
	fmt.Println(res) //[6 7 8]
	fmt.Println(ok) //true
}
func Len(array interface{}) int {
	var length int
	
	switch b := array.(type) {
	case nil:
		length = 0
	case []int:
		length = len(b)
	case []string:
		length = len(b)
	case []float32:
		length = len(b)
	default:
		length = 0
	}
	return length
}
</code></pre>
<h3 id="174-接口組合"><a class="header" href="#174-接口組合">1.7.4 接口組合</a></h3>
<p>接口間通過嵌套創造出新接口。</p>
<pre><code class="language-go">type Interface1 interface {
	Write(p []byte) (n int, err error)
}

type Interface2 interface {
	Close() error
}

type InterfaceCombine interface {
	Interface1
	Interface2
}
</code></pre>
<h3 id="175-接口應用"><a class="header" href="#175-接口應用">1.7.5 接口應用</a></h3>
<ol>
<li>類型推斷</li>
</ol>
<p>類型推斷可將接口還原為原始類型，或用來判斷是否實現了某種更具體的接口類型。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var a interface{} = func(a int) string {
		rteurn fmt.Sprintf(&quot;d:%d&quot;, a)
	}
	
	switch b := a.(type) {
	case nil:
		fmt.Println(&quot;nil&quot;)
	case *int:
		fmt.Println(*b)
	case func(int) string:
		fmt.Println(b(66))
	case fmt.Stringer:
		fmt.Println(b)
	default:
		fmt.Println(&quot;unknown&quot;)
	}
}
</code></pre>
<ol>
<li>實現多態功能</li>
</ol>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Message interface {
	sending()
}

type User struct {
	name string
	phone string
}

func (u *User) sending() {
	fmt.Printf(&quot;Sending user phone to %s&lt;%s&gt;\n&quot;, u.name, u.phone)
}

type admin struct {
	name string
	phone string
}

func (a *admin) sending() {
	fmt.Printf(&quot;Sending admin phone to %s&lt;%s&gt;\n&quot;, a.name, a.phone)
}

func main() {
	bill := User{&quot;Barry&quot;, &quot;barry@gmail.com&quot;}
	sendMessage(&amp;bill)
	
	lisa := admin{&quot;Barry&quot;, &quot;barry@gmail.com&quot;}
	sendMessage(&amp;lisa)
}

func sendMessage(n Message) {
	n.sending()
}
</code></pre>
<h2 id="18-反射"><a class="header" href="#18-反射">1.8 反射</a></h2>
<h3 id="181-反射的定義"><a class="header" href="#181-反射的定義">1.8.1 反射的定義</a></h3>
<p>反射指，編譯時不知道變量的具體類型，運行時（Run time）可以訪問、檢測和修改狀態或行為的能力。</p>
<p>reflect包定義了接口和結構體，獲取類型信息。</p>
<ul>
<li>reflect.Type接口提供類型信息</li>
<li>reflect.Value結構體提供值相關信息，可以獲取甚至改變類型的值</li>
</ul>
<pre><code class="language-go">func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
</code></pre>
<h3 id="182-反射的三大法則"><a class="header" href="#182-反射的三大法則">1.8.2 反射的三大法則</a></h3>
<ol>
<li>接口類型變量轉換為反射類型對象</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	var x float64 = 3.4
	fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))
	fmt.Println(&quot;value:&quot;, reflect.ValueOf(x))
	
	v := reflect.ValueOf(x)
	fmt.Println(&quot;type:&quot;, v.Type())
	fmt.Println(&quot;kind is float64:&quot;, v.Kind() == reflect.Float64)
	fmt.Println(&quot;value:&quot;, v.Float())
}
//輸出
//type: float64
//value: 3.4
//kind is float64: true
//type: float64
//value: 3.4
</code></pre>
<ol>
<li>反射類型對象轉換為接口類型變量</li>
</ol>
<pre><code class="language-go">func (v Value) Interface() interface{}
y := v.Interface().(float64)
fmt.Println(y)
package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	var name interface{} = &quot;shirdon&quot;
	fmt.Printf(&quot;原始接口變量類型為%T，值為%v\n&quot;, name, name)
	
	t := reflect.TypeOf(name)
	v := reflect.ValueOf(name)
	fmt.Printf(&quot;Type類型為%T，值為%v\n&quot;, t, t)
	fmt.Printf(&quot;Value類型為%T，值為%v\n&quot;, v, v)
	
	i := v.Interface()
	fmt.Printf(&quot;新對象interface{}類型為%T，值為%v\n&quot;, i, i)
}
//輸出
//原始接口變量類型為string，值為shirdon
//Type類型為*reflect.rtype，值為string
//Value類型為reflect.Value，值為shirdon
//新對象interface{}類型為string，值為shirdon
</code></pre>
<ol>
<li>修改反射類型對象，其值必須是可寫的（settable）</li>
</ol>
<p>reflect.TypeOf()和reflect.ValueOf()函數中若傳遞的不是指針，則只是變量復制，對該反射對象修改，不會影響原始變量。
反射對象可寫性要點:</p>
<ul>
<li>變量指針創建的反射對象</li>
<li>CanSet()可判斷</li>
<li>Elem()返回指針指向的數據</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	var name string = &quot;shirdon&quot;
	//var name int = 12
	
	v1 := reflect.ValueOf(&amp;name)
	v2 := v1.Elem()
	fmt.Println(&quot;可寫性:&quot;, v1.CanSet())
	fmt.Println(&quot;可寫性:&quot;, v2.CanSet())
}

//輸出
//可寫性：false
//可寫性：true
func (v Value) SetBool(x bool)
func (v Value) SetBytes(x []byte)
func (v Value) SetFloat(x float64)
func (v Value) SetInt(x int64)
func (v Value) SetString(x string)
package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	var name string = &quot;shirdon&quot;
	fmt.Println(&quot;name原始值:&quot;, name)
	
	v1 := reflect.ValueOf(&amp;name)
	v2 := v1.Elem()
	
	v2.SetString(&quot;yx&quot;)
	fmt.Println(&quot;反射對象修改後，name值:&quot;, name)
}

//輸出
//name原始值: shirdon
//反射對象修改後，name值: yx
</code></pre>
<h2 id="19-goroutine簡介"><a class="header" href="#19-goroutine簡介">1.9 goroutine簡介</a></h2>
<p>每一個並發執行的活動叫goroutine。</p>
<pre><code class="language-go">go func_name()
package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func hello() {
	fmt.Println(&quot;hello&quot;)
}

func main() {
	go hello()
	time.Sleep(1*time.Second)
	fmt.Println(&quot;end&quot;)
}
</code></pre>
<h2 id="110-單元測試go-test"><a class="header" href="#110-單元測試go-test">1.10 單元測試（go test）</a></h2>
<p>testing庫，*_test.go文件。</p>
<pre><code class="language-go">//sum.go
package testexample

func Min(arr []int) (min int) {
	min = arr[0]
	for _, v := range arr {
		if v &lt; min {
			min = v
		}
	}
	return
}

//sum_test.go
package testexample

import (
	&quot;fmt&quot;
	&quot;testing&quot;
)

func TestMin(t *testing.T) {
	array := []int{6, 8, 10}
	ret := Min(array)
	fmt.Println(ret)
}

//go test
//go test -v
//go test -v -run=&quot;Test&quot;
</code></pre>
<table><thead><tr><th>參數</th><th>作用</th></tr></thead><tbody>
<tr><td>-v</td><td>打印每個測試函數的名字和運行時間</td></tr>
<tr><td>-c</td><td>生成測試可執行文件，但不執行，默認命名pkg.test</td></tr>
<tr><td>-i</td><td>重新安裝運行測試依賴包，但不編譯和運行測試代碼</td></tr>
<tr><td>-o</td><td>指定生成測試可執行文件的名稱</td></tr>
</tbody></table>
<h2 id="111-go編譯與工具"><a class="header" href="#111-go編譯與工具">1.11 Go編譯與工具</a></h2>
<h3 id="1111-編譯go-build"><a class="header" href="#1111-編譯go-build">1.11.1 編譯（go build）</a></h3>
<pre><code class="language-go">//build
//----main.go
//----utils.go

//main.go
package main

import (
	&quot;fmt&quot;
)

func main() {
	printString()
	fmt.Println(&quot;go build&quot;)
}

//utils.go
package main

import &quot;fmt&quot;

func printString() {
	fmt.Println(&quot;test&quot;)
}

//cd build
//go build
//go build main.go utils.go
//go build -o file.exe main.go utils.go
//pkg
//----mainpkg.go
//----buildpkg.go

//mainpkg.go
package main

import (
	&quot;fmt&quot;
	&quot;pkg&quot;
)

func main() {
	pkg.CallFunc()
	fmt.Println(&quot;go build&quot;)
}

//buildpkg.go
package pkg

import &quot;fmt&quot;

func CallFunc() {
	fmt.Println(&quot;test&quot;)
}
//go build .../pkg
//compile.go
package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;go build&quot;)
}
//CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build compile.go
</code></pre>
<ul>
<li>CGO_ENABLED: 是否使用C語言的Go編譯器；</li>
<li>GOOS：目標操作系統</li>
<li>GOARCH：目標操作系統的架構</li>
</ul>
<table><thead><tr><th>系統編譯參數</th><th>架構</th></tr></thead><tbody>
<tr><td>linux(&gt;=Linux 2.6)</td><td>386 / amd64 / arm</td></tr>
<tr><td>darwin(OS X(Snow Lepoard + Lion))</td><td>386 / amd64</td></tr>
<tr><td>freebsd(&gt;=FreeBSD 7)</td><td>386 / amd64</td></tr>
<tr><td>windows(&gt;=Windows 2000)</td><td>386 / amd64</td></tr>
</tbody></table>
<table><thead><tr><th>附加參數</th><th>作用</th></tr></thead><tbody>
<tr><td>-v</td><td>編譯時顯示包名</td></tr>
<tr><td>-p n</td><td>開啟並發編譯，默認值為CPU邏輯核數</td></tr>
<tr><td>-a</td><td>強制重新構建</td></tr>
<tr><td>-n</td><td>打印編譯時會用到的所有命令，但不真正執行</td></tr>
<tr><td>-x</td><td>打印編譯時會用到的所有命令</td></tr>
<tr><td>-race</td><td>開啟競態檢測</td></tr>
</tbody></table>
<h3 id="1112-編譯後運行go-run"><a class="header" href="#1112-編譯後運行go-run">1.11.2 編譯後運行（go run）</a></h3>
<p>編譯後直接運行，且無可執行文件。</p>
<pre><code class="language-go">//hello.go
package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;go run&quot;)
}
//go run hello.go
</code></pre>
<h3 id="1113-編譯並安裝go-install"><a class="header" href="#1113-編譯並安裝go-install">1.11.3 編譯並安裝（go install）</a></h3>
<p>類似go build，只是編譯中間文件放在$GOPATH/pkg目錄下，編譯結果放在$GOPATH/bin目錄下。</p>
<pre><code class="language-go">//install
//|----main.go
//|----pkg
//    |----installpkg.go

//main.go
package main

import (
	&quot;fmt&quot;
	&quot;pkg&quot;
)

func main() {
	pkg.CallFunc()
	fmt.Println(&quot;go build&quot;)
}

//installpkg.go
package pkg

import &quot;fmt&quot;

func CallFunc() {
	fmt.Println(&quot;test&quot;)
}
//go install
</code></pre>
<h3 id="1114-獲取代碼go-get"><a class="header" href="#1114-獲取代碼go-get">1.11.4 獲取代碼（go get）</a></h3>
<p>動態遠程拉取或更新代碼包及其依賴包，自動完成編譯和安裝。需要安裝Git，SVN，HG等。</p>
<table><thead><tr><th>標記名稱</th><th>標記描述</th></tr></thead><tbody>
<tr><td>-d</td><td>只下載，不安裝</td></tr>
<tr><td>-f</td><td>使用-u時才有效，忽略對已下載代碼包導入路徑的檢查。適用於從別人處Fork代碼包</td></tr>
<tr><td>-fix</td><td>下載代碼包後先修正，然後編譯和安裝</td></tr>
<tr><td>-insecure</td><td>運行非安全scheme(如HTTP)下載代碼包。</td></tr>
<tr><td>-t</td><td>同時下載測試源碼文件中的依賴代碼包</td></tr>
<tr><td>-u</td><td>更新已有代碼包及其依賴包</td></tr>
</tbody></table>
<pre><code class="language-go">go get -u github.com/shirdon1/TP-Link-HS110
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="web開發基礎"><a class="header" href="#web開發基礎">Web開發基礎</a></h3>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#2_Go_Web_2">第2章 Go Web開發基礎</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#21_helloWorldWeb_4">2.1 helloWorldWeb</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#22_Web_28">2.2 Web程序運行原理簡介</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#221_Web_29">2.2.1 Web基本原理</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#222_HTTP_43">2.2.2 HTTP簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#223_HTTP_46">2.2.3 HTTP請求</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#224_HTTP_83">2.2.4 HTTP響應</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#225_URIURL_155">2.2.5 URI與URL</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#226_HTTPS_172">2.2.6 HTTPS簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#227_HTTP2_176">2.2.7 HTTP2簡介</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#228_Web_193">2.2.8 Web應用程序的組成</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#23_nethttp_237">2.3 net/http包</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#231__238">2.3.1 創建簡單服務器端</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#232__342">2.3.2 創建簡單的客戶端</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#24_htmltemplate_496">2.4 html/template包</a></li>
<li>
<ul>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#241__498">2.4.1 模板原理</a></li>
<li><a href="https://blog.csdn.net/oqqyx1234567/article/details/120101351#242_htmltemplate_537">2.4.2 使用html/template包</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第2章-go-web開發基礎"><a class="header" href="#第2章-go-web開發基礎">第2章 Go Web開發基礎</a></h1>
<h2 id="21-helloworldweb"><a class="header" href="#21-helloworldweb">2.1 helloWorldWeb</a></h2>
<pre><code class="language-go">//helloWorldWeb.go
//go run helloWorldWeb.go
//127.0.0.1
package main
import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello World&quot;)
}

func main() {
	server := &amp;http.Server {
		Addr: &quot;0.0.0.0:80&quot;,
	}
	http.HandleFunc(&quot;/&quot;, hello)
	server.ListenAndServe()
}
</code></pre>
<h2 id="22-web程序運行原理簡介"><a class="header" href="#22-web程序運行原理簡介">2.2 Web程序運行原理簡介</a></h2>
<h3 id="221-web基本原理"><a class="header" href="#221-web基本原理">2.2.1 Web基本原理</a></h3>
<ol>
<li>運行原理
（1）用戶打開客戶端瀏覽器，輸入URL地址。
（2）客戶端瀏覽器通過HTTP協議向服務器端發送瀏覽請求。
（3）服務器端通過CGI程序接收請求，調用解釋引擎處理“動態內容”，訪問數據庫並處理數據，通過HTTP協議將得到的處理結果返回給客戶端瀏覽器。
（4）客戶端瀏覽器解釋並顯示HTML頁面。</li>
<li>DNS（Domain Name System，域名系統）
將主機名和域名轉換為IP地址。
DNS解析過程：
（1）用戶打開瀏覽器，輸入URL地址。瀏覽器從URL中抽取域名（主機名），傳給DNS應用程序的客戶端。
（2）DNS客戶端向DNS服務器端發送查詢報文，其中包含主機名。
（3）DNS服務器端向DNS客戶端發送回答報文，其中包含該主機名對應IP地址。
（4）瀏覽器收到DNS的IP地址後，向該IP地址定位的HTTP服務器端發起TCP連接。</li>
</ol>
<h3 id="222-http簡介"><a class="header" href="#222-http簡介">2.2.2 HTTP簡介</a></h3>
<p>HTTP（Hyper Text Transfer Protocal，超文本傳輸協議），簡單請求-響應協議，運行在TCP協議上，無狀態。它指定客戶端發送給服務器端的消息和得到的響應。請求和響應消息頭是ASCII碼；消息內容則類似MIME格式。</p>
<h3 id="223-http請求"><a class="header" href="#223-http請求">2.2.3 HTTP請求</a></h3>
<p>客戶端發送到服務器端的請求消息。</p>
<ol>
<li>請求行（Request Line）</li>
</ol>
<p>請求方法、URI、HTTP協議/協議版本組成。</p>
<table><thead><tr><th>請求方法</th><th>方法描述</th></tr></thead><tbody>
<tr><td>GET</td><td>請求頁面，並返回頁面內容，請求參數包含在URL中，提交數據最多1024byte</td></tr>
<tr><td>HEAD</td><td>類似GET，只獲取報頭</td></tr>
<tr><td>POST</td><td>提交表單或上傳文件，數據（含請求參數）包含在請求體中</td></tr>
<tr><td>PUT</td><td>取代指定內容的文檔</td></tr>
<tr><td>DELETE</td><td>刪除指定資源</td></tr>
<tr><td>OPTIONS</td><td>查看服務器的性能</td></tr>
<tr><td>CONNECT</td><td>服務器當作跳板，訪問其他網頁</td></tr>
<tr><td>TRACE</td><td>回顯服務器收到的請求，用於測試或診斷</td></tr>
</tbody></table>
<ol>
<li>請求頭（Request Header）</li>
</ol>
<table><thead><tr><th>請求頭</th><th>示例</th><th>說明</th></tr></thead><tbody>
<tr><td>Accept</td><td>Accept: text/plain, text/html</td><td>客戶端能夠接收的內容類型</td></tr>
<tr><td>Accept-charset</td><td>Accept-charset: iso-8859-5</td><td>字符編碼集</td></tr>
<tr><td>Accept-Encoding</td><td>Accept-Encoding: compress, gzip</td><td>壓縮編碼類型</td></tr>
<tr><td>Accept-Language</td><td>Accept-Language: en, zh</td><td>語言</td></tr>
<tr><td>Accept-Ranges</td><td>Accept-Ranges: bytes</td><td>子範圍字段</td></tr>
<tr><td>Authorization</td><td>Authorization: Basic dbXleoOEpePOetpoe2Ftyd==</td><td>授權證書</td></tr>
<tr><td>Cache-Control</td><td>Cache-Control: no-cache</td><td>緩存機制</td></tr>
<tr><td>Connection</td><td>Connection: close</td><td>是否需要持久連接（HTTP1.1默認持久連接）</td></tr>
<tr><td>Cookie</td><td>Cookie: $version=1; Skin=new;</td><td>請求域名下的所有cookie值</td></tr>
<tr><td>Content-Length</td><td>Content-Length: 348</td><td>內容長度</td></tr>
</tbody></table>
<ol>
<li>請求體（Request Body）</li>
</ol>
<p>HTTP請求中傳輸數據的實體。</p>
<h3 id="224-http響應"><a class="header" href="#224-http響應">2.2.4 HTTP響應</a></h3>
<p>服務器端返回給客戶端。</p>
<ol>
<li>響應狀態碼（Response Status Code）</li>
</ol>
<p>表示服務器的響應狀態。</p>
<table><thead><tr><th>狀態碼</th><th>說明</th><th>詳情</th></tr></thead><tbody>
<tr><td>100</td><td>繼續</td><td>服務器收到部分請求，等待客戶端繼續提出請求</td></tr>
<tr><td>101</td><td>切換協議</td><td>請求者已要求服務器切換協議，服務器已確認並準備切換協議</td></tr>
<tr><td>200</td><td>成功</td><td>成功處理請求</td></tr>
<tr><td>201</td><td>已創建</td><td>服務器創建了新的資源</td></tr>
<tr><td>202</td><td>已接受</td><td>已接收請求，但尚未處理</td></tr>
<tr><td>203</td><td>非授權信息</td><td>成功處理請求，但返回信息來自另一個源</td></tr>
<tr><td>204</td><td>無內容</td><td>成功處理請求，無返回內容</td></tr>
<tr><td>205</td><td>重置內容</td><td>成功處理請求，內容重置</td></tr>
<tr><td>206</td><td>部分內容</td><td>成功處理部分內容</td></tr>
<tr><td>300</td><td>多種選擇</td><td>可執行多種操作</td></tr>
<tr><td>301</td><td>永久移動</td><td>永久重定向</td></tr>
<tr><td>302</td><td>臨時移動</td><td>暫時重定向</td></tr>
<tr><td>303</td><td>查看其他位置</td><td>重定向目標文檔應通過GET獲取</td></tr>
<tr><td>304</td><td>未修改</td><td>使用上次網頁資源</td></tr>
<tr><td>305</td><td>使用代理</td><td>應使用代理訪問</td></tr>
<tr><td>307</td><td>臨時重定向</td><td>臨時從其他位置響應</td></tr>
<tr><td>400</td><td>錯誤請求</td><td>無法解析</td></tr>
<tr><td>401</td><td>未授權</td><td>無身份驗證或驗證未通過</td></tr>
<tr><td>403</td><td>禁止訪問</td><td>拒絕</td></tr>
<tr><td>404</td><td>未找到</td><td>找不到</td></tr>
<tr><td>405</td><td>方法禁用</td><td>禁用指定方法</td></tr>
<tr><td>406</td><td>不接受</td><td>無法使用內容響應</td></tr>
<tr><td>407</td><td>需要代理授權</td><td>需要使用代理授權</td></tr>
<tr><td>408</td><td>請求超時</td><td>請求超時</td></tr>
<tr><td>409</td><td>沖突</td><td>完成請求時發生沖突</td></tr>
<tr><td>410</td><td>已刪除</td><td>資源永久刪除</td></tr>
<tr><td>411</td><td>需要有效長度</td><td>不接受標頭字段不含有效內容長度</td></tr>
<tr><td>412</td><td>未滿足前提條件</td><td>服務器未滿足某個前提條件</td></tr>
<tr><td>413</td><td>請求實體過大</td><td>超出能力</td></tr>
<tr><td>414</td><td>請求URI過長</td><td>網址過長，無法處理</td></tr>
<tr><td>415</td><td>不支持類型</td><td>格式不支持</td></tr>
<tr><td>416</td><td>請求範圍不符</td><td>頁面無法提供請求範圍</td></tr>
<tr><td>417</td><td>未滿足期望值</td><td>未滿足期望請求標頭字段</td></tr>
<tr><td>500</td><td>服務器內部發生錯誤</td><td>服務器錯誤</td></tr>
<tr><td>501</td><td>未實現</td><td>不具備功能</td></tr>
<tr><td>502</td><td>錯誤網關</td><td>收到無效響應</td></tr>
<tr><td>503</td><td>服務不可用</td><td>無法使用</td></tr>
<tr><td>504</td><td>網關超時</td><td>沒及時收到請求</td></tr>
<tr><td>505</td><td>HTTP版本不支持</td><td>不支持HTTP協議版本</td></tr>
</tbody></table>
<ol>
<li>響應頭（Response Headers）</li>
</ol>
<p>包含服務器對請求的應答信息。</p>
<table><thead><tr><th>響應頭</th><th>說明</th></tr></thead><tbody>
<tr><td>Allow</td><td>服務器支持的請求方法</td></tr>
<tr><td>Content-Encondig</td><td>文檔編碼方法。</td></tr>
<tr><td>Content-Length</td><td>內容長度，瀏覽器持久HTTP連接時需要</td></tr>
<tr><td>Content-Type</td><td>文檔的MIME類型</td></tr>
<tr><td>Date</td><td>GMT時間</td></tr>
<tr><td>Expires</td><td>過期時間後，不再緩存</td></tr>
<tr><td>Last-Modified</td><td>文檔最後改動時間。通過比較客戶端頭if-Modified-Since，可能返回304（Not Modified）。</td></tr>
<tr><td>Location</td><td>客戶端應去哪裡提取文檔。</td></tr>
<tr><td>Refresh</td><td>瀏覽器應刷新時間，秒</td></tr>
<tr><td>Server</td><td>服務器名字</td></tr>
<tr><td>Set-Cookie</td><td>設置頁面關聯Cookie</td></tr>
<tr><td>WWW-Authenticate</td><td>客戶應在Authorization中提供授權信息，通常返回401。</td></tr>
</tbody></table>
<ol>
<li>響應體（Response Body）</li>
</ol>
<p>HTTP請求返回的內容。
HTML，二進制數據，JSON文檔，XML文檔等。</p>
<h3 id="225-uri與url"><a class="header" href="#225-uri與url">2.2.5 URI與URL</a></h3>
<ol>
<li>URI（Uniform Resource Identifier，統一資源標識符）
用來標識Web上每一種可用資源，概念。由資源的命名機制、存放資源的主機名、資源自身的名稱等組成。</li>
<li>URL（Uniform Resource Locator，統一資源定位符）
用於描述網絡上的資源（描述信息資源的字符串），實現。使用統一格式，包括文件、服務器地址和目錄等。</li>
</ol>
<pre><code class="language-URL">scheme://host[:port#]/path/.../[?query-string][#anchor]
//協議（服務方式）
//主機域名或IP地址（可含端口號）
//具體地址，目錄和文件名等
</code></pre>
<ol>
<li>URN（Uniform Resource Name，統一資源名）
帶有名字的因特網資源，是URL的更新形式，不依賴位置，可減少失效鏈接個數。</li>
</ol>
<h3 id="226-https簡介"><a class="header" href="#226-https簡介">2.2.6 HTTPS簡介</a></h3>
<p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer），在HTTP基礎上，通過傳輸加密和身份認證保證傳輸過程的安全型。HTTP + SSL/TLS。</p>
<p>TLS（Transport Layer Security，傳輸層安全性協議），及其前身SSL（Secure Socket Layer，安全套接字層），保障通信安全和數據完整性。</p>
<h3 id="227-http2簡介"><a class="header" href="#227-http2簡介">2.2.7 HTTP2簡介</a></h3>
<ol>
<li>HTTP協議歷史</li>
</ol>
<ul>
<li>HTTP 0.9
只支持GET方法，不支持MIME類型和HTTP各種頭信息等。</li>
<li>HTTP 1.0
增加很多方法、各種HTTP頭信息，以及對多媒體對象的處理。</li>
<li>HTTP 1.1
主流HTTP協議，改善結構性缺陷，明確語義，增刪特性，支持更復雜的Web應用程序。</li>
<li>HTTP 2
優化性能，兼容HTTP 1.1語義，是二進制協議，頭部採用HPACK壓縮，支持多路復用、服務器推送等。</li>
</ul>
<ol>
<li>HTTP 1.1與HTTP 2的對比</li>
</ol>
<ul>
<li>頭信息壓縮
HTTP 1.1中，每一次發送和響應，都有HTTP頭信息。HTTP 2壓縮頭信息，減少帶寬。</li>
<li>推送功能
HTTP 2之前，只能客戶端發送數據，服務器端返回數據。HTTP2中，服務器可以主動向客戶端發起一些數據傳輸（如css和png等），服務器可以並行發送html，css，js等數據。</li>
</ul>
<h3 id="228-web應用程序的組成"><a class="header" href="#228-web應用程序的組成">2.2.8 Web應用程序的組成</a></h3>
<ol>
<li>處理器（hendler）
接收HTTP請求並處理。調用模板引擎生成html文檔返給客戶端。</li>
</ol>
<p>MVC軟件架構模型</p>
<ul>
<li>模型（Model）
處理與業務邏輯相關的數據，以及封裝對數據的處理方法。有對數據直接訪問的權力，例如訪問數據庫。</li>
<li>視圖（View）
實現有目的的顯示數據，一般沒有程序的邏輯。</li>
<li>控制器（Controller）
組織不同層面，控制流程，處理用戶請求，模型交互等事件，並做出響應。</li>
</ul>
<p>title模型Model控制器Controller視圖View瀏覽器模板引擎數據庫</p>
<ol>
<li>模板引擎（template engine）
分離界面與數據（內容），組合模板（template）與數據（data），生成html文檔。
分為置換型（模板內容中特定標記替換）、解釋型和編譯型等。</li>
</ol>
<p>模板template數據data模板引擎HTML文檔</p>
<h2 id="23-nethttp包"><a class="header" href="#23-nethttp包">2.3 net/http包</a></h2>
<h3 id="231-創建簡單服務器端"><a class="header" href="#231-創建簡單服務器端">2.3.1 創建簡單服務器端</a></h3>
<ol>
<li>創建和解析HTTP服務器端</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;net/http&quot;
)

func sayHello(w http.ResponseWriter, req *http.Request) {
	w.Write([]byte(&quot;Hello World&quot;))
}

func main() {
	//註冊路由
	http.HandleFunc(&quot;/hello&quot;, sayHello)
	//開啟對客戶端的監聽
	http.ListenAndServe(&quot;:8080&quot;, nil)
}
http.HandleFunc()函數

//輸入參數：監聽端口號和事件處理器handler
http.ListenAndServe()函數

type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}

type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
package main

import (
	&quot;net/http&quot;
)

type Refer struct {
	handler http.Handler
	refer string
}

func (this *Refer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Referer() == this.refer {
		this.handler.ServeHTTP(w, r)
	} else {
		w.WriteHeader(403)
	}
}

func myHandler(w http.ResponseWriter, req *http.Request) {
	w.Write([]byte(&quot;this is handler&quot;))
}

func hello(w http.ResponseWriter, req *http.Request) {
	w.Write([]byte(&quot;hello&quot;))
}

func main() {
	referer := &amp;Refer{
		handler: http.HandlerFunc(myHandler),
		refer: &quot;www.shirdon.com&quot;,
	}
	http.HandleFunc(&quot;/hello&quot;, hello)
	http.ListenAndServe(&quot;:8080&quot;, referer)
}
</code></pre>
<ol>
<li>創建和解析HTTPS服務器端</li>
</ol>
<pre><code class="language-go">//證書文件路徑，私鑰文件路徑
func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error
package main

import (
	&quot;log&quot;
	&quot;net/http&quot;
)

func handle(w http.ResponseWriter, r *http.Request) {
	log.Printf(&quot;Got connection: %s&quot;, r.Proto)
	w.Write([]byte(&quot;Hello this is a HTTP 2 message!&quot;))
}

func main() {
	srv := &amp;http.Server{Addr: &quot;:8088&quot;, Handler: http.HandlerFunc(handle)}
	log.Printf(&quot;Serving on https://0.0.0.0:8088&quot;)
	log.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))
}
</code></pre>
<h3 id="232-創建簡單的客戶端"><a class="header" href="#232-創建簡單的客戶端">2.3.2 創建簡單的客戶端</a></h3>
<pre><code class="language-go">//src/net/http/client.go
var DefaultClient = &amp;Client{}

func Get(url string) (resp *Response, err error) {
	return DefaultClient.Get(url)
}

func (c *Client) Get(url string) (resp *Response, err error) {
	req, err := NewRequest(&quot;GET&quot;, url, nil)
	if err != nil {
		return nil, err
	}
	return c.Do(req)
}

func Post(url, contentType string, body io.Reader) (resp *Response, err error) {
	return DefaultClient.Post(url, contentType, body)
}

func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error) {
	req, err := NewRequest(&quot;POST&quot;, url, body)
	if err != nil {
		return nil, err
	}
	req.Header.set(&quot;Content-Type&quot;, contentType)
	return c.Do(req)
}
func NewRequest(method, url string, body io.Reader) (*Request, error)
//請求類型
//請求地址
//若body實現io.Closer接口，則Request返回值的Body字段會被設置為body值，並被Client的Do()、Post()和PostForm()方法關閉。
</code></pre>
<ol>
<li>創建GET請求</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

func main() {
	resp, err := http.Get(&quot;https://www.baidu.com&quot;)
	if err != nil {
		fmt.Println(&quot;err:&quot;, err)
	}
	closer := resp.Body
	bytes, err := ioutil.ReadAll(closer)
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>創建POST請求</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

func main() {
	url := &quot;https://www.shirdon.com/comment/add&quot;
	body := `{&quot;userId&quot;: 1, &quot;articleId&quot;: 1, &quot;comment&quot;: 這是一條評論}`
	resp, err := http.Post(url, &quot;application/x-www-form-urlencoded&quot;, bytes.NewBuffer([]byte(body)))
	if err != nil {
		fmt.Println(&quot;err:&quot;, err)
	}
	bytes, err := ioutil.ReadAll(resp.Body)
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>創建PUT請求</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

func main() {
	url := &quot;https://www.shirdon.com/comment/update&quot;
	payload := strings.NewReader(`{&quot;userId&quot;: 1, &quot;articleId&quot;: 1, &quot;comment&quot;: 這是一條評論}`)
	req, _ := http.NewRequest(&quot;PUT&quot;, url, payload)
	req.Header.Add(&quot;Content-Type&quot;, &quot;application/json&quot;)
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Println(&quot;err:&quot;, err)
	}
	defer res.Body.Close()
	bytes, err := ioutil.ReadAll(res.Body)
	fmt.Println(string(res))
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>創建DELETE請求</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

func main() {
	url := &quot;https://www.shirdon.com/comment/delete&quot;
	payload := strings.NewReader(`{&quot;userId&quot;: 1, &quot;articleId&quot;: 1, &quot;comment&quot;: 這是一條評論}`)
	req, _ := http.NewRequest(&quot;DELETE&quot;, url, payload)
	req.Header.Add(&quot;Content-Type&quot;, &quot;application/json&quot;)
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Println(&quot;err:&quot;, err)
	}
	defer res.Body.Close()
	bytes, err := ioutil.ReadAll(res.Body)
	fmt.Println(string(res))
	fmt.Println(string(bytes))
}
</code></pre>
<ol>
<li>請求頭設置</li>
</ol>
<pre><code class="language-go">type Header map[string][]string
headers := http.Header{&quot;token&quot;: {&quot;feeowiwpor23dlspweh&quot;}}
headers.Add(&quot;Accept-Charset&quot;, &quot;UTF-8&quot;)
headers.Set(&quot;Host&quot;, &quot;www.shirdon.com&quot;)
headers.Set(&quot;Location&quot;, &quot;www.baidu.com&quot;)
</code></pre>
<h2 id="24-htmltemplate包"><a class="header" href="#24-htmltemplate包">2.4 html/template包</a></h2>
<p>text/template處理任意格式的文本，html/template生成可對抗代碼注入的安全html文檔。</p>
<h3 id="241-模板原理"><a class="header" href="#241-模板原理">2.4.1 模板原理</a></h3>
<ol>
<li>模板和模板引擎
模板是事先定義好的不變的html文檔，模板渲染使用可變數據替換html文檔中的標記。模板用於顯示和數據分離（前後端分離）。模板技術，本質是模板引擎利用模板文件和數據生成html文檔。</li>
<li>Go語言模板引擎</li>
</ol>
<ul>
<li>模板文件後綴名通常為.tmpl和.tpl，UTF-8編碼</li>
<li>模板文件中{{和}}包裹和標識傳入數據</li>
<li>點號（.）訪問數據，{{.FieldName}}訪問字段</li>
<li>除{{和}}包裹內容外，其他內容原樣輸出</li>
</ul>
<p>使用：
（1）定義模板文件
按照相應語法規則去定義。
（2）解析模板文件
創建指定模板名稱的模板對象</p>
<pre><code class="language-go">func New(name string) *Template
</code></pre>
<p>解析模板內容</p>
<pre><code class="language-go">func (t *Template) Parse(src string) (*Template, error)
</code></pre>
<p>解析模板文件</p>
<pre><code class="language-go">func ParseFiles(filenames...string) (*Template, error)
</code></pre>
<p>正則匹配解析文件，template.ParaeGlob(“a*”)</p>
<pre><code class="language-go">func ParseGlob(pattern string) (*Template, error)
</code></pre>
<p>（3）渲染模板文件</p>
<pre><code class="language-go">func (t *Template) Execute(wr io.Writer, data interface{}) error

//配合ParseFiles()函數使用，需指定模板名稱
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error
</code></pre>
<h3 id="242-使用htmltemplate包"><a class="header" href="#242-使用htmltemplate包">2.4.2 使用html/template包</a></h3>
<ol>
<li>第1個模板
template_example.tmpl</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;模板使用示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;p&gt;加油，小夥伴， {{ . }} &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
package main

import (
	&quot;fmt&quot;
	&quot;html/template&quot;
	&quot;net/http&quot;
)

func helloHandleFunc(w http.ResponseWriter, r *http.Request) {
	// 1. 解析模板
	t, err := template.ParseFiles(&quot;./template_example.tmpl&quot;)
	if err != nil {
		fmt.Println(&quot;template parsefile failed, err:&quot;, err)
		return
	}
	// 2.渲染模板
	name := &quot;我愛Go語言&quot;
	t.Execute(w, name)
}

func main() {
	http.HandleFunc(&quot;/&quot;, helloHandleFunc)
	http.ListenAndServe(&quot;:8086&quot;, nil)
}
</code></pre>
<ol>
<li>模板語法
模板語法都包含在{{和}}中間。</li>
</ol>
<pre><code class="language-go">type UserInfo struct {
	Name string
	Gender string
	Age int
}

func sayHello(w http.ResponseWriter, r *http.Request) {
	tmpl, err := template.ParseFiles(&quot;./hello.html&quot;)
	if err != nil {
		fmp.Println(&quot;create template failed, err:&quot;, err)
		return
	}

	user := UserInfo {
		Name: &quot;張三&quot;,
		Gender: &quot;男&quot;,
		Age: 28,
	}
	tmpl.Execute(w, user)
}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;p&gt;Hello {{.Name}}&lt;/p&gt;
   &lt;p&gt;性別：{{.Gender}}&lt;/p&gt;
   &lt;p&gt;年齡：{{.Age}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>常用語法：</p>
<ul>
<li>注釋</li>
</ul>
<pre><code class="language-go">{{/* 這是一個注釋，不會解析 */}}
</code></pre>
<ul>
<li>管道（pipeline）
產生數據的操作，{{.Name}}等。支持|鏈接多個命令，類似UNIX下管道。</li>
<li>變量
變量捕獲管道的執行結果。</li>
</ul>
<pre><code class="language-go">$variable := pipeline
</code></pre>
<ul>
<li>條件判斷</li>
</ul>
<pre><code class="language-go">{{if pipeline}} T1 {{end}}
{{if pipeline}} T1 {{else}} T0 {{end}}
{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
</code></pre>
<ul>
<li>range關鍵字</li>
</ul>
<pre><code class="language-go">{{range pipeline}} T1 {{end}}
{{range pipeline}} T1 {{else}} T0 {{end}}
package main

import (
	&quot;log&quot;
	&quot;os&quot;
	&quot;text/template&quot;
)

func main() {
	//創建一個模版
	rangeTemplate := `
{{if .Kind}}
{{range $i, $v := .MapContent}}
{{$i}} =&gt; {{$v}} , {{$.OutsideContent}}
{{end}}
{{else}}
{{range .MapContent}}
{{.}} , {{$.OutsideContent}}
{{end}}    
{{end}}`

	str1 := []string{&quot;第一次 range&quot;, &quot;用 index 和 value&quot;}
	str2 := []string{&quot;第二次 range&quot;, &quot;沒有用 index 和 value&quot;}

	type Content struct {
		MapContent     []string
		OutsideContent string
		Kind           bool
	}
	var contents = []Content{
		{str1, &quot;第一次外面的內容&quot;, true},
		{str2, &quot;第二次外面的內容&quot;, false},
	}

	// 創建模板並將字符解析進去
	t := template.Must(template.New(&quot;range&quot;).Parse(rangeTemplate))

	// 接收並執行模板
	for _, c := range contents {
		err := t.Execute(os.Stdout, c)
		if err != nil {
			log.Println(&quot;executing template:&quot;, err)
		}
	}
}
/*
//輸出
0 =&gt; 第一次 range, 第一次外面的內容
1 =&gt; 用 index 和 value, 第一次外面的內容

第二次 range, 第二次外面的內容
沒有用 index 和 value, 第二次外面的內容
*/
</code></pre>
<ul>
<li>with關鍵字</li>
</ul>
<pre><code class="language-go">{{with pipeline}} T1 {{end}}
{{with pipeline}} T1 {{else}} T0 {{end}}
</code></pre>
<ul>
<li>比較函數
比較函數只適用於基本函數（或重定義的基本類型，如type Banance float32），整數和浮點數不能相互比較。
布爾函數將任何類型的零值視為假。
只有eq可以接受2個以上參數。</li>
</ul>
<pre><code class="language-go">{{eq arg1 arg2 arg3}}
eq
ne
lt
le
gt
ge
</code></pre>
<ul>
<li>預定義函數</li>
</ul>
<table><thead><tr><th>函數名</th><th>功能</th></tr></thead><tbody>
<tr><td>and</td><td>返回第1個空參數或最後一個參數，所有參數都執行。and x y等價於if x then y else x</td></tr>
<tr><td>or</td><td>返回第1個非空參數或最後一個參數，所有參數都執行。and x y等價於if x then y else x</td></tr>
<tr><td>not</td><td>非</td></tr>
<tr><td>len</td><td>長度</td></tr>
<tr><td>index</td><td>index y 1 2 3, index[1][2][3]</td></tr>
<tr><td>print</td><td>fmt.Sprint</td></tr>
<tr><td>printf</td><td>fmt.Sprintf</td></tr>
<tr><td>println</td><td>fmt.Sprintln</td></tr>
<tr><td>html</td><td>html逸碼等價表示</td></tr>
<tr><td>urlquery</td><td>可嵌入URL查詢的逸碼等價表示</td></tr>
<tr><td>js</td><td>JavaScript逸碼等價表示</td></tr>
<tr><td>call</td><td>call func a b, func(a, b);1或2個返回值，第2個為error，非nil會中斷並返回給調用者。</td></tr>
</tbody></table>
<ul>
<li>自定義函數
模板對象t的函數字典加入funcMap內的鍵值對。funcMap某個值不是函數類型，或該函數類型不符合要求，會panic。返回*Template便於鏈式調用。</li>
</ul>
<pre><code class="language-go">func (t *Template) Funcs(funcMap FuncMap) *Template
</code></pre>
<p>FuncMap映射函數要求1或2個返回值，第2個為error，非nil會中斷並返回給調用者。</p>
<pre><code class="language-go">type FuncMap map[string]interface{}
package main

import (
	&quot;fmt&quot;
	&quot;html/template&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

func Welcome() string { //沒參數
	return &quot;Welcome&quot;
}

func Doing(name string) string { //有參數
	return name + &quot;, Learning Go Web template &quot;
}

func sayHello(w http.ResponseWriter, r *http.Request) {
	htmlByte, err := ioutil.ReadFile(&quot;./funcs.html&quot;)
	if err != nil {
		fmt.Println(&quot;read html failed, err:&quot;, err)
		return
	}
	// 自定義一個匿名模板函數
	loveGo := func() (string) {
		return &quot;歡迎一起學習《Go Web編程實戰派從入門到精通》&quot;
	}
	// 採用鏈式操作在Parse()方法之前調用Funcs添加自定義的loveGo函數
	tmpl1, err := template.New(&quot;funcs&quot;).Funcs(template.FuncMap{&quot;loveGo&quot;: loveGo}).Parse(string(htmlByte))
	if err != nil {
		fmt.Println(&quot;create template failed, err:&quot;, err)
		return
	}
	funcMap := template.FuncMap{
		//在FuncMap中聲明相應要使用的函數，然後就能夠在template字符串中使用該函數
		&quot;Welcome&quot;: Welcome,
		&quot;Doing&quot;:   Doing,
	}
	name := &quot;Shirdon&quot;
	tmpl2, err := template.New(&quot;test&quot;).Funcs(funcMap).Parse(&quot;{{Welcome}}&lt;br/&gt;{{Doing .}}&quot;)
	if err != nil {
		panic(err)
	}

	// 使用user渲染模板，並將結果寫入w
	tmpl1.Execute(w, name)
	tmpl2.Execute(w, name)
}

func main() {
	http.HandleFunc(&quot;/&quot;, sayHello)
	http.ListenAndServe(&quot;:8087&quot;, nil)
}
</code></pre>
<p>funcs.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
		&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
		&lt;title&gt;tmpl test&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;{{loveGo}}&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>模板嵌套
可以通過文件嵌套和define定義</li>
</ul>
<pre><code class="language-go">{{define &quot;name&quot;}} T {{end}}
{{template &quot;name&quot;}}
{{template &quot;name&quot; pipeline}}
{{block &quot;name&quot; pipeline}} T {{end}}
//等價於
{{define &quot;name&quot;}} T {{end}}
{{template &quot;name&quot; pipeline}}
</code></pre>
<p>t.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;tmpl test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;測試嵌套template語法&lt;/h1&gt;
&lt;hr&gt;
{{template &quot;ul.html&quot;}}
&lt;hr&gt;
{{template &quot;ol.html&quot;}}
&lt;/body&gt;
&lt;/html&gt;
{{define &quot;ol.html&quot;}}
&lt;h1&gt;這是ol.html&lt;/h1&gt;
&lt;ol&gt;
    &lt;li&gt;I love Go&lt;/li&gt;
    &lt;li&gt;I love java&lt;/li&gt;
    &lt;li&gt;I love c&lt;/li&gt;
&lt;/ol&gt;
{{end}}
</code></pre>
<p>ul.html</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;注釋&lt;/li&gt;
    &lt;li&gt;日誌&lt;/li&gt;
    &lt;li&gt;測試&lt;/li&gt;
&lt;/ul&gt;
package main

import (
	&quot;fmt&quot;
	&quot;html/template&quot;
	&quot;net/http&quot;
)

//定義一個UserInfo結構體
type UserInfo struct {
	Name string
	Gender string
	Age int
}

func tmplSample(w http.ResponseWriter, r *http.Request) {
	tmpl, err := template.ParseFiles(&quot;./t.html&quot;, &quot;./ul.html&quot;)
	if err != nil {
		fmt.Println(&quot;create template failed, err:&quot;, err)
		return
	}
	user := UserInfo{
		Name:   &quot;張三&quot;,
		Gender: &quot;男&quot;,
		Age:    28,
	}
	tmpl.Execute(w, user)
	fmt.Println(tmpl)
}

func main() {
	http.HandleFunc(&quot;/&quot;, tmplSample)
	http.ListenAndServe(&quot;:8087&quot;, nil)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="golang-單步除錯利器--delve"><a class="header" href="#golang-單步除錯利器--delve">Golang 單步除錯利器 — Delve</a></h2>
<p><a href="https://golang.org/">Golang</a> 是一個靜態語言，雖然也有支援 GDB，但<a href="https://golang.org/doc/gdb">官方也有說</a>，若單純使用內建的 toolchain，推薦使用 <a href="https://github.com/derekparker/delve">Delve</a> 這個工具，因為 GDB 對於 Go 的 stack 管理、線程或執行時期的環境，並沒有支援的很完善，有時甚至會看到錯誤的狀態。</p>
<p>Delve 也是單步執行工具，和 GDB 很像，但是他更方便安裝，本身也是 go 的 package 之一，安裝方法如下：</p>
<p>Mac 要先安裝編譯用的 toolchain：</p>
<pre><code>$ xcode-select --install
$ go get -u github.com/derekparker/delve/cmd/dlv
</code></pre>
<p>對於 Windows 和 Linux 系統，只需要執行 <code>go get</code>即可：</p>
<p>https://github.com/go-delve/delve/tree/master/Documentation/installation</p>
<pre><code>$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3
</code></pre>
<p>記得，所有平臺都要先將 <code>$GOPATH/bin</code> 加入系統環境 <code>PATH</code>變數，這樣才找得到執行檔。</p>
<h2 id="除錯"><a class="header" href="#除錯">除錯</a></h2>
<p>首先，我們用下面的程式當作範例：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func demo(s string, x int) string {
    ret := fmt.Sprintf(&quot;This is a demo, your input is: %s %d&quot;, s, x)
    return ret
}

func main() {
    s := &quot;string&quot;
    i := 1111
    fmt.Println(demo(s, i))
}
</code></pre>
<p>存檔成為 <code>delve-demo.go</code></p>
<p>接著，在 console 使用 <code>dlv debug &lt;filename&gt;</code>將 delve 跑起來：</p>
<pre><code>$ dlv debug delve-demo.go --check-go-version=false
</code></pre>
<p>你會看到下面的訊息：</p>
<pre><code>$ dlv debug delve-demo.go                                                                                                                                  system
Type 'help' for list of commands.
(dlv) 
</code></pre>
<p>但其實程式還沒真的跑起來，此時可以先設定中斷點，再來跑程式。</p>
<p>設定中斷點：
使用 <code>&lt;package&gt;.&lt;function&gt;</code>或是 <code>&lt;filename&gt;:&lt;line number&gt;</code>的格式：</p>
<pre><code># 方法 1
(dlv) break main.main
Breakpoint 1 set at 0x10b0958 for main.main() ./delve-demo.go:12# 方法 2
(dlv) break delve-demo.go:7
Breakpoint 2 set at 0x10b0758 for main.demo() ./delve-demo.go:7
</code></pre>
<p>接著使用 <code>c</code> 或是 <code>continue</code>讓程式跑起來，你就會看到 dlv 停在中斷點上：</p>
<pre><code>(dlv) b main.main
Breakpoint 1 set at 0x10b0958 for main.main() ./delve-demo.go:12
(dlv) c
&gt; main.main() ./delve-demo.go:12 (hits goroutine(1):1 total:1) (PC: 0x10b0958)
     7: func demo(s string, x int) string {
     8:  ret := fmt.Sprintf(&quot;This is a demo, your input is: %s %d&quot;, s, x)
     9:  return ret
    10: }
    11:
=&gt;  12: func main() {
    13:  s := &quot;string&quot;
    14:  i := 1111
    15:  fmt.Println(demo(s, i))
    16: }
(dlv)
</code></pre>
<p>其他使用方式就和 GDB 雷同，下面把比較常用的指令列出來：</p>
<p>單部執行： <code>n</code> 或 <code>next</code>跳進去函式 (step in)： <code>s</code> 或 <code>step</code>跳出函式 (step out)： <code>stepout</code>看函式引數： <code>args</code>
例如：</p>
<pre><code>(dlv) args
s = &quot;string&quot;
x = 1111
</code></pre>
<p>印出參數或表達式： <code>print &lt;參數&gt;</code>
例如：</p>
<pre><code>(dlv) p x
1111
(dlv) p x+5
1116
(dlv) p x != 5
true
</code></pre>
<p>印出目前所有的 goroutine：</p>
<pre><code>(dlv) goroutines
[4 goroutines]
* Goroutine 1 - User: ./delve-demo.go:9 main.demo (0x10b08e9) (thread 2350822)
  Goroutine 2 - User: /usr/local/Cellar/go/1.10.3/libexec/src/runtime/proc.go:292 runtime.gopark (0x102c209)
  Goroutine 3 - User: /usr/local/Cellar/go/1.10.3/libexec/src/runtime/proc.go:292 runtime.gopark (0x102c209)
  Goroutine 4 - User: /usr/local/Cellar/go/1.10.3/libexec/src/runtime/proc.go:292 runtime.gopark (0x102c209)
</code></pre>
<p>更多詳細的指令可以參考 <a href="https://github.com/derekparker/delve/blob/master/Documentation/cli/README.md">github 說明</a>。</p>
<h2 id="testing-除錯"><a class="header" href="#testing-除錯">testing 除錯</a></h2>
<p>如果要在跑 go test 的時候除錯也很容易，要跑全部的 test case 只要執行</p>
<pre><code>dlv test -- -test.v
# 如同
go test ./...
</code></pre>
<p>或是隻執行單個測資：</p>
<pre><code>dlv test -- -test.run &lt;test function&gt;
# 如同
go test -run &lt;test function&gt;
</code></pre>
<p>Happy debugging！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="從一知半解到略懂-go-modules"><a class="header" href="#從一知半解到略懂-go-modules">從一知半解到略懂 Go modules</a></h2>
<p>一直以來沒有好好去詳讀 go modules 的文件，所以都覺得對 go modules 只是一知半解。這次花了些時間看了關於 go modules 的相關文件，並實際寫個小範例體驗，最後整理成本文分享。</p>
<h3 id="本文環境"><a class="header" href="#本文環境">本文環境</a></h3>
<ul>
<li>macOS 10.15</li>
<li>Go 1.13</li>
</ul>
<h3 id="引言"><a class="header" href="#引言">引言</a></h3>
<p>先前 <a href="https://myapollo.com.tw/zh-tw/golang-hello-world-gopath/">Golang - 從 Hello World 認識 GOPATH</a> 一文中，我們認識了 GOPATH 的作用，然而 GOPATH 會讓我們的專案程式碼與其他相依的程式碼一起存在 <code>$GOPATH/src</code> 資料夾底下，相較於其他程式語言而言，使用上較不直覺，也欠缺相依性管理的功能。</p>
<p>Go 1.11 之後提供 <a href="https://blog.golang.org/using-go-modules">go modules</a> 讓我們可以不需要把專案程式碼放在 <code>$GOPATH/src</code> 中開發，此外還能管理套件相依性，相當便利。</p>
<h3 id="go-modules-初體驗"><a class="header" href="#go-modules-初體驗">Go modules 初體驗</a></h3>
<p>首先設置好 GOPATH 之後，先在 <code>$GOPATH/src</code> 之外，新增 1 個資料夾存放專案程式：</p>
<pre><code>$ export GOPATH=/path/to/goworkspace
$ mkdir myproject
$ cd myproject
</code></pre>
<p>接著用以下指令新增 Go module:</p>
<pre><code>$ go mod init github.com/username/myproject
</code></pre>
<p>p.s. <code>github.com/username/myproject</code> 可以換成任意字串，因為個人希望將 Go module 放置於 GitHub, 因此將模組名稱設定為 <code>github.com/username/myproject</code></p>
<p>上述指令成功後，將會看到資料夾內出現 1 個檔案 <code>go.mod</code> :</p>
<pre><code>module github.com/username/myproject

go 1.13
</code></pre>
<p><code>go.mod</code> 用來紀錄 Go module 的名稱與所使用的 Go 版本，以及相依的 Go modules, 該檔案是 Go module 必備的檔案</p>
<p>再來新增 2 個資料夾，以及 2 個 <code>.go</code> 檔，建立範例所需要的環境：</p>
<pre><code>$ mkdir greeting cli
$ touch greeting/greeting.go cli/say.go
</code></pre>
<p>進行至此， <code>myproject</code> 的資料夾結構應如下所示：</p>
<pre><code>.
├── cli
│   └── say.go
├── go.mod
└── greeting
    └── greeting.go
</code></pre>
<p>最後將 <code>greeting.go</code> 與 <code>say.go</code> 填入以下程式碼。 <code>greeting.go</code> 是 1 個簡單的 package, 用以列印所傳入的字串；而 <code>say.go</code> 則是用以呼叫 <code>greeting.go</code> package 所提供的函示。</p>
<p><code>greeting.go</code> 的內容：</p>
<pre><code class="language-go">package greeting

import &quot;fmt&quot;

func Say(s string) {
    fmt.Println(s)
}
</code></pre>
<p><code>say.go</code> 的內容：</p>
<pre><code class="language-go">package main

import &quot;github.com/username/myproject/greeting&quot;

func main() {
    greeting.Say(&quot;Hello&quot;)
}
</code></pre>
<p>最後，試著編譯一次，正常的話不會有任何錯誤訊息：</p>
<pre><code>$ go build ./...
</code></pre>
<p>至此，我們已經利用 go modules 成功地將 Go 專案移出 <code>$GOPATH/src</code> 囉！</p>
<p>p.s. 如果把 <code>go.mod</code> 刪除的話，就會發現類似以下的錯誤，這是由於 go 找不到 <code>go.mod</code> 因此轉而至 <code>$GOPATH</code> 尋找相關的 go package 的緣故：</p>
<pre><code>cli/say.go:3:8: cannot find package &quot;github.com/username/myproject/greeting&quot; in any of:
    /usr/local/go/src/github.com/username/myproject/greeting (from $GOROOT)
    $GOPATH/src/github.com/username/myproject/greeting (from $GOPATH)
</code></pre>
<h3 id="使用-go-modules-進行套件相依性管理"><a class="header" href="#使用-go-modules-進行套件相依性管理">使用 go modules 進行套件相依性管理</a></h3>
<p>Go modules 提供的另一個方便的功能則是套件相依性管理，接下來實際透過以下指令安裝套件試試：</p>
<pre><code>$ go get github.com/fatih/color
</code></pre>
<p>安裝成功之後，可以再看一次 <code>go.mod</code> ，會發現多了 1 行 <code>require github.com/fatih/color v1.9.0</code> :</p>
<pre><code>module github.com/username/myproject

go 1.13

require github.com/fatih/color v1.9.0
</code></pre>
<p><code>require github.com/fatih/color v1.9.0</code> 目前的 Go 專案需要 v1.9.0 版的 <code>github.com/fatih/color</code> 。</p>
<p>p.s. go modules 使用的版本號規則是<a href="https://semver.org/">semantic version</a> , 有興趣的話，可以詳閱該文件</p>
<p>有時候我們可能會需要使用指定版本的 package, 這時候可以在 package 尾端加上 <code>@版本號</code> ，例如以下指定使用 v1.8.0 的 <code>github.com/fatih/color</code> ：</p>
<pre><code>$ go get github.com/fatih/color@v1.8.0
</code></pre>
<p>安裝完成後，再看一次 <code>go.mod</code> 會發現除了 <code>github.com/fatih/color</code> 版本變為 v1.8.0 之外，又多了 2 個 <code>//indirect</code> 的 go packages:</p>
<pre><code class="language-go">module github.com/username/myproject

go 1.13

require (
    github.com/fatih/color v1.8.0
    github.com/mattn/go-colorable v0.1.4 // indirect
    github.com/mattn/go-isatty v0.0.11 // indirect
)
</code></pre>
<p><code>//indirect</code> 指的是被相依的套件所使用的 packages:</p>
<blockquote>
<p>The indirect comment indicates a dependency is not used directly by this module, only indirectly by other module dependencies.</p>
</blockquote>
<p>另一種常見情況是我們可能會指定 package 到某個 commit id, 這時候就能夠使用 <a href="https://golang.org/cmd/go/#hdr-Pseudo_versions">pseudo-version</a> ，例如 <code>v0.0.0-20170915032832-14c0d48ead0c</code> 就是 1 個指定使用 <code>20170915032832-14c0d48ead0c</code> commit 的 pseudo-version.</p>
<blockquote>
<p><a href="https://golang.org/cmd/go/#hdr-Pseudo_versions">pseudo-version</a> , which is the go command’s version syntax for a specific untagged commit.</p>
</blockquote>
<p>接著，可以再把 <code>greeting.go</code> 與 <code>say.go</code> 改為以下形式，使用剛剛所安裝的 package 。</p>
<p><code>greeting.go</code> 的內容:</p>
<pre><code class="language-go">package greeting

import &quot;fmt&quot;

import &quot;github.com/fatih/color&quot;

func Say(s string) {
    fmt.Println(s)
}

func SayWithColor(s string) {
    color.Red(s)
}
</code></pre>
<p><code>say.go</code> 的內容：</p>
<pre><code class="language-go">package main

import &quot;github.com/username/myproject/greeting&quot;

func main() {
    greeting.Say(&quot;Hello&quot;)
    greeting.SayWithColor(&quot;World&quot;)
}
</code></pre>
<h3 id="gomod-的-replace-語法"><a class="header" href="#gomod-的-replace-語法"><code>go.mod</code> 的 replace 語法</a></h3>
<p><code>go.mod</code> 還提供 <code>replace</code> 語法，能夠讓我們取代指定的套件，例如 <code>replace github.com/fatih/color =&gt; ../mycolor</code> 代表至 <code>../mycolor</code> 資料夾中載入 <code>github.com/fatih/color</code> package, 例如以下的 <code>go.mod</code> :</p>
<pre><code class="language-go">module github.com/username/myproject

go 1.13

require (
    github.com/fatih/color v1.8.0
    github.com/mattn/go-colorable v0.1.4 // indirect
    github.com/mattn/go-isatty v0.0.11 // indirect
)

replace github.com/fatih/color =&gt; ../mycolor
</code></pre>
<p>除了直接編輯 <code>go.mod</code> 之外，也可以用以下指令：</p>
<pre><code>$ go mod edit -replace github.com/fatih/color=../mycolor
</code></pre>
<p><code>replace</code> 能夠讓我們輕易地將特定 package 重新定位到特定路徑下，除了能夠方便修改之外，也能夠讓我們更輕鬆地測試 package 不同版本的行為等等，值得注意的是特定路徑下的 package 也必須有 <code>go.mod</code> 檔才行</p>
<p><code>../mycolor</code> 是代表在 <code>go.mod</code> 檔案的所在目錄的上一層，所以可以先切換至上一層目錄後，再次下載 <code>https://github.com/fatih/color</code> 試試：</p>
<pre><code>$ cd ../
$ git clone https://github.com/fatih/color mycolor
</code></pre>
<p>此時的資料夾結構應該會類似以下：</p>
<pre><code>.
├── mycolor
│   ├── LICENSE.md
│   ├── README.md
│   ├── color.go
│   ├── color_test.go
│   ├── doc.go
│   ├── go.mod
│   ├── go.sum
│   └── vendor
├── myproject
│   ├── cli
│   ├── go.mod
│   ├── go.sum
│   └── greeting
└── pkg
</code></pre>
<p>接著回到 <code>myproject</code> 試著編譯看看，正常的話就不會出現任何訊息：</p>
<pre><code>$ cd myproject
$ go build ./...
</code></pre>
<p>如此代表成功體驗 replace 的功用了！</p>
<h3 id="結語-1"><a class="header" href="#結語-1">結語</a></h3>
<p>以上就是關於 go modules 的一些解說與用法，還有很多細節可以詳閱官方文件，相信大家閱讀之後都可以有不少收獲！</p>
<p>Happy coding!</p>
<h3 id="references-1"><a class="header" href="#references-1">References</a></h3>
<p>https://blog.golang.org/using-go-modules</p>
<p>https://golang.org/ref/mod</p>
<h3 id="出處"><a class="header" href="#出處">出處</a></h3>
<p>https://myapollo.com.tw/zh-tw/golang-go-module-tutorial/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-modules"><a class="header" href="#go-modules">Go modules</a></h1>
<p><strong>避免重複造輪子</strong> ，所以今天要介紹的就是怎麼使用 Go modules 引用外部的 library</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>這邊要使用 <code>go mod init &lt;project-name&gt;</code> 進行初始化（類似 <code>npm init</code>），完成後會多一個檔案 <code>go.mod</code>（就像 Nodejs 中的 <code>package.json</code>），因為現在都還沒安裝任何依賴所以 <code>go.mod</code> 裡面只有一行 <code>module go-phishing</code></p>
<pre><code class="language-go"> go mod init go-phishing
</code></pre>
<h3 id="安裝使用-dependencies"><a class="header" href="#安裝使用-dependencies">安裝、使用 dependencies</a></h3>
<pre><code class="language-go">go get github.com/sirupsen/logrus
</code></pre>
<pre><code class="language-go">package main

import (
  &quot;github.com/sirupsen/logrus&quot;
)

func main() {
  logrus.SetLevel(logrus.TraceLevel)

  logrus.Trace(&quot;trace msg&quot;)
  logrus.Debug(&quot;debug msg&quot;)
  logrus.Info(&quot;info msg&quot;)
  logrus.Warn(&quot;warn msg&quot;)
  logrus.Error(&quot;error msg&quot;)
  logrus.Fatal(&quot;fatal msg&quot;)
  logrus.Panic(&quot;panic msg&quot;)
}
</code></pre>
<pre><code class="language-go">go run main.go
</code></pre>
<p>編譯完再看一下 <code>go.mod</code> 裡面就有 <code>logrus</code> 了，跟 Nodejs 的 <code>package.json</code> 長得很像</p>
<pre><code class="language-go">module go-phishing

go 1.18

require (
	github.com/sirupsen/logrus v1.8.1 // indirect
	golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 // indirect
)
</code></pre>
<h2 id="gosum"><a class="header" href="#gosum"><code>go.sum</code></a></h2>
<p>編譯完之後除了 <code>go.mod</code> 之外還會多出一個檔案 <code>go.sum</code>，因為 <code>logrus</code> 也會用到某些 package，裡面記錄的是所有用到的 package 版本，類似 Nodejs 的 <code>package-lock.json</code>，如果你有在使用 git 之類的版本控制系統，記得要在 commit 時把它加進去</p>
<pre><code class="language-sh">github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE=
github.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
</code></pre>
<h2 id="go-modules-指令介紹-1"><a class="header" href="#go-modules-指令介紹-1">Go Modules 指令介紹</a></h2>
<pre><code>Usage:go mod &lt;command&gt; [arguments]The commands are:download    // 將依賴全部下載到本機中，位置為 $GOPATH/pkg/mod/cache
edit        // 編輯 go.mod 例如鎖定某個依賴的版本
graph       // 列出專案中哪一個部分使用了某個依賴
init        // 建立 go.mod
tidy        // 增加遺失的依賴，移除未使用的依賴
vendor      // 將既有的 go.mod 依賴全部存在 /vendor 底下
verify      // 驗證本地依賴依然符合 go.sum 
why         // 解釋某個依賴為何存在在 go.mod 中，誰使用了它
</code></pre>
<h2 id="如何在一個新的專案使用-go-modules"><a class="header" href="#如何在一個新的專案使用-go-modules">如何在一個新的專案使用 Go Modules？</a></h2>
<p>以下以 OSX 為例</p>
<pre><code>// 先確認 Go 的版本已經在 1.11 以上
$ brew upgrade go$ mkdir gomod-test // 請確定當前位置在 $GOPATH 以外的地方
$ cd gomod-test
</code></pre>
<p>其實不一定要在 <code>$GOPATH</code> 以外的地方，只是當前 Go Modules 還在實驗階段，如果是在 <code>$GOPATH</code> 的專案，預設依然會照舊有的 vendor 機制，除非將環境變數 <code>GO111MODULE</code> 該為 <code>on</code> 來強制開啟，但既然 Go Modules 一個重要的性質是去除 <code>$GOPATH</code> ，就讓我們試試看在其他地方開專案吧！</p>
<p>接著初始化 Go Modules</p>
<pre><code>$ go mod init github.com/hieven/gomod-test
</code></pre>
<p>便會看到專案底下出現 <code>go.mod</code> 的檔案，而這也是最重要的檔案，之後會紀錄每一個 dependency 以及版本。現在應該長得像這樣</p>
<pre><code>// go.mod
module github.com/hieven/gomod-test
</code></pre>
<p>最後讓我們做一個簡單的 hello world</p>
<pre><code>// main.go
package mainimport &quot;fmt&quot;func main() {
  fmt.Println(&quot;hello world&quot;)
}
</code></pre>
<p>此時還沒有任何改變，但接著我們嘗試加入一個 dependency</p>
<pre><code>package mainimport &quot;fmt&quot;
import &quot;github.com/gofrs/uuid&quot;func main() {
  uuid, _ := uuid.NewV4()
  
  fmt.Println(&quot;hello world&quot;, uuid)
}
</code></pre>
<p>接著運行程式 <code>$ go run main.go</code> 會發現程式神奇的運作了</p>
<pre><code>$ hello world 3f99abff-8404-42ec-b9f6-5fa165e5d447
</code></pre>
<p>再來檢查 <code>go.mod</code> ，會發現已經多了一個 dependency</p>
<pre><code>module github.com/hieven/gomod-testrequire (
  github.com/gofrs/uuid v3.1.0+incompatible
)
</code></pre>
<p>原因是 Go Modules 不僅僅是一個 <code>go mod xxx</code> 的工具而已，同時也整合了既有的 <code>go get</code>、<code>go run</code>、<code>go build</code>、<code>go test</code> ，每當這些指令運行時，都會去檢查整個 project 底下新的 dependency 並自動更新到 <code>go.mod</code> 底下</p>
<h2 id="既有的專案如何遷移至-go-modules"><a class="header" href="#既有的專案如何遷移至-go-modules">既有的專案如何遷移至 Go Modules？</a></h2>
<p>剛好在既有的 project 中分別有用 glide 以及 govendor，所以剛好都試過這兩個的遷移方法，其實非常簡單。只要到 project 底下執行</p>
<pre><code>$ go mod init
</code></pre>
<p>便自動會去讀 <code>glide.yaml</code> 或是 <code>vendor/vendor.json</code> 並產生一個 <code>go.mod</code> 。個人目前還沒有遇到問題</p>
<p>如果有興趣的人可以參考我在 <a href="https://github.com/hieven/go-instagram/pull/22">go-instagram</a> 中的一個 PR，便是把 glide 轉移成 Go Modules</p>
<p>此外，可以試試看執行</p>
<pre><code>$ go mod tidy
</code></pre>
<p>來移除沒使用的依賴，我自己的私人專案在使用 tidy 之後，成功移除了好幾個呢！</p>
<h2 id="如何讓-travis-能使用-go-modules"><a class="header" href="#如何讓-travis-能使用-go-modules">如何讓 Travis 能使用 Go Modules？</a></h2>
<p>基本上現在的 Travis 也有支援 Go 1.11 了，所以 Go Modules 自然而然就有了。</p>
<p>唯一要特別注意的是， Travis 底下預設把 project 放在 <code>$GOPATH</code> 底下，所以要在 env 中把 Go Modules 打開才行</p>
<p>具體設定就是要注意這兩行</p>
<pre><code>// .travis.ymlgo:
  - &quot;1.11&quot;env:
  - GO111MODULE=on
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang大殺器之跟蹤剖析trace"><a class="header" href="#golang大殺器之跟蹤剖析trace">Golang大殺器之跟蹤剖析trace</a></h1>
<p>在 Go 中有許許多多的分析工具，在之前我有寫過一篇 《Golang 大殺器之性能剖析 PProf》 來介紹 PProf，如果有小夥伴感興趣可以去我博客看看。</p>
<p>但單單使用 PProf 有時候不一定足夠完整，因為在真實的程序中還包含許多的隱藏動作，例如 Goroutine 在執行時會做哪些操作？執行/阻塞了多長時間？在什麼時候阻止？在哪裡被阻止的？誰又鎖/解鎖了它們？GC 是怎麼影響到 Goroutine 的執行的？這些東西用 PProf 是很難分析出來的，但如果你又想知道上述的答案的話，你可以用本文的主角 <code>go tool trace</code> 來打開新世界的大門。目錄如下：</p>
<ul>
<li>
<ol>
<li>初步瞭解</li>
</ol>
<ul>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__1_1">1.1. Scheduler latency profile</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__1_2">1.2. Goroutine analysis</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__1_3">1.3. View trace</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__1_4">1.4. View Events</a></li>
</ul>
</li>
<li>
<ol start="2">
<li>結合實戰</li>
</ol>
<ul>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__2_1">2.1. View trace</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__2_2">2.2. Network blocking profile</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__2_3">2.3. Syscall blocking profile</a></li>
</ul>
</li>
<li>
<p><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__3">3. 總結</a></p>
</li>
<li>
<ol start="4">
<li>參考</li>
</ol>
<ul>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/733765/#outline__4_1">4.1. 相關文章</a></li>
</ul>
</li>
</ul>
<h2 id="初步瞭解"><a class="header" href="#初步瞭解">初步瞭解</a></h2>
<pre><code class="language-go">import (
&quot;os&quot;
&quot;runtime/trace&quot;
)
func main() {
trace.Start(os.Stderr)
defer trace.Stop()
ch := make(chan string)
go func() {
ch &lt;- &quot;EDDYCJY&quot;
}()
&lt;-ch
}
</code></pre>
<p>生成跟蹤文件：</p>
<pre><code>$ go run main.go 2&gt; trace.out
</code></pre>
<p>啟動可視化界面：</p>
<pre><code>$ go tool trace trace.out
2019/06/22 16:14:52 Parsing trace...
2019/06/22 16:14:52 Splitting trace...
2019/06/22 16:14:52 Opening browser. Trace viewer is listening on http://127.0.0
</code></pre>
<ul>
<li>View trace：查看跟蹤</li>
<li>Goroutine analysis：Goroutine 分析</li>
<li>Network blocking profile：網絡阻塞概況</li>
<li>Synchronization blocking profile：同步阻塞概況</li>
<li>Syscall blocking profile：系統調用阻塞概況</li>
<li>Scheduler latency profile：調度延遲概況</li>
<li>User defined tasks：用戶自定義任務</li>
<li>User defined regions：用戶自定義區域</li>
<li>Minimum mutator utilization：最低 Mutator 利用率</li>
</ul>
<h3 id="scheduler-latency-profile"><a class="header" href="#scheduler-latency-profile">Scheduler latency profile</a></h3>
<p>在剛開始查看問題時，除非是很明顯的現象，否則不應該一開始就陷入細節，因此我們一般先查看 “Scheduler latency profile”，我們能通過 Graph 看到整體的調用開銷情況，如下：</p>
<p><img src="go/images/r15UROyX55.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>演示程序比較簡單，因此這裡就兩塊，一個是 <code>trace</code> 本身，另外一個是 <code>channel</code> 的收發。</p>
<h3 id="goroutine-analysis"><a class="header" href="#goroutine-analysis">Goroutine analysis</a></h3>
<p>第二步看 “Goroutine analysis”，我們能通過這個功能看到整個運行過程中，每個函數塊有多少個有 Goroutine 在跑，並且觀察每個的 Goroutine 的運行開銷都花費在哪個階段。如下：</p>
<p><img src="go/images/uDzI373A8O.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>通過上圖我們可以看到共有 3 個 goroutine，分別是 <code>runtime.main</code>、<code>runtime/trace.Start.func1</code>、<code>main.main.func1</code>，那麼它都做了些什麼事呢，接下來我們可以通過點擊具體細項去觀察。如下：</p>
<p><img src="go/images/1GGf8EPASz.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>同時也可以看到當前 Goroutine 在整個調用耗時中的佔比，以及 GC 清掃和 GC 暫停等待的一些開銷。如果你覺得還不夠，可以把圖表下載下來分析，相當於把整個 Goroutine 運行時掰開來看了，這塊能夠很好的幫助我們<strong>對 Goroutine 運行階段做一個的剖析，可以得知到底慢哪，然後再決定下一步的排查方向</strong>。如下：</p>
<table><thead><tr><th style="text-align: left">名稱</th><th style="text-align: left">含義</th><th style="text-align: left">耗時</th></tr></thead><tbody>
<tr><td style="text-align: left">Execution Time</td><td style="text-align: left">執行時間</td><td style="text-align: left">3140ns</td></tr>
<tr><td style="text-align: left">Network Wait Time</td><td style="text-align: left">網絡等待時間</td><td style="text-align: left">0ns</td></tr>
<tr><td style="text-align: left">Sync Block Time</td><td style="text-align: left">同步阻塞時間</td><td style="text-align: left">0ns</td></tr>
<tr><td style="text-align: left">Blocking Syscall Time</td><td style="text-align: left">調用阻塞時間</td><td style="text-align: left">0ns</td></tr>
<tr><td style="text-align: left">Scheduler Wait Time</td><td style="text-align: left">調度等待時間</td><td style="text-align: left">14ns</td></tr>
<tr><td style="text-align: left">GC Sweeping</td><td style="text-align: left">GC 清掃</td><td style="text-align: left">0ns</td></tr>
<tr><td style="text-align: left">GC Pause</td><td style="text-align: left">GC 暫停</td><td style="text-align: left">0ns</td></tr>
</tbody></table>
<h3 id="view-trace"><a class="header" href="#view-trace">View trace</a></h3>
<p>在對當前程序的 Goroutine 運行分佈有了初步瞭解後，我們再通過 “查看跟蹤” 看看之間的關聯性，如下：</p>
<p><img src="go/images/49dm1D9sxy.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>這個跟蹤圖粗略一看，相信有的小夥伴會比較懵逼，我們可以依據註解一塊塊查看，如下：</p>
<ol>
<li>時間線：顯示執行的時間單元，根據時間維度的不同可以調整區間，具體可執行 <code>shift</code> + <code>?</code> 查看幫助手冊。</li>
<li>堆：顯示執行期間的內存分配和釋放情況。</li>
<li>協程：顯示在執行期間的每個 Goroutine 運行階段有多少個協程在運行，其包含 GC 等待（GCWaiting）、可運行（Runnable）、運行中（Running）這三種狀態。</li>
<li>OS 線程：顯示在執行期間有多少個線程在運行，其包含正在調用 Syscall（InSyscall）、運行中（Running）這兩種狀態。</li>
<li>虛擬處理器：每個虛擬處理器顯示一行，虛擬處理器的數量一般默認為系統內核數。</li>
<li>協程和事件：顯示在每個虛擬處理器上有什麼 Goroutine 正在運行，而連線行為代表事件關聯。</li>
</ol>
<p><img src="go/images/7SCIMdE1Ch.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>點擊具體的 Goroutine 行為後可以看到其相關聯的詳細信息，這塊很簡單，大家實際操作一下就懂了。文字解釋如下：</p>
<ul>
<li>Start：開始時間</li>
<li>Wall Duration：持續時間</li>
<li>Self Time：執行時間</li>
<li>Start Stack Trace：開始時的堆棧信息</li>
<li>End Stack Trace：結束時的堆棧信息</li>
<li>Incoming flow：輸入流</li>
<li>Outgoing flow：輸出流</li>
<li>Preceding events：之前的事件</li>
<li>Following events：之後的事件</li>
<li>All connected：所有連接的事件</li>
</ul>
<h3 id="view-events"><a class="header" href="#view-events">View Events</a></h3>
<p>我們可以通過點擊 View Options-Flow events、Following events 等方式，查看我們應用運行中的事件流情況。如下：</p>
<p><img src="https://codertw.com/wp-content/uploads/img/zvY05yYqS1.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>通過分析圖上的事件流，我們可得知這程序從 <code>G1 runtime.main</code> 開始運行，在運行時創建了 2 個 Goroutine，先是創建 <code>G18 runtime/trace.Start.func1</code>，然後再是 <code>G19 main.main.func1</code> 。而同時我們可以通過其 Goroutine Name 去了解它的調用類型，如：<code>runtime/trace.Start.func1</code> 就是程序中在 <code>main.main</code> 調用了 <code>runtime/trace.Start</code> 方法，然後該方法又利用協程創建了一個閉包 <code>func1</code> 去進行調用。</p>
<p><img src="https://codertw.com/wp-content/uploads/img/19FIo3yXwQ.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>在這裡我們結合開頭的代碼去看的話，很明顯就是 <code>ch</code> 的輸入輸出的過程了。</p>
<h2 id="結合實戰"><a class="header" href="#結合實戰">結合實戰</a></h2>
<p>今天生產環境突然出現了問題，機智的你早已埋好 <code>_ &quot;net/http/pprof&quot;</code> 這個神奇的工具，你麻利的執行了如下命令：</p>
<ul>
<li>curl http://127.0.0.1:6060/debug/pprof/trace?seconds=20 &gt; trace.out</li>
<li>go tool trace trace.out</li>
</ul>
<h3 id="view-trace-1"><a class="header" href="#view-trace-1">View trace</a></h3>
<p>你很快的看到了熟悉的 List 界面，然後不信邪點開了 View trace 界面，如下：</p>
<p><img src="https://codertw.com/wp-content/uploads/img/fSuT85XW5T.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>完全看懵的你，穩住，對著合適的區域執行快捷鍵 <code>W</code> 不斷地放大時間線，如下：</p>
<p><img src="https://codertw.com/wp-content/uploads/img/K1u29cJ0Xi.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>經過初步排查，你發現上述絕大部分的 G 竟然都和 <code>google.golang.org/grpc.(*Server).Serve.func</code> 有關，關聯的一大串也是 <code>Serve</code> 所觸發的相關動作。</p>
<p><img src="https://codertw.com/wp-content/uploads/img/AJ7fEw734f.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>這時候有經驗的你心裡已經有了初步結論，你可以繼續追蹤 View trace 深入進去，不過我建議先鳥瞰全貌，因此我們再往下看 “Network blocking profile” 和 “Syscall blocking profile” 所提供的信息，如下：</p>
<h3 id="network-blocking-profile"><a class="header" href="#network-blocking-profile">Network blocking profile</a></h3>
<p><img src="https://codertw.com/wp-content/uploads/img/1TizZ2FBz7.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<h3 id="syscall-blocking-profile"><a class="header" href="#syscall-blocking-profile">Syscall blocking profile</a></h3>
<p><img src="https://codertw.com/wp-content/uploads/img/6dQ43Z54mk.jpg" alt="Golang大殺器之跟蹤剖析trace" /></p>
<p>通過對以上三項的跟蹤分析，加上這個洩露，這個阻塞的耗時，這個涉及的內部方法名，很明顯就是哪位又忘記關閉客戶端連接了，趕緊改改改。</p>
<h2 id="總結-5"><a class="header" href="#總結-5">總結</a></h2>
<p>通過本文我們習得了 <code>go tool trace</code> 的武林秘籍，它能夠跟蹤捕獲各種執行中的事件，例如 Goroutine 的創建/阻塞/解除阻塞，Syscall 的進入/退出/阻止，GC 事件，Heap 的大小改變，Processor 啟動/停止等等。</p>
<p>希望你能夠用好 Go 的兩大殺器 pprof + trace 組合，此乃排查好搭檔，誰用誰清楚，即使他並不萬能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序進程執行緒線程協程傻傻分得清楚"><a class="header" href="#程序進程執行緒線程協程傻傻分得清楚">程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a></h1>
<p>要成為一個優秀的軟體工程師，進程（process）、線程（thread）是一定要搞懂與掌握的知識點，不僅是因為它們是電腦科學根本的知識，更是因為懂得在適當的時機善用它們，可以增進程式的執行效率，也就是提升效能。</p>
<h2 id="程式-program"><a class="header" href="#程式-program">程式 Program</a></h2>
<p>在瞭解進程與線程之前，得先談談 program 這個東西，其實所謂的 program 就是工程師撰寫的程式碼的集合，例如 Line、 Chrome 就個別是 program，而他們的特點是<strong>還沒有被執行</strong>，因此也就還沒有被載入至記憶體中，而是存放在<a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E7%B4%9A%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE">次級儲存裝置</a>中。</p>
<h2 id="進程-process"><a class="header" href="#進程-process">進程 Process</a></h2>
<p><strong>Process 進程則是指被執行且載入記憶體的 program</strong>**。**Process 也是 OS 分配資源的最小單位，可以從 OS 得到如 CPU Time、Memory…等資源，意思是這個 process 在運行時會消耗多少 CPU 與記憶體。文章一開始放了一張 MacOS 活動監視器的截圖，相信不管是使用哪種作業系統的讀者都有看過類似的介面，而監視器中列出的是你的電腦正在執行的應用程式，而它們其實就是一個個 process，可以從圖片中看出每一個 process 消耗的 CPU、CPU 時間與每個 process 的獨立 ID (PID)。</p>
<h2 id="進程的優缺點與小結"><a class="header" href="#進程的優缺點與小結">進程的優缺點與小結</a></h2>
<ul>
<li>優點：每個進程有自己獨立的系統資源分配空間，不同進程之間的資源不共享，因此不需要特別對進程做互斥存取的處理。</li>
<li>缺點：建立進程以及進程的上下文切換（Context Switch）都較消耗資源，進程間若有通訊的需求也較為複雜。</li>
</ul>
<p>小結：程式 (Program)是寫好尚未執行的 code，程式被執行後才會變成進程 (Process)。</p>
<h2 id="線程-thread"><a class="header" href="#線程-thread">線程 Thread</a></h2>
<p>線程可以想像成存在於 process 裡面，而一個進程裡至少會有一個線程，前面有說 process 是 OS 分配資源的最小單位，而 thread 則是作業系統能夠進行運算排程的最小單位，也就是說實際執行任務的並不是進程，而是進程中的線程，一個進程有可能有多個線程，其中多個線程可以共用進程的系統資源，可以把進程比喻為一個工廠，線程則是工廠裡面的工人，負責任務的實際執行。</p>
<h2 id="multiprocessing-多進程--multithreading-多線程"><a class="header" href="#multiprocessing-多進程--multithreading-多線程">MultiProcessing 多進程 &amp; MultiThreading 多線程</a></h2>
<p>這兩個概念我想繼續利用工廠與工人的比喻會比較好理解與記憶。</p>
<p>Multiprocessing 好比建立許多工廠（通常會取 CPU 的數量），每個工廠中會分配ㄧ名員工(thread)執行工作，因此優勢在於同一時間內可以完成較多的事。</p>
<p>Multithreading 則是將許多員工聚集到同一個工廠內，它的優勢則是<strong>有機會讓相同的工作在比較短的時間內完成。</strong></p>
<h2 id="多線程的-race-condition"><a class="header" href="#多線程的-race-condition">多線程的 Race Condition</a></h2>
<p>剛剛有提到在多執行緒中 (Multithreading)，不同 thread 是可以共享資源的，而若兩個 thread 若同時存取或改變全域變數，可能會發生同步 (Synchronization) 問題。若執行緒之間互搶資源，則可能產生死結 (Deadlock)，因此使用多線程時必須特別注意避免這些狀況發生。</p>
<h2 id="concurrent--parallel-並發與並行"><a class="header" href="#concurrent--parallel-並發與並行">Concurrent &amp; Parallel 並發與並行</a></h2>
<p><img src="go/images/1_7GZrAWoGc_nZtuvHIJ9w-w.jpeg" alt="" /></p>
<p>這兩個是許多人容易誤解的概念，然而透過上面的圖就可以一目瞭然，Parallel 並行是利用多個 CPU 達到同時並行處理任務的需求（也就是同一個時間點有許多任務在同時執行），Concurrent 則是許多任務在爭搶同一個 CPU 的資源，因此一個時間點只會有一個任務正在執行，只是因為切換非常快，使用者通常不會感覺到任務實際上一直在切換。</p>
<h2 id="協程-coroutine"><a class="header" href="#協程-coroutine">協程 Coroutine</a></h2>
<p>大部分的文章討論的都是 process 與 thread 的概念，直到最近在學 golang，碰到了 goroutine，才知道原來還有 coroutine 協程的存在。</p>
<p><img src="go/images/1_lddypV9b9Iy5lYseCY2fPA.png" alt="" /></p>
<p>先講重點</p>
<blockquote>
<p>協程是一種使用者態的輕量級執行緒，協程的排程完全由使用者控制。</p>
</blockquote>
<p>可以想像進程中有線程，而線程中則又有協程。*<strong>而協程的調度完全由用戶控制*</strong>，協程也會有自己的 registers、context、stack 等等，並且由協程的調度器來控制目前由哪個協程執行，哪個協程要被 block 。process 及 thread 的調度，是由 CPU 內核去進行調度，而協程卻不ㄧ樣，OS 甚至不知道協程的存在，如果 coroutine 被卡住，則會在用戶端直接切換另外一個 coroutine 給此 thread 繼續執行，這樣其他 coroutine 就不會被block住，讓資源能夠有效的被利用，藉此實現 Concurrent 的概念。</p>
<p>相較於建立一個線程需要花費 MB 等級的記憶體，建立一個協程可以壓到 KB 等級，協程間的切換也絕對快於線程間的切換。</p>
<p>如果有興趣，真的非常推薦去學<a href="https://gobyexample.com/goroutines"> Go 語言的 goroutine</a>，相信你也會被它的強大給深深吸引的。</p>
<h2 id="小結"><a class="header" href="#小結">小結</a></h2>
<p>透過這篇文章快速帶過進程、線程、協程的概念，然而實際上要使用多進程、多線程開發時要考慮的因素真的很多，一不小心可能會造成上面提過的 race condition 或是性能不升反降的囧境，因此在使用上仍須經過謹慎考慮與效能驗證囉！</p>
<h2 id="補充名詞對照"><a class="header" href="#補充名詞對照">補充：名詞對照</a></h2>
<p>其實本篇文章所提及的進程與線程都是對岸的用語，為了避免讀者誤解，下面整理了一些臺灣與對岸的名詞對照表：</p>
<p>process:</p>
<ul>
<li>臺灣：程序、處理程序</li>
<li>對岸：進程</li>
</ul>
<p>thread:</p>
<ul>
<li>臺灣：執行緒</li>
<li>對岸：線程</li>
</ul>
<p>concurrent:</p>
<ul>
<li>臺灣：並行</li>
<li>大陸：並發</li>
</ul>
<p>parallel:</p>
<ul>
<li>臺灣：平行</li>
<li>大陸：並行</li>
</ul>
<p>可以看到兩個地區對並行的定義是不一樣的，因此建議讀者已英文記比較不會搞混喔～</p>
<h2 id="出處-1"><a class="header" href="#出處-1">出處</a></h2>
<p>https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-的並發goroutine-與-channel-介紹"><a class="header" href="#go-的並發goroutine-與-channel-介紹">Go 的並發：Goroutine 與 Channel 介紹</a></h1>
<p>Goroutine 像是 Go 語言的 thread, 使 Go 建立多工處理, 搭配 Channel 使 Goroutine 操作簡單化, 本文介紹 Goroutine 及 Channel 的使用方式。</p>
<blockquote>
<p>範例程式碼可以在 <a href="https://github.com/peterhpchen/golang-concurrency-example">golang-concurrency-example</a> 中找到，每個程式第一行可以找到其範例檔名。</p>
</blockquote>
<h2 id="單執行緒"><a class="header" href="#單執行緒">單執行緒</a></h2>
<p>在單執行緒下，每行程式碼都會依照順序執行。</p>
<pre><code class="language-go">// single-thread.go
func say(s string) {
    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {g
    say(&quot;world&quot;)
    say(&quot;hello&quot;)
}
world
world
world
world
world
hello
hello
hello
hello
hello
</code></pre>
<p>上例會先執行完 <code>say(&quot;world&quot;)</code> 後再執行 <code>say(&quot;hello&quot;)</code>。</p>
<p><img src="go/images/single-thread.png" alt="" /></p>
<p>但有時個別方法的處理是沒有先後順序的，這時善用多執行緒就可以大大的提升效率。</p>
<h2 id="多執行緒"><a class="header" href="#多執行緒">多執行緒</a></h2>
<p>在多執行緒下，最多可以同時執行與 CPU 數相等的 Goroutine。</p>
<pre><code class="language-go">// multi-thread.go
func main() {
    go say(&quot;world&quot;)
    say(&quot;hello&quot;)
}
world
hello
hello
world
world
hello
hello
world
world
hello
</code></pre>
<p>如此一來, <code>say(&quot;world&quot;)</code>會跑在另一個執行緒(Goroutine)上，使其並行執行。</p>
<p><img src="go/images/multi-thread.png" alt="" /></p>
<blockquote>
<p>CPU 數可以使用 <code>runtime.NumCPU()</code> 取得。</p>
</blockquote>
<h2 id="goroutine-介紹"><a class="header" href="#goroutine-介紹">Goroutine 介紹</a></h2>
<p>可以想成建立了一個 Goroutine 就是建立了一個新的 Thread。</p>
<pre><code class="language-go">go f(x, y, z)
</code></pre>
<ul>
<li>以 <code>go</code> 開頭的函式叫用可以使 <code>f</code> 跑在另一個 Goroutine 上</li>
<li><code>f</code>, <code>x</code>, <code>y</code>, <code>z</code> 取自目前的 goroutine</li>
<li><code>main</code> 函式也是跑在 Goroutine 上</li>
<li>Main Goroutine 執行結束後, 其他的 Goroutine 會跟著強制關閉</li>
</ul>
<h2 id="等待"><a class="header" href="#等待">等待</a></h2>
<p>多執行緒下，經常需要處理的是執行緒之間的狀態管理，其中一個經常發生的事情是<strong>等待</strong>，例如A執行緒需要等B執行緒計算並取得資料後才能繼續往下執行，在這情況下<strong>等待</strong>就變得十分重要。</p>
<h3 id="應該等待的時機"><a class="header" href="#應該等待的時機">應該等待的時機</a></h3>
<pre><code class="language-go">func main() {
    go say(&quot;world&quot;)
    go say(&quot;hello&quot;)
}
</code></pre>
<p>這個狀態下會有三個 Goroutine:</p>
<ul>
<li><code>main</code></li>
<li><code>say(&quot;world&quot;)</code></li>
<li><code>say(&quot;hello&quot;)</code></li>
</ul>
<p>這裡的問題發生在 <code>main</code> Goroutine 結束時，另外兩個 <code>say</code> Goroutine 會被強制關閉導致結果錯誤，這時就需要等待其他的 Goroutine 結束後 <code>main</code> Goroutine 才能結束。</p>
<p>接下來會介紹三種等待的方式，並且分析其利弊：</p>
<ul>
<li><code>time.Sleep</code>: 休眠指定時間</li>
<li><code>sync.WaitGroup</code>: 等待直到指定數量的 <code>Done()</code> 叫用</li>
<li>Channel 阻塞: 使用 Channel 阻塞機制，使用接收時等待的特性避免執行緒繼續執行</li>
</ul>
<h4 id="timesleep"><a class="header" href="#timesleep">time.Sleep</a></h4>
<p>使 Goroutine 休眠，讓其他的 Goroutine 在 main 結束前有時間執行完成。</p>
<pre><code class="language-go">// sleep.go
func main() {
    go say(&quot;world&quot;)
    go say(&quot;hello&quot;)

    time.Sleep(5 * time.Second)
}
</code></pre>
<p><img src="go/images/sleep.png" alt="" /></p>
<p>缺點：</p>
<ul>
<li>休息指定時間可能會比 Goroutine 需要執行的時間長或短，<strong>太長會耗費多餘的時間，太短會使其他 Goroutine 無法完成</strong></li>
</ul>
<h4 id="syncwaitgroup"><a class="header" href="#syncwaitgroup">sync.WaitGroup</a></h4>
<pre><code class="language-go">// wait-group.go
func say(s string, wg *sync.WaitGroup) {
    defer wg.Done()

    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    wg := new(sync.WaitGroup)
    wg.Add(2)

    go say(&quot;world&quot;, wg)
    go say(&quot;hello&quot;, wg)

    wg.Wait()
}
</code></pre>
<p><img src="go/images/wait-group.png" alt="" /></p>
<ul>
<li>產生與想要等待的 Goroutine 同樣多的 <code>WaitGroup</code> Counter</li>
<li>將 <code>WaitGroup</code> 傳入 Goroutine 中，在執行完成後叫用 <code>wg.Done()</code> 將 Counter 減一</li>
<li><code>wg.Wait()</code> 會等待直到 Counter 減為零為止</li>
</ul>
<p>優點</p>
<ul>
<li>避免時間預估的錯誤</li>
</ul>
<p>缺點</p>
<ul>
<li>需要手動配置對應的 Counter</li>
</ul>
<h4 id="channel-5"><a class="header" href="#channel-5">Channel</a></h4>
<p>最後介紹的是使用 Channel 等待, 原為 Goroutine 溝通時使用的，但因其阻塞的特性，使其可以當作等待 Goroutine 的方法。</p>
<pre><code class="language-go">// channel-wait.go
func say(s string, c chan string) {
    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
    c &lt;- &quot;FINISH&quot;
}

func main() {
    ch := make(chan string)

    go say(&quot;world&quot;, ch)
    go say(&quot;hello&quot;, ch)

    &lt;-ch
    &lt;-ch
}
</code></pre>
<p><img src="go/images/channel-wait.png" alt="" /></p>
<p>起了兩個 Goroutine(<code>say(&quot;world&quot;, ch)</code>, <code>say(&quot;hello&quot;, ch)</code>) ，因此需要等待兩個 <code>FINISH</code> 推入 Channel 中才能結束 Main Goroutine。</p>
<p>優點</p>
<ul>
<li>避免時間預估的錯誤</li>
<li>語法簡潔</li>
</ul>
<blockquote>
<p>Channel 阻塞的方法為 Go 語言中等待的主要方式。</p>
</blockquote>
<h2 id="多執行緒下的共享變數"><a class="header" href="#多執行緒下的共享變數">多執行緒下的共享變數</a></h2>
<p>在執行緒間使用同樣的變數時，最重要的是確保變數在當前的正確性，在沒有控制的情況下極有可能發生問題，下面有個例子：</p>
<pre><code class="language-go">// total-error.go
func main() {
    total := 0
    for i := 0; i &lt; 1000; i++ {
        go func() {
            total++
        }()
    }
    time.Sleep(time.Second)
    fmt.Println(total)
}
</code></pre>
<p><img src="go/images/total-error.png" alt="" /></p>
<p>假設目前加到28，在多執行緒的情況下：</p>
<ul>
<li><code>goroutine1</code> 取值 28 做運算</li>
<li><code>goroutine2</code> 有可能在 <code>goroutine1</code> 做 <code>total++</code> 前就取 <code>total</code> 的值，因此有可能取到 28</li>
<li>這樣的情況下做兩次加法的結果會是 29 而非 30</li>
</ul>
<p>在多個 goroutine 裡對同一個變數<code>total</code>做加法運算，在賦值時無法確保其為安全的而導致運算錯誤，此問題稱為 <strong>Race Condition</strong>。</p>
<h3 id="互斥鎖syncmutex"><a class="header" href="#互斥鎖syncmutex">互斥鎖(sync.Mutex)</a></h3>
<p>在這種狀況下，可以使用互斥鎖(<code>sync.Mutex</code>)來保證變數的安全：</p>
<pre><code class="language-go">// total-mutex.go
type SafeNumber struct {
    v   int
    mux sync.Mutex // 互斥鎖
}

func main() {
    total := SafeNumber{v: 0}
    for i := 0; i &lt; 1000; i++ {
        go func() {
            total.mux.Lock()
            total.v++
            total.mux.Unlock()
        }()
    }
    time.Sleep(time.Second)
    total.mux.Lock()
    fmt.Println(total.v)
    total.mux.Unlock()
}
</code></pre>
<p><img src="go/images/total-mutex.png" alt="" /></p>
<p>互斥鎖使用在資料結構(<code>struct</code>)中，用以確保結構中變數讀寫時的安全，它提供兩個方法：</p>
<ul>
<li><code>Lock</code></li>
<li><code>Unlock</code></li>
</ul>
<p>在 <code>Lock</code> 及 <code>Unlock</code> 中間，會使其他的 Goroutine 等待，確保此區塊中的變數安全。</p>
<h3 id="藉由-channel-保證變數的安全性"><a class="header" href="#藉由-channel-保證變數的安全性">藉由 Channel 保證變數的安全性</a></h3>
<pre><code class="language-go">// total-channel.go
func main() {
    total := 0
    ch := make(chan int, 1)
    ch &lt;- total
    for i := 0; i &lt; 1000; i++ {
        go func() {
            ch &lt;- &lt;-ch + 1
        }()
    }
    time.Sleep(time.Second)
    fmt.Println(&lt;-ch)
}
</code></pre>
<p><img src="go/images/total-channel.png" alt="" /></p>
<ul>
<li>goroutine1 拉出 <code>total</code> 後，Channel 中沒有資料了</li>
<li>因為 Channel 中沒有資料，因此造成 goroutine2 等待</li>
<li>goroutine1 計算完成後，將 <code>total</code> 推入 Channel</li>
<li>goroutine2 等到 Channel 中有資料，拉出後結束等待，繼續做運算</li>
</ul>
<p>因為 Channel 推入及拉出時等待的特性，被拉出來做計算的值會保證是安全的。</p>
<blockquote>
<blockquote>
<p>因為此範例一定要拉出 Channel 資料才能做運算，所以使用非立即阻塞的 Buffered Channel ，與 Unbuffered Channel 的差別等下會說明。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>上述的三個例子在 main goroutine 中都使用 <code>time.Sleep</code> 避免程式提前結束。</p>
</blockquote>
</blockquote>
<h2 id="channel-介紹"><a class="header" href="#channel-介紹">Channel 介紹</a></h2>
<p>上面藉由兩個在多執行緒中重要的議題：<strong>等待</strong>及<strong>變數的共享</strong>，帶出 Channel 強大的處理能力，接著來深入瞭解一下 Channel。</p>
<p>Channel 可以想成一條管線，這條管線可以推入數值，並且也可以將數值拉取出來。</p>
<p>因為 Channel 會等待至另一端完成推入/拉出的動作後才會繼續往下處理，這樣的特性使其可以在 Goroutines 間同步的處理資料，而不用使用明確的 <code>lock</code>, <code>unlock</code> 等方法。</p>
<p>建立 Channel</p>
<pre><code class="language-go">ch := make(chan int) // 建立 int 型別的 Channel
</code></pre>
<p>推入/拉出 Channel 內的值，使用 <code>&lt;-</code> 箭頭運算子：</p>
<ul>
<li>Channel 在 <code>&lt;-</code> 左邊：將箭頭右邊的數值推入 Channel 中</li>
</ul>
<pre><code class="language-go">ch &lt;- v    // Send v to channel ch.
v := &lt;-ch  // Receive from ch, and assign value to v.
</code></pre>
<h3 id="channel-的阻塞"><a class="header" href="#channel-的阻塞">Channel 的阻塞</a></h3>
<p>Goroutine 使用 Channel 時有兩種情況會造成阻塞：</p>
<ul>
<li>將資料推入 Channel，但其他 Goroutine 還未拉取資料時，將資料推入的 Goroutine 會被迫等待其他 Goroutine 拉取資料才能往下執行</li>
</ul>
<p><img src="go/images/channel-sleep-push.png" alt="" /></p>
<ul>
<li>
<p>當 Channel 中沒有資料，但要從中拉取時，想要拉取資料的 Goroutine 會被迫等待其他 Goroutine 推入資料並自己完成拉取後才能往下執行</p>
<p><img src="go/images/channel-sleep-pull.png" alt="" /></p>
</li>
</ul>
<h4 id="goroutine-推資料入-channel-時的等待情境"><a class="header" href="#goroutine-推資料入-channel-時的等待情境">Goroutine 推資料入 Channel 時的等待情境</a></h4>
<pre><code class="language-go">// channel-block-push.go
func main() {
    ch := make(chan string)

    go func() { // calculate goroutine
        fmt.Println(&quot;calculate goroutine starts calculating&quot;)
        time.Sleep(time.Second) // Heavy calculation
        fmt.Println(&quot;calculate goroutine ends calculating&quot;)

        ch &lt;- &quot;FINISH&quot; // goroutine 執行會在此被迫等待

        fmt.Println(&quot;calculate goroutine finished&quot;)
    }()

    time.Sleep(2 * time.Second) // 使 main 比 goroutine 慢
    fmt.Println(&lt;-ch)
    time.Sleep(time.Second)
    fmt.Println(&quot;main goroutine finished&quot;)
}
</code></pre>
<pre><code class="language-sh">calculate goroutine starts calculating
calculate goroutine ends calculating
FINISH
calculate goroutine finished
main goroutine finished
</code></pre>
<p>此例使用 <code>time.Sleep</code> 強迫 main 執行慢於 calculate，現在來觀察輸出的結果：</p>
<ul>
<li>calculate 會先執行並且計算完成</li>
<li>calculate 將 <code>FINISH</code> 訊號推入 Channel</li>
<li>但由於目前 main 還未拉取 Channel 中的資料，所以 calculate 會被迫等待，因此 calculate 的最後一行 <code>fmt.Println(&quot;main goroutine finished&quot;)</code> 沒有馬上輸出在畫面上</li>
<li>main 拉取了 Channel 中的資料</li>
<li>calculate 執行<code>fmt.Println(&quot;main goroutine finished&quot;)</code> 並結束</li>
<li>main 執行完成</li>
</ul>
<h4 id="goroutine-拉資料出-channel-時的等待情境"><a class="header" href="#goroutine-拉資料出-channel-時的等待情境">Goroutine 拉資料出 Channel 時的等待情境</a></h4>
<pre><code class="language-go">// channel-block-pull.go
func main() {
    ch := make(chan string)

    go func() {
        fmt.Println(&quot;calculate goroutine starts calculating&quot;)
        time.Sleep(time.Second) // Heavy calculation
        fmt.Println(&quot;calculate goroutine ends calculating&quot;)

        ch &lt;- &quot;FINISH&quot;

        fmt.Println(&quot;calculate goroutine finished&quot;)
    }()

    fmt.Println(&quot;main goroutine is waiting for channel to receive value&quot;)
    fmt.Println(&lt;-ch) // goroutine 執行會在此被迫等待
    fmt.Println(&quot;main goroutine finished&quot;)
}
</code></pre>
<pre><code class="language-sh">main goroutine is waiting for channel to receive value
calculate goroutine starts calculating
calculate goroutine ends calculating
calculate goroutine finished
FINISH
main goroutine finished
</code></pre>
<ul>
<li>main 因拉取的時候 calculate 還沒將資料推入 Channel 中，因此 main 會被迫等待，因此 main 的最後一行 <code>fmt.println</code> 沒有馬上輸出在畫面上</li>
<li>calculate 執行並且計算完成</li>
<li>calculate 將 <code>FINISH</code> 推入 Channel</li>
<li>calculate 執行完成</li>
<li>main 拉取了 Channel 中的資料並且執行完成</li>
</ul>
<h3 id="unbuffered-channel"><a class="header" href="#unbuffered-channel">Unbuffered Channel</a></h3>
<p>前面一直提到的是 Unbuffered Channel，此種 Channel 只要</p>
<ul>
<li>推入一個資料會造成推入方的等待</li>
<li>拉出時沒有資料會造成拉出方的等待</li>
</ul>
<p>使用 Unbuffered Channel 的壞處是：如果推入方的執行一次的時間較拉取方短，會造成推入方被迫等待拉取方才能在做下一次的處理，這樣的等待是不必要並且需要被避免的。</p>
<p>為瞭解決推入方等待問題，可以使用另一種 Channel：Buffered Channel。</p>
<h3 id="buffered-channel"><a class="header" href="#buffered-channel">Buffered Channel</a></h3>
<pre><code class="language-go">ch: make(chan int, 100)
</code></pre>
<p>Buffered Channel 的宣告會在第二個參數中定義 buffer 的長度，它只會在 Buffered 中資料填滿<strong>以後</strong>才會阻塞造成等待，以上例來說：第101個資料推入的時候，推入方的 Goroutine 才會等待。</p>
<p><img src="go/images/buffered-channel.png" alt="" /></p>
<p>下面的例子分別使用 Buffered Channel 跟 Unbuffered Channel 的差別：</p>
<pre><code class="language-go">// unbuffered-channel-error.go
func main() {
    ch := make(chan int)
    ch &lt;- 1 // 等到天荒地老
    fmt.Println(&lt;-ch)
}
</code></pre>
<pre><code class="language-sh">fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        /go/unbuffered-channel-error.go:9 +0x59
exit status 2
</code></pre>
<p>上例使用 Unbuffered Channel：</p>
<ul>
<li>只有一條 Goroutine：main</li>
<li>推入 1 後因為還沒有其他 Goroutine 拉取 Channel 中的資料，所以進入阻塞狀態</li>
<li>因為 main 已經在推入資料時阻塞，所以拉取的程式永遠不會被執行，造成死結</li>
</ul>
<p><img src="go/images/unbuffered-channel-error.png" alt="" /></p>
<p>在相同的情況下，Buffered Channel 並不會被阻塞：</p>
<pre><code class="language-go">// buffered-channel.go
func main() {
    ch := make(chan int, 1)
    ch &lt;- 1
    fmt.Println(&lt;-ch)
}
</code></pre>
<p>原因是：</p>
<ul>
<li>推入 1 後 Channel 內的資料數為1並沒有超過 Buffer 的長度1，所以不會被阻塞</li>
<li>因為沒有阻塞，所以下一行拉取的程式碼可以被執行，並且完成執行</li>
</ul>
<p><img src="go/images/buffered-channel-work.png" alt="" /></p>
<h3 id="loop-中的-channel"><a class="header" href="#loop-中的-channel">Loop 中的 Channel</a></h3>
<p>在迴圈中的 Channel 可以藉由第二個回傳值 <code>ok</code> 確認 Channel 是否被關閉，如果被關閉的話代表此 Channel 已經不再使用，可以結束巡覽。</p>
<pre><code class="language-go">// for-loop.go
func main() {
    c := make(chan int)
    go func() {
        for i := 0; i &lt; 10; i++ {
            c &lt;- i
        }
        close(c) // 關閉 Channel
    }()
    for {
        v, ok := &lt;-c
        if !ok { // 判斷 Channel 是否關閉
            break
        }
        fmt.Println(v)
    }
}
</code></pre>
<pre><code class="language-sh">0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>如果對 Closed Channel 推入資料的話會造成 Panic：</p>
<pre><code class="language-go">// closed-channel-panic.go
func main() {
    c := make(chan int)
    close(c)
    c &lt;- 0 // Panic!!!
}
panic: send on closed channel
</code></pre>
<blockquote>
<p>為了避免將資料推入已關閉的 Channel 中造成 Panic，Channel 的關閉應該由推入的 Goroutine 處理。</p>
</blockquote>
<h3 id="range-中的-channel"><a class="header" href="#range-中的-channel">range 中的 Channel</a></h3>
<p><code>range</code> 是可以巡覽 Channel 的，終止條件為 Channel 的狀態為已關閉的(Closed)：</p>
<pre><code class="language-go">// range.go
func main() {
    c := make(chan int, 10)
    go func() {
        for i := 0; i &lt; 10; i++ {
            c &lt;- i
        }
        close(c) // 關閉 Channel
    }()
    for i := range c { // 在 close 後跳出迴圈
        fmt.Println(i)
    }
}
</code></pre>
<h3 id="使用-select-避免等待"><a class="header" href="#使用-select-避免等待">使用 select 避免等待</a></h3>
<p>在 Channel 推入/拉取時，會有一段等待的時間而造成 Goroutine 無法回應，如果此 Goroutine 是負責處理畫面的，使用者就會看到畫面 lag 的情況，這是我們不想見的情況。</p>
<p>例如之前提到的例子：</p>
<pre><code class="language-go">// block.go
func main() {
    ch := make(chan string)

    go func() {
        fmt.Println(&quot;calculate goroutine starts calculating&quot;)
        time.Sleep(time.Second) // Heavy calculation
        fmt.Println(&quot;calculate goroutine ends calculating&quot;)

        ch &lt;- &quot;FINISH&quot;

        fmt.Println(&quot;calculate goroutine finished&quot;)
    }()

    fmt.Println(&quot;main goroutine is waiting for channel to receive value&quot;)
    fmt.Println(&lt;-ch) // goroutine 執行會在此被迫等待
    fmt.Println(&quot;main goroutine finished&quot;)
}
</code></pre>
<pre><code class="language-sh">main goroutine is waiting for channel to receive value # main goroutine 阻塞
calculate goroutine starts calculating
calculate goroutine ends calculating
calculate goroutine finished
FINISH # main goroutine 解除阻塞
main goroutine finished
</code></pre>
<p>main goroutine 要拉取 <code>ch</code> 的資料時，會被迫等待，這時會無法回饋目前的狀態給使用者，造成卡頓的清況。</p>
<p>這時可以使用 Go 提供的 <code>select</code> 語法，讓開發者可以很輕鬆的處理 Channel 的多種情況，包括阻塞時的處理。</p>
<pre><code class="language-go">// select.go
func main() {
    ch := make(chan string)

    go func() {
        fmt.Println(&quot;calculate goroutine starts calculating&quot;)
        time.Sleep(time.Second) // Heavy calculation
        fmt.Println(&quot;calculate goroutine ends calculating&quot;)

        ch &lt;- &quot;FINISH&quot;
        time.Sleep(time.Second)
        fmt.Println(&quot;calculate goroutine finished&quot;)
    }()

    for {
        select {
        case &lt;-ch: // Channel 中有資料執行此區域
            fmt.Println(&quot;main goroutine finished&quot;)
            return
        default: // Channel 阻塞的話執行此區域
            fmt.Println(&quot;WAITING...&quot;)
            time.Sleep(500 * time.Millisecond)
        }
    }
}
</code></pre>
<pre><code class="language-sh">WAITING... # main goroutine 在阻塞時可以回應
calculate goroutine starts calculating
WAITING... # main goroutine 在阻塞時可以回應
WAITING... # main goroutine 在阻塞時可以回應
calculate goroutine ends calculating
main goroutine finished # main goroutine 解除阻塞並結束程式
</code></pre>
<p>將剛剛的例子改為 <code>select</code> 來處理，可以使 Channel 的推入/拉取不會阻塞：</p>
<ul>
<li>會在沒有阻塞的情況下才會執行對應的區塊</li>
<li><code>case &lt;-ch:</code>: 會等到沒有阻塞情況時(<code>ch</code> 內有資料)才會執行</li>
<li><code>default:</code>: 在所有的 <code>case</code> 都阻塞的情況下執行</li>
</ul>
<p>因為有 <code>default</code> 可以設置，當 Channel 阻塞時也可以藉由 <code>default</code> 輸出資訊讓使用者知道。</p>
<h2 id="總結-6"><a class="header" href="#總結-6">總結</a></h2>
<p>一開始提到了單執行緒跟多執行緒的差別，接著帶出 Goroutine ，並介紹各種等待方式(<code>time.Sleep</code>, <code>sync.WaitGroup</code> 及 Channel)和執行緒間分享變數的問題(Race Condition)及解決方法(<code>sync.Mutex</code> 及 Channel)，從而帶出 Channel 在執行緒中方便強大的能力。</p>
<p>再來講述 Channel 的使用方式，及其阻塞的時機(推入阻塞及拉取阻塞)，接著說明 Unbuffered 及 Buffered Channel 的差別，並且說明可以藉由 Unbuffered Channel 降低效能上的損失。</p>
<p>Channel 傳回的第二個參數：<code>ok</code>，可以判斷此 Channel 是否已經關閉，並被 <code>range</code> 用在結束巡覽的判斷中。</p>
<p>最後說明瞭 <code>select</code> 可以 Channel 在阻塞時讓 Goroutine 保持非阻塞的狀態避免卡頓。</p>
<p>藉由 Goroutine 及 Channel 簡單的語法但是強大的能力使工程師開發多工程式的時候可以寫出優雅又易於維護的代碼，是 Go 語言的優勢之一。</p>
<h2 id="參考資料-4"><a class="header" href="#參考資料-4">參考資料</a></h2>
<ul>
<li><a href="https://tour.golang.org/concurrency">A tour of Go - Goroutines</a></li>
<li><a href="https://medium.com/@trevor4e/learning-gos-concurrency-through-illustrations-8c4aff603b3">Trevor Forrey - Learning Go’s Concurrency Through Illustrations</a></li>
</ul>
<h2 id="出處-2"><a class="header" href="#出處-2">出處</a></h2>
<p>https://peterhpchen.github.io/2020/03/08/goroutine-and-channel.html</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="websocket"><a class="header" href="#websocket">WebSocket</a></h2>
<pre><code class="language-go">package main

import (
	&quot;log&quot;
    &quot;fmt&quot;

	&quot;github.com/gorilla/websocket&quot;
)

// https://github.com/binance-exchange/go-binance/blob/master/service_websocket.go
func main() {
	c, _, err := websocket.DefaultDialer.Dial(&quot;wss://stream.binance.com:9443/ws/btsusdt@depth20@100ms&quot;, nil)
	if err != nil {
		log.Fatal(&quot;dial:&quot;, err)
	}
	defer c.Close()

	// 啟動一個協程，讀取從服務端發送過來的數據
	go func() {
		for {
			_, message, _ := c.ReadMessage()
			fmt.Println(string(message))
		}
	}()

	// 阻塞主線程
	down := make(chan byte)
	for {
		&lt;-down
	}
}
</code></pre>
<pre><code class="language-go">func main() {

    // 定義客戶端的地址
    u := url.URL{Scheme: &quot;ws&quot;, Host: &quot;locaalhost:999&quot;, Path: &quot;/connect&quot;}

    // 與客戶端建立連接
    c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)
    if err != nil {
        log.Fatal(&quot;dial:&quot;, err)
    }
    defer c.Close()

    // 啟動一個協程，讀取從服務端發送過來的數據
    go func() {
        for {
            _, message, _ := c.ReadMessage()
            fmt.Println(string(message))
        }
    }()


    // 阻塞主線程
    down := make(chan byte)
    for {
        &lt;-down
    }
}
</code></pre>
<pre><code class="language-go">package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;github.com/gorilla/websocket&quot;
    &quot;log&quot;
    &quot;net/url&quot;
)

var addr = flag.String(&quot;addr&quot;, &quot;localhost:9999&quot;, &quot;proxy server addr&quot;)

func main() {

    u := url.URL{Scheme: &quot;ws&quot;, Host: *addr, Path: &quot;/connect&quot;}

    c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)
    if err != nil {
        log.Fatal(&quot;dial:&quot;, err)
    }
    defer c.Close()

    down := make(chan byte)
    go func() {
        for {
            _, message, _ := c.ReadMessage()
            fmt.Println(&quot;服務端發送:&quot; + string(message))
        }
    }()

    go func() {
        for {
            var input string
            fmt.Scanln(&amp;input)
            c.WriteMessage(websocket.TextMessage, []byte(input))
        }
    }()

    for {
        &lt;-down
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-pointer-from-a-function-in-go"><a class="header" href="#returning-pointer-from-a-function-in-go">Returning Pointer from a Function in Go</a></h1>
<p>Pointers in Go programming language or Golang is a variable which is used to store the memory address of another variable. We can pass pointers to the function as well as return pointer from a function in Golang. In <a href="https://www.geeksforgeeks.org/c-programming-language/">C</a>/<a href="https://www.geeksforgeeks.org/c-plus-plus/">C++</a>, it is not recommended to return the address of a local variable outside the function as it goes out of scope after function returns. So to execute the concept of returning a pointer from function in C/C++ you must define the local variable as a static variable.</p>
<p><strong>Example:</strong> In the below program, the line of code(<em>int lv = n1 * n1;</em>) will give warning as it is local to the function. To avoid warnings make it static.</p>
<pre><code class="language-cpp">// C++ program to return the
// pointer from a function
#include &lt;iostream&gt;
using namespace std;
  
// taking a function having
// pointer as return type
int* rpf(int);
  
int main()
{
  
    int n = 745;
  
    // displaying the value of n
    cout &lt;&lt; n &lt;&lt; endl;
  
    // calling the function
    cout &lt;&lt; *rpf(n) &lt;&lt; endl;
}
  
// defining function
int* rpf(int n1)
{
  
    // taking a local variable
    // inside the function
    int lv = n1 * n1;
  
    // remove comment or make the above
    // declaration as static which
    // result into successful
    // compilation
    // static int lv = n1 * n1;
  
    // this will give warning as we
    // are returning the address of
    // the local variable
    return &amp;lv;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>745
</code></pre>
<p>The main reason behind this scenario is that compiler always make a stack for a function call. As soon as the function exits the function stack also get removed which causes the local variables of functions goes out of scope. Making it static will resolve the problem. As static variables have a property of preserving their value even after they are out of their scope.</p>
<p>But the <strong>Go compiler is very Intelligent!</strong>. It will not allocate the memory on the stack to the local variable of the function. It will allocate this variable on the heap. In the below program, variable <em>lv</em> will have the memory allocated on the <strong>heap</strong> as Go compiler will perform escape analysis to escape the variable from the local scope.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-go"> Go program to return the
// pointer from the function
package main
  
import &quot;fmt&quot;
  
// main function
func main() {
  
    // calling the function
    n := rpf()
  
    // displaying the value
    fmt.Println(&quot;Value of n is: &quot;, *n)
  
}
  
// defining function having integer
// pointer as return type
func rpf() *int {
  
    // taking a local variable
    // inside the function
    // using short declaration
    // operator
    lv := 100
  
    // returning the address of lv
    return &amp;lv
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Value of n is:  100
</code></pre>
<p><strong>Note:</strong> Golang doesn’t provide any support for the pointer arithmetic like C/C++. If you will perform then the compiler will throw an error as invalid operation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang-記憶體管理-gc-全面解析"><a class="header" href="#golang-記憶體管理-gc-全面解析">Golang 記憶體管理 GC 全面解析</a></h1>
<p>出處 : https://alanzhan.dev/post/2022-02-13-golang-memory-management/</p>
<h1 id="記憶體管理的爭論"><a class="header" href="#記憶體管理的爭論">記憶體管理的爭論</a></h1>
<p>關於記憶體管理，往往都會討論到一個持續很久的爭論，就是記憶體到底要給誰管？給機器管？還是給人管？不管是機器管或者是人管，大家的初衷都是一致的，認為記憶體管理是非常重要的，但大家的意見還是分歧了：</p>
<ul>
<li>c / c++ ：認為記憶體管理如此重要，所以我希望把記憶體管理的自由交付給工程師，因為這些人我相信他的技能非常的強，他知道甚麼時候該申請記憶體，甚麼時候該釋放記憶體。</li>
<li>Java / .Net(C#) / golang / etc ：它們觀點卻站在反面，目的雖然一樣，認為記憶體管理如此重要，但是我們不能相信人，我希望通過自動化的方式管理記憶體。</li>
</ul>
<p>我們可以思考一下這兩者的差異，當然 c / c++ 記憶體使用與釋放的效率非常的高，因為工程師知道我的記憶體甚麼時候不用，我直接把他 free 掉，但是人總是會犯錯，如果有人忘記釋放記憶體，那麼就會導致記憶體洩漏，最終導致程式崩潰。</p>
<p>在越是年輕的語言，在追求的反而是開發的效率，希望可以通過一種自動化的方式管理記憶體，減少人為的錯誤，使得開發的效率變高，所以記憶體的管理反而變得十分的重要，那麼記憶體管理會面臨哪些挑戰呢？</p>
<h1 id="heap-記憶體管理的挑戰"><a class="header" href="#heap-記憶體管理的挑戰">Heap 記憶體管理的挑戰</a></h1>
<ul>
<li>記憶體分配需要系統調用，在頻繁記憶體分配的時候，系統性能較低。</li>
<li>多線程共享相同的記憶體空間時，同時申請記憶體，需要加鎖，否則會產生同一塊記憶體被多個線程訪問的狀況。</li>
<li>記憶體碎片化的問題，經過不斷的記憶體分配與回收，記憶體碎片會比較嚴重，記憶體的使用效率會降低。</li>
</ul>
<p>所以這是 c / c++ 這些比較傳統的語言，假如自己去申請 heap 記憶體，如果不做處理，可能會引發的問題。</p>
<h1 id="heap-記憶體管理"><a class="header" href="#heap-記憶體管理">Heap 記憶體管理</a></h1>
<p>那麼現在的語言要怎麼解決這種問題呢？</p>
<p><img src="go/images/2022-02-13-heap-management.jpg" alt="" /></p>
<p>假設 heap 是目前的所擁有的 heap 記憶體，針對這個 heap 的管理主要會有三個角色跟次要輔助用的 Header：</p>
<ul>
<li>Allocator ： 記憶體的分配器，主要動態處理記憶體的分配請求，程式啟動時 Allocator 會在初始化的時候，預先向操作系統申請記憶體，接下來可能會先記憶體做一定的格式化。</li>
<li>Mutator ： Mutator 可以理解為我們的程式，Mutator 只要負責跟 Allocator 申請記憶體就好，他不需要顯式的去釋放(回收)記憶體。</li>
<li>Collector ： 垃圾回收器，回收記憶體空間，他會去掃描整的 heap 記憶體，哪些是活躍物件，那些是非活耀物件，當發現非活耀，就會回收記憶體。</li>
<li>Object Header ： 當記憶體分配出去時，同時會對這塊記憶體做標記，用來標記物件的， Collector 和 Allocator 會來同步物件 Metadata。</li>
</ul>
<p>大家可以根據上面的敘述稍微順一下，那麼我們就來看看 golang 怎麼處理的：</p>
<ul>
<li>初始化連續記憶體作為 heap 。</li>
<li>有記憶體申請的時候，Allocator 從 heap 記憶體的未分配區塊切割小記憶體塊。</li>
<li>用鏈表將以分配的記憶體連接起來。</li>
<li>需要描述每個記憶體塊的 metadata ，大小、是否使用、下一塊記憶體位置等。</li>
</ul>
<p><img src="go/images/2022-02-13-allocator-object-header.jpg" alt="" /></p>
<h2 id="tcmalloc"><a class="header" href="#tcmalloc">TCMalloc</a></h2>
<p>golang 這門語言的記憶體管理是基於 TCMalloc 基礎上進行設計的，所以在認識 golang 記憶體管理之前，先梳理一下 TCMalloc (Thread Cache Malloc) 的原理。</p>
<p><img src="go/images/2022-02-13-tcmalloc.jpg" alt="" /></p>
<p>我們先回想剛剛所講述的記憶體管理會面臨哪些挑戰，<a href="https://alanzhan.dev/post/2022-02-13-golang-memory-management/#heap-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86%E7%9A%84%E6%8C%91%E6%88%B0">Heap 記憶體管理的挑戰</a></p>
<ul>
<li>記憶體分配需要系統調用，在頻繁記憶體分配的時候，系統性能較低。
<ul>
<li>所以 TCMalloc 會先去申請記憶體並且預分配記憶體。</li>
</ul>
</li>
<li>多線程共享相同的記憶體空間時，同時申請記憶體，需要加鎖，否則會產生同一塊記憶體被多個線程訪問的狀況。
<ul>
<li>可以看到 ThreadCache 那個區塊，他為了每一個 thread 維護了一塊 ThreadCache ，而且每一個都是線程獨立的記憶體空間，也就是說，當 application 要申請記憶體的時候，他會優先向 ThreadCache 申請，也因為 ThreadCache 各自維護了各自的記憶體，所以 application 要申請記憶體的時候，不需要加鎖去申請。</li>
<li>如果 ThreadCache 把記憶體用盡了怎魔辦？他會去向 CentralCache 申請記憶體，但是這個時候需要加鎖，但是聰明的你已經發現，加鎖的可能性已經變低了。</li>
<li>如果 CentralCache 也沒有空間了，他就會向 PageHeap 申請空間。</li>
<li>如果 PageHeap 也沒有空間了，他就會向 VirtualMemory 申請更多記憶體。</li>
</ul>
</li>
</ul>
<p>所以 TCMalloc 解決了記憶體管理會面臨的挑戰以及記憶體的逐級申請機制，那我們在想一下，假設 application 都向 ThreadCache 申請記憶體，而且都不管物件大小，拿來就用，那這不就意味著記憶體管理是很混亂的嗎？</p>
<p>TCMalloc 對於這種混亂的場景又做了增強，他把記憶體分為不同等級 (Size Class)，首先他申請記憶體的動作還按照一個頁一個頁去申請的，但是這個頁的大小是 8K，他會把申請的記憶體，按照不同的 Size Class (每個 Size Class 都會對應一個大小，譬如 8 byte、16 byte) 劃分，總共劃分了 128 種，而相同的大小 Size Class 會組成 Span list，假如 application 去申請一個 byte ，TCMalloc 就會從 Size Class 0 分配記憶體給 application，這是小物件的狀態，但是如果申請大物件的時候，會跳過 ThreadCache 與 CentralCache 去跟 PageHeap 申請記憶體，這就是 TCMalloc 的實現原理。</p>
<ul>
<li>page : 記憶體頁，一塊 8K 大小。 golang 與操作系統之間的記憶體申請與釋放，都是以 page 為單位。</li>
<li>span : 記憶塊，一個或多個連續的 page 組成一個 span。</li>
<li>sizeclass : 空間規格，每個 span 都會帶有一個 sizeclass，標記 span 中的 page 應該如何使用。</li>
<li>object : 物件，用來存儲一個變數數據的記憶體空間，一個 span 在初始化的時候，就會被切割成一堆等大的物件。假設 object 的大小為 16B ， span 大小為 8K ，那麼 span 中的 page 就會被初始化為 8K / 16B = 512 個 object，當 application 來申請的時候，就是分配一個 object 出去。</li>
<li>物件大小定義
<ul>
<li>小物件 : 0 ~ 256KB</li>
<li>中物件 : 256KB ~ 1MB</li>
<li>大物件 : &gt; 1MB</li>
</ul>
</li>
<li>小物件分配流程 ： ThreadCache -&gt; CentralCache -&gt; HeapPage，大部分時候， ThreadCache 的緩存都是足夠的，不需要去訪問 CentralCache 和 HeapPage，無須加鎖，所以分配效率是很高的。</li>
<li>中物件分配流程 ： 直接在 PageHeap 中挑選適當大小的即可，128 Page 的 Span 保存的就是最大的 1MB。</li>
<li>大物件分配流程 ： 從 large span set 選擇合適數量頁面組成 span ，用來存儲數據。</li>
</ul>
<h2 id="golang-記憶體分配"><a class="header" href="#golang-記憶體分配">Golang 記憶體分配</a></h2>
<p>golang 記憶體分配基本上與 TCMalloc 一致，它是在 TCMalloc 在原型上修改與增強，看下面這張圖會看起來很像 TCMalloc，但是還是有一些差異的。</p>
<ul>
<li>在 mcache 內一個 span class 對應兩個 span class ，一個是用來存指針的，一個是用來存直接引用的，存直接引用的 span 無須 GC。</li>
<li>當 mcache 記憶體不夠的時候，會向 mcentral 申請，會優先去 nonempty 的鏈找，因為 nonempty 保存的是這邊有可用的 page，如果還是找不到，就會去 mheap 申請。
<ul>
<li>補充 ： mcache 從 mcentral 獲取和歸還 span 。
<ul>
<li>獲取時，上鎖，從 nonempty 鏈表找到一個可用的 span，並且將其從 nonempty 鏈表刪除，將取出的 span 加入到 empty 鏈，將 span 返回給工作線程，解鎖。</li>
<li>歸還時，上鎖，將 span 從 empty 鏈中刪除，將 span 加入到 nonempty 鏈，解鎖。</li>
</ul>
</li>
</ul>
</li>
<li>在 meap 內依照 Span Class 維護了一個 Binary Sort Tree ，但是他維護了兩棵樹。
<ul>
<li>free ： free 中保存的 span 是空閒的，非垃圾回收的 span。</li>
<li>scav ： scav 中保存的是空閒的，並且已經垃圾回收的 span。</li>
<li>如果是垃圾回收導致 span 的是放，sapn 會被加入到 scav 中，否則會被加入到 free ，比如剛從 Virtual Memory 申請的記憶體。</li>
</ul>
</li>
</ul>
<p><img src="go/images/2022-02-13-golang-memory-management.jpg" alt="" /></p>
<ul>
<li>mcache : 小物件的記憶體分配。
<ul>
<li>size class 總共有 67 個，而 class = 0 是特殊的 span，用於大於 32 kb 的物件，每個 class 兩個 span 。</li>
<li>span 大小是按照 8KB ，按照 span class 大小切分。</li>
</ul>
</li>
<li>mcentral
<ul>
<li>當 mcache 的 span 內所有記憶體塊都被佔用的時候， mcache 會向 mcentral 申請一個 span， mache 拿到 span 後繼續分配物件。</li>
<li>當 mcentral 向 mcache 提供 span 時，如果沒有符合的 span ， mcentral 會向 mheap 申請 span。</li>
</ul>
</li>
<li>mheap
<ul>
<li>當 mheap 沒有足夠的記憶體時，mheap 會向 OS 申請記憶體。</li>
<li>mheap 維護 span 不再是鏈表了，而是 Binary Sort Tree 。</li>
<li>heap 會進行 span 的維護，它包含了地址 mapping 和 span 是否包含指針 metadata，目的是為了更高效的分配、回收與再利用。</li>
</ul>
</li>
</ul>
<h1 id="記憶體回收"><a class="header" href="#記憶體回收">記憶體回收</a></h1>
<h2 id="常見記憶體回收策略"><a class="header" href="#常見記憶體回收策略">常見記憶體回收策略</a></h2>
<h3 id="引用計數"><a class="header" href="#引用計數">引用計數</a></h3>
<ul>
<li>常見語言 ： Python 、 PHP 、 Swift</li>
<li>特性 ： 對每一個物件維護一個引用計數，當引用該物件的物件被銷毀時，引用計數就減 1 ，當引用計數為 0 時，就回收該物件。</li>
<li>優點 ： 物件可以很快的被回收，不會出現記憶體耗盡或者達到某個閥值才回收。</li>
<li>缺點 ： 不能很好的處理循環引用，而且維護引用計數，也有一定的代價。</li>
</ul>
<h3 id="標記清除"><a class="header" href="#標記清除">標記清除</a></h3>
<ul>
<li>常見語言 ： golang</li>
<li>特性 ： 從根變數開始遍歷檢查所有引用物件，引用物件被標計為「被引用」，沒有被標記的就進行回收。</li>
<li>優點 ： 解決引用技術的缺點。</li>
<li>缺點 ： 需要 STW (Stop the world)，即要暫停程式運行。</li>
</ul>
<h3 id="分代收集"><a class="header" href="#分代收集">分代收集</a></h3>
<ul>
<li>常見語言 ： Java 、 .Net(C#) 、 Nodejs (Javascript)</li>
<li>按照生命週期進行劃分不同代空間，生命週期較長的放入老生代，短的放入新生代，新生代的回收頻率會高於老生代的頻率，通常會被分為三代。
<ul>
<li>Young ： 或者被稱為 eden ，存放新創的物件，物件生命週期非常的短，幾乎用完就可以被回收。</li>
<li>Tenured ：或者被稱為 old ， 在 Young 區多次回收後存活下來的物件，將被移轉到 Tenured 區。</li>
<li>Perm ： 永久代，主要存加載類的資訊，生命週期較長，幾乎不會被回收。</li>
</ul>
</li>
<li>優點 ： 大部分的物件都是朝生夕死的，所以可以更高效的清除用完即丟的物件。</li>
<li>缺點 ： 演算法較為複雜，執行的步驟較多。</li>
</ul>
<h2 id="golang-gc-工作流程"><a class="header" href="#golang-gc-工作流程">Golang GC 工作流程</a></h2>
<p>golang GC 的大部分處理是和用戶程式碼並行的，大致上分為四個步驟，基本上就是標記與清除 Mark 與 Sweep。</p>
<ul>
<li>Mark
<ul>
<li>Mark Prepare : 初始化 GC 任務，包括開啟屏障 (WB : write barrier) 和輔助 GC (mutator assis)，和統計 root 物件的任務數量等，這時候需要 STW (stop the world)。</li>
<li>GC Drains : 掃描所有的 root 物件，包括全局指針和 goroutine (G) stack 上的指針 (掃描對應的 G 時，需要停止該 G)，將其加入標計對列 (灰色對列)，並循環處理灰色對列的物件，直到灰色對列為空，這個過程是背景並行處理的。</li>
</ul>
</li>
<li>Mark Termination : 完成標計工作，重新掃描全局指針和 stack。因為 Mark 和用戶的程式是併行的，所以在 Mark 過程中也有可能會有新的物件和指針賦值，這個時候需要通過屏障記錄下來，然後在 rescan 檢查一下，這個過程也是會 STW 的。</li>
<li>Sweep : 按照標記結果回收所有白色對象，這個過程是背景平行處理的。</li>
<li>Sweep Termination : 對未清理的 span 進行清理，只有上一輪的 GC 清理完畢，才會開始新一輪的 GC 。</li>
</ul>
<p><img src="go/images/2022-02-13-golang-gc-flow-chart.jpg" alt="" /></p>
<h2 id="三色標計法"><a class="header" href="#三色標計法">三色標計法</a></h2>
<ul>
<li>GC 開始時，默認所有的 object 都是垃圾，所以都是白色。</li>
<li>從 root 區開始遍歷查找，被找到的物件會被標計為灰色。</li>
<li>從所有灰色的 物件，將他們內部引用的變數標記為灰色，自己則標計為黑色。</li>
<li>循環上面的步驟，直到沒有灰色的物件，只剩下黑白兩種，白色的都是垃圾。</li>
<li>對於黑色的物件，如果在標記期間發生寫操作，寫屏障會在真正賦值前將物件標計為灰色。</li>
<li>標記過程中，mallocgc 新分配的物件，會先被標計為黑色再返回。</li>
</ul>
<h2 id="golang-垃圾回收觸發機制"><a class="header" href="#golang-垃圾回收觸發機制">Golang 垃圾回收觸發機制</a></h2>
<ul>
<li>記憶體分配量達到閥值觸發 GC
<ul>
<li>每次記憶體分配都會檢查當前記憶體分配量，是否已經達到閥值，如果達到閥值則會立即啟動 GC。
<ul>
<li>閥值 = 上次 GC 記憶體分配量 * 記憶體增長量。</li>
<li>記憶體增長量，由環境變數 GOGC 控制，默認為 100，即每當記憶體擴大一倍的時候，啟動 GC。</li>
</ul>
</li>
</ul>
</li>
<li>定期觸發 GC
<ul>
<li>默認情況下，每兩分鐘觸發一次 gc，這個間隔在 src/rumtime/proc.go:forcegcperiod 變數中被宣告。</li>
</ul>
</li>
<li>手動觸發
<ul>
<li>程式代碼中，也可以使用 runtime.GC() 來手動觸發GC。這個主要用於測試 GC 性能和統計。</li>
</ul>
</li>
</ul>
<h1 id="總結-7"><a class="header" href="#總結-7">總結</a></h1>
<p>從<a href="https://alanzhan.dev/post/2022-01-24-golang-goroutine">上一篇</a>讀了那麼硬的知識後，今天來挑戰記憶體管理的歷史到 golang 的記憶體管理相關知識，讀完之後覺得有點痛苦，但是這將會化身成為我們成長的一大養分不是嗎？看完之後你的感想為何呢？</p>
<p>歡迎到我的 Facebook <a href="https://www.facebook.com/alanzhan0513">Alan 的筆記本</a> 留言，順手給我個讚吧！你的讚將成為我持續更新的動力，感謝你的閱讀，讓我們一起學習成為更好的自己。</p>
<h2 id="參考-1"><a class="header" href="#參考-1">參考</a></h2>
<ul>
<li><a href="http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/">Writing a Memory Allocator</a></li>
<li><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc : Thread-Caching Malloc</a></li>
<li><a href="http://legendtkl.com/2015/12/11/go-memory/">tcmalloc 介紹</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29216091">圖解 TCMalloc</a></li>
<li><a href="https://studygolang.com/articles/30505">年度最佳【golang】內存分配詳解</a></li>
<li><a href="https://www.gushiciku.cn/pl/arPC/zh-tw">常見的幾種垃圾回收演算法，背就完了~</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang-goroutine-與-gmp-原理全面分析"><a class="header" href="#golang-goroutine-與-gmp-原理全面分析">Golang Goroutine 與 GMP 原理全面分析</a></h1>
<p>最近在研讀 Kubernetes ，所以得好好地跟 golang 這個語言當朋友，看著看著看到了 goroutine ，但是始終不解 goroutine 是哪來幹嘛、為何而生的？所以我們在開始深入認識 goroutine 之前，我們可能要先來認識一下歷史，這樣我們才能更全面的認識 goroutine 的原理與設計思想。</p>
<h1 id="golang-調度器的由來"><a class="header" href="#golang-調度器的由來">Golang 調度器的由來</a></h1>
<h2 id="單進程時代"><a class="header" href="#單進程時代">單進程時代</a></h2>
<p>我們都知道軟體是跑在操作系統之上的，真正來計算的人是 CPU，早期的操作系統每個程序就是一個進程，直到一個程序運行完畢之後，才能運行下一個進程。</p>
<p>假設有三個進程，分別為 A 、 B 與 C ，那麼在 CPU 上的調度就是依照執行順序執行。</p>
<pre><code>Example: A -&gt; B -&gt; C
</code></pre>
<p>但是在這樣的單進程操作系統時代，會面臨以下的問題：</p>
<ol>
<li>每次只能執行一個進程，計算機只能一個任務一個任務的執行。</li>
<li>若進程發生了 IO 操作堵塞時，容易造成 CPU 資源的浪費。</li>
</ol>
<p>於是就誕生了多進程 / 多線程 的操作系統。</p>
<h2 id="多進程--多線程時代"><a class="header" href="#多進程--多線程時代">多進程 / 多線程時代</a></h2>
<p>在多進程 / 多線程德操作系統中，就解決掉了阻塞的問題，因為一個進程阻塞 CPU 就可以立刻切換到其他進程中去執行，而且調度 CPU 的算法可以保證運行的進程，都可以分配到 CPU 的運行分片，從宏觀的角度來看，似乎多個進程是同時在運行的，相信會有同學不清楚 CPU 的調度原理不清楚的話，可以查看一下 <a href="https://bbs.huaweicloud.com/blogs/288296">CPU 調度原理</a>。</p>
<p>多個進程在分配 CPU 的運行時間片的時候，一切看起來沒問題的，但是工程師們又發現了新的問題，進程在創建、切換、銷毀，都會佔用很長得時間，CPU 的利用率雖然起來了，但是進程過多時，CPU 會有很大一部分的時間都會被用來運行切換進程。</p>
<p>那麼進程在切換的時候，會造成那些開銷呢？</p>
<h3 id="進程切換開銷"><a class="header" href="#進程切換開銷">進程切換開銷</a></h3>
<ul>
<li>直接開銷
<ul>
<li>切換頁表全域性目錄 (PGD)</li>
<li>切換 Kernel 堆疊</li>
<li>切換硬體上下文 (進程恢復之前，必須裝入戰存器的資料，統稱為硬體上下文)</li>
<li>重新整理 TLB</li>
<li>系統調度器的代碼執行</li>
</ul>
</li>
<li>間接開銷
<ul>
<li>CPU 緩存失效導致進程需要用到內存直接訪問的 IO 操作變多</li>
</ul>
</li>
</ul>
<p>所以我們該如何才能提高 CPU 的利用率呢？</p>
<h2 id="協程來提高-cpu-利用率"><a class="header" href="#協程來提高-cpu-利用率">協程來提高 CPU 利用率</a></h2>
<p>聰明的工程師們就發現，其實線程分為內核態線程 (Kernel Thread) 與用戶態線程 (User Thread)，而一個「用戶態線程」必須綁定一個「內核態線程」，但是 CPU 不會知道有「用戶態線程」的存在，他只知道他運行的是一個「內核態線程」 (Linux PCB 進程控制塊)。</p>
<p>那麼我們能不能在用戶態創建維護一個輕量級的協程 (co-routine)，讓多個輕量級的線程綁定到同一個內核態線程上？如果一個內核態線程分到一個運行的時間片之後，那我是不是能在有效的時間內，把用戶態堆積的所有協程都執行完成呢？然後再把 CPU 交出去，那這樣是不是整個執行效率會高很多呢？</p>
<p>所以這就是 Go 語言線程調度遵循的一些原則，那我們來看看 Goroutine。</p>
<h2 id="goroutine-1"><a class="header" href="#goroutine-1">Goroutine</a></h2>
<p>Goroutine 就是 Go 語言的協程概念，Go 語言基於 GMP 模型實現用戶態線程</p>
<ul>
<li>Goroutine ： 表示 goroutine ，每個 goroutine 都有自已的 stack 空間、定時器，初始化的 stack 大小在 2k 左右，空間會隨著需求增長。</li>
<li>Machine ： 抽象化代表內核線程，紀錄內核線程 stack 信息，當 goroutine 調度到線程時候，使用該 goroutine 自己的 stack 信息。</li>
<li>Process ： 表示調度器，負責調度 goroutine ，維護一個本地 goroutine 對列，並且把對列跟 M 綁定，讓 M 從 P 上獲得 goroutine 並執行，同時還負責部分記憶體管理。</li>
</ul>
<p><img src="go/images/2022-01-24-gmp.jpg" alt="" /></p>
<h3 id="mpg-的對應關係"><a class="header" href="#mpg-的對應關係">MPG 的對應關係</a></h3>
<ul>
<li>KSE: Kernel Scheduling Entity</li>
<li>M 我們可以理解跟 Kernel Task 一對一對應</li>
<li>一個 P 上面可以有多個 G，P 會去識當前狀態來決定要跟哪個 M 來綁定，比如說一個 M 已經陷入到內核態，而 P 就有可能換主，去找其他 M 執行。</li>
</ul>
<p><img src="go/images/2022-01-24-mpg.jpg" alt="" /></p>
<h3 id="gmp-模型細節"><a class="header" href="#gmp-模型細節">GMP 模型細節</a></h3>
<p><img src="go/images/2022-01-24-gmp-detail.jpg" alt="" /></p>
<ul>
<li>LRQ： local run queue</li>
<li>GRQ： global run queue</li>
<li>sudog： 阻塞 queue</li>
<li>gFree： 全局自由 G 列表</li>
<li>pidle： 全局空閒 P 列表</li>
</ul>
<p>以下真的上圖的一些細節展開贅述：</p>
<ul>
<li>假設 go 語言在主程序，起了多個 goroutine ，那麼在啟動的過程中，會有一個參數可以設定， go 可以運行多少個併發的現程，一般而言，會看你的節點上有多少個 CPU 併發數就是多少，所以在初始化的過程中，就會按照你的設定數量去初始化 P 。</li>
<li>當 go 語言開始執行了，那其實 go 語言的 main 方法，本身也是一個 goroutine ，所以他就會被落到一個 P 上，那麼這個 main 方法又起了很多個 goroutine ，那麼他就會在當前的 P 上掛載多個 G ，所以在這一刻， P 上會有一堆排隊的 G ，這時候，還沒充分的利用多核心的優勢，因為 G 都掛載在同一個 P 上，但是其他的 P 不可能空手啥事都不幹，這樣未免也太浪費 CPU 了吧！</li>
<li>如果 P 已經空手了，那麼他就會去看 GRQ ，如果還是沒有，他就會去看看其他的 P 是不是有 G 可以執行，假設他發現第一個 P 有正在對列的 G ，那麼他就會拿取一半的 G 過來運行，但是所有的 P 都有這個機制，所以很快的堆積的 G 就被消化完畢。</li>
<li>但是會不會有一種狀況發生，我創建了一堆 G ，超出了 LRQ 的長度 (默認 256)，那麼這個 G 就會放到 GRQ 內。</li>
<li>如果 M 陷入內核態了，那麼 P 就會跟 M 斷開綁定關係， P 就會取找說 哪個 M 是空閒的，並且跟他綁定在一起。</li>
<li>如果一個 G 產生了阻塞，那處於 wait 狀態的 G ，就會被丟到 sudog 阻塞對列裡，他不跟任何的 P 產生綁定關係。</li>
<li>如果 G 已經完成運行後，他會把自己放到 gFree 去，這樣就可以重複使用 G ，減少開銷。</li>
</ul>
<h4 id="p-的狀態"><a class="header" href="#p-的狀態">P 的狀態</a></h4>
<p><img src="go/images/2022-01-24-p-state-machine.jpg" alt="" /></p>
<ul>
<li>_Pidle： 處理器沒有運行用戶代碼或者調度器，被空閒對列或者改變其狀態的結構持有，運行對列為空。</li>
<li>_Prunning： 被線程 M 持有，並且正在執行用戶代碼或者調度器。</li>
<li>_Psyscall： 沒有執行用戶代碼，當前線程陷入系統調用。</li>
<li>_Pgcstop： 被線程 M 持有，當前處理器於垃圾回收被停止。</li>
<li>_Pdead： 當前處理器已經不被使用。</li>
</ul>
<h4 id="g-的狀態"><a class="header" href="#g-的狀態">G 的狀態</a></h4>
<p><img src="go/images/2022-01-24-g-state-machine.jpg" alt="" /></p>
<ul>
<li>_Gidle： 剛剛被分配，並且還沒被初始化，值為 0 ，為創建 goroutine 後的默認值。</li>
<li>_Grunnable： 沒有執行代碼，沒有 stack 的所有權，存儲在運行對列中，可能在某個 P 的本地對列或者全局對列中。</li>
<li>_Grunning： 正在執行代碼的 goroutine，擁有 stack 的所有權。</li>
<li>_Gsyscall： 正在執行系統調用，擁有 stack 的所有權，與 P 脫離，但是與某個 M 綁定，會在調用結束後，被分配到運行對列。</li>
<li>_Gwaiting： 被阻塞的 goroutine，阻塞在某個 channel 的發送或者接收對列。</li>
<li>_Gdead： 當前 goroutine 未被使用，沒有執行代碼，可能有分配的 stack ，分佈在空閒列表，可能是一個剛初始化 goroutine ，也可能是執行 goexit 退出的 goroutine。</li>
<li>_Gcopystac： stack 正在被拷貝，沒有執行代碼，不在運行對列上，執行權在。</li>
<li>_Gscan： GC 正在掃描 stack 空間，沒有執行代碼，可以與其他狀態同時存在。</li>
</ul>
<h3 id="調度器行為"><a class="header" href="#調度器行為">調度器行為</a></h3>
<ul>
<li>為了保證公平，當 GRQ 中有待執行的 G 時候，通過 schedtick 保證有一定的機率 (1/61)，會從 GRQ 中查找 G。</li>
<li>從 P 的 LRQ 中查找待處理的 G。</li>
<li>如果前面兩種都沒找到 G，會通過 runtime.findrunnable 進行阻塞查找 G。
<ul>
<li>從 LRQ 、 GRQ 中查找。</li>
<li>從網路輪詢器中查找是否有 G 等待運行。</li>
<li>通過 runtime.runqsteal 嘗試從其他隨機的 P 中竊取一半的 G。</li>
</ul>
</li>
</ul>
<h1 id="總結-8"><a class="header" href="#總結-8">總結</a></h1>
<p>好久沒看那麼硬的知識了，但我總覺得我今天會消化不良，我需要反反覆覆在看個好幾次，看完之後你的心得如何呢？</p>
<p>歡迎到我的 Facebook <a href="https://www.facebook.com/alanzhan0513">Alan 的筆記本</a> 留言，順手給我個讚吧！你的讚將成為我持續更新的動力，感謝你的閱讀，讓我們一起學習成為更好的自己。</p>
<h2 id="參考-2"><a class="header" href="#參考-2">參考</a></h2>
<ul>
<li><a href="https://github.com/aceld/golang/blob/main/2%E3%80%81Golang%E7%9A%84%E5%8D%94%E7%A8%8B%E8%AA%BF%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%A8%AD%E8%A8%88%E6%80%9D%E6%83%B3%EF%BC%9F.md">Golang的協程調度器原理及GMP設計思想？</a></li>
</ul>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="golang---物件導向"><a class="header" href="#golang---物件導向">GoLang - 物件導向</a></h2>
<p>在這幾篇，會以 Go 語言的入門基礎進行逐步說明，本篇針對物件導向進行說明</p>
<p>在 Go 語言沒有像其他語言一樣有明確定義物件導向(Class, object, instance…) 封裝層，並且沒有 this, self 這種可以代表物件本身的屬性，以及沒有靜態屬性 (那麼本篇結束？)</p>
<p>當然，答案其實是不盡然，在 Go 雖然沒有其他語言有明確定義物件導向，但其實一樣也可實作出物件導向結構。</p>
<p>由於在實作方式會和其他語言有所不同，這部分會讓多數人搞混，就連官方看待 “Go是否為物件導向語言?” 問題，他們回答的是 “yes and no”，以含糊的方式回答。因此，當你進入 Go 的領域時，請放下過去 OO 包袱，重新在這裡學習 Go 語言的物件導向結構。</p>
<h3 id="struct-3"><a class="header" href="#struct-3">struct:</a></h3>
<p>在開始說明 struct 在實作物件導向的用法前，先說明他的基本結構，基本上在宣告一個 struct 時，可以同時宣告他的屬性，例如:</p>
<blockquote>
<p>struct 命名，若字首大寫則為 public 權限，如果小寫則只在自己的 package 內可以訪問。</p>
</blockquote>
<pre><code class="language-go">type User struct{
	name string
	age int
	phone int
}
</code></pre>
<p>例如：</p>
<pre><code class="language-go">type User struct {
  name  string
  age   int
  phone string
}

func main() {

  var user1 User
  user1.name = &quot;Adam&quot;
  user1.age = 10
  user1.phone = &quot;0912345678&quot;

  fmt.Println(user1)
}
//output {Adam 10 0912345678}
</code></pre>
<p>另外，也可直接宣告 struct 預設值</p>
<pre><code class="language-go">type User struct {
  name  string
  age   int
  phone string
}

func main() {

  user1 := User{&quot;Adam&quot;, 10, &quot;0912345678&quot;}

  fmt.Println(user1)
}
//output {Adam 10 0912345678}
</code></pre>
<p>這裡不詳細說明 struct 的各種用法，後續再針對這部份進行介紹，接著來說明如何在 method 如何來結合 struct與func做出物件導向。</p>
<h3 id="method"><a class="header" href="#method">method:</a></h3>
<p>struct 的結構可以在 Go 語言中實作 Class 以及可定義屬性，而 函數 則可實作方法。並且 func 會各自獨立存在。</p>
<p>而 method 可以將 struct 與 func 建立關聯，他的基本結構為：</p>
<pre><code class="language-go">func (receiverParam ReceiverType) funcName(param paramType) (resultsType) {

}
</code></pre>
<p>在下方示範一個例子， user 表示為一般用戶，member 表示為付費會員，在這裡透過 methods 各別定義出兩者的 struct與 func，</p>
<p>func 可以看到，帶入的參數會指定是什麼 struct。</p>
<p>在這裡例子，兩個 methods 名稱都一樣 (都叫 data()) ，但是會依照收的 struct 不同來做區分：</p>
<pre><code class="language-go">type User struct {
  name  string
  age   int
  phone string
}

func (tg User) data() string {
  return &quot;this is user:&quot; + tg.name
}

type Member struct {
  name    string
  balance int
  age     int
  phone   string
}

func (tg Member) data() string {
  return &quot;this is member:&quot; + tg.name
}

func main() {

  user1 := User{&quot;Adam&quot;, 10, &quot;0912345678&quot;}
  member1 := Member{&quot;Brown&quot;, 11, 233, &quot;0912345679&quot;}

  fmt.Println(user1.data()) //output this is user:Adam
  fmt.Println(member1.data()) //output this is member:Brown

}
</code></pre>
<p>當然，這裡透過一個簡單的例子說明，希望對於學習 Go 語言的物件導向應用能有所幫助。在 Go 語言可以做出非常簡單優雅的物件導向架構。更進階的，可以透過 struct 匿名欄位來做出更多元的應用。最後，雖然沒有像其他程式語言，預設就攜帶著豐富的物件導向結構，但是在實際開發需求中，還是可以透過這樣的功能堆疊，進行開發。</p>
<h2 id="建立類別-class-和物件-object-1"><a class="header" href="#建立類別-class-和物件-object-1">建立類別 (Class) 和物件 (Object)</a></h2>
<p>傳統的程序式程式設計 (procedural programming) 或是指令式程式設計 (imperative programming) 學到函式大概就算學完基本概念。</p>
<p>不過，近年來，物件導向程式設計 (object-oriented programming) 是程式設計主流的模式 (paradigm)，即使 C 這種非物件導向的語言，我們也會用結構和函式模擬物件的特性。本文將介紹如何在 Go 撰寫物件導向程式。</p>
<h3 id="五分鐘的物件導向概論"><a class="header" href="#五分鐘的物件導向概論">五分鐘的物件導向概論</a></h3>
<p>由於物件導向是程式設計主流的模式 (paradigm)，很多語言都直接在語法機制中支援物件導向，然而，每個語言支援的物件導向特性略有不同，像 C++ 的物件系統相當完整，而 Perl 的原生物件系統則相對原始。物件導向在理論上是和語言無關的，但在實務上卻受到不同語言特性 (features) 的影響。學習物件導向時，除了學習在某個特定語言下的實作方式外，更應該學習其抽象層次的思維，有時候，暫時放下實作細節，從更高的視角看物件及物件間訊息的流動，對於學習物件導向有相當的幫助。</p>
<p>物件導向是一種將程式碼以更高的層次組織起來的方法。大部分的物件導向以類別 (class) 為基礎，透過類別可產生實際的物件 (object) 或實體 (instance) ，類別和物件就像是餅乾模子和餅乾的關係，透過同一個模子可以產生很多片餅乾。物件擁有屬性 (field) 和方法 (method)，屬性是其內在狀態，而方法是其外在行為。透過物件，狀態和方法是連動的，比起傳統的程序式程式設計，更容易組織程式碼。</p>
<p>許多物件導向語言支援封裝 (encapsulation)，透過封裝，程式設計者可以決定物件的那些部分要對外公開，那些部分僅由內部使用，封裝不僅限於靜態的資料，決定物件應該對外公開的行為也是封裝。當多個物件間互動時，封裝可使得程式碼容易維護，反之，過度暴露物件的內在屬性和細部行為會使得程式碼相互糾結，難以除錯。</p>
<p>物件間可以透過組合 (composition) 再利用程式碼。物件的屬性不一定要是基本型別，也可以是其他物件。組合是透過有… (has-a) 關係建立物件間的關連。例如，汽車物件有引擎物件，而引擎物件本身又有許多的狀態和行為。繼承 (inheritance) 是另一個再利用程式碼的方式，透過繼承，子類別 (child class) 可以再利用父類別 (parent class) 的狀態和行為。繼承是透過是… (is-a) 關係建立物件間的關連。例如，研究生物件是學生物件的特例。然而，過度濫用繼承，容易使程式碼間高度相依，造成程式難以維護。可參考組合勝過繼承 (composition over inheritance) 這個指導原則來設計自己的專案。</p>
<p>透過多型 (polymorphism) 使用物件，不需要在意物件的實作，只需依照其公開介面使用即可。例如，我們想要開車，不論駕駛 Honda 汽車或是 Ford 汽車，由於汽車的儀錶板都大同小異，都可以執行開車這項行為，而不需在意不同廠牌的汽車的內部差異。多型有許多種形式，如：</p>
<ul>
<li>特定多態 (ad hoc polymorphism)：
<ul>
<li>函數重載 (functional overloading)：同名而不同參數型別的方法 (method)</li>
<li>運算子重載 (operator overloading) ： 對不同型別的物件使用相同運算子 (operator)</li>
</ul>
</li>
<li>泛型 (generics)：對不同型別使用相同實作</li>
<li>子類型 (Subtyping)：不同子類別共享相同的公開介面，不同語言有不同的繼承機制</li>
</ul>
<p>以物件導向實作程式，需要從宏觀的角度來思考，不僅要設計單一物件的公開行為，還有物件間如何互動，以達到良好且易於維護的程式碼結構。除了閱讀本教程或其他程式設計的書籍以學習如何實作物件外，可閱讀關於 物件導向分析及設計 (object-oriented analysis and design) 或是設計模式 (design pattern) 的書籍，以增進對物件導向的瞭解。</p>
<p><strong>[Update on 2018/05/20]</strong> 嚴格來說，Go 只能撰寫基於物件的程式 (object-based programming)，無法撰寫物件導向程式 (object-oriented programming)，因為 Go 僅支援一部分的物件導向特性，像是 Go 不支援繼承。</p>
<p>由於 Go 的設計思維，以 Go 實作基於物件的程式時，會和 Java 或 Python 等相對傳統的物件系統略有不同，本文會在相關處提及相同及相異處，供讀者參考。</p>
<h2 id="建立物件-object-1"><a class="header" href="#建立物件-object-1">建立物件 (Object)</a></h2>
<p>以下範例程式碼建立簡單的 Point 類別和物件：</p>
<pre><code class="language-go">package main                                  /*  1 */

import (                                      /*  2 */
        &quot;log&quot;                                 /*  3 */
)                                             /*  4 */

// `X` and `Y` are public fields.             /*  5 */
type Point struct {                           /*  6 */
        X float64                             /*  7 */
        Y float64                             /*  8 */
}                                             /*  9 */

// Use an ordinary function as constructor    /* 10 */
func NewPoint(x float64, y float64) *Point {  /* 11 */
        p := new(Point)                       /* 12 */

        p.X = x                               /* 13 */
        p.Y = y                               /* 14 */

        return p                              /* 15 */
}                                             /* 16 */

func main() {                                 /* 17 */
        p := NewPoint(3, 4)                   /* 18 */

        if !(p.X == 3.0) {                    /* 19 */
                log.Fatal(&quot;Wrong value&quot;)      /* 20 */
        }                                     /* 21 */

        if !(p.Y == 4.0) {                    /* 22 */
                log.Fatal(&quot;Wrong value&quot;)      /* 23 */
        }                                     /* 24 */
}                                             /* 25 */
</code></pre>
<p>第 6 行至第 9 行的部分是形態宣告。Golang 沿用結構體為類別的型態，而沒有用新的保留字。</p>
<p>第 11 行至第 16 行的部分是建構函式。在一些程式語言中，會有為了建立物件使用特定的建構子 (constructor)，而 Golang 沒有引入額外的新語法，直接以一般的函式充當建構函式來建立物件即可。</p>
<p>第 17 行至第 25 行為外部程式。在我們的 Point 物件 <code>p</code> 中，我們直接存取 <code>p</code> 的屬性 <code>X</code> 和 <code>Y</code>，這在物件導向上不是好的習慣，因為我們無法控管屬性，物件可能會產生預期外的行為，比較好的方法，是將屬性隱藏在物件內部，由公開方法去存取。我們在後文中會討論。</p>
<h2 id="類別宣告不限定於結構體-1"><a class="header" href="#類別宣告不限定於結構體-1">類別宣告不限定於結構體</a></h2>
<p>雖然大部分的 Golang 類別都使用結構體，但其實 Golang 類別內部可用其他的型別，如下例：</p>
<pre><code class="language-go">type Vector []float64                     /*  1 */

func NewVector(args ...float64) Vector {  /*  2 */
        return args                       /*  3 */
}                                         /*  4 */

func WithSize(s int) Vector {             /*  5 */
        v := make([]float64, s)           /*  6 */

        return v                          /*  7 */
}                                         /*  8 */
</code></pre>
<p>在第 1 行中，我們宣告 <code>Vector</code> 型態，該型態內部不是使用結構體，而是使用陣列。</p>
<p>我們在第 2 行至第 4 行間及第 5 行至第 8 間宣告了兩個建構函式。由此例可知，Go 不限定建構函式的數量，我們可以視需求使用多個不同的建構函式。</p>
<h2 id="撰寫方法-method-1"><a class="header" href="#撰寫方法-method-1">撰寫方法 (Method)</a></h2>
<p>在物件導向程式中，我們很少直接操作屬性 (field)，通常會將屬性私有化，再加入相對應的公開方法 (method)。我們將先前的 Point 物件改寫如下：</p>
<pre><code class="language-go">package main                                  /*  1 */

import (                                      /*  2 */
        &quot;log&quot;                                 /*  3 */
)                                             /*  4 */

// `x` and `y` are private fields.            /*  5 */
type Point struct {                           /*  6 */
        x float64                             /*  7 */
        y float64                             /*  8 */
}                                             /*  9 */

func NewPoint(x float64, y float64) *Point {  /* 10 */
        p := new(Point)                       /* 11 */

        p.SetX(x)                             /* 12 */
        p.SetY(y)                             /* 13 */

        return p                              /* 14 */
}                                             /* 15 */

// The getter of x                            /* 16 */
func (p *Point) X() float64 {                 /* 17 */
        return p.x                            /* 18 */
}                                             /* 19 */

// The getter of y                            /* 20 */
func (p *Point) Y() float64 {                 /* 21 */
        return p.y                            /* 22 */
}                                             /* 23 */

// The setter of x                            /* 24 */
func (p *Point) SetX(x float64) {             /* 25 */
        p.x = x                               /* 26 */
}                                             /* 27 */

// The setter of y                            /* 28 */
func (p *Point) SetY(y float64) {             /* 29 */
        p.y = y                               /* 30 */
}                                             /* 31 */

func main() {                                 /* 32 */
        p := NewPoint(0, 0)                   /* 33 */

        if !(p.X() == 0) {                    /* 34 */
                log.Fatal(&quot;Wrong value&quot;)      /* 35 */
        }                                     /* 36 */

        if !(p.Y() == 0) {                    /* 37 */
                log.Fatal(&quot;Wrong value&quot;)      /* 38 */
        }                                     /* 39 */

        p.SetX(3)                             /* 40 */
        p.SetY(4)                             /* 41 */

        if !(p.X() == 3.0) {                  /* 42 */
                log.Fatal(&quot;Wrong value&quot;)      /* 43 */
        }                                     /* 44 */

        if !(p.Y() == 4.0) {                  /* 45 */
                log.Fatal(&quot;Wrong value&quot;)      /* 46 */
        }                                     /* 47 */
}                                             /* 48 */
</code></pre>
<p>第 6 行至第 9 行是類別宣告的部分。在這個版本的宣告中，我們將 <code>x</code> 和 <code>y</code> 改為小寫，代表該屬性是私有屬性，其可視度僅限於同一 package 中。</p>
<p>第 10 行至第 15 行是 <code>Point</code> 類別的建構函式。請注意我們刻意在第 12 行及第 13 行用該類別的 setters 來初始化屬性，這是刻意的動作。因為我們要確保在設置屬性時的行為保持一致。</p>
<p>第 16 行至第 31 行是 <code>Point</code> 類別的 getters 和 setters。所謂的 getters 和 setters 是用來存取內部屬性的 method。比起直接暴露屬性，使用 getters 和 setters 會有比較好的控制權。日後要修改 getters 或 setters 的實作時，也只要修改同一個地方即可。</p>
<p>在本例中，getters 和 setters 都是公開 method。但 getters 或 setters 不一定必為公開 method。例如，我們想做唯讀的 <code>Point</code> 物件時，就可以把 setters 的部分設為私有 method，留給類別內部使用。</p>
<p>在 Go 語言中，沒有 <code>this</code> 或 <code>self</code> 這種代表物件的關鍵字，而是由程式設計者自訂代表物件的變數，在本例中，我們用 <code>p</code> 表示物件本身。透過這種帶有物件的函式宣告後，函式會和物件連動；在物件導向中，將這種和物件連動的函式稱為方法 (method)。</p>
<p>雖然在這個例子中，暫時無法直接看出使用方法的好處，比起直接操作屬性，透過私有屬性搭配公開方法帶來許多的益處。例如，如果我們希望 Point 在建立之後是唯讀的，我們只要將 <code>SetX</code> 和 <code>SetY</code> 改為私有方法即可。或者，我們希望限定 Point 所在的範圍為 0.0 至 1000.0，我們可以在 <code>SetX</code> 和 <code>SetY</code> 中檢查參數是否符合我們的要求。</p>
<h2 id="靜態方法-static-method-1"><a class="header" href="#靜態方法-static-method-1">靜態方法 (Static Method)</a></h2>
<p>有些讀者學過 Java 或 C#，可能有聽過過靜態方法 (static method)。這是因為 Java 和 C# 直接將物件導向的概念融入其語法中，然而，為了要讓某些方法在不建立物件時即可使用，所使用的一種補償性的語法機制。由於 Go 語言沒有將物件導向的概念直接加在語法中，不需要用這種語法，直接用頂層函式即可。</p>
<p>例如：我們撰寫一個計算兩點間長度的函式：</p>
<pre><code class="language-go">package main                                   /*  1 */

import (                                       /*  2 */
        &quot;log&quot;                                  /*  3 */
        &quot;math&quot;                                 /*  4 */
)                                              /*  5 */

type Point struct {                            /*  6 */
        x float64                              /*  7 */
        y float64                              /*  8 */
}                                              /*  9 */

func NewPoint(x float64, y float64) *Point {   /* 10 */
        p := new(Point)                        /* 11 */

        p.SetX(x)                              /* 12 */
        p.SetY(y)                              /* 13 */

        return p                               /* 14 */
}                                              /* 15 */

func (p *Point) X() float64 {                  /* 16 */
        return p.x                             /* 17 */
}                                              /* 18 */

func (p *Point) Y() float64 {                  /* 19 */
        return p.y                             /* 20 */
}                                              /* 21 */

func (p *Point) SetX(x float64) {              /* 22 */
        p.x = x                                /* 23 */
}                                              /* 24 */

func (p *Point) SetY(y float64) {              /* 25 */
        p.y = y                                /* 26 */
}                                              /* 27 */

// Use an ordinary function as static method.  /* 28 */
func Dist(p1 *Point, p2 *Point) float64 {      /* 29 */
        xSqr := math.Pow(p1.X()-p2.X(), 2)     /* 30 */
        ySqr := math.Pow(p1.Y()-p2.Y(), 2)     /* 31 */

        return math.Sqrt(xSqr + ySqr)          /* 32 */
}                                              /* 33 */

func main() {                                  /* 34 */
        p1 := NewPoint(0, 0)                   /* 35 */
        p2 := NewPoint(3.0, 4.0)               /* 36 */

        if !(Dist(p1, p2) == 5.0) {            /* 37 */
                log.Fatal(&quot;Wrong value&quot;)       /* 38 */
        }                                      /* 39 */
}                                              /* 40 */
</code></pre>
<p>本範例和前一節的範例大同小異。主要的差別在於第 29 行至第 33 間多了一個用來計算距離的函式。該函式不綁定特定的物件，相當於 Java 的靜態函式。</p>
<p>因為 Golang 不是 Java 這種純物件導向語言，而是混合命令式和物件式兩種語法，所以不需要使用特定的語法來實踐靜態函式，使用一般的函式即可。</p>
<p>或許有讀者會擔心，使用過多的頂層函式會造成全域空間的汙染和衝突；實際上不需擔心，雖然我們目前將物件和主程式寫在一起，實務上，物件會寫在獨立的package 中，藉由 package 即可大幅減低命名空間衝突的議題。</p>
<h2 id="使用嵌入-embedding-取代繼承-inheritance-1"><a class="header" href="#使用嵌入-embedding-取代繼承-inheritance-1">使用嵌入 (Embedding) 取代繼承 (Inheritance)</a></h2>
<p>繼承 (inheritance) 是一種重用程式碼的方式，透過從父類別 (parent class) 繼承程式碼，子類別 (child class) 可以少寫一些程式碼。此外，對於靜態型別語言來說，繼承也是實現多型 (polymorphism) 的方式。然而，Go 語言卻刻意地拿掉繼承，這是出自於其他語言的經驗。</p>
<p>繼承雖然好用，但也引起許多的問題。像是 C++ 相對自由，可以直接使用多重繼承，但這項特性會引來菱型繼承 (diamond inheritance) 的議題，Java 和 C# 刻意把這個機制去掉，改以介面 (interface) 進行有限制的多重繼承。從過往經驗可知過度地使用繼承，會增加程式碼的複雜度，使得專案難以維護。出自於工程上的考量，Go 捨去繼承這個語法特性。</p>
<p>為了補償沒有繼承的缺失，Go 加入了嵌入 (embedding) 這個新的語法特性，透過嵌入，也可以達到程式碼共享的功能。</p>
<p>例如，我們擴展 Point 類別至三維空間：</p>
<pre><code class="language-go">package main                                                 /*  1 */

import (                                                     /*  2 */
        &quot;log&quot;                                                /*  3 */
)                                                            /*  4 */

type Point struct {                                          /*  5 */
        x float64                                            /*  6 */
        y float64                                            /*  7 */
}                                                            /*  8 */

func NewPoint(x float64, y float64) *Point {                 /*  9 */
        p := new(Point)                                      /* 10 */

        p.SetX(x)                                            /* 11 */
        p.SetY(y)                                            /* 12 */

        return p                                             /* 13 */
}                                                            /* 14 */

func (p *Point) X() float64 {                                /* 15 */
        return p.x                                           /* 16 */
}                                                            /* 17 */

func (p *Point) Y() float64 {                                /* 18 */
        return p.y                                           /* 19 */
}                                                            /* 20 */

func (p *Point) SetX(x float64) {                            /* 21 */
        p.x = x                                              /* 22 */
}                                                            /* 23 */

func (p *Point) SetY(y float64) {                            /* 24 */
        p.y = y                                              /* 25 */
}                                                            /* 26 */

type Point3D struct {                                        /* 27 */
        // Point is embedded                                 /* 28 */
        Point                                                /* 29 */
        z float64                                            /* 30 */
}                                                            /* 31 */

func NewPoint3D(x float64, y float64, z float64) *Point3D {  /* 32 */
        p := new(Point3D)                                    /* 33 */

        p.SetX(x)                                            /* 34 */
        p.SetY(y)                                            /* 35 */
        p.SetZ(z)                                            /* 36 */

        return p                                             /* 37 */
}                                                            /* 38 */

func (p *Point3D) Z() float64 {                              /* 39 */
        return p.z                                           /* 40 */
}                                                            /* 41 */

func (p *Point3D) SetZ(z float64) {                          /* 42 */
        p.z = z                                              /* 43 */
}                                                            /* 44 */

func main() {                                                /* 45 */
        p := NewPoint3D(1, 2, 3)                             /* 46 */

        // GetX method is from Point                         /* 47 */
        if !(p.X() == 1) {                                   /* 48 */
                log.Fatal(&quot;Wrong value&quot;)                     /* 49 */
        }                                                    /* 50 */

        // GetY method is from Point                         /* 51 */
        if !(p.Y() == 2) {                                   /* 52 */
                log.Fatal(&quot;Wrong value&quot;)                     /* 53 */
        }                                                    /* 54 */

        // GetZ method is from Point3D                       /* 55 */
        if !(p.Z() == 3) {                                   /* 56 */
                log.Fatal(&quot;Wrong value&quot;)                     /* 57 */
        }                                                    /* 58 */
}                                                            /* 59 */
</code></pre>
<p>第 5 行至第 26 行是原本的 <code>Point</code> 類別，這和先前的實作是雷同的，不多做說明。</p>
<p>第 27 行至第 44 行是 <code>Point3D</code> 類別，我們來看一下這個類別。</p>
<p>第 27 行至第 31 行是 <code>Point3D</code> 的類別宣告。請注意我們在第 29 行嵌入了 <code>Point</code> 類別。</p>
<p>第 32 行至第 38 行是 <code>Point3d</code> 的建構函式。雖然我們沒有為 <code>Point3D</code> 宣告 <code>SetX()</code> 及 <code>SetY()</code> method，但我們有嵌入 <code>Point</code> 類別，所以我們在第 34 行及第 35 行可以直接使用這些 method。</p>
<p>第 45 行至第 59 行是外部程式的部分。由於我們的 <code>Point3D</code> 內嵌了 <code>Point</code>，雖然 <code>Point3D</code> 沒有自己實作 <code>X()</code> 和 <code>Y()</code> method，我們在第 48 行及第 52 行可直接呼叫這些 method。</p>
<p>在本例中，我們重用了 <code>Point</code> 的方法，再加入 <code>Point3D</code> 特有的方法。實際上的效果等同於繼承。</p>
<p>然而，<code>Point</code> 和 <code>Point3D</code> 兩者在類別關係上卻是不相干的獨立物件。在以下例子中，我們想將 <code>Point3D</code> 加入 <code>Point</code> 物件組成的切片，而引發程式的錯誤：</p>
<pre><code class="language-go">// Declare Point and Point3D as above.
 
func main() {
    points := make([]*Point, 0)
 
    p1 := NewPoint(3, 4)
    p2 := NewPoint3D(1, 2, 3)
 
    // Error!
    points = append(points, p1, p2)
}
</code></pre>
<p>在 Go 語言中，需要使用介面 (interface) 來解決這個議題，這就是我們下一篇文章所要探討的主題。</p>
<h2 id="嵌入指標-1"><a class="header" href="#嵌入指標-1">嵌入指標</a></h2>
<p>除了嵌入其他結構外，結構也可以嵌入指標。我們將上例改寫如下：</p>
<pre><code class="language-go">package main
 
import (
    &quot;log&quot;
)
 
type Point struct {
    x float64
    y float64
}
 
func NewPoint(x float64, y float64) *Point {
    p := new(Point)
 
    p.SetX(x)
    p.SetY(y)
 
    return p
}
 
func (p *Point) X() float64 {
    return p.x
}
 
func (p *Point) Y() float64 {
    return p.y
}
 
func (p *Point) SetX(x float64) {
    p.x = x
}
 
func (p *Point) SetY(y float64) {
    p.y = y
}
 
type Point3D struct {
    // Point is embedded as a pointer
    *Point
    z float64
}
 
func NewPoint3D(x float64, y float64, z float64) *Point3D {
    p := new(Point3D)
 
    // Forward promotion
    p.Point = NewPoint(x, y)
 
    // Forward promotion
    p.Point.SetX(x)
    p.Point.SetY(y)
 
    p.SetZ(z)
 
    return p
}
 
func (p *Point3D) Z() float64 {
    return p.z
}
 
func (p *Point3D) SetZ(z float64) {
    p.z = z
}
 
func main() {
    p := NewPoint3D(1, 2, 3)
 
    // GetX method is from Point
    if !(p.X() == 1) {
        log.Fatal(&quot;Wrong value&quot;)
    }
 
    // GetY method is from Point
    if !(p.Y() == 2) {
        log.Fatal(&quot;Wrong value&quot;)
    }
 
    // GetZ method is from Point3D
    if !(p.Z() == 3) {
        log.Fatal(&quot;Wrong value&quot;)
    }
}
</code></pre>
<p>同樣地，仍然不能透過嵌入指楆讓型別直接互通，而需要透過介面 (interface)。</p>
<h2 id="結語-2"><a class="header" href="#結語-2">結語</a></h2>
<p>在本文中，我們介紹了 Golang 的物件系統。相較於 C++ 或 Java 或 C#，Golang 的物件系統相對比較輕量，儘量不使用新的保留字，而用現用的語法來實現物件的特性。</p>
<p>Golang 的物件系統刻意拿掉繼承，改用嵌入來重用程式碼，這是由先前的程式語言中學習到的經驗和教訓。但嵌入無法實踐子類別 (subtyping)，這個問題要等到我們下一篇講到的介面 (interface) 才有解。</p>
<hr />
<p>沒有 object、沒有 class 、沒有繼承的 Go，
靠著 struct / method / interface，
好像也享有 OOP 語言的優點呢</p>
<h2 id="method-1"><a class="header" href="#method-1">method</a></h2>
<p>本來以為 Go 是物件導向，後來發現<strong>沒有 class</strong>！
基本上使用 struct 與 method 來達到類似的效果。</p>
<p>method 是一個有 receiver argument 的 function
we can define method on a type. （不一定是 struct，但這個 type 要在同個 package 中，int 這些 built-in type 要先透過 type 關鍵字來定義一個新型別才能用，例如 <code>type myint int</code>）</p>
<pre><code>// 定義 Vertex struct
type Vertex struct {
	X, Y float64
}
// Abs method
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
    // 使用 method 時就像別的語言使用一個 class 內ㄉ function 一樣
	fmt.Println(v.Abs())
}
</code></pre>
<ul>
<li><strong>receiver argument 的型別很重要！golang 會依據他的型別幫忙轉～所以如果這個 method 要改值，記得在 receiver 那邊寫好是吃 pointer（打星星）</strong></li>
</ul>
<pre><code>// v *Vertex 這樣就算下面的 v 並不是一個 pointer，go 也會幫忙轉 &amp;v
func (v *Vertex) Scale(f float64) { 
	v.X = v.X * f
	v.Y = v.Y * f
}
func main() {
    // 如果拿掉上面 receiver 的*，也可以在這邊 &amp;Vertex{3, 4}
	v := Vertex{3, 4}
    // 或是 (&amp;v).Scale(10)
	v.Scale(10)
}
</code></pre>
<h2 id="interface"><a class="header" href="#interface">interface</a></h2>
<p>Go 裡 interface 是一個型別，裡面有定義一堆 method signatures，
只要合乎這些簽章的數值（通常是 struct）就可以放進這個介面變數。
如果這個變數沒有實作規定的 method 的話，就會噴錯。</p>
<ul>
<li>empty interface
沒有定義任何 method 的 interface 當作 input 的型別，就可以接受任意型別的 input。</li>
</ul>
<p>以下例子來自<a href="https://ithelp.ithome.com.tw/articles/10218401">day15 - 介面(續)</a>
empty interface + 以 type 為不同 case 的 switch</p>
<pre><code>func main() {
	printAnyType(2020)
	printAnyType(&quot;Iron Man&quot;)
	printAnyType(0.25)
}

// 定義一個函式，接收任何型別，並且格式化輸出值
func printAnyType(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf(&quot;case int: %d \n&quot;, v)
	case string:
		fmt.Printf(&quot;case string: %s \n&quot;, v)
	default:
		fmt.Printf(&quot;default: %v \n&quot;, v)
	}
}
</code></pre>
<h2 id="沒有繼承"><a class="header" href="#沒有繼承">沒有繼承</a></h2>
<p>畢竟沒有 class，也沒有繼承的概念。
而是使用 struct 中包 struct，稱之為 composition。
go 中還能使用 embbeded，這裡不打了。</p>
<p>在物件導向程式中，通常會用繼承來共享上層元件的程式碼。然而，go語言沒有繼承的特性，但我們能用組合的方式來共享程式碼。不僅如此，go語言還提供一種優於組合的語法特性，稱作內嵌。</p>
<h3 id="組合composition-1"><a class="header" href="#組合composition-1">組合(composition)</a></h3>
<p>先來談談我所知道的組合，大部分的文章會講到組合是聚合(aggregation)的一種，而它們都是源自於UML的產物，實際上UML定義的定義很模糊也很難理解。因此，我要講的是它們最基本的一面，也就是 <code>Is-A</code> 和 <code>Has-A</code> 關係:</p>
<ul>
<li>Is-A: 繼承關係，表示一個物件也是另一個物件。</li>
<li>Has-A: 組合關係，表示一個物件擁有另一個物件。</li>
</ul>
<p>很多文章和書都建議我們要多用<strong>組合少用繼承</strong>，這是因為繼承會對物件造成巨大的依賴關係。我們用一個範例來說明組合:</p>
<pre><code class="language-go">// 定義一個英雄結構，包含了正常人結構
type Hero struct {
	Person   *Person
	HeroName string
	HerkRank int
}

// 定義一個正常人結構
type Person struct {
	Name string
}

func main() {
	var tony = &amp;Hero{&amp;Person{&quot;Tony Stark&quot;}, &quot;Iron Man&quot;, 1}
	fmt.Printf(&quot;Hero=%+v\n&quot;, *tony)
	fmt.Printf(&quot;Person=%+v\n&quot;, *(tony.Person))
}
</code></pre>
<p>執行結果:</p>
<pre><code class="language-bash">Hero={Person:0xc0000841e0 HeroName:Iron Man HerkRank:1}
Person={Name:Tony Stark}
</code></pre>
<p>上面範例中，我們看到了所謂的組合就是結構再包結構的概念，透過這樣的方式共享結構資料或方法。</p>
<h3 id="內嵌embedding-1"><a class="header" href="#內嵌embedding-1">內嵌(Embedding)</a></h3>
<p>再來談談go語言的內嵌特性，這個特性並沒有寫在<strong>A Tour of Go</strong>，而是在<strong>Effective Go</strong>裡頭。</p>
<p>Effective Go: <a href="https://golang.org/doc/effective_go.html#embedding">Embedding</a></p>
<p>Go語言的內嵌其實就是組合的概念，只是它更加簡潔及強大。內嵌允許我們在結構內組合其他結構時，不需要定義欄位名稱，並且能直接透過該結構叫用欄位或方法。我們將上面的範例改成使用內嵌，如下:</p>
<pre><code class="language-go">// 定義一個英雄結構
type Hero struct {
	*Person   // 不需要欄位名稱
	HeroName string
	HerkRank int
}

// 定義一個正常人結構
type Person struct {
	Name string
}

func main() {
	var tony = &amp;Hero{
		&amp;Person{&quot;Tony Stark&quot;},
		&quot;Iron Man&quot;,
		1}

	fmt.Printf(&quot;%s\n&quot;, tony.Name)    // 直接叫用內部結構資料
	// 等於 fmt.Printf(&quot;%s\n&quot;, tony.Person.Name)
}
// 執行結果: Tony Stark
</code></pre>
<p>實際上，內嵌的結構欄位還是會有名稱，就是和結構本身的名稱同名。</p>
<p>另外，上面範例是用匿名初始化，也可以使用具名初始化，差別在於初始化參數的數量和順序是可以被調整的:</p>
<pre><code class="language-go">var tony = &amp;Hero{
		Person:   &amp;Person{&quot;Tony Stark&quot;},
		HeroName: &quot;Iron Man&quot;,
		HeroRank: 1}
</code></pre>
<h3 id="內嵌與方法-1"><a class="header" href="#內嵌與方法-1">內嵌與方法</a></h3>
<p>上面看到的範例都是內嵌結構資料，現在我們來試試看內嵌結構方法，修改同一個範例如下:</p>
<pre><code class="language-go">// 定義一個英雄結構
type Hero struct {
	*Person
	HeroName string
	HeroRank int
}

// 英雄都會飛
func (*Hero) Fly() {
	fmt.Println(&quot;I can fly.&quot;)
}

// 定義一個正常人結構
type Person struct {
	Name string
}

// 正常人會走路
func (*Person) Walk() {
	fmt.Println(&quot;I can walk.&quot;)
}

func main() {
	var tony = &amp;Hero{
		Person:   &amp;Person{&quot;Tony Stark&quot;},
		HeroName: &quot;Iron Man&quot;,
		HeroRank: 1}

	tony.Walk()   // 等於 tony.Person.Walk()
	tony.Fly()
}
</code></pre>
<p>執行結果:</p>
<pre><code class="language-bash">I can walk.
I can fly.
</code></pre>
<h3 id="內嵌結構欄位同名-1"><a class="header" href="#內嵌結構欄位同名-1">內嵌結構欄位同名</a></h3>
<p>當有多個內嵌結構時，就有可能發生欄位同名的問題。我們稍微修改一下範例，超級英雄也會想養一隻寵物，這很合理的。因此，我們就加入一個寵物結構:</p>
<pre><code class="language-go">// 定義一個英雄結構
type Hero struct {
	*Person
	*Pet
	HeroName string
	HeroRank int
}

// 定義一個正常人結構
type Person struct {
	Name string
}

// 定義一個寵物結構
type Pet struct {
	Name string
}

func main() {
	var tony = &amp;Hero{
		Person:   &amp;Person{&quot;Tony Stark&quot;},
		Pet:   &amp;Pet{&quot;Pepper&quot;},
		HeroName: &quot;Iron Man&quot;,
		HeroRank: 1}

	fmt.Printf(&quot;%s\n&quot;, tony.Name)
}
</code></pre>
<p>由於 Person 和 Parner 都有 Name 這個欄位，直接叫用 tony.Name 就會產生衝突，編譯器會顯示錯誤訊息:</p>
<pre><code class="language-bash">./main.go:40:25: ambiguous selector tony.Name
</code></pre>
<h3 id="內嵌其他型別-1"><a class="header" href="#內嵌其他型別-1">內嵌其他型別</a></h3>
<p>事實上，可以被內嵌的型別不只有結構，也可以是基本型別，範例如下:</p>
<pre><code class="language-go">type Data struct {
	int
	string
	float32
	bool
}

func main() {
	var data = &amp;Data{1, &quot;Iron Man&quot;, 1.2, true}
	fmt.Println(*data)
	fmt.Printf(&quot;%+v \n&quot;, *data)
}
</code></pre>
<p>執行結果</p>
<pre><code class="language-bash">{1 Iron Man 1.2 true}
{int:1 string:Iron Man float32:1.2 bool:true} 
</code></pre>
<p>基本型別被內嵌之後，欄位名稱就是型別的原始名稱，ex: int, string, ...。</p>
<h3 id="小結-1"><a class="header" href="#小結-1">小結</a></h3>
<p>今天介紹了go語言的內嵌特性，使得沒有繼承的go語言，依然可以相互共享結構內的程式碼。而這樣的作法在實務上究竟是否優於繼承，可能需要寫久一點，才會深刻了解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-簡單例子來理解-syncmutex-和-syncrwmutex"><a class="header" href="#go-簡單例子來理解-syncmutex-和-syncrwmutex">Go 簡單例子來理解 sync.Mutex 和 sync.RWMutex</a></h1>
<p>出處: https://clouding.city/go/mutex-rwmutex/</p>
<p>用簡單的例子來理解 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code>。</p>
<h2 id="蓋一間銀行"><a class="header" href="#蓋一間銀行">蓋一間銀行</a></h2>
<p>假設有一間銀行，可以存款和查詢餘額。</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

type Bank struct {
    balance int
}

func (b *Bank) Deposit(amount int) {
    b.balance += amount
}

func (b *Bank) Balance() int {
    return b.balance
}

func main() {
    b := &amp;Bank{}

    b.Deposit(1000)
    b.Deposit(1000)
    b.Deposit(1000)

    fmt.Println(b.Balance())
}
$ go run main.go
3000
</code></pre>
<p>執行之後結果是 3000 沒問題，1000+1000+1000=3000。</p>
<h2 id="同時存款"><a class="header" href="#同時存款">同時存款</a></h2>
<p>銀行不太可能讓人一個一個排隊存款，也需要支援同時存款，當今天存款的動作是並行的，會發生什麼事呢？</p>
<p>這邊用 sync.WaitGroup 去等待所有 goroutine 執行完畢，之後再印出餘額。</p>
<pre><code class="language-go">func main() {
    var wg sync.WaitGroup
    b := &amp;Bank{}

    wg.Add(3)
    go func() {
        b.Deposit(1000)
        wg.Done()
    }()
    go func() {
        b.Deposit(1000)
        wg.Done()
    }()
    go func() {
        b.Deposit(1000)
        wg.Done()
    }()

    wg.Wait()

    fmt.Println(b.Balance())
}
$ go run main.go
3000
</code></pre>
<p>還是 3000 沒問題，那我們同時存款 1000 次的時候會發生什麼事呢？</p>
<pre><code class="language-go">func main() {
    var wg sync.WaitGroup
    b := &amp;Bank{}

    n := 1000
    wg.Add(n)
    for i := 1; i &lt;= n; i++ {
        go func() {
            b.Deposit(1000)
            wg.Done()
        }()
    }

    fmt.Println(b.Balance())
}
$ go run main.go
946000
</code></pre>
<p>誒奇怪，正常來說 1000 * 1000 = 1000000 嗎？怎麼數字不正確！</p>
<p>我們這次多帶一個參數 <code>-race</code> 跑看看</p>
<blockquote>
<p><code>-race</code> 參數是 go 的 <a href="https://blog.golang.org/race-detector">Race Detector</a>，內建整合工具，可以輕鬆檢查出是否有 race condition</p>
</blockquote>
<pre><code class="language-shell">$ go run -race main.go
==================
WARNING: DATA RACE
Read at 0x00c00009e010 by goroutine 8:
  main.main.func1()
      .../main.go:15 +0x6f

Previous write at 0x00c00009e010 by goroutine 7:
  main.main.func1()
      .../main.go:15 +0x85

Goroutine 8 (running) created at:
  main.main()
      .../main.go:31 +0xf4

Goroutine 7 (finished) created at:
  main.main()
      .../main.go:31 +0xf4
==================
996000
Found 1 data race(s)
exit status 66
</code></pre>
<p>喔喔喔發現原來有 <a href="https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3">race condition</a>， 因為同時去對 Bank.balance 去做存取的動作，數量少的時候可能沒問題，當量大的時候就可能出錯。</p>
<h2 id="syncmutex"><a class="header" href="#syncmutex">sync.Mutex</a></h2>
<p>為了防止這種狀況發生，就可以用<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%8E%96">互斥鎖</a> <code>sync.Mutex</code> 來處理這個問題，同時間只有一個 goroutine 能存取該變數。</p>
<p>這次我們在 <code>Deposit()</code> 存款前先 <code>Lock()</code>，存款後再 <code>Unlock()</code>。</p>
<pre><code class="language-go">type Bank struct {
    balance int
    mux     sync.Mutex
}

func (b *Bank) Deposit(amount int) {
    b.mux.Lock()
    b.balance += amount
    b.mux.Unlock()
}

func (b *Bank) Balance() int {
    return b.balance
}
$ go run -race main.go
1000000
</code></pre>
<p>這次結果正確了，而且也沒跳出 race condition 的警訊。</p>
<h2 id="同時存款和查詢"><a class="header" href="#同時存款和查詢">同時存款和查詢</a></h2>
<p>想當然會有多人一起存款，就會有多人一起查詢餘額。<del>也會有多人一起運動</del></p>
<p>多加一組查詢 1000 次的 goroutine 再執行看看。</p>
<pre><code class="language-go">func main() {
    var wg sync.WaitGroup

    b := &amp;Bank{}

    n := 1000
    wg.Add(n)
    for i := 1; i &lt;= n; i++ {
        go func() {
            b.Deposit(1000)
            wg.Done()
        }()
    }
    wg.Add(n)
    for i := 1; i &lt;= n; i++ {
        go func() {
            _ = b.Balance()
            wg.Done()
        }()
    }

    wg.Wait()

    fmt.Println(b.Balance())
}
$ go run -race main.go
==================
WARNING: DATA RACE
Read at 0x00c0000180e0 by goroutine 59:
  main.main.func2()
      .../main.go:22 +0x6f

Previous write at 0x00c0000180e0 by goroutine 58:
  main.(*Bank).Deposit()
      .../main.go:15 +0x70
  main.main.func1()
      .../main.go:35 +0x75

Goroutine 59 (running) created at:
  main.main()
      .../main.go:40 +0x153

Goroutine 58 (finished) created at:
  main.main()
      .../main.go:33 +0xf4
==================
==================
WARNING: DATA RACE
Read at 0x00c0000180e0 by goroutine 60:
  main.main.func2()
      .../main.go:22 +0x6f

Previous write at 0x00c0000180e0 by goroutine 58:
  main.(*Bank).Deposit()
      .../main.go:15 +0x70
  main.main.func1()
      .../main.go:35 +0x75

Goroutine 60 (running) created at:
  main.main()
      .../main.go:40 +0x153

Goroutine 58 (finished) created at:
  main.main()
      .../main.go:33 +0xf4
==================
1000000
Found 2 data race(s)
exit status 66
</code></pre>
<p>不意外，因為同時對 balance 去做讀寫，當然跳出 race condition 的警告。</p>
<p>我們一樣在 Balance() 加上 <code>Lock()</code> 和 <code>Unlock()</code> 後執行。</p>
<pre><code class="language-go">type Bank struct {
    balance int
    mux     sync.Mutex
}

func (b *Bank) Deposit(amount int) {
    b.mux.Lock()
    b.balance += amount
    b.mux.Unlock()
}

func (b *Bank) Balance() (balnce int) {
    b.mux.Lock()
    balance = b.balance
    b.mux.Unlock()
    return 
}
$ go run -race main.go
1000000
</code></pre>
<p>結果成功了，也沒有 race 的警告了。</p>
<h2 id="讀寫互相阻塞"><a class="header" href="#讀寫互相阻塞">讀寫互相阻塞</a></h2>
<p>目前這邊看起來都還不錯，但以現在的情況來說，只要有人讀，或只要有人寫，就會被 block。</p>
<p>假如銀行存款和查詢各要上花一秒：</p>
<pre><code class="language-go">package main

import (
    &quot;log&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Bank struct {
    balance int
    mux     sync.Mutex
}

func (b *Bank) Deposit(amount int) {
    b.mux.Lock()
    time.Sleep(time.Second) // spend 1 second
    b.balance += amount
    b.mux.Unlock()
}

func (b *Bank) Balance() (balance int) {
    b.mux.Lock()
    time.Sleep(time.Second) // spend 1 second
    balance = b.balance
    b.mux.Unlock()
    return 
}

func main() {
    var wg sync.WaitGroup
    b := &amp;Bank{}

    n := 5
    wg.Add(n)
    for i := 1; i &lt;= n; i++ {
        go func() {
            b.Deposit(1000)
            log.Printf(&quot;Write: deposit amonut: %v&quot;, 1000)
            wg.Done()
        }()
    }
    wg.Add(n)
    for i := 1; i &lt;= n; i++ {
        go func() {
            log.Printf(&quot;Read: balance: %v&quot;, b.Balance())
            wg.Done()
        }()
    }

    wg.Wait()
}
$ go run -race main.go
2020/05/02 02:11:24 Write: deposit amonut: 1000
2020/05/02 02:11:25 Write: deposit amonut: 1000
2020/05/02 02:11:26 Write: deposit amonut: 1000
2020/05/02 02:11:27 Write: deposit amonut: 1000
2020/05/02 02:11:28 Write: deposit amonut: 1000
2020/05/02 02:11:29 Read: balance: 5000
2020/05/02 02:11:30 Read: balance: 5000
2020/05/02 02:11:31 Read: balance: 5000
2020/05/02 02:11:32 Read: balance: 5000
2020/05/02 02:11:33 Read: balance: 5000
</code></pre>
<p>就會發現，每隔一秒才能處理一個 action，以各五次讀寫來說，總共就要花上 10 秒，但對讀來說，應該可以瘋狂讀，每次讀都會是安全的， 值也都會是一樣，除非當下有寫的動作，它不應該被其他讀的動作 block。</p>
<h2 id="syncrwmutex"><a class="header" href="#syncrwmutex">sync.RWMutex</a></h2>
<p><code>sync.RWMutex</code> 是一個<a href="https://zh.wikipedia.org/wiki/%E8%AE%80%E5%AF%AB%E9%8E%96">讀寫鎖</a>(multiple readers, single writer lock)，多讀單寫，可以允許多個讀並發，單個寫。</p>
<p>把 <code>sync.Mutex</code> 換成 <code>sync.RWMutex</code>：</p>
<pre><code class="language-go">type Bank struct {
    balance int
    mux     sync.RWMutex    // read write lock
}

func (b *Bank) Deposit(amount int) {
    b.mux.Lock()            // write lock
    time.Sleep(time.Second)
    b.balance += amount
    b.mux.Unlock()          // wirte unlock
}

func (b *Bank) Balance() (balance int) {
    b.mux.RWLock()          // read lock
    time.Sleep(time.Second)
    balance = b.balance
    b.mux.RWUnlock()        // read unlock
    return 
}
$ go run -race main.go
2020/05/02 02:13:59 Write: deposit amonut: 1000
2020/05/02 02:14:00 Read: balance: 1000
2020/05/02 02:14:00 Read: balance: 1000
2020/05/02 02:14:00 Read: balance: 1000
2020/05/02 02:14:00 Read: balance: 1000
2020/05/02 02:14:00 Read: balance: 1000
2020/05/02 02:14:01 Write: deposit amonut: 1000
2020/05/02 02:14:02 Write: deposit amonut: 1000
2020/05/02 02:14:03 Write: deposit amonut: 1000
2020/05/02 02:14:04 Write: deposit amonut: 1000
</code></pre>
<p>執行之後會發現，本來要花 10 秒，已經縮短成 5 秒了，只要當下是讀的時候，都會同時進行，並不會互相影響，寫的時候就會 block 讀和寫，只有一個寫會發生。</p>
<h2 id="總結-9"><a class="header" href="#總結-9">總結</a></h2>
<ol>
<li>在寫 goroutine 的時候，需要考慮 race condition，在執行或測試上可以加上 <code>-race</code> 去檢查，以免結果與預期不符</li>
<li>遇到 race condition 的時候可以考慮用 <code>sync.Mutex</code> 來解決，有讀寫阻塞的時候可以用 <code>sync.RWMutex</code></li>
<li><code>syncRWMutex</code> 可以有同時允許多個 <code>RLock</code> 和 <code>RUnlock</code> 但只能有一個 <code>Lock</code> 和 <code>Unlock</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang---深入理解-interface-常見用法"><a class="header" href="#golang---深入理解-interface-常見用法">Golang - 深入理解 interface 常見用法</a></h1>
<p>出處: https://blog.kennycoder.io/2020/02/03/Golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3interface%E5%B8%B8%E8%A6%8B%E7%94%A8%E6%B3%95/</p>
<p>此篇文章介紹在 Golang 中 interface 的常見用法，interface 在 Golang 中是一個很重要的環節。interface 可以拿來實現多種用途，請看介紹。</p>
<h2 id="interface-定義"><a class="header" href="#interface-定義">interface 定義</a></h2>
<p>interface 又稱接口，其實功能有點類似於 Java 中的 interface，但是在一些地方完全不同於 Java 中 interface 的設計。</p>
<p>在 Golang 中，interface 其中一個功能就是可以使用 interface 定義行為，也就是說 interface 中可以定義一些方法來表示一個對象的行為，而當我們有自定義的型態假設想要擁有這些行為，就是去實踐 interface 裡面的方法。</p>
<h2 id="interface-定義行為"><a class="header" href="#interface-定義行為">interface 定義行為</a></h2>
<p>來看個例子：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Animal interface {
	Eat()
	Run()
}

type Dog struct {
	Name string
}

func (d *Dog) Eat() {
	fmt.Printf(&quot;%s is eating\n&quot;, d.Name)
}

func (d *Dog) Run() {
	fmt.Printf(&quot;%s is running\n&quot;, d.Name)
}

func ShowEat(animal Animal) {
	animal.Eat()
}

func ShowRun(animal Animal) {
	animal.Run()
}

func main() {
	dog := Dog{Name:&quot;Kenny&quot;}
	ShowEat(&amp;dog)
	ShowRun(&amp;dog)
}
</code></pre>
<ol>
<li>建立一個 Animal 型態的 interface，其定義了 Eat () 跟 Run ()，來表達動物都會擁有的行為。</li>
<li>建立一個 Dog Struct，並且實踐 interface 裡面的 Eat () 跟 Run ()。要注意的是，由於在實作 <code>Eat</code> 與 <code>Run</code> 方法時，都是用指標 <code>(d *Dog)</code> ，這個所代表的意思是透過傳遞指標來操控同一個 Struct 實例，如果沒有用指標則會導致淺複製的行為，並不是操控同一個 Struct。</li>
<li>建立 ShowEat、ShowRun 方法，並且參數型態用 Animal。</li>
</ol>
<p>以上的程式碼可以得知以下兩件事情：</p>
<ol>
<li>在 Golang 中如果自定義型態實現了 interface 的所有方法，那麼它就會認定該自定義型態也是 interface 型態的一種。也就是所謂的鴨子型別 (Duck typing) 的實現。只要你有符合這些種種的行為，即使你不是真的鴨子，那麼還是會認定你是一隻鴨子。</li>
<li>透過 ShowRun 跟 ShowEat () 得知實現了多型的行為。所謂多型的意思是相同的訊息給予不同的物件會引發不同的動作，因為參數型態用 Animal 所以，每個動物會有各自的吃跟跑的行為，執行出來的結果也會各自不一樣。</li>
</ol>
<h2 id="interface-型態與值"><a class="header" href="#interface-型態與值">interface 型態與值</a></h2>
<p>將 main 裡面程式碼改成這樣：</p>
<pre><code class="language-go">func main() {
	var animal Animal
	fmt.Println(animal)
}
</code></pre>
<p>這樣輸出會是 nil。</p>
<ol>
<li>
<p>這代表著 <code>animal</code> 在底層儲存的型態為 <code>nil</code>。interface 類型默認是一個指針 (引用類型)，如果沒有對 interface 初始化就使用，那麼會輸出 <code>nil</code>。</p>
</li>
<li>
<p>但是我們可以指定自定義型態給 nil interface，如果該自定義型態有實現該 interface 方法即可。</p>
<pre><code class="language-go">func main() {
	var animal Animal
	animal = &amp;Dog{Name:&quot;Kenny&quot;}
	fmt.Println(animal)
}
</code></pre>
<p>運行結果為 <code>&amp;{Kenny}</code>。</p>
<p>也就是說 <code>animal</code> 底層儲存的型態會 <code>*Dog</code>，而值是 <code>Dog</code> 結構實例的位址值。</p>
</li>
</ol>
<h2 id="interface-繼承"><a class="header" href="#interface-繼承">interface 繼承</a></h2>
<p>一個自定義型態是可以實現多個 interface 的。此外，interface 也可以繼承別的 interface 的行為：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Eater interface {
	Eat()
}

type Runner interface {
	Run()
}

type Animal interface {
	Eater
	Runner
}

type Dog struct {
	Name string
}

func (d *Dog) Eat() {
	fmt.Printf(&quot;%s is eating\n&quot;, d.Name)
}

func (d *Dog) Run() {
	fmt.Printf(&quot;%s is running\n&quot;, d.Name)
}

func ShowEat(animal Animal) {
	animal.Eat()
}

func ShowRun(animal Animal) {
	animal.Run()
}

func ShowEat2(eater Eater) {
	eater.Eat()
}

func ShowRun2(runner Runner) {
	runner.Run()
}

func main() {
	dog := Dog{Name:&quot;Kenny&quot;}
	ShowEat(&amp;dog)
	ShowRun(&amp;dog)
	ShowEat2(&amp;dog)
	ShowRun2(&amp;dog)
}
</code></pre>
<p>在 Animal interface 透過內嵌的方式，將 Eater interface、Runner interface 定義的行為放進去。</p>
<p>這樣的話 Dog Struct 必須都實現 Eat () 跟 Run () 才能是 Animal 的一種。此外，因為這樣做也代表，Dog Struct 也是 Eater 及 Runner 的一種。</p>
<p>所以看到定義的 ShowEat2 () 跟 ShowRun2 () 皆能接受 Dog Struct。</p>
<h2 id="透過-interface-儲存異質陣列或-slice"><a class="header" href="#透過-interface-儲存異質陣列或-slice">透過 interface 儲存異質陣列或 slice</a></h2>
<p>前面說過 Golang 會檢查類型的實例，是否都有實現 interface 定義的行為，如果是的話就可以接受介面型態是不同型態實例的指定。</p>
<p>透過這種特性，假設我們有個需求是一個陣列或 slice 存放的型態無法事先確定，且每個元素的型態可能都不是一樣，就可以透過 interface 來解決！</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Eater interface {
	Eat()
}

type Runner interface {
	Run()
}

type Animal interface {
	Eater
	Runner
}

type Dog struct {
	Name string
}

func (d *Dog) Eat() {
	fmt.Printf(&quot;%s is eating\n&quot;, d.Name)
}

func (d *Dog) Run() {
	fmt.Printf(&quot;%s is running\n&quot;, d.Name)
}

type Cat struct {
	Name string
}

func (c *Cat) Eat() {
	fmt.Printf(&quot;%s is eating\n&quot;, c.Name)
}

func (c *Cat) Run() {
	fmt.Printf(&quot;%s is running\n&quot;, c.Name)
}

func ShowEat(animal Animal) {
	animal.Eat()
}

func ShowRun(animal Animal) {
	animal.Run()
}

func ShowEat2(eater Eater) {
	eater.Eat()
}

func ShowRun2(runner Runner) {
	runner.Run()
}

func main() {
	animals := [...]Animal{
		&amp;Dog{Name:&quot;Kenny&quot;},
		&amp;Cat{Name:&quot;Nicole&quot;},
	}

	for _, animal := range animals {
		fmt.Println(animal)
	}

	instances := [...]interface{}{
		123,
		&quot;Hello World&quot;,
		&amp;Dog{Name:&quot;Kenny&quot;},
		&amp;Cat{Name:&quot;Nicole&quot;},
	}

	for _, instance := range instances {
		fmt.Println(instance)
	}
}
</code></pre>
<p>在這邊多定義了 Cat Struct，並且同樣實現了 Animal interface。</p>
<p>因此在前面可以建立 Animal 型態的陣列，裡面可以放不同結構體的實例，只要裡面放置的結構體有實現 Animal interface 行為，就會被當作 Animal 實例。</p>
<p>而第二個例子是利用空接口型態，裡面可以放置各種型態的元素，以這個例子來看既能放 int、string、Dog Struct、Cat Struct。</p>
<p>也因為空接口的特性也是實現泛型的重要關鍵。</p>
<h2 id="型態斷言"><a class="header" href="#型態斷言">型態斷言</a></h2>
<p>但是根據以上的例子會發現一個問題：</p>
<p>假設利用自定義型態為 Animal interface 指定型態的話，該型態就能存取 interface 的行為，並不能存取自定義型態的屬性及其它自定義型態的方法。</p>
<p>這時候可以利用 Golang 提供的型態斷言的特性，請看：</p>
<pre><code class="language-go">func main() {
	var animal Animal
	animal = &amp;Dog{Name:&quot;Kenny&quot;}
	dog := animal.(*Dog)
	fmt.Println(dog.Name)

	animal = &amp;Cat{Name:&quot;Nicole&quot;}
	cat := animal.(*Dog)
	fmt.Println(cat.Name)
}
</code></pre>
<p>透過<code>.(type)</code> 的方式來斷定該接口實際上是存放哪個實例。但是有個缺點是如果型態判斷錯誤，會直接造成 panic。</p>
<p>出現以下錯誤訊息：</p>
<pre><code>panic: interface conversion: main.Animal is *main.Cat, not *main.Dog
</code></pre>
<p>這是因為後面的 animal 是指定 Cat 實例，結果後面型態斷言用 Dog，會造成執行時期的錯誤。</p>
<p>要怎麼避免呢？</p>
<p>可以透過 switch 的方式一一去判斷型態：</p>
<pre><code class="language-go">func main() {
	animals := [...]Animal{
			&amp;Dog{Name:&quot;Kenny&quot;},
			&amp;Cat{Name:&quot;Nicole&quot;},
		}

	for _, animal := range animals {
		switch animal.(type) {
		case *Dog:
			fmt.Println(animal.(*Dog).Name)
		case *Cat:
			fmt.Println(animal.(*Cat).Name)
		default:
			fmt.Println(&quot;you are not animal!!&quot;)
		}
	}
}
</code></pre>
<p>透過<code>.(type)</code> 來一一比對出對的型態。</p>
<p>此外，Golang 型態斷言也提供了檢測機制：</p>
<pre><code class="language-go">func main() {
	animals := [...]Animal{
			&amp;Dog{Name:&quot;Kenny&quot;},
			&amp;Cat{Name:&quot;Nicole&quot;},
		}

	for _, animal := range animals {
		if dog, ok := animal.(*Dog); ok {
			fmt.Println(dog.Name)
		}

		if cat, ok := animal.(*Cat); ok {
			fmt.Println(cat.Name)
		}
	}
}
</code></pre>
<p>當然了，如果斷言的形態越多用 switch 相對可讀性會較高。</p>
<h2 id="空-interface-的限制"><a class="header" href="#空-interface-的限制">空 interface 的限制</a></h2>
<p>根據以上的例子可以空接口提供很多便利性，但是也有其限制：</p>
<p>一個空的接口會隱藏值對應的表示方式和所有的公開的方法，必須使用類型斷言才能來來訪問內部的值，如果事先不知道空接口指向的值的具體類型，就無法操作。</p>
<p>為此，才需要 <strong>reflect 機制</strong>，可以知道一個接口類型的變量具體是什麼（什麼類型），有什麼能力（有哪些方法）。這也是在寫 Golang 程式庫常常會用到的特性，因為有 interface 可以實現泛型的特性，有了泛型的特性又可以透過 reflect 機制來促發其不同型態的屬性及方法。</p>
<h2 id="總結-10"><a class="header" href="#總結-10">總結</a></h2>
<ul>
<li>Golang interface 重點是「行為」，不管定義的介面型態是什麼，只要行為符合就屬於該介面型態的一種。</li>
<li>Golang interface 可以說是動態語言鴨子型別的展現。</li>
<li>利用 interface 可實現泛型、多型的功能，從而可以調用同一個函數名的函數但實現完全不同的功能。</li>
</ul>
<p>所以根據以上 interface 的特點，在看看 Golang 的標準程式庫裡面運用大量的 interface 的特性來完成，例如標準程式庫定義檔案讀寫的 Reader、Writer interface：</p>
<pre><code class="language-go">type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
</code></pre>
<p>利用 <code>os.File</code> 實現了 Reader、Writer interface，來實作檔案讀寫的實現。</p>
<hr />
<h2 id="interface-接口"><a class="header" href="#interface-接口">Interface 接口</a></h2>
<p>要特別注意，這個interface跟其他語言中的定義與作用會不太一樣。</p>
<p>首先讓我們回憶一下golang的特性，會想起他是「輕量級的物件導向」，也就是他沒有完全實作物件導向的所有特徵。具體來說，golang沒有class（類別）與繼承（這樣還能稱之為物件導向嗎？）。但是現代軟體開發，如果需要類似「多型」的需求怎麼辦呢？interface就是golang中用來實踐多型的利器，雖然並不是完全符合多型的概念，但至少在概念上是接近的。尤其是在golang這種強型別的語言，interface可以發揮更高的潛能。</p>
<p>interface有兩種，分別是型態與定義。<strong>interface可以代表任何型態，這在開發上可以帶來極大的便利（弱型別語言表示）</strong>，我們來看看具體上要如何實作：</p>
<pre><code class="language-go">func Hello(value interface{}) {  
}
</code></pre>
<p>將interface作為參數宣告，這個函數就可以接受任意型態的參數。但在實際使用之前，我們還是必須先辨別傳遞進來的參數型別，才能做接下來的邏輯實作，畢竟golang依然是個強型別的語言，沒有因為有了interface就做出讓步。</p>
<pre><code class="language-go">func Hello(value interface{}) {  
    // 透過型態斷言揭露 interface{} 真正的型態。
    switch v := value.(type) {
        // 如果 value 是字串型態。
        case string:
            fmt.Println(&quot;value 是字串，內容是 &quot; + v)
        // 如果 value 是 int 型態。
        case int:
            fmt.Printf(&quot;value 是數值，加上二就是 %d&quot;, v + 2)
    }
}
</code></pre>
<p>延續第一個範例，我們從外部得到型別未知的參數<code>value</code>，透過<code>switch</code>與<code>value.(type)</code>方法，可以將不同型別的邏輯分離出來，做不同的處理。如果你很確定參數的型別，也可以直接使用宣告的方式來取代<code>switch</code>判斷，方法如下：</p>
<pre><code class="language-go">func Hello(value interface{}) {  
    fmt.Println(&quot;value 是字串，內容是 &quot; + value.(string))
}
</code></pre>
<p>但如果interface參數與你預期的型別不同，會出現<code>panic</code>警告。作為參數可以為任意類別，如果函數的返回值為interface，也就代表函數可以返回任意類別值。</p>
<p>在變數的方面，<strong>當我們定義一個空的interface，它可以指定為任意型別</strong>：</p>
<pre><code class="language-go">var a interface{}
var i int = 5
s := &quot;Hello world&quot;
// a可以儲存任意類別的值
a = i
a = s
</code></pre>
<p>到這邊你可能會想，一個強型別語言為什麼需要想辦法實作一個可以是任何型態的參數或變數，這不是根本否定的強型別的價值嗎？我想到一個長久以來在工程師圈關於「限制-自由」的拉扯，有一句名言是這樣總結的：</p>
<blockquote>
<p>限制帶給你新的自由</p>
</blockquote>
<p>限制的好處是當我們在規則與紀律之中妥協，我們可以更早發現不協調之處，讓bug無所遁形。如果毫無限制邊界，反而讓人無從發揮。我認為這並不是一個布林的問題，而是float，在光譜之中有眾多選擇，可以讓每個人依喜好與需求做選擇。</p>
<p>這樣的設計讓golang在大部份的時候受到型別拘束保護，不會產生型別的意外狀況；當在需要開發套件與第三方程式串接的時候，又不需要把自己綁死侷限了開發空間的可能，是語言設計者的一個優雅的權衡。</p>
<p>我們來看另一個例子，如何在golang中用interface實現多型：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type Animal interface {
	Speak() string
}

type Dog struct {
}

func (d Dog) Speak() string {
	return &quot;Woof!&quot;
}

type Cat struct {
}

func (c Cat) Speak() string {
	return &quot;Meow!&quot;
}

type Pikachu struct {
}

func (p Pikachu) Speak() string {
	return &quot;Pika pika!&quot;
}

type Programmer struct {
}

func (j Programmer) Speak() string {
	return &quot;Design patterns!&quot;
}
func main() {
	animals := []Animal{Dog{}, Cat{}, Pikachu{}, Programmer{}}
	for _, animal := range animals {
		fmt.Println(animal.Speak())
	}
}
</code></pre>
<p>如果執行這段程式，我們會得到：</p>
<pre><code class="language-repl">Woof!
Meow!
Pika pika!
Design patterns!
</code></pre>
<p>Animal作為一個interface定義一個空的<code>Speak()</code>方法，藉由宣告一個Animal陣列<code>animals</code>將貓、狗、皮卡丘、工程師實體傳進陣列中，接著實體各自執行自己實作的<code>Speak()</code>方法。</p>
<hr />
<p><strong>struct</strong></p>
<p>struct 用來自定義複雜資料結構，可以包含多個欄位（屬性），可以巢狀；go中的struct型別理解為類，可以定義方法，和函式定義有些許區別；struct型別是值型別。</p>
<pre><code class="language-go">package main

type User struct {
	Name string
	Age  int32
	mess string
}

var user User
var user1 *User = &amp;User{}
var user2 *User = new(User)
</code></pre>
<p><strong>struct的方法</strong></p>
<p>在go語言中，我們可以為自定義型別定義型別相關的方法，比如：</p>
<pre><code class="language-go">func (p *player) Name() string {
	return p.name
}
</code></pre>
<p>上面的程式碼為player這個自定義型別宣告一個名為Name的方法，該方法返回一個string。值得注意的是（p *player）這段程式碼指定了我們是<strong>為player建立方法</strong>，並將呼叫該方法的例項指標當作變數p傳入該函式，如果沒有（p *player）這段程式碼，這個方法就變成了一個普通的全域性函式。</p>
<p><strong>struct的嵌入（Embedding）</strong></p>
<p>go語言中的“繼承”和其他語言中的繼承有很大區別，比如：</p>
<pre><code class="language-go">type player struct {
	User
}
</code></pre>
<p>這是一種<strong>繼承</strong>的寫法，在go語言中這種方式叫做<strong>嵌入（embed）</strong>，此時player型別就擁有了User型別的Name, Age, mess 等變數</p>
<p><strong>struct的tag</strong></p>
<p>這種方式主要是用在xml，json和struct間相互轉換，非常方便直觀，比如介面給的引數一般是json傳過來，但是內部我們要轉為struct再進行處理。</p>
<pre><code class="language-go">package main

import &quot;encoding/json&quot;
import &quot;fmt&quot;

type User struct {
	Name string `json:&quot;userName&quot;`
	Age  int    `json:&quot;userAge&quot;`
}

func main() {
	var user User
	user.Name = &quot;nick&quot;
	user.Age = 18
	conJson, _ := json.Marshal(user)
	fmt.Println(string(conJson)) //{&quot;userName&quot;:&quot;nick&quot;,&quot;userAge&quot;:0}
}
</code></pre>
<p><strong>interface</strong></p>
<p>golang不支援完整的物件導向思想，它沒有繼承，多型則完全依賴介面實現。golang只能模擬繼承，<strong>其本質是組合</strong>，只不過golang語言為我們提供了一些語法糖使其看起來達到了繼承的效果。Golang中的介面，不需要顯示的實現。Interface型別可以定義一組方法，但是這些不需要實現。並且interface不能包含任何變數。只要一個變數，含有介面型別中的所有方法，那麼這個變數就實現這個介面。因此，golang中沒有implement類似的關鍵字；如果一個變數含有了一個interface型別的多個方法，那麼這個變數就實現了多個介面；如果一個變數只含有了一個interface的方部分方法，那麼這個變數沒有實現這個介面。</p>
<p><strong>interface的定義</strong></p>
<p>interface型別預設是一個指標。</p>
<pre><code class="language-go">package main

type Car interface {
	NameGet() string
	Run(n int)
	Stop()
}
</code></pre>
<p>空介面 Interface{}：空介面沒有任何方法，所以所有型別都實現了空介面。</p>
<pre><code class="language-go">var a int
var b interface{} //空介面
b = a
</code></pre>
<p><strong>interface的多型</strong></p>
<p>一種事物的多種形態，都可以按照統一的介面進行操作。這種方式是用的最多的，有點像c 中的類繼承。</p>
<pre><code class="language-go">package main

type Item interface {
	Name() string
	Price() float64
}
type VegBurger struct {
}

func (r *VegBurger) Name() string {
	return &quot;vegburger&quot;
}
func (r *VegBurger) Price() float64 {
	return 1.5
}

type ChickenBurger struct {
}

func (r *ChickenBurger) Name() string {
	return &quot;chickenburger&quot;
}
func (r *ChickenBurger) Price() float64 {
	return 5.5
}
</code></pre>
<p><strong>Interface巢狀</strong></p>
<p>一個介面可以巢狀在另外的介面。即需要實現2個介面的方法。在下面的例子中Used就包含了Car這個介面的所有方法。</p>
<pre><code class="language-go">package main

type Car interface {
	NameGet() string
	Run(n int)
	Stop()
}
type Used interface {
	Car
	Cheap()
}
</code></pre>
<p><strong>總結</strong></p>
<p>以上就是這篇文章的全部內容了，希望本文的內容對大家的學習或者工作具有一定的參考學習價值，如果有疑問大家可以留言交流，謝謝大家對指令碼之家的支援。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mapstringinterface操作"><a class="header" href="#mapstringinterface操作">map[string]interface操作</a></h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    datalist := make(map[string]interface{}, 0)
	fmt.Println(datalist)

	data := []string{&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;}

	for _, name := range data {
		datalist[name] = true
	}

	fmt.Println(datalist)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pytorch"><a class="header" href="#pytorch">Pytorch</a></h2>
<h3 id="動手學深度學習"><a class="header" href="#動手學深度學習">動手學深度學習</a></h3>
<p><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/">動手學深度學習(Pytorch)-線上中文電子書</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/ShusenTang/Dive-into-DL-PyTorch">動手學深度學習(Pytorch)-程式碼</a></p>
<h3 id="官方教程"><a class="header" href="#官方教程">官方教程</a></h3>
<p><a href="https://link.zhihu.com/?target=https%3A//pytorch.apachecn.org/docs/1.2/">Pytorch官方教程-中文</a></p>
<h3 id="manning"><a class="header" href="#manning">MANNING</a></h3>
<p><a href="https://link.zhihu.com/?target=https%3A//livebook.manning.com/book/deep-learning-with-pytorch/welcome/v-10/">Deep Learning with Pytorch-線上原文電子書</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/deep-learning-with-pytorch/dlwpt-code">Deep Learning with Pytorch-程式碼</a></p>
<hr />
<p><a href="https://ithelp.ithome.com.tw/users/20120549/ironman/3377">那些年我們一起學過的深度學習 系列</a></p>
<p><a href="https://ithelp.ithome.com.tw/users/20130687/ironman/3761">Knock Knock! Deep Learning 系列</a></p>
<p><a href="https://grady1006.medium.com/google-colab%E7%B3%BB%E5%88%97-%E7%94%A8%E5%85%8D%E8%B2%BB%E7%9A%84gpu-pytorch%E8%A8%93%E7%B7%B4%E8%87%AA%E5%B7%B1%E7%9A%84%E5%88%86%E9%A1%9E%E6%A8%A1%E5%9E%8B-%E4%BB%A5%E5%81%9C%E8%BB%8A%E7%A9%BA%E4%BD%8D%E8%BE%A8%E8%AD%98%E7%82%BA%E4%BE%8B-389ee6b01be2">用免費的GPU+Pytorch訓練自己的分類模型-以智能車位分析為例</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pytorch-學習筆記"><a class="header" href="#pytorch-學習筆記">PyTorch 學習筆記</a></h1>
<p>colab 使用GPU 的方法</p>
<p>Edit -&gt;NoteBook Settings 選GPU</p>
<p><img src="ml/images/1*HpmXaFjFCDL_jAtLaYEeGw.jpeg" alt="img" /></p>
<p>如果要將定義好的張量放到GPU上執行，可以用x.cuda()來指定</p>
<pre><code class="language-python">import torch
import numpy as np
x_tensor = torch.rand(5,3)
y_numpy = np.random.rand(5,3)
x_numpy = x_tensor.numpy()
y_tensor = torch.from_numpy(y_numpy)

print(x_tensor)
print(x_numpy)
print(y_numpy)
print(y_tensor)

if torch.cuda.is_available():
    x = x_tensor.cuda()
    y = y_tensor.cuda()
    print(x+y)
</code></pre>
<p>關於自動微分變數，在使用自動微分變數後，針對後續變數的計算，系統會自動展開計算突來運算。也因為這個關係，可以很快地運用.backward 來執行反向傳播演算法。</p>
<p>下面的例子宣告x 是個張量變數(tensor)，無法調用x.grad_fn方法</p>
<pre><code class="language-python">import torch
import numpy as np
x = torch.ones(3,3)
y = x + 10
print(x)
print(x.grad_fn)
</code></pre>
<p>傳回</p>
<pre><code>tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]])
None
</code></pre>
<p>宣告x為自動微分變數， x = Variable(torch.ones(2,2),requires_grad = True)</p>
<pre><code class="language-python">import torch
import numpy as np
from torch.autograd import Variable
x = Variable(torch.ones(2,2),requires_grad = True)
y = x + 2
print(y.grad_fn)
</code></pre>
<p>傳回 &lt;AddBackward0 object at 0x7fc37bd17438&gt;</p>
<pre><code class="language-python">import torch
import numpy as np
from torch.autograd import Variable
num_x = np.array([[1.0, 2.0],[3.0,4.0]])
tensor_x = torch.from_numpy(num_x)
x = Variable(tensor_x,requires_grad = True)
y = x + 2
z = y*y
print(z)
m = torch.mean(z)
print(m)
</code></pre>
<p>傳回</p>
<p>tensor([[ 9., 16.], [25., 36.]], dtype=torch.float64, grad_fn=<MulBackward0>) tensor(21.5000, dtype=torch.float64, grad_fn=<MeanBackward0>)</p>
<pre><code class="language-python">import torch
import numpy as np
from torch.autograd import Variable
num_x = np.array([[1.0, 2.0],[3.0,4.0]])
tensor_x = torch.from_numpy(num_x)
x = Variable(tensor_x,requires_grad = True)
y = x + 2
z = y*y   #等價  z=torch.mul(y, y)
m = torch.mean(z)
m.backward()
print(x.grad)
</code></pre>
<p>傳回</p>
<p>tensor([[1.5000, 2.0000]</p>
<p>, [2.5000, 3.0000]], dtype=torch.float64)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">python</a></h1>
<ul>
<li>
<p><a href="https://myapollo.com.tw/zh-tw/begin-to-asyncio/">Python asyncio 從不會到上路</a></p>
</li>
<li>
<p><a href="https://ithelp.ithome.com.tw/users/20107274/articles">python的asyncio模組</a></p>
</li>
</ul>
<h2 id="利用conda嚐鮮python-310"><a class="header" href="#利用conda嚐鮮python-310">利用Conda嚐鮮Python 3.10</a></h2>
<pre><code class="language-sh">conda create -n py310 python=3.10 -c conda-forge -y
conda activate py310
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="再見了-pip最佳-python-套件管理器poetry-完全入門指南"><a class="header" href="#再見了-pip最佳-python-套件管理器poetry-完全入門指南">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a></h1>
<p>前陣子工作上的專案從原先的 pip 改用 Poetry 管理 Python 套件，由於採用 Poetry 正是我的提議，所以必須身先士卒，研究 Poetry 使用上的重點與學習成本，並評估是否真有所值——講白了就是至少要利大於弊，不然會徒增團隊適應上的負擔。</p>
<p>拜這個機會所賜，我對 Poetry 總算有了一個較為全面的理解。</p>
<p>習慣以後，現在我所有的個人開發也都改用 Poetry 來管理套件及虛擬環境，對於 Poetry 這個略嫌複雜的工具（相比於 pip），上手的同時我也感受到它確實存在一些學習門檻，間接促使了本文的誕生。</p>
<p>有鑑於 Poetry 真的有點複雜，如果要推薦別人使用，我想還是有必要好好介紹一下。</p>
<p>本文除了講解如何使用 Poetry，還會先不厭其煩地闡述它所解決的痛點，若興趣不大，可以直接跳到「<a href="https://blog.kyomind.tw/python-poetry/#%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E4%BD%BF%E7%94%A8-Poetry">從零開始使用 Poetry</a>」章節，但看完前導部分，相信能更加體會 Poetry 的必要性。</p>
<p>為了讓你無痛上手！這將會是一篇超過 8000 字的長文，還請多多擔待。🙏</p>
<h3 id="主要目錄"><a class="header" href="#主要目錄">主要目錄</a></h3>
<p>供快速跳轉（桌面版用戶可和右下角的「回到最上方」搭配使用）：</p>
<ul>
<li><a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F">Poetry 是什麼？</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%90%8D%E8%A9%9E%E8%A7%A3%E9%87%8B%EF%BC%9A%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83%E7%AE%A1%E7%90%86%E3%80%81%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E3%80%81%E7%9B%B8%E4%BE%9D%E6%80%A7%E7%AE%A1%E7%90%86">名詞解釋：虛擬環境管理、套件管理、相依性管理</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#pip-%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E8%B6%B3">pip 的最大不足</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#pip-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E9%81%B8%E6%93%87">pip 替代方案選擇</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E4%BD%BF%E7%94%A8-Poetry">從零開始使用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%AE%89%E8%A3%9D-Poetry">安裝 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%88%9D%E5%A7%8B%E5%8C%96-Poetry-%E5%B0%88%E6%A1%88">初始化 Poetry 專案</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E7%AE%A1%E7%90%86-Poetry-%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83">管理 Poetry 虛擬環境</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">Poetry 常用指令</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E8%A6%8B%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%83%E8%88%87%E6%93%8D%E4%BD%9C-QA">Poetry 常見使用情境與操作 QA</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E7%B5%90%E8%AA%9E">結語</a></li>
</ul>
<h2 id="poetry-是什麼"><a class="header" href="#poetry-是什麼">Poetry 是什麼？</a></h2>
<p>比起 <a href="https://github.com/python-poetry/poetry#poetry-dependency-management-for-python">Poetry GitHub</a> 的說明：</p>
<blockquote>
<p><strong>Poetry: Dependency Management for Python</strong>
Poetry helps you declare, manage and install dependencies of Python projects, ensuring you have the right stack everywhere.</p>
</blockquote>
<p>我覺得 <a href="https://python-poetry.org/">Poetry 官網</a>的 slogan 更加簡潔有力：</p>
<p><img src="python/images/qTTgg0U.png" alt="" /></p>
<p>簡單來說，<strong>Poetry 類似 pip，能協助你進行套件管理</strong>（dependency management），<strong>但又比 pip 強大得多</strong>，因為它還包含了 pip 所未有的功能：</p>
<ul>
<li>虛擬環境管理</li>
<li>套件相依性管理</li>
<li>套件的打包與發布</li>
</ul>
<p>其中<strong>最為關鍵</strong>的是「<strong>套件的相依性管理</strong>」，也是本文的重點，而「套件的打包與發布」與本文主題較無關係，所以不會提及。</p>
<h2 id="名詞解釋虛擬環境管理套件管理相依性管理"><a class="header" href="#名詞解釋虛擬環境管理套件管理相依性管理">名詞解釋：虛擬環境管理、套件管理、相依性管理</a></h2>
<p>開始前，要先大致說明標題中這三者的區別，才不易混淆文中的內容。這裡的定義可能不盡準確，但至少對理解文中的表達能有所幫助。</p>
<h3 id="虛擬環境管理"><a class="header" href="#虛擬環境管理">虛擬環境管理</a></h3>
<p>指的是使用內建的 venv 或 vituralenv 套件來建立及管理 Python 的虛擬環境，不同的虛擬環境間各自獨立，講白了就是指向的路徑各不相同。</p>
<h3 id="套件管理依賴管理dependency-management"><a class="header" href="#套件管理依賴管理dependency-management">套件管理、依賴管理（dependency management）</a></h3>
<p>指的是使用 pip 這類的套件管理器來管理 Python 環境（未必是虛擬環境），即管理環境中所安裝的全部套件（package、dependency）及其版本。</p>
<p>在這個語境下，dependency 基本上就是指安裝的 package。</p>
<h3 id="套件的相依性管理依賴解析"><a class="header" href="#套件的相依性管理依賴解析">「套件的」相依性管理、依賴解析</a></h3>
<p>這個有點難定義，它並不是一個非常通俗且有共識的名詞，我在英文中也還難找到對應的名詞。本文使用它時，主要指的是<strong>套件與套件之間的依賴關係及版本衝突管理</strong>，也就是套件的「<strong>相依性管理</strong>」。在下文提及的 Podcast 中，又稱為「<strong>依賴解析</strong>」。</p>
<p>所謂套件的「版本衝突」指的是單一套件被兩個以上的套件所依賴，但不同的套件對依賴的套件有著不同的<strong>最低或最高版本要求</strong>，若兩者的要求沒有「交集」，則會產生衝突而導致套件失效或無法安裝。</p>
<h2 id="pip-的最大不足"><a class="header" href="#pip-的最大不足">pip 的最大不足</a></h2>
<p>大概在 2 年前就知道了 Poetry 的存在，不過那時我還沒有套件相依性管理的強烈需求，加上看起來需要一些學習成本（確實如此），所以就一直擱在一旁，直到真正體會到了 pip 的不足。</p>
<p>pip 是 Python 內建的套件管理工具，而它的最大罩門，就是對於「套件間的相依性管理」能力不足。尤其是在「移除」套件時的依賴解析——可以說基本沒有。這也是我提議改用 Poetry 的根本原因。</p>
<p>怎麼說？看完下面的例子就能明白。</p>
<h3 id="pip-uninstall的困境以-flask-為例"><a class="header" href="#pip-uninstall的困境以-flask-為例"><code>pip uninstall</code>的困境：以 Flask 為例</a></h3>
<p>假設現在你的工作專案中有開發 API 的需求，經過一番研究與討論，決定使用 <a href="https://github.com/pallets/flask">Flask</a> 網頁框架來進行開發。</p>
<p>我們知道，很多套件都有依賴的套件，也就是使用「別人已經造好的輪子」來構成套件功能的一部分。</p>
<p>安裝主套件時，這些依賴套件也必須一併安裝，主套件才能正常運作，這裡的 Flask 就是如此。安裝 Flask 時，不僅會安裝單一個套件<code>flask</code>，還會安裝所有 Flask 的必要構成部分，如下：</p>
<pre><code>❯ pip install flask
Collecting flask
  Downloading Flask-2.1.1-py3-none-any.whl (95 kB)
     |████████████████████████████████| 95 kB 993 kB/s
Collecting importlib-metadata&gt;=3.6.0
  Using cached importlib_metadata-4.11.3-py3-none-any.whl (18 kB)
Collecting itsdangerous&gt;=2.0
  Downloading itsdangerous-2.1.2-py3-none-any.whl (15 kB)
Collecting Werkzeug&gt;=2.0
  Downloading Werkzeug-2.1.1-py3-none-any.whl (224 kB)
     |████████████████████████████████| 224 kB 2.8 MB/s
Collecting click&gt;=8.0
  Downloading click-8.1.2-py3-none-any.whl (96 kB)
     |████████████████████████████████| 96 kB 1.9 MB/s
Collecting Jinja2&gt;=3.0
  Downloading Jinja2-3.1.1-py3-none-any.whl (132 kB)
     |████████████████████████████████| 132 kB 3.7 MB/s
Collecting zipp&gt;=0.5
  Using cached zipp-3.7.0-py3-none-any.whl (5.3 kB)
Collecting MarkupSafe&gt;=2.0
  Downloading MarkupSafe-2.1.1-cp38-cp38-macosx_10_9_x86_64.whl (13 kB)
Installing collected packages: zipp, MarkupSafe, Werkzeug, Jinja2, itsdangerous, importlib-metadata, click, flask
Successfully installed Jinja2-3.1.1 MarkupSafe-2.1.1 Werkzeug-2.1.1 click-8.1.2 flask-2.1.1 importlib-metadata-4.11.3 itsdangerous-2.1.2 zipp-3.7.0
</code></pre>
<p>從上可知，<code>pip install flask</code>還會一併安裝<code>importlib-metadata</code>、<code>itsdangerous</code>等 7 個依賴套件，實際上總共安裝了 8 個套件！</p>
<p>pip 在「安裝」套件時的相依性管理還是可以的，這並不難，因為套件的依賴要求都寫在安裝檔裡了，根本不需要「解析」。</p>
<hr />
<p>附帶一提，這 8 個套件包括<code>flask</code>，除了<code>importlib-metadata</code>和<code>zipp</code>外，其餘 6 個實際上都是 <a href="https://palletsprojects.com/p/">Flask 團隊自行開發的套件</a>。</p>
<p>但是並不是隻有 Flask 框架會使用（依賴）這些套件。</p>
<p>比如其中的 <a href="https://palletsprojects.com/p/click/">Click</a> 就是一個廣泛使用的命令製作工具。套件官網是這麼介紹的：</p>
<blockquote>
<p>Click is a Python package for <strong>creating beautiful command line interfaces</strong> in a composable way with as little code as necessary.</p>
</blockquote>
<p>別的套件也可能依賴<code>click</code>來提供命令列的功能，換句話說，主套件的依賴套件也可能被其他第三方套件所依賴、使用。</p>
<hr />
<p>好，一切都很美好，就這樣一年過去，團隊決定改用火紅的 FastAPI 取代 Flask 來實作專案的 API，作為 API 的主要開發人員，你興高採列地安裝了 FastAPI，更新了所有程式碼，最後要移除 Flask，這時問題就來了。</p>
<p>安裝 Flask 的時候，只需要<code>pip install flask</code>，pip 就會幫你一併安裝所有依賴套件。現在要移除它，也只要<code>pip uninstall flask</code>就可以了嗎？</p>
<p>很遺憾，<strong>答案是否定的</strong>。</p>
<h3 id="pip-的致命缺陷缺乏移除套件時的依賴解析相依性管理"><a class="header" href="#pip-的致命缺陷缺乏移除套件時的依賴解析相依性管理">pip 的致命缺陷：缺乏移除套件時的依賴解析（相依性管理）</a></h3>
<p>僅執行<code>pip uninstall flask</code>的話，pip 就<strong>真的只會</strong>幫你移除<code>flask</code>這個套件<strong>本身</strong>而已。那剩下的、再也用不到的套件怎麼辦？你只能一個一個手動移除！</p>
<p>但你千萬不要真的嘗試手動移除依賴套件！——因為你無法確定這些依賴套件<strong>是否同時被別的套件所依賴</strong>。</p>
<h3 id="pip-手動移除依賴套件的潛在風險以-flask--black-為例"><a class="header" href="#pip-手動移除依賴套件的潛在風險以-flask--black-為例">pip 手動移除依賴套件的潛在風險：以 Flask + Black 為例</a></h3>
<p>繼續以 Flask 為例，還記得其中一個依賴套件是<code>click</code>，如前所述，它是一個協助製作命令列界面的工具。</p>
<p>假設專案中同時也使用 <a href="https://github.com/psf/black">Black</a> 這個 formatter 進行程式碼風格管理（沒錯！我現在個人開發也都改用 Black 取代 <a href="https://github.com/google/yapf">yapf</a> 了），Black 是一個可以透過 CLI 執行的工具，很巧的，它也是使用<code>click</code>來實作命令列界面。</p>
<p>可想而知，移除 Flask 時，如果你同時把<code>click</code>也跟著一併移除，會發生什麼樣的悲劇——你的 Black 壞了。</p>
<p>簡言之，直接 pip 手動移除依賴套件存在下列兩大疑慮，不建議輕易嘗試：</p>
<p><strong>一、無法確定想移除的套件還有多少依賴套件</strong></p>
<p>正常而言，你不會去注意安裝時總共一併安裝了多少依賴套件。雖然有<code>pip show</code>這類的指令可以大概知曉套件的依賴，但這指令只會顯示「<strong>直接</strong>依賴套件」而不會顯示「依賴套件的依賴」，所以列出來的結果未必準確：</p>
<pre><code>❯ pip show flask
Name: Flask
Version: 2.1.1
Summary: A simple framework for building complex web applications.
Home-page: https://palletsprojects.com/p/flask
Author: Armin Ronacher
Author-email: armin.ronacher@active-4.com
License: BSD-3-Clause
Location: /Users/kyo/.pyenv/versions/3.8.12/envs/test/lib/python3.8/site-packages
Requires: importlib-metadata, Werkzeug, click, Jinja2, itsdangerous
Required-by:
</code></pre>
<p>可以看到，<code>Requires:</code>只顯示了 5 個依賴套件，因為剩下的 2 個（<code>zipp</code>、<code>markupsafe</code>）是「<strong>依賴的依賴</strong>」，在更下層，並未顯示。</p>
<p><strong>二、即使確定所有依賴套件，也無法確定這些套件是否還被其他套件所依賴</strong></p>
<p>好繞口啊！上述的<code>click</code>例子就是解釋這個困境。</p>
<h3 id="小結pip-只適合小型專案或只新增不移除套件的專案"><a class="header" href="#小結pip-只適合小型專案或只新增不移除套件的專案">小結：pip 只適合小型專案或「只新增不移除」套件的專案</a></h3>
<p>以前我的個人或工作上的專案往往規模不大，pip 就真的只負責新增，鮮少需要考慮移除套件的情況，所以缺少移除套件時的依賴解析，似乎也沒什麼大問題。</p>
<p>但稍具模規的專案往往就需要考慮套件的退場，以維持開發及部署環境的簡潔，尤其在使用容器化部署時，過多不必要的套件會徒增 image 的肥大，產生額外的成本與浪費。</p>
<p>然而透過上面的例子可知，僅靠 pip 想要乾淨移除過時的套件，且不影響既有的套件，簡直是不可能的任務！所以我們需要有完整套件<strong>依賴解析、相依性管理</strong>的套件管理器。</p>
<h2 id="pip-替代方案選擇"><a class="header" href="#pip-替代方案選擇">pip 替代方案選擇</a></h2>
<p>因為 pip 存在這樣的致命弱點，所以很早就有相關的方案提出想要解決它，最知名的莫過於 <a href="https://pipenv.pypa.io/en/latest/">Pipenv</a>！</p>
<p>關於 pip 的前世今生，以及為何它難以演化成理想的、可以完美管理套件相依性的版本，可以參考〈<a href="https://blog.kyomind.tw/pyenv-setup/">告別 Anaconda：在 macOS 上使用 pyenv + pyenv-virtualenv 建立 Python 開發環境</a>〉中推薦過的單集 Podcast：<a href="https://pythonhunter.org/episodes/ep15">《捕蛇者說》Ep 15. 和 PyPA 的成員聊聊 Python 開發工作流</a>。</p>
<p>從 Podcast 網頁「時間節點」目錄中可知，該集對 Python 的虛擬環境與套件管理機制及相關工具，有著非常廣泛的討論，十分精彩，強力推薦！（為了寫這篇又聽了第 3 次）</p>
<p><a href="https://i.imgur.com/gzcAU7e.png"><img src="https://i.imgur.com/gzcAU7e.png" alt="img" /></a></p>
<h3 id="pipenv-vs-poetry"><a class="header" href="#pipenv-vs-poetry">Pipenv vs Poetry</a></h3>
<p>講到需要有充分「套件相依性管理」功能的套件管理器，你基本上也只能從 Pipenv 和 Poetry 兩者之中二擇一了。</p>
<p>如果是在兩年前，這個選擇難題恐怕不容易回答，而且 Pipenv 會有較大的機率勝出，但兩年後的今天，我建議你毫不猶豫地選擇 Poetry。</p>
<h3 id="我選擇-poetry-的第一個理由"><a class="header" href="#我選擇-poetry-的第一個理由">我選擇 Poetry 的第一個理由</a></h3>
<p>第一個理由：不要選擇 Pipenv。</p>
<p>乍看之下有點鬧，但卻不失為一個具體的理由，因為當你搜尋「python poetry」關鍵字的時候，那些教你怎麼使用 Poetry 的文章往往也會一併提及為何不選擇 Pipenv。</p>
<p>以下兩篇有著較為完整的說明，請容我直接引用。</p>
<p>〈<a href="https://note.koko.guru/posts/using-poetry-manage-python-package-environments">Python - 取代 Pipenv 的新套件管理器 Poetry</a>〉：</p>
<blockquote>
<p>Pipenv 雖然強大，卻也暴露出了一些問題如 Lock 過慢、Windows 支援性差、對 PyPI 套件打包的友善度差…等更多其他問題，甚至有越來越多人表明 <a href="http://greyli.com/do-not-use-pipenv/">不要使用 Pipenv</a> 或 <a href="https://blog.gslin.org/archives/2019/12/21/9347/pipenv-%E7%9A%84%E5%87%8B%E9%9B%B6%E8%88%87%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-poetry/">pipenv 的凋零與替代方案 poetry</a> 等。</p>
</blockquote>
<blockquote>
<p>同時 Pipenv 的社群維護狀況也越來越差，有許多的 PR 都沒有被 Release，導致許多貢獻者抱怨，甚至有人發出了該篇 <a href="https://github.com/pypa/pipenv/issues/4058">If this project is dead, just tell us</a> issue 想知道是否專案已經不在維護。</p>
</blockquote>
<p>〈<a href="https://greyli.com/poetry-a-better-choice-than-pipenv/">相比 Pipenv，Poetry 是一個更好的選擇</a>〉（本文作者<a href="https://greyli.com/about/">李輝</a>為 Flask 團隊成員）：</p>
<blockquote>
<p>Pipenv 描繪了一個美夢，讓我們以為 Python 也有了其他語言那樣完善的包管理器，不過這一切卻在後來者 Poetry 這裡得到了更好的實現。</p>
</blockquote>
<blockquote>
<p>這幾年 Pipenv 收獲了很多用戶，但是也暴露了很多問題。雖然 Lock 太慢、Windows 支持不好和 bug 太多的問題都已經改進了很多，但對我來說，仍然不能接受隨時更新鎖定依賴的設定，在上一篇文章《<a href="http://greyli.com/do-not-use-pipenv/">不要用 Pipenv</a>》裡也吐槽了很多相關的問題。</p>
</blockquote>
<p>兩篇的內容總結就是一句話：不要用 Pipenv。</p>
<p>目前 Pipenv 已經由 <a href="https://github.com/pypa">PyPA</a>（同時也維護 pip 及 vituralenv）接手，上述「擺爛」的情況應該是有所好轉，不過我似乎還沒看到有什麼文章大力鼓吹或宣告 Pipenv 已經「great again」，所以個人對它的未來發展還是持保留態度。</p>
<h3 id="選擇-poetry-的第二個理由pyprojecttoml"><a class="header" href="#選擇-poetry-的第二個理由pyprojecttoml">選擇 Poetry 的第二個理由：pyproject.toml</a></h3>
<p>pyproject.toml 是 <a href="https://peps.python.org/pep-0518/">PEP 518</a> 所提出的新標準：</p>
<blockquote>
<p>The build system dependencies will be stored in a file named <code>pyproject.toml</code> that is written in the TOML format.</p>
</blockquote>
<p>雖然原意是作為套件打包的標準，但後來又有了 <a href="https://peps.python.org/pep-0621/">PEP 621</a>，擴充定性為 Python 生態系工具的共同設定檔標準，現在已經被愈來愈多套件所支援，詳細可參考<a href="https://github.com/carlosperate/awesome-pyproject">這個清單</a>及頁面中的說明：</p>
<blockquote>
<p><code>pyproject.toml</code> is a new configuration file defined in <a href="https://www.python.org/dev/peps/pep-0518/">PEP 518</a> and expanded in <a href="https://www.python.org/dev/peps/pep-0621/">PEP 621</a>. It is design to store build system requirements, but it can also store any tool configuration for your Python project, possibly replacing the need for <code>setup.cfg</code> or other tool-specific files.</p>
</blockquote>
<p>作為規範控，我很願意追隨這個標準。</p>
<p>並且，Poetry 使用<code>pyproject.toml</code>可遠遠不止是設定檔的程度，基本上相當於 Pipenv 的<code>Pipfile</code>或 npm 的<code>package.json</code>。</p>
<p>少了<code>pyproject.toml</code>，Poetry 是無法運作的。</p>
<p>好，漫長的前言到此結束，讓我們進入正題，開始學習上手 Poetry。</p>
<hr />
<h2 id="從零開始使用-poetry"><a class="header" href="#從零開始使用-poetry">從零開始使用 Poetry</a></h2>
<p>本文所有的參考資料會放在文末的「參考」一欄中，不過在此還是要特別提及主要的參考對象，總共有二：</p>
<ul>
<li><a href="https://python-poetry.org/docs/">Poetry 官方文件</a></li>
<li><a href="https://realpython.com/dependency-management-python-poetry/">Dependency Management With Python Poetry</a></li>
</ul>
<p>在本文找不到你需要的內容，以上二處可能會有，所以特別提及。</p>
<p>另外本文主要以 macOS 和 Linux 環境來進行教學及安裝，Windows 用戶如果有無法順利安裝的情況，建議參考官方文件內容修正。相信如果有問題，應該也只會集中在安裝設定階段，本文其餘部分仍可適用。</p>
<h2 id="安裝-poetry"><a class="header" href="#安裝-poetry">安裝 Poetry</a></h2>
<p>Poetry 和 pip、git、pyenv 等工具一樣，都是典型的命令列工具，需要先安裝才能下達指令<code>poetry</code>。</p>
<h3 id="安裝方式選擇"><a class="header" href="#安裝方式選擇">安裝方式選擇</a></h3>
<p>而 Poetry 提供了兩種安裝方式：</p>
<ol>
<li><strong>全域安裝</strong>至使用者的家目錄。</li>
<li><strong>pip 安裝</strong>至專案的 Python 環境。</li>
</ol>
<p><strong>個人推薦使用全域安裝</strong>，連<a href="https://python-poetry.org/docs/#alternative-installation-methods-not-recommended">官方文件也這麼說</a>。</p>
<p>因為 pip 安裝是直接安裝到專案所屬的 Python 環境裡，而且 Poetry 所依賴的套件非常多，<strong>總計超過 30 個，會嚴重影響專案環境的整潔度</strong>。文件中也警告這些依賴套件的版本可能和專案既有的版本<strong>產生衝突</strong>：</p>
<blockquote>
<p>Be aware that it will also install Poetry’s dependencies which might cause conflicts with other packages.</p>
</blockquote>
<h3 id="全域安裝至家目錄"><a class="header" href="#全域安裝至家目錄">全域安裝至家目錄</a></h3>
<p>所以我們就使用全域安裝吧！參考 Poetry 的 <a href="https://github.com/python-poetry/poetry#installation">GitHub 說明</a>。</p>
<p>macOS / Linux：</p>
<pre><code>curl -sSL https://install.python-poetry.org | python3 -
</code></pre>
<p>Windows：</p>
<pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -
</code></pre>
<p>文件表示安裝的路徑如下：</p>
<blockquote>
<p>The installer installs the <code>poetry</code> tool to Poetry’s <code>bin</code> directory. This location depends on your system:</p>
</blockquote>
<ul>
<li><code>$HOME/.local/bin</code> for Unix</li>
<li><code>%APPDATA%\Python\Scripts</code> on Windows</li>
</ul>
<p>以 macOS 為例，此時如果要下指令，就需要打完整路徑<code>$HOME/.local/bin/poetry</code>，顯然不太方便，所以我們需要設定 PATH。</p>
<h3 id="設定-path"><a class="header" href="#設定-path">設定 PATH</a></h3>
<p>新增<code>poetry</code>指令執行檔所在的路徑至 PATH。</p>
<p>在<code>.zshrc</code>或<code>.bashrc</code>或<code>.bash_profile</code>新增：</p>
<pre><code>export PATH=$PATH:$HOME/.local/bin
</code></pre>
<p>存檔後重啟 shell 即可使用。直接在命令列打上<code>poetry</code>指令測試：</p>
<pre><code>❯ poetry
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]

...
</code></pre>
<h3 id="設定-alias"><a class="header" href="#設定-alias">設定 alias</a></h3>
<p>比起<code>pip</code>，<code>poetry</code>這個指令顯然太冗長了！我們還是給它一個 alias 吧！</p>
<p>基於它是我非常常用的指令，我願意賦與它「單字母」alias 的特權，我使用<code>p</code>：</p>
<pre><code>alias p='poetry'
</code></pre>
<p>測試結果：</p>
<pre><code>❯ p
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]
</code></pre>
<p>alias 是方便自己使用，但本文基於表達清晰考量，下面的解說原則上並不會使用 alias 表示。</p>
<h2 id="初始化-poetry-專案"><a class="header" href="#初始化-poetry-專案">初始化 Poetry 專案</a></h2>
<p>為了方便解說，我們先建立一個全新的專案，名為<code>poetry-demo</code>。</p>
<p>指令都很簡單，但還是建議可以一步一步跟著操作。</p>
<p>就像 git 專案需要初始化，Poetry 也需要，因為每一個使用了 Poetry 的專案中一定要有一個<code>pyproject.toml</code>。所以先來初始化，使用<code>poetry init</code>：</p>
<pre><code>mkdir poetry-demo
cd poetry-demo
poetry init
</code></pre>
<p>此時會跳出一連串的互動對話，協助你建立專案的資料，大部分可以直接<code>enter</code>跳過：</p>
<pre><code>This command will guide you through creating your pyproject.toml config.

Package name [poetry-demo]:
Version [0.1.0]:
Description []:
Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:
License []:
Compatible Python versions [^3.8]:

Would you like to define your main dependencies interactively? (yes/no) [yes]
</code></pre>
<p>直到出現「Would you like to define your main dependencies interactively? (yes/no) [yes]」，我會選「no」，隨即讓你確認本次產生的<code>toml</code>檔內容：</p>
<pre><code>Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file

[tool.poetry]
name = &quot;poetry-demo&quot;
version = &quot;0.1.0&quot;
description = &quot;&quot;
authors = [&quot;kyo &lt;odinxp@gmail.com&gt;&quot;]

[tool.poetry.dependencies]
python = &quot;^3.8&quot;

[tool.poetry.dev-dependencies]

[build-system]
requires = [&quot;poetry-core&gt;=1.0.0&quot;]
build-backend = &quot;poetry.core.masonry.api&quot;
</code></pre>
<p>並詢問你「Do you confirm generation? (yes/no) [yes]」，按<code>enter</code>使用預設選項或回答「yes」則<code>pyproject.toml</code>建立完成。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
└── pyproject.toml

0 directories, 1 file
</code></pre>
<h2 id="管理-poetry-虛擬環境"><a class="header" href="#管理-poetry-虛擬環境">管理 Poetry 虛擬環境</a></h2>
<p>我覺得學習 Poetry 的第一道關卡，就是它對於虛擬環境的管理。</p>
<h3 id="強制虛擬環境"><a class="header" href="#強制虛擬環境">強制虛擬環境</a></h3>
<p>Poetry 預設上（可透過<code>poetry config</code>修改）會強制套件都要安裝在虛擬環境中，以免汙染全域，所以它整合了<code>vitrualenv</code>。</p>
<p>在執行<code>poetry add、install</code>等指令時，Poetry 都會自動檢查<strong>是否正在使用虛擬環境：</strong></p>
<ul>
<li>如果是，則會直接安裝套件至當前的虛擬環境。</li>
<li>如果否，則會自行幫你建立一個獨立的虛擬環境，再進行套件安裝。</li>
</ul>
<h3 id="容易混淆的虛擬環境"><a class="header" href="#容易混淆的虛擬環境">容易混淆的虛擬環境</a></h3>
<p>Poetry 直接整合的虛擬環境管理算是立意良善，相當於把<code>pip</code>+<code>venv</code>的功能整合在一起，但如此也帶來一定的複雜度，尤其在你已經自行使用了<code>venv</code>、<code>vitrualenv</code>或 <code>pyenv-vitrualenv</code>或<code>conda</code>來管理虛擬環境的情況下！</p>
<p>沒錯，Python 的虛擬環境管理就是這麼麻煩。</p>
<p>個人建議，對新手而言，於 Poetry 的專案中，<strong>一律使用 Poetry</strong> 來管理虛擬環境即可。</p>
<h3 id="以指令建立虛擬環境"><a class="header" href="#以指令建立虛擬環境">以指令建立虛擬環境</a></h3>
<p>使用指令<code>poetry env use python</code>：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo-IEWSZKSE-py3.8 in /Users/kyo/Library/Caches/pypoetry/virtualenvs
Using virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>重點說明：</p>
<ul>
<li>Poetry 原則上會使用目前的 Python 版本來建立虛擬環境，這取決於<code>python</code>在你的 PATH 是連結到哪個版本，也可以明示為<code>python3</code>或<code>python3.8</code>，前提是 PATH 中確實存在這些連結。</li>
<li>Poetry 會統一將虛擬環境建立在「特定目錄」下，本例中是<code>/Users/kyo/Library/Caches/pypoetry/virtualenvs</code>。</li>
<li>虛擬環境的命名模式固定為<code>專案名稱-亂數-Python版本</code>。</li>
</ul>
<p>老實說我個人不是很喜歡這樣的做法，因為如此一來單一專案允許建立複數個虛擬環境（Python 3.7、 3.8、3.9 可以各來一個），彈性之餘也增加了混亂程度，且命名模式我也不喜歡，太冗長了。</p>
<p>既然 Poetry 管理的套件環境是高度綁定專案本身的，我更偏好<code>venv</code>式的做法，也就是<strong>把虛擬環境放到專案目錄內</strong>，而不是統一放在獨立的目錄下，讓虛擬環境與專案呈現<strong>直觀的一對一關係</strong>。</p>
<p>所幸 Poetry 具備這樣的選項。</p>
<h3 id="修改config建立專案內的venv虛擬環境"><a class="header" href="#修改config建立專案內的venv虛擬環境">修改<code>config</code>，建立專案內的<code>.venv</code>虛擬環境</a></h3>
<p>讓我們使用<code>poetry config</code>指令來查看 Poetry 目前幾個主要的設定，需要使用<code>--list</code>這個參數：</p>
<pre><code>❯ poetry config --list
cache-dir = &quot;/Users/kyo/Library/Caches/pypoetry&quot;
experimental.new-installer = true
installer.parallel = true
virtualenvs.create = true
virtualenvs.in-project = false
virtualenvs.path = &quot;{cache-dir}/virtualenvs&quot;
</code></pre>
<p>其中<code>virtualenvs.create = true</code>若改成<code>false</code>，則可以停止 Poetry 在「偵測不到虛擬環境時會自行建立」的行為模式，但建議還是不要更動。</p>
<p>而<code>virtualenvs.in-project = false</code>就是我們要修改的目標：</p>
<pre><code>poetry config virtualenvs.in-project true
</code></pre>
<p>好，我們先把之前建立的虛擬環境刪除：</p>
<pre><code>❯ poetry env remove python
Deleted virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>重新建立，看看行為有何差異：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo in /Users/kyo/Documents/code/poetry-demo/.venv
Using virtualenv: /Users/kyo/Documents/code/poetry-demo/.venv
</code></pre>
<p>可以看出：</p>
<ul>
<li>虛擬環境的路徑改為「專案的根目錄」。</li>
<li>名稱固定為<code>.venv</code>。</li>
</ul>
<p>我覺得這樣的設定更加簡潔。</p>
<h3 id="啟動與退出虛擬環境"><a class="header" href="#啟動與退出虛擬環境">啟動與退出虛擬環境</a></h3>
<p>啟動虛擬環境，需移至專案目錄底下，使用指令<code>poetry shell</code>：</p>
<pre><code>❯ poetry shell
Spawning shell within /Users/kyo/Documents/code/poetry-demo/.venv
❯ . /Users/kyo/Documents/code/poetry-demo/.venv/bin/activate 
</code></pre>
<p><code>poetry shell</code>指令會偵測當前目錄或所屬上層目錄是否存在<code>pyproject.toml</code>來確定所要啟動的虛擬環境，所以如果不移至專案目錄，則會出現下列錯誤：</p>
<pre><code>❯ poetry shell

  RuntimeError

  Poetry could not find a pyproject.toml file in /Users/kyo/Documents/code or its parents

  at ~/Library/Application Support/pypoetry/venv/lib/python3.8/site-packages/poetry/core/factory.py:369 in locate
      365│             if poetry_file.exists():
      366│                 return poetry_file
      367│
      368│         else:
    → 369│             raise RuntimeError(
      370│                 &quot;Poetry could not find a pyproject.toml file in {} or its parents&quot;.format(
      371│                     cwd
      372│                 )
      373│             )
</code></pre>
<p>可以看出 Poetry 的錯誤訊息非常清楚，讓你很容易知曉修正的方向，這是作為一個命令列工具的必要優點。</p>
<p>退出就簡單多了，只需要<code>exit</code>即可。</p>
<h2 id="poetry-常用指令"><a class="header" href="#poetry-常用指令">Poetry 常用指令</a></h2>
<p>Poetry 是一個獨立的命令列工具，就像 pyenv，它有自己的指令，需要花費額外的心力學習。這可能是使用 Poetry 的第二道關卡。所幸和 pyenv 一樣，常用的指令就那幾個而已，所以不用擔心，下面會一一介紹。</p>
<p>繼續使用前面提過的 Flask 和 Black 這兩個套件來加以來示範並說明 Poetry 的優勢與和 pip 的不同之處。本文的示範就只會安裝或移除這兩個套件而已。</p>
<h3 id="poetry-新增套件"><a class="header" href="#poetry-新增套件">Poetry 新增套件</a></h3>
<p>使用指令：</p>
<pre><code>poetry add
</code></pre>
<p>相當於<code>pip install</code>，我們來試著安裝 Flask 看看會有什麼變化：</p>
<p><a href="https://i.imgur.com/H7pPtsk.png"><img src="https://i.imgur.com/H7pPtsk.png" alt="img" /></a></p>
<p>圖中可以看出 Poetry 漂亮的命令列資訊呈現，會清楚告知總共新增了幾個套件。</p>
<p>此時專案中的<code>pyproject.toml</code>也會發生變化：</p>
<pre><code>...
[tool.poetry.dependencies]
python = &quot;^3.8&quot;
Flask = &quot;^2.1.1&quot;

[tool.poetry.dev-dependencies]

[build-system]
...
</code></pre>
<p>這裡要說明，安裝 Flask，則<code>pyproject.toml</code>就只會顯示<code>Flask = &quot;^2.1.1&quot;</code>這個 <strong>top-level</strong> 的 package 項目，其餘的依賴套件<strong>不會</strong>直接記錄在<code>toml</code>檔中。</p>
<p>我覺得這是一大優點，方便區分哪些是你<strong>主動安裝</strong>的主要套件，而哪些又是基於套件的依賴關係而一併安裝的依賴套件。</p>
<h3 id="poetrylock-與更新順序"><a class="header" href="#poetrylock-與更新順序">poetry.lock 與更新順序</a></h3>
<p>除了<code>pyproject.toml</code>，此時專案中還會增加一個新增檔案，名為<code>poetry.lock</code>，它實際上就相當於 pip 中的<code>requirements.txt</code>，詳細記載了所有安裝的套件與版本。</p>
<p>當你使用<code>poetry add</code>指令時，Poetry 會自動依序幫你做完這三件事：</p>
<ul>
<li>更新<code>pyproject.toml</code>。</li>
<li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。</li>
<li>依照<code>poetry.lock</code>的內容，更新虛擬環境。</li>
</ul>
<p>換句話說，<code>poetry.lock</code>的內容主要是取決於<code>pyproject.toml</code>，但兩者並不會自己連動，一定要基於特定指令才會進行同步與更新，<code>poetry add</code>就是一個典型案例。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
└── pyproject.toml

0 directories, 2 files
</code></pre>
<h3 id="更新-poetrylock"><a class="header" href="#更新-poetrylock">更新 poetry.lock</a></h3>
<p>當你自行修改了<code>pyproject.toml</code>內容，比如變更特定套件的版本與範圍（這是有可能的，尤其在手動處理版本衝突的時候），此時<code>poetry.lock</code>的內容與<code>pyproject.toml</code>出現了脫鉤，必須讓它依照新的<code>pyproject.toml</code>內容來自我更新，使用指令：</p>
<pre><code>poetry lock
</code></pre>
<p>如此一來，手動修改的內容，才能確保也更新到<code>poetry.lock</code>，畢竟虛擬環境如果要重新建立，是基於<code>poetry.lock</code>的內容來安裝套件，而非<code>pyproject.toml</code>。</p>
<p>再次強調，<code>poetry.lock</code>相當於 Poetry 的<code>requirements.txt</code>。</p>
<h3 id="列出全部套件清單--樹狀顯示"><a class="header" href="#列出全部套件清單--樹狀顯示">列出全部套件清單 + 樹狀顯示</a></h3>
<p>類似<code>pip list</code>，這裡使用<code>poetry show</code>：</p>
<pre><code>❯ poetry show
click              8.1.2  Composable command line interface toolkit
flask              2.1.1  A simple framework for building complex web applications.
importlib-metadata 4.11.3 Read metadata from Python packages
itsdangerous       2.1.2  Safely pass data to untrusted environments and back.
jinja2             3.1.1  A very fast and expressive template engine.
markupsafe         2.1.1  Safely add untrusted strings to HTML/XML markup.
werkzeug           2.1.1  The comprehensive WSGI web application library.
zipp               3.8.0  Backport of pathlib-compatible object wrapper for zip files
</code></pre>
<p>特別提醒的是，這裡的清單內容並不是來自於虛擬環境，這點和 pip 不同，而是來自於<code>poetry.lock</code>的內容。</p>
<p>而 Poetry 最為人津津樂道的就是它的樹狀顯示<code>poetry show --tree</code>：</p>
<pre><code>❯ poetry show --tree
flask 2.1.1 A simple framework for building complex web applications.
├── click &gt;=8.0
│   └── colorama *
├── importlib-metadata &gt;=3.6.0
│   └── zipp &gt;=0.5
├── itsdangerous &gt;=2.0
├── jinja2 &gt;=3.0
│   └── markupsafe &gt;=2.0
└── werkzeug &gt;=2.0
</code></pre>
<p>讓主要套件與其依賴套件的關係層次，一目瞭然。</p>
<h3 id="安裝套件至-dev-dependencies"><a class="header" href="#安裝套件至-dev-dependencies">安裝套件至 dev-dependencies</a></h3>
<p>有些套件，比如<code>pytest</code>、<code>flake8</code>等等，只會在開發環境中使用，產品的部署環境並不需要，Poetry 允許你區分這兩者，將上述的套件安裝至<code>dev-dependencies</code>區塊，方便讓你輕鬆建立一份沒有這些套件的虛擬環境。</p>
<p>在此以 Black 為例，安裝方式如下：</p>
<pre><code>poetry add black -D
</code></pre>
<p>或</p>
<pre><code>poetry add black --dev
</code></pre>
<p>結果的區別顯示在<code>pyproject.toml</code>裡：</p>
<pre><code>...
[tool.poetry.dependencies]
python = &quot;^3.8&quot;
Flask = &quot;^2.1.1&quot;

[tool.poetry.dev-dependencies]
black = &quot;^22.3.0&quot;
...
</code></pre>
<p>可以看到<code>black</code>被列在不同區塊：<code>tool.poetry.dev-dependencies</code>。</p>
<p>然而這是記載上的差異，使用上具體的差別為何？下面會再次提及，可以理解為「輸出套件環境」上的差異。</p>
<h3 id="poetry-移除套件"><a class="header" href="#poetry-移除套件">Poetry 移除套件</a></h3>
<p>使用<code>poetry remove</code>指令。和<code>poetry add</code>一樣，可以加上<code>-D</code>參數來移除置於開發區的套件。</p>
<p>而移除套件時的「依賴解析」能力，正是 Poetry 遠遠優於 pip 的主要環節，因為 pip 沒有嘛！也是為何我提議改用 Poetry 的關鍵理由——為了順利移除套件。</p>
<p>前面已經提過，pip 的<code>pip uninstall</code>只會移除你所指定的套件，而不會連同依賴套件一起移除——因為 pip 沒有「依賴解析」功能。如果貿然移除「安裝時所有一併安裝」的依賴套件，可能會造成巨大的災難，讓別的套件失去效用。</p>
<p>前面也舉了 Flask 和 Black 都共同依賴<code>click</code>這個套件的例子，在人為手動移除的情況下，你可能未曾注意 Black 也依賴了<code>click</code>，結果為了「徹底移除」Flask 的所有相關套件，不小心把<code>click</code>也移除掉了。</p>
<p>當然，我知道，絕大部分的真實情況是——你根本不會去移除一段時間前安裝但已不再使用的套件。</p>
<hr />
<p>好，解釋了很多，接下來就是 Poetry 的表演了，它會幫你處理這些棘手的「套件相依性」難題，讓你輕鬆移除 Flask 而不影響 Black：</p>
<p><a href="https://i.imgur.com/79TycuL.png"><img src="https://i.imgur.com/79TycuL.png" alt="img" /></a></p>
<p>可以對比上面安裝 Flask 時的截圖，總共安裝了 8 個套件，但現在移除卻只有 7 個——沒錯，因為 Poetry 知道 Black 還需要<code>click</code>！不能移除：</p>
<pre><code>❯ poetry show --tree
black 22.3.0 The uncompromising code formatter.
├── click &gt;=8.0.0
│   └── colorama *
├── mypy-extensions &gt;=0.4.3
├── pathspec &gt;=0.9.0
├── platformdirs &gt;=2
├── tomli &gt;=1.1.0
└── typing-extensions &gt;=3.10.0.0
</code></pre>
<p>一個套件直到環境中的<strong>其餘套件都不再依賴它</strong>，Poetry 才會安心讓它被移除。</p>
<h3 id="輸出-poetry-虛擬環境的-requirementstxt"><a class="header" href="#輸出-poetry-虛擬環境的-requirementstxt">輸出 Poetry 虛擬環境的 requirements.txt</a></h3>
<p>理論上，全面改用 Poetry 後，專案中是不需要存在<code>requirements.txt</code>，因為它的角色已經完全被<code>poetry.lock</code>所取代。</p>
<p>但事實是，你還是很可能需要它，甚至還需要隨著<code>poetry.lock</code>同步更新它的內容！至少對我而言就是如此，我在 Docker 部署環境中並不使用 Poetry，所以我需要一份完全等價於<code>poetry.lock</code>的<code>requirements.txt</code>用於 Docker 部署。</p>
<p>如果你想說，那我就在 Poetry 的虛擬環境下，使用以往熟悉的指令<code>pip freeze &gt; requirements.txt</code>，來產生一份不就好了？我本來也是這麼想的。但實際的產出卻是如此（目前 poetry-demo 專案僅剩下 Black）：</p>
<pre><code>black @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/11/4c/fc/cd6d885e9f5be135b161e365b11312cff5920d7574c8446833d7a9b1a3/black-22.3.0-cp38-cp38-macosx_10_9_x86_64.whl
click @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/f0/23/09/b13d61d1fa8b3cd7c26f67505638d55002e7105849de4c4432c28e1c0d/click-8.1.2-py3-none-any.whl
mypy-extensions @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/b6/a0/b0/a5dc9acd6fd12aba308634f21bb7cf0571448f20848797d7ecb327aa12/mypy_extensions-0.4.3-py2.py3-none-any.whl
...
</code></pre>
<p>這呈現好像不是我們以前熟悉的那種：</p>
<pre><code>black==22.3.0
click==8.1.2
mypy_extensions==0.4.3
...
</code></pre>
<p>沒錯，只要是使用<code>poetry add</code>安裝的套件，在<code>pip freeze</code>就會變成這樣。此時想輸出類似<code>requirements.txt</code>的樣式，需要使用<code>poetry export</code>。</p>
<p>預設輸出會有 hash 值，不想納入則要加上參數去除。現在我都是用以下指令來輸出：</p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes
</code></pre>
<p>我們再看一下輸出結果，雖然不盡相同，但也相去不遠了…嗎？等等，怎麼是空白？</p>
<hr />
<p>因為<code>poetry export</code>預設只會輸出<code>toml</code>中的<code>[tool.poetry.dependencies]</code>區塊的套件！還記得上面我們把 Black 安裝到<code>[tool.poetry.dev-dependencies]</code>了嗎？</p>
<p>顯然 Poetry 認為你的 export 需求基本上就為了部署，並不需要開發區的套件。這倒是沒錯，不過基於演示需求，我們必須輸出<code>[tool.poetry.dev-dependencies]</code>的套件，才能看到 Black。</p>
<p>加上<code>—-dev</code>參數即可：</p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes --dev
</code></pre>
<p>輸出的<code>requirements.txt</code>內容：</p>
<pre><code>black==22.3.0; python_full_version &gt;= &quot;3.6.2&quot;
click==8.1.2; python_version &gt;= &quot;3.7&quot; and python_full_version &gt;= &quot;3.6.2&quot;
colorama==0.4.4; python_version &gt;= &quot;3.7&quot; and python_full_version &gt;= &quot;3.6.2&quot; and platform_system == &quot;Windows&quot;
...
</code></pre>
<p>雖然長得有點不一樣，但這個檔案確實是可以<code>pip install</code>的。</p>
<p>從這裡也可以看出前面提及的「區分套件安裝區塊」的價值了——有些時候並不需要輸出開發專用套件。</p>
<p><code>poetry export</code>所有參數用法與說明，請參考<a href="https://python-poetry.org/docs/cli/#export">文件</a>。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
├── pyproject.toml
└── requirements.txt

0 directories, 3 files
</code></pre>
<h3 id="小結poetry-常用指令清單"><a class="header" href="#小結poetry-常用指令清單">小結：Poetry 常用指令清單</a></h3>
<p>算來算去，Poetry 的常用指令主要有下面幾個：</p>
<ul>
<li><code>poetry add</code></li>
<li><code>poetry remove</code></li>
<li><code>poetry export</code></li>
<li><code>poetry env use</code></li>
<li><code>poetry shell</code></li>
<li><code>poetry show</code></li>
<li><code>poetry init</code></li>
<li><code>poetry install</code></li>
</ul>
<p>其中一半以上，單一專案可能只會用個一兩次而已，比如<code>init</code>、<code>install</code>和<code>env use</code>，實際上需要學習的指令並不多。</p>
<p>那麼，只要知曉這些指令，就可以順利運用 Poetry 了嗎？可能是，也可能否，所以我下面還會再補充 Poetry 的常見使用情境與操作方式，讓你接納 Poetry 的阻力可以進一步下降！</p>
<h2 id="poetry-常見使用情境與操作-qa"><a class="header" href="#poetry-常見使用情境與操作-qa">Poetry 常見使用情境與操作 QA</a></h2>
<p>這部分會以「使用場景」的角度切入，介紹 Poetry 應用情境與操作說明，還包括一些自問自答，如下：</p>
<ol>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%80%E3%80%81%E6%96%B0%E5%A2%9E%E5%B0%88%E6%A1%88%E4%B8%A6%E4%BD%BF%E7%94%A8-Poetry">新增專案並使用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%8C%E3%80%81%E7%8F%BE%E6%9C%89%E5%B0%88%E6%A1%88%E6%94%B9%E7%94%A8-Poetry">現有專案改用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%89%E3%80%81%E5%9C%A8%E5%88%A5%E8%87%BA%E4%B8%BB%E6%A9%9F%E5%9B%9E%E5%BE%A9%E5%B0%88%E6%A1%88%E7%8B%80%E6%85%8B">在別臺主機回復專案狀態</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%9B%9B%E3%80%81%E6%88%91%E6%83%B3%E8%A6%81%E9%87%8D%E5%BB%BA%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83">我想要重建虛擬環境</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">為什麼我不在 Docker 環境中使用 Poetry？</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%85%AD%E3%80%81%E6%88%91%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%BF%92%E6%85%A3%E7%9A%84-vituralenv-%E5%97%8E%EF%BC%9F">我可以使用自己習慣的 vituralenv 嗎？</a></li>
</ol>
<h3 id="一新增專案並使用-poetry"><a class="header" href="#一新增專案並使用-poetry">一、新增專案並使用 Poetry</a></h3>
<p>這是最理想的狀態，沒有過去的「包袱」，可謂是最能輕鬆採用 Poetry 的情境。</p>
<p>使用順序不外乎是：</p>
<ol>
<li><code>poetry init</code>：初始化，建立<code>pyproject.toml</code>。</li>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。</li>
<li><code>poetry shell</code>：進入專案但虛擬環境還未啟動，以這個指令啟動。如果使用本指令時虛擬環境<strong>還不存在或已移除</strong>，則會直接自動幫你建立虛擬環境並使用。</li>
<li><code>poetry add</code>：新增套件，必要使用<code>-D</code>參數新增至 dev 區塊。</li>
<li><code>poetry remove</code>：移除套件，若是移除 dev 區塊的套件，需要加上<code>-D</code>參數。</li>
</ol>
<p>這部分和前面內容沒有差別，因為前面內容就是以全新專案作為基礎。</p>
<h3 id="二現有專案改用-poetry"><a class="header" href="#二現有專案改用-poetry">二、現有專案改用 Poetry</a></h3>
<p>這是極為常見的需求，但並沒有很正式的做法，因為不存在<code>poetry import</code>之類的指令。</p>
<p>首先要考量的就是：要怎麼把<code>requirements.txt</code>的所有項目加到<code>pyproject.toml</code>中呢？經過一番 Google，基本上<a href="https://stackoverflow.com/questions/62764148/how-to-import-requirements-txt-from-an-existing-project-using-poetry">只能土法煉鋼</a>：</p>
<pre><code>cat requirements.txt | xargs poetry add
</code></pre>
<p>在這個過程是有可能遇到問題的，因為 Poetry 對套件的版本衝突比較敏感，所以在<code>requirements.txt</code>能正常安裝的項目，在上述指令的過程中可能會出錯。</p>
<p>那怎麼辦？只能照著錯誤訊息去修正<code>requirements.txt</code>中的套件版本。</p>
<p>並且，這個 import 做法實在是不得已，因為我們最早介紹<code>pyproject.toml</code>時有提到，原則上它只會記載「主套件」，但這個做法相當於把<code>requirements.txt</code>中的<strong>所有套件都當作主套件</strong>來<code>add</code>了！——畢竟<code>requirements.txt</code>沒有能力區分主套案與依賴套件，都是「一視同仁」地列出。</p>
<p>如此做法讓專案的套件失去了主從之分，日後想要移除主套件時，就需要比較多心力去分辨主從，比如使用<code>poetry show --tree</code>去一一檢視，終究是麻煩的事。</p>
<p>完成轉換後，保險起見，重建一個虛擬環境會比較合適。</p>
<h3 id="三在別臺主機回復專案狀態"><a class="header" href="#三在別臺主機回復專案狀態">三、在別臺主機回復專案狀態</a></h3>
<p>這也是非常常見的需求。</p>
<p>第一步當然是<code>git clone</code>專案，此時專案中已經有 Poetry 所需的必要資訊了——也就是<code>pyproject.toml</code>和<code>poetry.lock</code>。</p>
<p>你還缺少的僅僅是虛擬環境。如果是全新的主機，則還得先安裝、設定好 Poetry。</p>
<p>移至專案目錄底下，然後依序操作：</p>
<ol>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。如果你懶得打這麼長的指令，直接<code>poetry shell</code>也是可以。</li>
<li><code>poetry install</code>：因為是舊專案，不再需要<code>init</code>，直接從<code>poetry.lock</code>安裝套件！使用的就是這個指令，類似<code>npm install</code>。</li>
</ol>
<h3 id="四我想要重建虛擬環境"><a class="header" href="#四我想要重建虛擬環境">四、我想要重建虛擬環境</a></h3>
<p>在使用專案內虛擬環境方案，也就是<code>.venv</code>的前提下，想要刪除這個虛擬環境並加以重建，也不需要使用<code>poetry env remove python</code>指令了，因為會出錯。</p>
<p>還有更簡單暴力的方式，是什麼呢？當然是直接刪除<code>.venv</code>資料夾即可。</p>
<p>然後再<code>poetry env use python</code>或<code>poetry shell</code>建一個新的就好。</p>
<h3 id="五為什麼我不在-docker-環境中使用-poetry"><a class="header" href="#五為什麼我不在-docker-環境中使用-poetry">五、為什麼我不在 Docker 環境中使用 Poetry？</a></h3>
<p>因為啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會增加新的藕合與依賴，我覺得並不妥當。</p>
<p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p>
<h3 id="六我可以使用自己習慣的-vituralenv-嗎"><a class="header" href="#六我可以使用自己習慣的-vituralenv-嗎">六、我可以使用自己習慣的 vituralenv 嗎？</a></h3>
<p>當然可以。</p>
<p>我本來也繼續使用<code>pyenv</code>的<code>vituralenv</code>，但兩者有時候也是會小小打架，後來還是索性用 Poetry 的虛擬環境就好。一個專案對應一個虛擬環境，我認為還是比較簡潔的做法。</p>
<hr />
<h2 id="結語-3"><a class="header" href="#結語-3">結語</a></h2>
<p>使用 Poetry 來管理專案的套件與虛擬環境，雖然需要一定的學習成本，但帶來的效益還是相當可觀的，尤其在你希望能乾淨且安心地移除套件的時候。</p>
<p>別再猶豫，從今天起，加入 Poetry 的行列吧！</p>
<h3 id="參考-3"><a class="header" href="#參考-3">參考</a></h3>
<ul>
<li>https://python-poetry.org/docs/</li>
<li>https://github.com/python-poetry/poetry</li>
<li>https://github.com/python-poetry/poetry/issues/3248</li>
<li>https://github.com/python-poetry/poetry/issues/5185</li>
<li><a href="https://note.koko.guru/posts/using-poetry-manage-python-package-environments">Python - 取代 Pipenv 的新套件管理器 Poetry</a></li>
<li><a href="https://greyli.com/poetry-a-better-choice-than-pipenv/">相比 Pipenv，Poetry 是一個更好的選擇</a></li>
<li><a href="https://shazi.info/pip-pipenv-%E5%92%8C-poetry-%E7%9A%84%E9%81%B8%E6%93%87/">pip, pipenv 和 poetry 的選擇</a></li>
<li><a href="https://realpython.com/dependency-management-python-poetry/">Dependency Management With Python Poetry</a></li>
<li><a href="https://pythonhunter.org/episodes/ep15">Ep 15. 和 PyPA 的成員聊聊 Python 開發工作流</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教你用python搭建grpc服務"><a class="header" href="#教你用python搭建grpc服務">教你用Python搭建gRPC服務</a></h1>
<h2 id="前言-2"><a class="header" href="#前言-2">前言</a></h2>
<p>前陣子剛好有個要使用 gRPC 的機會，同事看了一下官網的 Tutorial 覺得一時之間有點迷路，所以就寫了一份比較簡單的 gRPC Tutorial for Python，應該可以讓需要的人更快入門。</p>
<h2 id="protocol-buffers-簡介"><a class="header" href="#protocol-buffers-簡介">protocol buffers 簡介</a></h2>
<p>在介紹 gRPC 之前先來講講 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a>。我們在不同 service 之間做訊息溝通的時候，最常使用的也許是透過 json 來做傳遞，不過在使用 json 上面可能會遇到以下幾個問題：</p>
<ol>
<li>json 的 serialize/de-serialize 速度太慢</li>
<li>透過 json 傳資料的結構不夠清楚，得靠 API 文件搞定</li>
<li>用 json 傳資料的 size 太大</li>
</ol>
<p><a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 便是 Google 為瞭解決以上問題而生，它可以透過一個 <code>.proto</code> 檔案，在各語言生出相對應的檔案使用。目前<a href="https://github.com/google/protobuf">支援的程式語言很多</a>，有 Python、golang、js、java 等等。</p>
<h2 id="grpc-簡介"><a class="header" href="#grpc-簡介">grpc 簡介</a></h2>
<p>有了 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 之後，google 更進一步的推出了 gRPC。透過 gRPC，我們可以在 <code>.proto</code> 檔案當中也一併定義好 service，讓遠端使用的 client 可以如同呼叫本地的 library 一樣使用，不用再自己處理 routing 、連線等等的問題。</p>
<p><img src="python/images/1_ZVirmBhtvTcIPYSqo9gXAA.png" alt="img" /></p>
<p>上圖是從 <a href="https://grpc.io/">gRPC 官網</a>上面截下來的圖，可以看到 gRPC Server 是由 <code>C++</code> 撰寫，client 則分別是 Java 以及 Ruby，Server 跟 Client 端則是透過 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 來做傳遞。</p>
<h2 id="開發-grpc-流程"><a class="header" href="#開發-grpc-流程">開發 gRPC 流程</a></h2>
<p>接下來讓我們來用 Python 開發一個最簡單的 gRPC service。分別有以下四個部分：</p>
<ol>
<li>環境安裝 – 最基本的套件安裝</li>
<li><code>.proto</code> 檔案 – 定義 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 還有 service</li>
<li>Server – server 的 code</li>
<li>Client – client 呼叫 server 的 code</li>
</ol>
<p>最後完成的程式碼會放在 https://github.com/daikeren/gprc_tutorial</p>
<h3 id="環境安裝以及設定"><a class="header" href="#環境安裝以及設定">環境安裝以及設定</a></h3>
<p>首先我們要安裝相對應的套件，這邊我們用 <a href="https://docs.pipenv.org/">pipenv</a> 來作為環境管理工具。輸入以下指令安裝 grpcio 以及 grpcio-tools。</p>
<pre><code class="language-bash">pipenv install grpcio grpcio-tools
</code></pre>
<p>接著，我們先來定義我們 service 的功能，我們這邊為了 demo，我們這個 service 做的事情很簡單，只是將傳遞進來的 name 前面加上 “Hello” 再回傳回去。這邊當然是可以改成任何我們想要 Python Function。</p>
<pre><code class="language-python"># hello.py
def hello(name):
    return f&quot;Hello {name}&quot;
</code></pre>
<h3 id="proto-檔案"><a class="header" href="#proto-檔案"><code>.proto</code> 檔案</a></h3>
<p>接下來，我們創建一個 <code>hello.proto</code> 檔案，裡面描述了我們要使用的 message 以及 service</p>
<pre><code class="language-python">syntax = &quot;proto3&quot;;

message HelloRequest {
    string value = 1;
}

message HelloResponse {
    string value = 1;
}

service Hello {
    rpc Hello(HelloRequest) returns (HelloResponse) {}
}
</code></pre>
<p>這邊的 message 代表了我們要跟 gRPC 傳遞的參數、型別，service 則是敘述了 service name 以及傳入、傳回的參數。之後我們會透過 <code>gprc_tools</code> 來讀取 <code>.proto</code> 檔案產生相對應的 Python class。這邊可以看到我們定義的 message 以及 service 如下：</p>
<ul>
<li>message: 這邊定義了兩種 message，分別是 <code>HelloRequest</code> 以及 <code>HelloResponse</code>，裡面都只有一個叫做 <code>value</code> 的欄位，形態是 <code>string</code></li>
<li>service: 這邊定義了一個 service，裡面只有一個叫做 Hello 的 rpc 傳入值是 <code>HelloRequest</code>，傳回值則是 <code>HelloResponse</code></li>
</ul>
<p>接下來，我們輸入以下指令為 Python 產生 gRPC 的 class</p>
<pre><code class="language-bash">pipenv run python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. hello.proto
</code></pre>
<p>你會看到多出了兩個檔案</p>
<ul>
<li><code>hello_pb2.py</code>: 定義了相對應的 message class</li>
<li><code>hello_pb2_grpc.py</code>: 定義了相對應的 service class</li>
</ul>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<p>有了 <code>hello_pb2.py</code> 以及 <code>hello_pb2_grpc.py</code>，我們就可以開始實作我們的 gRPC server，詳細的程式碼如下：</p>
<pre><code class="language-python"># server.py
from concurrent import futures
import time

import grpc 
import hello_pb2
import hello_pb2_grpc

import hello

# 創建一個 HelloServicer，要繼承自 hello_pb2_grpc.HelloServicer
class HelloServicer(hello_pb2_grpc.HelloServicer):

# 由於我們 service 定義了 Hello 這個 rpc，所以要實作 Hello 這個 method
    def Hello(self, request, context):

# response 是個 HelloResponse 形態的 message
        response = hello_pb2.HelloResponse()
        response.value = hello.hello(request.value)
        return response


def serve():
# 創建一個 gRPC server
	server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))

# 利用 add_HelloServicer_to_server 這個 method 把上面定義的 HelloServicer 加到 server 當中
	hello_pb2_grpc.add_HelloServicer_to_server(HelloServicer(), server)

# 讓 server 跑在 port 50051 中
	server.add_insecure_port('[::]:50051')
	server.start()
	try:
		while True:
			time.sleep(86400)
	except KeyboardInterrupt:
		server.stop(0)


if __name__ == '__main__':
	serve()
</code></pre>
<p>接著我們可以輸入以下指令啟動 gRPC server</p>
<pre><code class="language-bash">pipenv run python server.py
</code></pre>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<p>client side 的 code 很單純，就是建立一個 channel 連線到 gRPC server，再用 stub 來呼叫。</p>
<pre><code class="language-python"># client.py 

import grpc

import hello_pb2
import hello_pb2_grpc

# 連接到 localhost:50051
channel = grpc.insecure_channel('localhost:50051')

# 創建一個 stub (gRPC client)
stub = hello_pb2_grpc.HelloStub(channel)

# 創建一個 HelloRequest 丟到 stub 去
request = hello_pb2.HelloRequest(value=&quot;World&quot;)

# 呼叫 Hello service，回傳 HelloResponse
response = stub.Hello(request)

print(response.value)
</code></pre>
<p>因為我們已經在 localhost 跑起來 server 了，執行以下的 client 程式碼：</p>
<pre><code class="language-bash">pipenv run python client.py
Hello World
</code></pre>
<h2 id="小結-2"><a class="header" href="#小結-2">小結</a></h2>
<p>看到這邊應該可以理解一個簡單的 gRPC 該怎麼實作，相信以這為基礎應該可以很容易擴展出未來更多的 gRPC 應用。</p>
<h2 id="參考-4"><a class="header" href="#參考-4">參考</a></h2>
<ul>
<li>https://www.icoding.co/2020/07/grpc-tutorial-for-python</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="別再用-print-來-debug-啦來用-python-debugger-吧"><a class="header" href="#別再用-print-來-debug-啦來用-python-debugger-吧">別再用 print 來 Debug 啦！來用 Python Debugger 吧！</a></h1>
<h2 id="前言-3"><a class="header" href="#前言-3">前言</a></h2>
<p>這幾年開發 Python 下來，發現不少人對於 debugger 其實還是有點陌生的。大部分在做除錯的時候，還是會用 print 或是 <a href="https://www.icoding.co/2012/08/logging-html">Python Logging</a> 來印出程式的變數，或是理解目前程式碼進行的流程，藉此來確認自己程式的行為。在看完這篇文章之後，讀者可以學會如何透過 Python Debugger 來取代原本的 debugging 行為，你將會發現你的 debug 會更加的有效率。</p>
<h2 id="print-大法好為什麼要用-debugger"><a class="header" href="#print-大法好為什麼要用-debugger">print 大法好！為什麼要用 debugger？</a></h2>
<p>對於剛開始接觸 Python 的人來說，最常使用的 debug tool 應該就是 print 了。隨著對於 Python 越來越瞭解，可能會透過 <a href="https://www.icoding.co/2012/08/logging-html">Python 的 logging module</a>，透過像是 <code>logging.debug</code> 之類的 code 來印出 debug message. 這樣看似沒問題，但是往往我們用 print 大法來 debug 的流程是這樣子的：</p>
<ol>
<li>印出某個變數的值 <code>var1</code></li>
<li>發現 <code>var1</code> 的變數跟預期不太一樣，但是 <code>var1</code> 的值又 depends on <code>var2</code></li>
<li>印出 <code>var2</code> 的值，重跑一次程式</li>
<li>發現 <code>var2</code> 的變數跟預期不太一樣，但是 <code>var2</code> 的值又 depends on <code>var3</code> + <code>var4</code></li>
<li>持續下去直到找到問題為止</li>
</ol>
<p>這來回幾次的過程當中，你會先花費大量的時間印出所有你想要的值，再從這些蛛絲馬跡當中尋找到你想要的資訊，推斷問題的所在。如果你的程式執行起來很方便就算了，但是當你的程式執行起來有些麻煩或是有些久的時候，你就會耗費大量的時間在不斷的修改程式上面。而 debugger 可以幫助你解決這個問題。</p>
<p>當你使用 debugger 的時候，你的除錯行為會變成如下：</p>
<ol>
<li>在你懷疑出問題的地方設定中斷點</li>
<li>執行程式，遇到中斷點的時候停下來</li>
<li>透過 debugger 的指令，來觀察你想要知道的變數值，或是一步一步的執行你的程式看看問題在哪裡</li>
<li>Bug 解掉了！移除中斷點</li>
</ol>
<h2 id="pdb-基本指令"><a class="header" href="#pdb-基本指令">pdb 基本指令</a></h2>
<p>Python 就有內建 debugger <a href="https://docs.python.org/3/library/pdb.html">pdb</a>，要使用 pdb 很簡單，有三種方式：</p>
<ol>
<li>不用修改原始程式碼的作法</li>
</ol>
<pre><code class="language-bash">python3 -m pdb file.py
</code></pre>
<ol>
<li>在需要插入中斷點的程式碼中插入 <a href="https://docs.python.org/3/library/functions.html#breakpoint">breakpoint()</a> function (Python 3.7 之後支援)</li>
</ol>
<p>Example.</p>
<pre><code class="language-python">def bug_here(a):
	breakpoint()
  b = a + 3
	return b
</code></pre>
<ol>
<li>在需要插入中斷點的程式碼插入 <code>import pdb;pdb.set_trace()</code></li>
</ol>
<p>Example.</p>
<pre><code class="language-python">def bug_here(a):
	import pdb;pdb.set_trace()
  b = a + 3
	return b
</code></pre>
<p>當你看到在 terminal 下面看到出現 <code>(Pdb)</code> 出現，就代表你成功的使用了 pdb.</p>
<p>以下是些比較常用的 pdb 指令：</p>
<ul>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-break">b(reak)</a> – 添加 breakpoint</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-p">p</a> – 印出變數值</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-list">l(ist)</a> – 印出目前所在 function/frame上下 11 行的程式碼</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-ll">ll (longlist)</a> – 印出目前所在 function/frame 的所有程式碼</li>
<li>執行指令
<ul>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-step">s(tep)</a> – 執行下一行程式碼，遇到執行 function 的時候，會進入 function 當中</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-next">n(ext)</a> – 執行下一行程式碼，遇到執行 function 的時候，不會進入 function 中。</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-return">r(eturn)</a> – 執行程式直到 function return</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-continue">c(ontinue)</a> – 持續執行程式碼直到遇到下一個中斷點</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-until">unt(il)</a> – 持續執行程式直到遇到某一行</li>
</ul>
</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-whatis">whatis</a> – 印出 expression 的型別</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-interact">interact</a> – 啟動一個 Python 的 interpreter</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-where">w(here)</a> – 印出 stack track 狀態</li>
<li><a href="https://docs.python.org/3/library/pdb.html#pdbcommand-quit">q(uit)</a> – 離開 pdb</li>
</ul>
<p>其他關於 pdb 的指令可以參考 <a href="https://docs.python.org/3/library/pdb.html">pdb 官方文件</a>有很清楚的說明。</p>
<h2 id="debugger-進階"><a class="header" href="#debugger-進階">debugger 進階</a></h2>
<p>Python 內建的 pdb 已經可以滿足不少基本需求，在瞭解 pdb 的基本之後，再介紹以下兩種會讓你除錯生產力更加提升的方法。</p>
<h3 id="ipdb"><a class="header" href="#ipdb">ipdb</a></h3>
<p>對於使用過 Python 一段時間的人，應該都會對 <a href="https://ipython.org/">IPython</a> 印象深刻。當中提供的 autocomplete, syntax highlight 等功能都會讓我們生產力提升不少。<a href="https://pypi.org/project/ipdb/">ipdb</a> 就是一個可以增強原本 pdb 功能，為 pdb 帶來跟 <a href="https://ipython.org/">IPython</a> 一樣的體驗。</p>
<p>要使用 ipdb，首先先安裝</p>
<pre><code class="language-bash">pip install ipdb
</code></pre>
<p>我們有幾種方式可以啟動 ipdb</p>
<ul>
<li><code>python -m ipdb file.py</code></li>
<li>在想要插入中斷點的地方輸入</li>
</ul>
<pre><code class="language-python">import ipdb
ipdb.set_trace()
</code></pre>
<ul>
<li>同樣利用 Python 3.7 支援的 <a href="https://docs.python.org/3/library/functions.html#breakpoint">breakpoint()</a>，並且在啟動的時候多設定環境變數</li>
</ul>
<pre><code class="language-bash">PYTHONBREAKPOINT=ipdb.set_trace
</code></pre>
<h3 id="透過-ide-來做-debug"><a class="header" href="#透過-ide-來做-debug">透過 IDE 來做 debug</a></h3>
<p>如果你是 IDE 的使用者，那麼目前的 IDE 都有做了很好的整合，官方的說明文件或是網路上的 tutorial 已經很多了，以下附上一些 reference。</p>
<ul>
<li>PyCharm
<ul>
<li>https://www.youtube.com/watch?v=QJtWxm12Eo0</li>
<li><a href="https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.html">Step 2. Debug your first Python application – Help | PyCharm</a></li>
</ul>
</li>
<li>vscode
<ul>
<li><a href="https://www.youtube.com/watch?v=jHNfzAUccBA">how to debug python code in visual studio code – YouTube</a></li>
<li><a href="https://code.visualstudio.com/docs/python/debugging">Debugging configurations for Python apps in Visual Studio Code</a></li>
</ul>
</li>
</ul>
<h2 id="結論"><a class="header" href="#結論">結論</a></h2>
<p>學會使用 debugger 之後會讓你的生產力提升不少，當你下次在用 print 大法的時候，別忘記還有 debugger 可以用！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="神奇又美好的-decorator-嗷嗚"><a class="header" href="#神奇又美好的-decorator-嗷嗚">神奇又美好的 Decorator ，嗷嗚！</a></h1>
<h1 id="導言"><a class="header" href="#導言">【導言】</a></h1>
<p>由於 Python 的基本語法過於簡潔，所以大部分的設計與技巧都會為了強化其架構的依賴性與開發性，而讓 Python 的語法變得比原先的繁複。</p>
<p>這次要介紹一個少數「化繁為簡」的語法 — — Decorator ！</p>
<p>Decorator 本身的概念非常簡單，但簡單語法與使用背後還有一個<strong>小魔王就是 Closure</strong>！不過 Closure 這個部份較為複雜，不適合一併放入這篇文章，所以會在之後的文章內介紹其原理！<strong>今天大家就著重在 Decorator 如何使用，以及 Decorator 使用時機吧</strong>！</p>
<h1 id="本文章節"><a class="header" href="#本文章節">【本文章節】</a></h1>
<ul>
<li>【壹、什麼是 Decorator ?!】</li>
<li>【貳、Decorator 的 Syntax Candy — @小老鼠】</li>
<li>【參、Decorator 的有序性】</li>
<li>【肆、Decorator 如何帶參數 ?】</li>
<li>【伍、Decorator 也可以是 Class !?】</li>
</ul>
<h1 id="開發環境與建議先備知識"><a class="header" href="#開發環境與建議先備知識">【開發環境與建議先備知識】</a></h1>
<p><strong>OS</strong> <em>Ubuntu 16.04</em></p>
<p><strong>Python</strong> <em>3.6</em></p>
<p><strong>Required Knowledge</strong></p>
<ul>
<li>First Class Function (一級函數)</li>
<li>熟悉 Python function 概念</li>
</ul>
<h1 id="壹什麼是-decorator-"><a class="header" href="#壹什麼是-decorator-">【壹、什麼是 Decorator ?!】</a></h1>
<p>長話不如直接看一下範例 code ：</p>
<pre><code class="language-python">def print_func_name(func):
    def wrap():
        print(&quot;Now use function '{}'&quot;.format(func.__name__))
        func()
    return wrap


def dog_bark():
    print(&quot;Bark !!!&quot;)


def cat_miaow():
    print(&quot;Miaow ~~~&quot;)


if __name__ == &quot;__main__&quot;:
    print_func_name(dog_bark)()
    # &gt; Now use function 'dog_bark'
    # &gt; Bark !!!

    print_func_name(cat_miaow)()
    # &gt; Now use function 'cat_miaow'
    # &gt; Miaow ~~~
</code></pre>
<p>sample-1 https://gist.github.com/JackInTaiwan/8779504fbcbd0d8420e9996fab3c8641</p>
<p>以上的範例可以看到我們有兩個主要的 functions： <code>dog_bark()</code> 和 <code>cat_miaow()</code> 要執行，但兩個 functions 都有一個共同要做的事情，都想要先 print 出自己的 function name，所以對於共同要做的事情我們抽出來用 function <code>print_func_name(func)</code> 來完成。</p>
<p>邏輯是這樣的， <code>print_func_name(func)</code> 會把傳入的 function 再利用一個我們命為 <code>warp()</code> 的內部 function「加工修飾加上一些我們要的功能」，然後在用 <code>return wrap</code> 吐出修飾過的 function <code>wrap</code> ，如此就完成「修飾」的任務啦！最後記得在 <code>print_func_name(dog_bark)</code> 和 <code>print_func_name(cat_miaow)</code> 只會 return function 本身，所以要在後面加上 <code>()</code> 來 call function 喔！！</p>
<p>額外要注意，**在 Python 中，function 的地位和 C++、Java等不同，是屬於 ”First-class Citizen” (一等公民)，故稱作 ”First-class function” (一級函數、頭等函數)。**簡單來說，就是 function 也可以當成參數傳遞並執行。另外，JavaScript 等語言也都是採用 First-class Function 的概念喔！</p>
<p>以上的範例，基本上是一個「藉由抽出相同或相似邏輯來簡化」的簡單到不行的範例（當然現實世界中的例子可複雜得想放棄…）。但這麼簡單的一件事情，我們就稱 function <code>print_func_name(func)</code> 是一個 「Decorator」(裝飾器)！</p>
<h1 id="貳decorator-的-syntax-candy--小老鼠"><a class="header" href="#貳decorator-的-syntax-candy--小老鼠">【貳、Decorator 的 Syntax Candy — @小老鼠】</a></h1>
<p>在上一節中明示了什麼叫做 Decorator，這裡就要介紹它的 syntax candy — @小老鼠！</p>
<p>這邊簡單快速補充一下，syntax candy（語法糖、語法糖衣）就是讓語法簡化的語法，可能原先要寫數十行的 code，若該語言有提供對應的 syntax candy，很可能寫個幾行或是寫個符號上去，就可以輕鬆完成了。這在多數語言中都是極度常見的語法！</p>
<p>補充完畢。老師，範例請下（音樂聲起）：</p>
<pre><code class="language-python">def print_func_name(func):
    def warp():
        print(&quot;Now use function '{}'&quot;.format(func.__name__))
        func()
    return warp


@print_func_name
def dog_bark():
    print(&quot;Bark !!!&quot;)


@print_func_name
def cat_miaow():
    print(&quot;Miaow ~~~&quot;)


if __name__ == &quot;__main__&quot;:
    dog_bark()
    # &gt; Now use function 'dog_bark'
    # &gt; Bark !!!

    cat_miaow()
    # &gt; Now use function 'cat_miaow'
    # &gt; Miaow ~~~
</code></pre>
<p>sample-2 https://gist.github.com/JackInTaiwan/8c27ec000a5ab6f8f4ad124f9b5d9f5e</p>
<p>上面的範例中，我們在兩個主要的 functions 前面加上 decorator <code>@print_func_name</code> ，如此就發揮了 syntax candy 化簡語法的功效，用更簡單的語法來完成一模一樣的事情囉！</p>
<p>或許有沒有使用 syntax candy 對於這兩份範例 code 差不了幾行，但這是因為範例 code 太簡略，而且 function 都只被 call 過一次，所以才會感受不出來。syntax candy 是真實讓人愛不釋手的！</p>
<p>其實對於大部分的讀者來說，最先接觸到 Decorator 的很可能是它的 syntax candy，而不是在上一節【壹、什麼是 Decorator ?!】範例 code 中的形式。不過這地方不需要拘泥於人們口中所說的 decorator 是指原先的形式，還是它的 syntax candy，因為本質真的都一樣啦！所以本篇文章除非特別強調，否則都是指 syntax candy 形式的 decorator 。</p>
<h1 id="參decorator-的有序性"><a class="header" href="#參decorator-的有序性">【參、Decorator 的有序性】</a></h1>
<p>如果之前有閱讀過 <a href="https://medium.com/p/1e3b3998bccf/edit">Python進階技巧 (2) — Static/Class/Abstract Methods之實現</a> 的讀者，可能會記得（應該會有人記得的對吧？！）我提醒過 decorator 彼此間是有順序關係的，要額外注意！</p>
<p>來，老師下音樂，哦不，是下範例：</p>
<pre><code class="language-python">def print_func_name(func):
    def warp_1():
        print(&quot;Now use function '{}'&quot;.format(func.__name__))
        func()
    return warp_1


def print_time(func):
    import time
    def warp_2():
        print(&quot;Now the Unix time is {}&quot;.format(int(time.time())))
        func()
    return warp_2


@print_func_name
@print_time
def dog_bark():
    print(&quot;Bark !!!&quot;)



if __name__ == &quot;__main__&quot;:
    dog_bark()
    # &gt; Now use function 'warp_2'
    # &gt; Now the Unix time is 1541239747
    # &gt; Bark !!!
</code></pre>
<p>sample-3 https://gist.github.com/JackInTaiwan/15ebaa7abe6312ae12215bf56b6f2d5f</p>
<p>這裡會有一咪咪的複雜，大家要專心跟著 code 的順序看過一遍喔！</p>
<p><strong>decorators 多層的話是採 ”recursive” 的方式處理，如果一個 function 有兩個以上的 decorators ，邏輯上則會先合併「最靠近」的 decorator 吐出新的 function 再由上面一個的 decorator 吃進去！</strong></p>
<p>所以 <code>dog_bark()</code> 會先被 <code>@print_time</code> 吃進去，然後吐出一個叫做 <code>wrap_2</code> 的function，而這個 <code>warp_2</code> function 又會被 <code>@print_func_name</code> 吃進去，吐出一個叫做 <code>wrap_1</code> 的 function。</p>
<p>所以最後執行的結果順序是先 print <code>Now use function 'wrap_2'</code> 再 print <code>Now the Unix time is 1541239747</code> 。而且你會發現由於最外層的 <code>@print_func_name</code> 真正吃進去的 function 是已經被 <code>@print_time</code> 修飾過的 function，所以 print 的是<code>Now use function 'wrap_2'</code> 而不是 <code>Now use function 'dog_bark'</code> ！！</p>
<p>再來一個範例，檢驗大家是不是有跟上了～建議大家看完 code 先在心裡寫好答案再看結果。</p>
<p>下一段範例：</p>
<pre><code class="language-python">def print_func_name(func):
    def warp_1():
        print(&quot;Now use function '{}'&quot;.format(func.__name__))
        func()
    return warp_1


def print_time(func):
    import time
    def warp_2():
        print(&quot;Now the Unix time is {}&quot;.format(int(time.time())))
        func()
    return warp_2


@print_func_name
@print_time
def dog_bark():
    print(&quot;Bark !!!&quot;)


@print_time
@print_func_name
def cat_miaow():
    print(&quot;Miaow !!!&quot;)


if __name__ == &quot;__main__&quot;:
    dog_bark()
    # &gt; Now use function 'warp_2'
    # &gt; Now the Unix time is 1541239747
    # &gt; Bark !!!

    cat_miaow()
    # &gt; Now the Unix time is 1541239747
    # &gt; Now use function 'cat_miaow'
    # &gt; Miaow !!!
</code></pre>
<p>sample-4 https://gist.github.com/JackInTaiwan/41ded88d4c8c13c53c56f4455534e71b</p>
<p>和上一個範例（sample-3 ）相同，只是多了 <code>cat_miaow()</code> 而已。這次 <code>cat_miaow()</code> 上的 decorators 順序和 <code>dog_bark()</code> 的順序是相反的。</p>
<p>範例結果顯示，call <code>cat_miaow()</code> 會先 print <code>Now the Unix time is 1541239747</code> 再 print <code>Now use function'cat_miaow'</code> 最後才 print 主要 function 的 <code>Miaow !!!</code> 。</p>
<p>如果結果和你所想都完全符合，那恭喜你順利瞭解 decorator 的順序性問題惹！！！</p>
<h1 id="肆decorator-如何帶參數-"><a class="header" href="#肆decorator-如何帶參數-">【肆、Decorator 如何帶參數 ?】</a></h1>
<p>除了上面最簡單的用法之外，還可以在 decorator 處傳入參數，非常靈活好用！</p>
<p>請看以下範例：</p>
<pre><code class="language-python">import time



def print_func_name(time):
    def decorator(func):
        def wrap():
            print(&quot;Now use function '{}'&quot;.format(func.__name__))
            print(&quot;Now Unix time is {}.&quot;.format(int(time)))
            func()
        return wrap
    return decorator


@print_func_name(time=(time.time()))
def dog_bark():
    print(&quot;Bark !!!&quot;)



if __name__ == &quot;__main__&quot;:
    dog_bark()
    # &gt; Now use function 'dog_bark'
    # &gt; Now Unix time is 1639491313.
    # &gt; Bark !!!
</code></pre>
<p>sample-5 https://gist.github.com/JackInTaiwan/3fda507a8803d4d30a9a0f13df834f9c</p>
<p>從上面的範例可以知道要讓 decorator 傳入參數，只需要改成 <code>@print_func_name(param=param_variable)</code> 形式即可。此處可用 arguments 的形式也可以用 key arguments 的形式傳入參數。</p>
<p>值得注意的是，這種 decorator 帶參的寫法：function 內還有 function，且呈現 recursive 的對稱形式。這種形式就和 “Closure” 有關，之後的文章會詳細解說，這邊先不多加說明。第一層 <code>def print_func_name(time)</code> 是用來解析 decorator 傳入的參數的，第二層 <code>def decorator(func)</code> 是吃進主要要修飾的function，和前面的範例一樣。</p>
<p><strong>所以這個寫法的結論是：把原本的 code 外面多加一層用來傳入 decorator 的參數。</strong></p>
<h1 id="伍decorator-也可以是-class-"><a class="header" href="#伍decorator-也可以是-class-">【伍、Decorator 也可以是 Class !?】</a></h1>
<p>Decorator 除了有 function decorator ，也有 class decorator！畢竟 function 和 class 在 Python 裡頭都屬於 objects 呀！</p>
<p>再勞煩客倌看一回範例：</p>
<pre><code class="language-python">class Dog:
    def __init__(self, func):
        self.age = 10
        self.talent = func

    def bark(self):
        print(&quot;Bark !!!&quot;)

@Dog
def dog_can_pee():
    print(&quot;I can pee very hard......&quot;)



if __name__ == &quot;__main__&quot;:
    dog = dog_can_pee

    print(dog.age)
    # &gt; 10

    dog.bark()
    # &gt; Bark !!!

    dog.talent()
    # &gt; I can pee very hard......
</code></pre>
<p>sample-6 https://gist.github.com/JackInTaiwan/6f70279c19ed337a58c875f8f2f75cae</p>
<p>由上述範例可以得知，當我們的 decorator 是一個 class decorator 時，要傳入的 function 主體 <code>dog_can_pee</code> 就會從 class 裡頭的 <code>__init__</code> initializer 被吃進去，然後執行你想操作的動作：在這個例子裡，我將傳入的 function <code>dog_can_pee</code> 以 assign<code>self.talent</code> 的方式宣告為 class 的 instance method。</p>
<p><strong>這是一個非常重要、靈活而優雅的技巧，將 function</strong> <code>**dog_can_pee**</code> <strong>「封裝」到 class</strong> <code>**Dog**</code> <strong>的一種寫法。</strong></p>
<p>延續這個例子，再稍微完整一點的示範，為什麼這個寫法非常優雅：</p>
<pre><code class="language-python">class Dog:
    def __init__(self, func):
        self.talent = func

    def bark(self):
        print(&quot;Bark !!!&quot;)


@Dog
def dog_can_pee():
    print(&quot;I can pee very hard......&quot;)


@Dog
def dog_can_jump():
    print(&quot;I can jump uselessly QQQ&quot;)


@Dog
def dog_can_poo():
    print(&quot;I can poo like a super pooping machine!&quot;)



if __name__ == &quot;__main__&quot;:
    dog_1 = dog_can_pee
    dog_1.talent()
    # &gt; I can pee very hard......

    dog_2 = dog_can_jump
    dog_2.talent()
    # &gt; I can jump uselessly QQQ

    dog_3 = dog_can_poo
    dog_3.talent()
    # &gt; I can poo like a super pooping machine!
</code></pre>
<p>sample-7 https://gist.github.com/JackInTaiwan/4557776e4d04a398258d19b5bab4ef08</p>
<p>這個例子透過使用 class decorator 把不同的 function 封裝到這個原本的 class裡頭了。所以 <code>dog_1，</code> <code>dog_2</code> 和<code>dog_3</code> 這三隻狗明明都是 class <code>Dog</code> 會的才藝卻都不同！</p>
<p>達到同樣效果的寫法有很多種，其中一種是利用 class 繼承的方式達成，<strong>不過如果在此處使用 class 繼承可能會過於冗餘、臃種且擴充性低，用簡潔的 decorator 反而有簡單、重複率低且擴充高的優點！</strong></p>
<h1 id="結語-4"><a class="header" href="#結語-4">【結語】</a></h1>
<p>Decorator 被大量廣泛的使用在各方 library/package 中，具有幾個最主要的優點：</p>
<ul>
<li>靈活度高</li>
<li>易讀性高</li>
<li>協助封裝效果好</li>
<li>程式碼重複率低/簡潔度高</li>
</ul>
<p>有於篇幅有限，只能提供非常簡單的例子讓大家小酌一下，<strong>decorator 如果大家願意多花點時間結合各種寫法，相信大家一定會更能感受除了上面簡單的範例以外，它帶來的各種優點！</strong></p>
<p>另外， decorator 中會使用到 closure ，這是一個非常重要的概念，會在下一篇文章中解說，大家稍待一會兒！</p>
<h1 id="飯後餐點"><a class="header" href="#飯後餐點">【飯後餐點】</a></h1>
<p>最後附上一些延伸相關資料。</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%A0%AD%E7%AD%89%E5%87%BD%E6%95%B8">First-class function on Wiki</a></li>
<li><a href="https://foofish.net/python-decorator.html">理解 Python 裝飾器看這一篇就夠了</a></li>
</ul>
<p>如果你也喜歡我們的文章，幫我們動動手部肌肉，按下掌聲Clap，讓我們有動力繼續煮下一頓料理！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="理解-python-裝飾器看這一篇就夠了"><a class="header" href="#理解-python-裝飾器看這一篇就夠了">理解 Python 裝飾器看這一篇就夠了</a></h1>
<p>講 Python 裝飾器前，我想先舉個例子，雖有點汙，但跟裝飾器這個話題很貼切。</p>
<p>每個人都有的內褲主要功能是用來遮羞，但是到了冬天它沒法為我們防風禦寒，咋辦？我們想到的一個辦法就是把內褲改造一下，讓它變得更厚更長，這樣一來，它不僅有遮羞功能，還能提供保暖，不過有個問題，這個內褲被我們改造成了長褲後，雖然還有遮羞功能，但本質上它不再是一條真正的內褲了。於是聰明的人們發明長褲，在不影響內褲的前提下，直接把長褲套在了內褲外面，這樣內褲還是內褲，有了長褲後寶寶再也不冷了。裝飾器就像我們這裡說的長褲，在不影響內褲作用的前提下，給我們的身子提供了保暖的功效。</p>
<p>談裝飾器前，還要先要明白一件事，Python 中的函數和 Java、C++不太一樣，Python 中的函數可以像普通變量一樣當做參數傳遞給另外一個函數，例如：</p>
<pre><code class="language-python">def foo():
    print(&quot;foo&quot;)

def bar(func):
    func()

bar(foo)
</code></pre>
<p>正式回到我們的主題。裝飾器本質上是一個 Python 函數或類，它可以讓其他函數或類在不需要做任何代碼修改的前提下增加額外功能，裝飾器的返回值也是一個函數/類對象。它經常用於有切面需求的場景，比如：插入日誌、性能測試、事務處理、緩存、權限校驗等場景，裝飾器是解決這類問題的絕佳設計。有了裝飾器，我們就可以抽離出大量與函數功能本身無關的雷同代碼到裝飾器中並繼續重用。概括的講，裝飾器的作用就是為已經存在的對象添加額外的功能。</p>
<p>先來看一個簡單例子，雖然實際代碼可能比這復雜很多：</p>
<pre><code class="language-python">def foo():
    print('i am foo')
</code></pre>
<p>現在有一個新的需求，希望可以記錄下函數的執行日誌，於是在代碼中添加日誌代碼：</p>
<pre><code class="language-python">def foo():
    print('i am foo')
    logging.info(&quot;foo is running&quot;)
</code></pre>
<p>如果函數 bar()、bar2() 也有類似的需求，怎麼做？再寫一個 logging 在 bar 函數裡？這樣就造成大量雷同的代碼，為了減少重復寫代碼，我們可以這樣做，重新定義一個新的函數：專門處理日誌 ，日誌處理完之後再執行真正的業務代碼</p>
<pre><code class="language-python">def use_logging(func):
    logging.warn(&quot;%s is running&quot; % func.__name__)
    func()

def foo():
    print('i am foo')

use_logging(foo)
</code></pre>
<p>這樣做邏輯上是沒問題的，功能是實現了，但是我們調用的時候不再是調用真正的業務邏輯 foo 函數，而是換成了 use_logging 函數，這就破壞了原有的代碼結構， 現在我們不得不每次都要把原來的那個 foo 函數作為參數傳遞給 use_logging 函數，那麼有沒有更好的方式的呢？當然有，答案就是裝飾器。</p>
<h3 id="簡單裝飾器"><a class="header" href="#簡單裝飾器">簡單裝飾器</a></h3>
<pre><code class="language-python">def use_logging(func):

    def wrapper():
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func()   # 把 foo 當做參數傳遞進來時，執行func()就相當於執行foo()
    return wrapper

def foo():
    print('i am foo')

foo = use_logging(foo)  # 因為裝飾器 use_logging(foo) 返回的時函數對象 wrapper，這條語句相當於  foo = wrapper
foo()                   # 執行foo()就相當於執行 wrapper()
</code></pre>
<p>use_logging 就是一個裝飾器，它一個普通的函數，它把執行真正業務邏輯的函數 func 包裹在其中，看起來像 foo 被 use_logging 裝飾了一樣，use_logging 返回的也是一個函數，這個函數的名字叫 wrapper。在這個例子中，函數進入和退出時 ，被稱為一個橫切面，這種編程方式被稱為面向切面的編程。</p>
<h3 id="-語法糖"><a class="header" href="#-語法糖">@ 語法糖</a></h3>
<p>如果你接觸 Python 有一段時間了的話，想必你對 @ 符號一定不陌生了，沒錯 @ 符號就是裝飾器的語法糖，它放在函數開始定義的地方，這樣就可以省略最後一步再次賦值的操作。</p>
<pre><code class="language-python">def use_logging(func):

    def wrapper():
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func()
    return wrapper

@use_logging
def foo():
    print(&quot;i am foo&quot;)

foo()
</code></pre>
<p>如上所示，有了 @ ，我們就可以省去<code>foo = use_logging(foo)</code>這一句了，直接調用 foo() 即可得到想要的結果。你們看到了沒有，foo() 函數不需要做任何修改，只需在定義的地方加上裝飾器，調用的時候還是和以前一樣，如果我們有其他的類似函數，我們可以繼續調用裝飾器來修飾函數，而不用重復修改函數或者增加新的封裝。這樣，我們就提高了程序的可重復利用性，並增加了程序的可讀性。</p>
<p>裝飾器在 Python 使用如此方便都要歸因於 Python 的函數能像普通的對像一樣能作為參數傳遞給其他函數，可以被賦值給其他變量，可以作為返回值，可以被定義在另外一個函數內。</p>
<h3 id="argskwargs"><a class="header" href="#argskwargs">*args、**kwargs</a></h3>
<p>可能有人問，如果我的業務邏輯函數 foo 需要參數怎麼辦？比如：</p>
<pre><code class="language-python">def foo(name):
    print(&quot;i am %s&quot; % name)
</code></pre>
<p>我們可以在定義 wrapper 函數的時候指定參數：</p>
<pre><code class="language-python">def wrapper(name):
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func(name)
    return wrapper
</code></pre>
<p>這樣 foo 函數定義的參數就可以定義在 wrapper 函數中。這時，又有人要問了，如果 foo 函數接收兩個參數呢？三個參數呢？更有甚者，我可能傳很多個。當裝飾器不知道 foo 到底有多少個參數時，我們可以用 *args 來代替：</p>
<pre><code class="language-python">def wrapper(*args):
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func(*args)
    return wrapper
</code></pre>
<p>如此一來，甭管 foo 定義了多少個參數，我都可以完整地傳遞到 func 中去。這樣就不影響 foo 的業務邏輯了。這時還有讀者會問，如果 foo 函數還定義了一些關鍵字參數呢？比如：</p>
<pre><code class="language-python">def foo(name, age=None, height=None):
    print(&quot;I am %s, age %s, height %s&quot; % (name, age, height))
</code></pre>
<p>這時，你就可以把 wrapper 函數指定關鍵字函數：</p>
<pre><code class="language-python">def wrapper(*args, **kwargs):
        # args是一個數組，kwargs一個字典
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func(*args, **kwargs)
    return wrapper
</code></pre>
<h3 id="帶參數的裝飾器"><a class="header" href="#帶參數的裝飾器">帶參數的裝飾器</a></h3>
<p>裝飾器還有更大的靈活性，例如帶參數的裝飾器，在上面的裝飾器調用中，該裝飾器接收唯一的參數就是執行業務的函數 foo 。裝飾器的語法允許我們在調用時，提供其它參數，比如<code>@decorator(a)</code>。這樣，就為裝飾器的編寫和使用提供了更大的靈活性。比如，我們可以在裝飾器中指定日誌的等級，因為不同業務函數可能需要的日誌級別是不一樣的。</p>
<pre><code class="language-python">def use_logging(level):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if level == &quot;warn&quot;:
                logging.warn(&quot;%s is running&quot; % func.__name__)
            elif level == &quot;info&quot;:
                logging.info(&quot;%s is running&quot; % func.__name__)
            return func(*args)
        return wrapper

    return decorator

@use_logging(level=&quot;warn&quot;)
def foo(name='foo'):
    print(&quot;i am %s&quot; % name)

foo()
</code></pre>
<p>上面的 use_logging 是允許帶參數的裝飾器。它實際上是對原有裝飾器的一個函數封裝，並返回一個裝飾器。我們可以將它理解為一個含有參數的閉包。當我 們使用<code>@use_logging(level=&quot;warn&quot;)</code>調用的時候，Python 能夠發現這一層的封裝，並把參數傳遞到裝飾器的環境中。</p>
<pre><code class="language-python">@use_logging(level=&quot;warn&quot;)`等價於`@decorator
</code></pre>
<h3 id="類裝飾器"><a class="header" href="#類裝飾器">類裝飾器</a></h3>
<p>沒錯，裝飾器不僅可以是函數，還可以是類，相比函數裝飾器，類裝飾器具有靈活度大、高內聚、封裝性等優點。使用類裝飾器主要依靠類的<code>__call__</code>方法，當使用 @ 形式將裝飾器附加到函數上時，就會調用此方法。</p>
<pre><code class="language-python">class Foo(object):
    def __init__(self, func):
        self._func = func

    def __call__(self):
        print ('class decorator runing')
        self._func()
        print ('class decorator ending')

@Foo
def bar():
    print ('bar')

bar()
</code></pre>
<h3 id="functoolswraps"><a class="header" href="#functoolswraps">functools.wraps</a></h3>
<p>使用裝飾器極大地復用了代碼，但是他有一個缺點就是原函數的元信息不見了，比如函數的<code>docstring</code>、<code>__name__</code>、參數列表，先看例子：</p>
<pre><code class="language-python"># 裝飾器
def logged(func):
    def with_logging(*args, **kwargs):
        print func.__name__      # 輸出 'with_logging'
        print func.__doc__       # 輸出 None
        return func(*args, **kwargs)
    return with_logging

# 函數
@logged
def f(x):
   &quot;&quot;&quot;does some math&quot;&quot;&quot;
   return x + x * x

logged(f)
</code></pre>
<p>不難發現，函數 f 被<code>with_logging</code>取代了，當然它的<code>docstring</code>，<code>__name__</code>就是變成了<code>with_logging</code>函數的信息了。好在我們有<code>functools.wraps</code>，<code>wraps</code>本身也是一個裝飾器，它能把原函數的元信息拷貝到裝飾器裡面的 func 函數中，這使得裝飾器裡面的 func 函數也有和原函數 foo 一樣的元信息了。</p>
<pre><code class="language-python">from functools import wraps
def logged(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print func.__name__      # 輸出 'f'
        print func.__doc__       # 輸出 'does some math'
        return func(*args, **kwargs)
    return with_logging

@logged
def f(x):
   &quot;&quot;&quot;does some math&quot;&quot;&quot;
   return x + x * x
</code></pre>
<h3 id="裝飾器順序"><a class="header" href="#裝飾器順序">裝飾器順序</a></h3>
<p>一個函數還可以同時定義多個裝飾器，比如：</p>
<pre><code class="language-python">@a
@b
@c
def f ():
    pass
</code></pre>
<p>它的執行順序是從裡到外，最先調用最裡層的裝飾器，最後調用最外層的裝飾器，它等效於</p>
<pre><code class="language-python">f = a(b(c(f)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-import-概念"><a class="header" href="#python-import-概念">[Python] import 概念</a></h1>
<h1 id="基礎介紹"><a class="header" href="#基礎介紹">基礎介紹</a></h1>
<ul>
<li>package (套件/包) : 資料夾，含有 <code>__init__.py</code></li>
<li>module (模塊) : 檔案</li>
<li>import 的方式有兩種 : 絕對路徑 / 相對路徑</li>
<li>sys.modules : 是個 dictionary，用於存放已經 import 過的 modules</li>
<li>sys.path : 是個 list，用於搜尋 import module 的各種路徑</li>
</ul>
<h1 id="import-流程"><a class="header" href="#import-流程">import 流程</a></h1>
<p>雖然 import 的<strong>方式</strong>有兩種 : 絕對路徑 / 相對路徑
但是 import 的<strong>流程</strong>是相同的</p>
<pre><code>import xxxModule
</code></pre>
<ol>
<li>檢查 <code>xxxModule</code> 是否存在於 <code>sys.modules</code></li>
<li>若存在，則直接從 <code>sys.modules</code> 取出使用即可</li>
<li>若不存在，則依據 import 的<strong>方式</strong>來搜尋 <code>xxxModule.py</code> 的檔案位置</li>
<li>接著生成 <code>xxxModule</code></li>
<li>再來放入 <code>sys.modules</code></li>
<li>最後執行 <code>xxxModule.py</code> 裡面的 source code (以剛生成的 <code>xxxModule</code> 作為 scope 來執行)</li>
</ol>
<h1 id="syntax-比較"><a class="header" href="#syntax-比較">syntax 比較</a></h1>
<pre><code class="language-python"># 絕對路徑
import xxxModule
from xxxModule import xxxMethod

# 相對路徑
from . import xxxModule # 同一層目錄
from .. import xxxModule # 上一層目錄
from ... import xxxModule # 上上層目錄
from .xxxModule import xxxMethod

# 錯誤寫法
import .xxxModule # . 只能出現在 from 後面 
</code></pre>
<h1 id="絕對路徑"><a class="header" href="#絕對路徑">絕對路徑</a></h1>
<p>有了以上的概念後，接著我們利用範例來實際操作下 (<a href="https://github.com/hochun836/python_absolute_import">範例下載</a>)
為求簡單，這邊 import 的方式都先使用絕對路徑</p>
<ul>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E5%9F%BA%E7%A4%8E%E7%B7%B4%E7%BF%92-1">基礎練習 1</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E5%9F%BA%E7%A4%8E%E7%B7%B4%E7%BF%92-2">基礎練習 2</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E5%9F%BA%E7%A4%8E%E7%B7%B4%E7%BF%92-3">基礎練習 3</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E5%9F%BA%E7%A4%8E%E7%B7%B4%E7%BF%92-4">基礎練習 4</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E5%9F%BA%E7%A4%8E%E7%B7%B4%E7%BF%92-5">基礎練習 5</a></li>
</ul>
<h2 id="基礎練習-1"><a class="header" href="#基礎練習-1">基礎練習 1</a></h2>
<p>執行 <code>D:\hochun\example\python_absolute_import&gt;python app1.py</code></p>
<pre><code class="language-python"># 檔案結構
python_absolute_import
│  app1.py
│
└─packageA
  │  moduleA.py
  │  __init__.py
  │
  └─packageB
      │  moduleB.py
      └─  __init__.py
</code></pre>
<pre><code class="language-python"># packageA/__init__.py
print('&amp; packageA')

# packageA/moduleA.py
print('&amp; moduleA')

# packageA/packageB/__init__.py
print('&amp; packageB')

# packageA/packageB/moduleB.py
print('&amp; moduleB')
</code></pre>
<pre><code class="language-python"># app1.py
import sys
for idx, path in enumerate(sys.path):
    print(f'sys.path[{idx}]: {path}')

print('========== phase1 ==========')
print('&quot;packageA&quot; in sys.modules:', 'packageA' in sys.modules)
print('&quot;packageA.moduleA&quot; in sys.modules:', 'packageA.moduleA' in sys.modules)
print('&quot;packageA.packageB&quot; in sys.modules:', 'packageA.packageB' in sys.modules)
print('&quot;packageA.packageB.moduleB&quot; in sys.modules:', 'packageA.packageB.moduleB' in sys.modules)

print('========== phase2 ==========')
from packageA.packageB import moduleB
print('&quot;packageA&quot; in sys.modules:', 'packageA' in sys.modules)
print('&quot;packageA.moduleA&quot; in sys.modules:', 'packageA.moduleA' in sys.modules)
print('&quot;packageA.packageB&quot; in sys.modules:', 'packageA.packageB' in sys.modules)
print('&quot;packageA.packageB.moduleB&quot; in sys.modules:', 'packageA.packageB.moduleB' in sys.modules)

print('========== phase3 ==========')
from packageA import moduleA
print('&quot;packageA&quot; in sys.modules:', 'packageA' in sys.modules)
print('&quot;packageA.moduleA&quot; in sys.modules:', 'packageA.moduleA' in sys.modules)
print('&quot;packageA.packageB&quot; in sys.modules:', 'packageA.packageB' in sys.modules)
print('&quot;packageA.packageB.moduleB&quot; in sys.modules:', 'packageA.packageB.moduleB' in sys.modules)

print('========== phase4 ==========')
import packageA
print('packageA:', packageA)
</code></pre>
<p>輸出</p>
<pre><code class="language-sh">&amp; app1.py
sys.path[0]: D:\hochun\example\python_absolute_import #sys.path[0] 是當前路徑
sys.path[1]: C:\ProgramData\Anaconda3\python38.zip
sys.path[2]: C:\ProgramData\Anaconda3\DLLs
sys.path[3]: C:\ProgramData\Anaconda3\lib
sys.path[4]: C:\ProgramData\Anaconda3
sys.path[5]: C:\ProgramData\Anaconda3\lib\site-packages
sys.path[6]: C:\ProgramData\Anaconda3\lib\site-packages\win32
sys.path[7]: C:\ProgramData\Anaconda3\lib\site-packages\win32\lib
sys.path[8]: C:\ProgramData\Anaconda3\lib\site-packages\Pythonwin
========== phase1 ==========
&quot;packageA&quot; in sys.modules: False
&quot;packageA.moduleA&quot; in sys.modules: False
&quot;packageA.packageB&quot; in sys.modules: False
&quot;packageA.packageB.moduleB&quot; in sys.modules: False
========== phase2 ==========
&amp; packageA # from packageA.packageB import moduleB 先執行 packageA.py
&amp; packageB # from packageA.packageB import moduleB 再執行 packageB.py
&amp; moduleB # from packageA.packageB import moduleB 最後執行 moduleB.py
&quot;packageA&quot; in sys.modules: True # False 改變為 True
&quot;packageA.moduleA&quot; in sys.modules: False
&quot;packageA.packageB&quot; in sys.modules: True # False 改變為 True
&quot;packageA.packageB.moduleB&quot; in sys.modules: True # False 改變為 True
========== phase3 ==========
&amp; moduleA # 由於 sys.modules 已經有了 packageA，所以不會再執行 packageA.py
&quot;packageA&quot; in sys.modules: True
&quot;packageA.moduleA&quot; in sys.modules: True # False 改變為 True
&quot;packageA.packageB&quot; in sys.modules: True
&quot;packageA.packageB.moduleB&quot; in sys.modules: True
========== phase4 ==========
packageA: &lt;module 'packageA' from 'D:\hochun\example\python_absolute_import\packageA\__init__.py'&gt;
</code></pre>
<p>說明</p>
<ul>
<li>
<pre><code class="language-plaintext">from packageA.packageB import moduleB
</code></pre>
<ol>
<li>檢查 <code>packageA</code> / <code>packageB</code> / <code>moduleB</code> 是否存在於 <code>sys.modules</code></li>
<li>發現沒有，所以依據 import 的方式來搜尋 <code>packageA.py</code> / <code>packageB.py</code> / <code>moduleB.py</code> 的檔案位置</li>
<li>此處用的是絕對路徑，所以會利用 <code>sys.path</code> 來尋找檔案位置</li>
<li>有看到 <code>sys.path[0]</code> 就是根目錄嗎 ? 就是因為這個路徑，才找的到 <code>packageA.py</code> / <code>packageB.py</code> / <code>moduleB.py</code></li>
<li>如果在 <code>sys.path</code> 中都找不到的話，就會出現 <code>ModuleNotFoundError</code></li>
</ol>
</li>
<li>
<pre><code class="language-plaintext">from packageA import moduleA
</code></pre>
<ol>
<li>由於 <code>packageA</code> 已存在於 <code>sys.modules</code>，所以不會執行 <code>packageA.py</code></li>
<li>但是 <code>moduleA</code> 還不存在於 <code>sys.modules</code>，所以會依據 import 的方式來搜尋 <code>moduleA.py</code> 的檔案位置</li>
<li>此處用的是絕對路徑，所以會利用 <code>sys.path</code> 來尋找檔案位置</li>
</ol>
</li>
<li>
<pre><code class="language-plaintext">import packageA
</code></pre>
<ol>
<li>經過上面的說明，很清楚知道 import 同樣的 package or module，只要 <code>sys.modules</code> 中還存在，就不會執行第二次</li>
</ol>
</li>
<li>
<pre><code class="language-plaintext">print(packageA)
</code></pre>
<ol>
<li>有注意到嗎 ? 輸出的結果是一個名叫 <code>packageA</code> 的 <code>module</code> from <code>__init__.py</code></li>
</ol>
</li>
</ul>
<h2 id="基礎練習-2"><a class="header" href="#基礎練習-2">基礎練習 2</a></h2>
<p>執行 <code>D:\hochun\example\python_absolute_import&gt;python app2.py</code></p>
<pre><code class="language-python"># app2.py
print('&amp; app2.py')

print('dir():', dir())

import sys
print('dir():', dir())

a = 101
print('a be loaded')

b = 102
print('b be loaded')

c = 103
print('c be loaded')

print('dir():', dir())
</code></pre>
<p>輸出</p>
<pre><code class="language-python">&amp; app2.py
dir(): ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
dir(): ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'sys'] # 增加 'sys'
a be loaded
b be loaded
c be loaded
dir(): ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b', 'c', 'sys'] # 增加 'a', 'b', 'c'
</code></pre>
<p>觀察</p>
<ol>
<li>import 之後，或是宣告一個變數之後，我們可以在 <code>dir()</code> 中看到增加的名稱</li>
</ol>
<h2 id="基礎練習-3"><a class="header" href="#基礎練習-3">基礎練習 3</a></h2>
<p>執行 <code>D:\hochun\example\python_absolute_import&gt;python app3_1.py</code></p>
<pre><code class="language-python"># 檔案結構
python_absolute_import
│  app3_1.py
└─ app3_2.py
</code></pre>
<pre><code class="language-python"># app3_1.py
print('&amp; app3_1.py')

import sys

import app3_2

print('sys == app3_2.sys:', sys == app3_2.sys)
</code></pre>
<pre><code class="language-python"># app3_2.py
print('&amp; app3_2.py')

import sys
</code></pre>
<p>輸出</p>
<pre><code class="language-python">&amp; app3_1.py
&amp; app3_2.py
sys == app3_2.sys: True # 兩者的 sys 是相同的
</code></pre>
<p>觀察</p>
<ol>
<li>不論在哪隻 module 中， <code>import sys</code> 後的 <code>sys</code> 是指向相同的記憶體位置</li>
<li>所以，不論在哪隻 module 中，我們常用的 <code>sys.modules</code> / <code>sys.path</code> 也都會指向相同的記憶體位置</li>
</ol>
<h2 id="基礎練習-4"><a class="header" href="#基礎練習-4">基礎練習 4</a></h2>
<p>執行 <code>D:\hochun\example\python_absolute_import&gt;python app4_1.py</code></p>
<pre><code class="language-python"># 檔案結構
python_absolute_import
│  app4_1.py
└─ app4_2.py
</code></pre>
<pre><code class="language-python"># app4_1.py
print('&amp; app4_1.py')

import sys

print('[in app4_1.py] &quot;app4_1&quot; in sys.modules:', 'app4_1' in sys.modules)
print('[in app4_1.py] &quot;app4_2&quot; in sys.modules:', 'app4_2' in sys.modules)

import app4_2

print('[in app4_1.py] &quot;app4_1&quot; in sys.modules:', 'app4_1' in sys.modules)
print('[in app4_1.py] &quot;app4_2&quot; in sys.modules:', 'app4_2' in sys.modules)
</code></pre>
<pre><code class="language-python"># app4_2.py
print('&amp; app4_2.py')

import sys

print('[in app4_2.py] &quot;app4_1&quot; in sys.modules:', 'app4_1' in sys.modules)
print('[in app4_2.py] &quot;app4_2&quot; in sys.modules:', 'app4_2' in sys.modules)
</code></pre>
<p>輸出</p>
<pre><code class="language-python">&amp; app4_1.py
[in app4_1.py] &quot;app4_1&quot; in sys.modules: False # 一開始都是 False
[in app4_1.py] &quot;app4_2&quot; in sys.modules: False # 一開始都是 False
&amp; app4_2.py
[in app4_2.py] &quot;app4_1&quot; in sys.modules: False
[in app4_2.py] &quot;app4_2&quot; in sys.modules: True # False 變成 True，因為 import app4_2
[in app4_1.py] &quot;app4_1&quot; in sys.modules: False
[in app4_1.py] &quot;app4_2&quot; in sys.modules: True
</code></pre>
<p>觀察</p>
<ol>
<li><code>app4_1.py</code> 依賴於 <code>app4_2.py</code></li>
<li>想想看如果情況變成兩隻 module 互相依賴，那該怎麼辦 ? (別擔心，待下面範例解釋)</li>
</ol>
<h2 id="基礎練習-5"><a class="header" href="#基礎練習-5">基礎練習 5</a></h2>
<p>執行 <code>D:\hochun\example\python_absolute_import&gt;python app5_1.py</code></p>
<pre><code class="language-python"># 檔案結構
python_absolute_import
│  app5_1.py
└─ app5_2.py
</code></pre>
<pre><code class="language-python"># app5_1.py
print('&amp; app5_1.py')

firstName = 'peter'

print('[in app5_1.py] before import app5_2.py')

# (A)
import app5_2

# (B)
# import app5_2
# print('[in app5_1.py] name:', firstName, app5_2.lastName)

# (C)
# from app5_2 import lastName
# print('[in app5_1.py] name:', firstName, lastName)
</code></pre>
<pre><code class="language-python"># app5_2.py
print('&amp; app5_2.py')

print('[in app5_2.py] before import app5_1.py')

import app5_1

lastName = 'kang'

print('[in app5_2.py] after import app5_1.py')
</code></pre>
<p>輸出</p>
<pre><code class="language-python"># (A)
&amp; app5_1.py
[in app5_1.py] before import app5_2.py
&amp; app5_2.py
[in app5_2.py] before import app5_1.py
&amp; app5_1.py
[in app5_1.py] before import app5_2.py
[in app5_2.py] after import app5_1.py
[in app5_2.py] name: peter kang
</code></pre>
<pre><code class="language-python"># (B)
&amp; app5_1.py
[in app5_1.py] before import app5_2.py
&amp; app5_2.py
[in app5_2.py] before import app5_1.py
&amp; app5_1.py
[in app5_1.py] before import app5_2.py # 在這之前都與 (A) 一致
Traceback (most recent call last):
  File &quot;app5_1.py&quot;, line 14, in &lt;module&gt;
    import app5_2
  File &quot;D:\hochun\example\python_absolute_import\app5_2.py&quot;, line 5, in &lt;module&gt;
    import app5_1
  File &quot;D:\hochun\example\python_absolute_import\app5_1.py&quot;, line 15, in &lt;module&gt;
    print('[in app5_1.py] name:', firstName, app5_2.lastName)
AttributeError: partially initialized module 'app5_2' has no attribute 'lastName'
(most likely due to a circular import)
</code></pre>
<pre><code class="language-python"># (C)
&amp; app5_1.py
[in app5_1.py] before import app5_2.py
&amp; app5_2.py
[in app5_2.py] before import app5_1.py
&amp; app5_1.py
[in app5_1.py] before import app5_2.py # 在這之前都與 (A) 一致
Traceback (most recent call last):
  File &quot;app5_1.py&quot;, line 18, in &lt;module&gt;
    from app5_2 import lastName
  File &quot;D:\hochun\example\python_absolute_import\app5_2.py&quot;, line 5, in &lt;module&gt;
    import app5_1
  File &quot;D:\hochun\example\python_absolute_import\app5_1.py&quot;, line 18, in &lt;module&gt;
    from app5_2 import lastName
ImportError: cannot import name 'lastName' from partially initialized module 'app5_2' (most likely due to a circular import) (D:\hochun\example\python_absolute_import\app5_2.py)
</code></pre>
<p>觀察</p>
<ol>
<li><code>app5_1.py</code> / <code>app5_2.py</code> 互相依賴</li>
<li>依據 <code>app5_1.py</code> 不同的寫法 (A) / (B) / (C)，輸出結果也不同</li>
<li>(A) 不會報錯</li>
<li>(B) 報錯 <code>AttributeError</code>，因為在 <code>app5_2.py</code> 中， <code>lastName = 'kang'</code> 寫在 <code>import app5_1</code> 之後</li>
<li>(C) 報錯 <code>ImportError</code>，同理 (B)</li>
<li>那如果將 <code>app5_2.py</code> 中的 <code>lastName = 'kang'</code> 寫在 <code>import app5_1</code> 之前，是不是就不會報錯了呢 ? (留給大家 try 看看)</li>
</ol>
<h1 id="相對路徑"><a class="header" href="#相對路徑">相對路徑</a></h1>
<p>複習下，在<a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#import-%E6%B5%81%E7%A8%8B">import 流程</a>中有提到，雖然 import 的<strong>方式</strong>有兩種，但是 import 的<strong>流程</strong>是相同的
前面學習完了 import 的流程與 import 方式之一的<strong>絕對路徑</strong>
接下來，讓我們把<strong>相對路徑</strong>也一併搞定吧 ! (<a href="https://github.com/hochun836/python_relative_import">範例下載</a>)</p>
<ul>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E9%80%B2%E9%9A%8E%E7%B7%B4%E7%BF%92-1">進階練習 1</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E9%80%B2%E9%9A%8E%E7%B7%B4%E7%BF%92-2-1">進階練習 2-1</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E9%80%B2%E9%9A%8E%E7%B7%B4%E7%BF%92-2-2">進階練習 2-2</a></li>
<li><a href="https://blog.hochun836.com/2020/10/03/python/import-concept.html#%E9%80%B2%E9%9A%8E%E7%B7%B4%E7%BF%92-3">進階練習 3</a></li>
</ul>
<pre><code class="language-python"># 檔案結構
python_relative_import
│
├─level1
│  │  __init__.py
│  │
│  ├─level2
│  │  │  app1.py
│  │  │  app2.py
│  │  │  __init__.py
│  │  │
│  │  ├─level3
│  │  │      app3.py
│  │  │      __init__.py
│  │  │
│  │  └─utils
│  │          tool.py
│  │          __init__.py
│  │
│  └─utils
│          tool.py
│          __init__.py
│
└─utils
        tool.py
        __init__.py
</code></pre>
<pre><code class="language-python"># utils/__init__.py
print('&amp; [utils] __init__.py')

# utils/tool.py
print('&amp; [utils] tool.py')
name = 'chen'

# level1/__init__.py
print('&amp; [level1] __init__.py')

# level1/utils/__init__.py
print('&amp; [level1/utils] __init__.py')

# level1/utils/tool.py
print('&amp; [level1/utils] tool.py')
name = 'bob'

# level1/level2/__init__.py
print('&amp; [level1/level2] __init__.py')

# level1/level2/utils/__init__.py
print('&amp; [level1/level2/utils] __init__.py')

# level1/level2/utils/tool.py
print('&amp; [level1/level2/utils] tool.py')
name = 'peter'

# level1/level2/level3/__init__.py
print('&amp; [level1/level2/level3] __init__.py')
</code></pre>
<h2 id="進階練習-1"><a class="header" href="#進階練習-1">進階練習 1</a></h2>
<p>執行 <code>D:\hochun\example\python_relative_import\level1\level2&gt;python app1.py</code></p>
<pre><code class="language-python"># app1.py
print('&amp; [level1/level2] app1.py')

print('__name__:', __name__)
print('__package__:', __package__)

import sys
sys.path.append('../..') # 增加新的 path
sys.path = sys.path[1:] # 刪除 sys.path[0]

from utils.tool import name
print(name)
</code></pre>
<p>輸出</p>
<pre><code class="language-python">&amp; [level1/level2] app1.py
__name__: __main__
__package__: None
&amp; [utils] __init__.py
&amp; [utils] tool.py
chen # in utils/tool.py
</code></pre>
<p>觀察</p>
<ol>
<li>當下路徑為 <code>D:\hochun\example\python_relative_import\level1\level2</code></li>
<li><code>sys.path.append('../..')</code>，增加<strong>上上層路徑</strong>到 <code>sys.path</code></li>
<li><code>sys.path = sys.path[1:]</code>，刪除 <code>sys.path[0]</code> <strong>(當層路徑)</strong></li>
</ol>
<p>坑</p>
<ol>
<li>這個範例其實還是<strong>絕對路徑</strong>，所以尋找 module 會利用 <code>sys.path</code></li>
<li>若改為執行 <code>D:\hochun\example\python_relative_import&gt;python level1/level2/app1.py</code>，則會報錯 <code>ModuleNotFoundError: No module named 'utils'</code>，因為我們修改了 <code>sys.path</code>，進而造成在 <code>sys.path</code> 中找不到 module <code>utils</code>，所以才會報錯</li>
</ol>
<h2 id="進階練習-2-1"><a class="header" href="#進階練習-2-1">進階練習 2-1</a></h2>
<p>執行 <code>D:\hochun\example\python_relative_import\level1\level2&gt;python app2.py</code></p>
<pre><code class="language-python"># app2.py
print('&amp; [level1/level2] app2.py')

import sys

print('__name__:', __name__)
print('__package__:', __package__)

from ..utils import tool # 相對路徑
</code></pre>
<p>輸出</p>
<pre><code class="language-python">&amp; [level1/level2] app2.py
__name__: __main__ # 關鍵
__package__: None # 關鍵
Traceback (most recent call last):
  File &quot;app2.py&quot;, line 8, in &lt;module&gt;
    from ..utils import tool
ImportError: attempted relative import with no known parent package
</code></pre>
<p>觀察</p>
<ol>
<li>當下路徑為 <code>D:\hochun\example\python_relative_import\level1\level2</code></li>
<li><code>__name__</code> 為 <code>__main__</code></li>
<li><code>__package__</code> 為 <code>None</code></li>
<li><code>from ..utils import tool</code> 為 import 方式的<strong>相對路徑</strong></li>
</ol>
<p>坑</p>
<ol>
<li>若 import 方式為<strong>相對路徑</strong>，則利用的不是 <code>sys.path</code>，而是 <code>__name__</code> / <code>__package__</code></li>
<li>因為 <code>__package__</code> 為 <code>None</code>，這被視為<strong>最上層路徑</strong>，所以無法再用 <code>from ..utils import tool</code>，即便改成 <code>from .utils import tool</code> 也一樣會報錯</li>
<li>換句話說，若 module 中有寫到相對路徑，則不能直接下 <code>python</code> 指令去 run 該程式，除非使用 <code>python -m</code> (如下)</li>
</ol>
<h2 id="進階練習-2-2"><a class="header" href="#進階練習-2-2">進階練習 2-2</a></h2>
<p>執行 <code>D:\hochun\example\python_relative_import&gt;python -m level1.level2.app2</code></p>
<p>輸出</p>
<pre><code class="language-python">&amp; [level1] __init__.py
&amp; [level1/level2] __init__.py
&amp; [level1/level2] app2.py
__name__: __main__
__package__: level1.level2 # 關鍵，不是 None 了
&amp; [level1/utils] __init__.py
&amp; [level1/utils] tool.py
</code></pre>
<p>觀察</p>
<ol>
<li>當下路徑為 <code>D:\hochun\example\python_relative_import</code></li>
<li><code>python -m</code> 後面跟的是 <code>level1.level2.app2</code> 而非 <code>level1/level2/app2.py</code></li>
<li><code>__package__</code> 為 <code>level1.level2</code>，因為如此 import 方式的<strong>相對路徑</strong>才能做到<strong>相對</strong>的作用</li>
</ol>
<p>經由上述解釋後，現在的你應該能說出以下兩者的差異吧 !</p>
<ol>
<li><code>D:\hochun\example\python_relative_import&gt;python -m level1.level2.app2</code></li>
<li><code>D:\hochun\example\python_relative_import&gt;python level1/level2/app2.py</code></li>
</ol>
<h2 id="進階練習-3"><a class="header" href="#進階練習-3">進階練習 3</a></h2>
<pre><code class="language-python"># app3.py
print('&amp; [level1/level2/level3] app3.py')

import sys

print('__name__:', __name__)
print('__package__:', __package__)

from ...utils.tool import name

print(name)
</code></pre>
<p>最後這個練習就讓大家動手玩玩看囉</p>
<h1 id="參考文章"><a class="header" href="#參考文章">參考文章</a></h1>
<ol>
<li><a href="https://medium.com/pyladies-taiwan/python-%E7%9A%84-import-%E9%99%B7%E9%98%B1-3538e74f57e3">Python 的 Import 陷阱</a></li>
<li><a href="https://carsonwah.github.io/15213187969322.html">理解Python的 relative 和 absolute import</a></li>
</ol>
<h1 id="python-import導入上級目錄文件"><a class="header" href="#python-import導入上級目錄文件">Python-import導入上級目錄文件</a></h1>
<p>假設有如下目錄結構：</p>
<pre><code class="language-text">-- dir0
　　| file1.py
　　| file2.py
　　| dir3
　　　| file3.py
　　| dir4
　　　| file4.py
</code></pre>
<p>dir0文件夾下有file1.py、file2.py兩個文件和dir3、dir4兩個子文件夾，dir3中有file3.py文件，dir4中有file4.py文件。</p>
<h2 id="1導入同級模塊"><a class="header" href="#1導入同級模塊">1.導入同級模塊</a></h2>
<p>python導入同級模塊（在同一個文件夾中的py文件）直接導入即可。</p>
<pre><code class="language-python">import xxx
</code></pre>
<p>如在file1.py中想導入file2.py，注意無需加後綴&quot;.py&quot;：</p>
<pre><code class="language-python">import file2
# 使用file2中函數時需加上前綴&quot;file2.&quot;，即：
# file2.fuction_name()
</code></pre>
<h2 id="2導入下級模塊"><a class="header" href="#2導入下級模塊">2.導入下級模塊</a></h2>
<p>導入下級目錄模塊也很容易，需在下級目錄中新建一個空白的__init__.py文件再導入：</p>
<pre><code class="language-python">from dirname import xxx
</code></pre>
<p>如在file1.py中想導入dir3下的file3.py，首先要在dir3中新建一個空白的__init*__*.py文件。</p>
<pre><code class="language-text">-- dir0
　　| file1.py
　　| file2.py
　　| dir3
　　　| __init__.py
　　　| file3.py
　　| dir4
　　　| file4.py
</code></pre>
<p>再使用如下語句：</p>
<pre><code class="language-python"># plan A
from dir3 import file3
</code></pre>
<p>或是</p>
<pre><code class="language-python"># plan B
import dir3.file3
# import dir3.file3 as df3
</code></pre>
<p>但使用第二種方式則下文需要一直帶著路徑dir3書寫，較為累贅，建議可以另起一個別名。</p>
<h2 id="3導入上級模塊"><a class="header" href="#3導入上級模塊">3.導入上級模塊</a></h2>
<p>要導入上級目錄下模塊，可以使用sys.path： 　</p>
<pre><code class="language-python">import sys 
sys.path.append(&quot;..&quot;) 
import xxx
</code></pre>
<p>如在file4.py中想引入import上級目錄下的file1.py：</p>
<pre><code class="language-python">import sys 
sys.path.append(&quot;..&quot;) 
import file1
</code></pre>
<p>**sys.path的作用：**當使用import語句導入模塊時，解釋器會搜索當前模塊所在目錄以及sys.path指定的路徑去找需要import的模塊，所以這裡是直接把上級目錄加到了sys.path裡。</p>
<p>**“..”的含義：**等同於linux裡的‘..’，表示當前工作目錄的上級目錄。實際上python中的‘.’也和linux中一致，表示當前目錄。</p>
<h2 id="4導入隔壁文件夾下的模塊"><a class="header" href="#4導入隔壁文件夾下的模塊">4.導入隔壁文件夾下的模塊</a></h2>
<p>如在file4.py中想引入import在dir3目錄下的file3.py。</p>
<p>這其實是前面兩個操作的組合，其思路本質上是將上級目錄加到sys.path裡，再按照對下級目錄模塊的方式導入。</p>
<p>同樣需要被引文件夾也就是dir3下有空的__init__.py文件。</p>
<pre><code class="language-text">-- dir
　　| file1.py
　　| file2.py
　　| dir3
　　　| __init__.py
　　　| file3.py
　　| dir4
　　　| file4.py
</code></pre>
<p>同時也要將上級目錄加到sys.path裡：</p>
<pre><code class="language-python">import sys
sys.path.append(&quot;..&quot;)
from dir3 import file3
</code></pre>
<h2 id="5常見錯誤及import原理"><a class="header" href="#5常見錯誤及import原理">5.常見錯誤及import原理：</a></h2>
<p>在使用直接從上級目錄引入模塊的操作時：</p>
<pre><code class="language-python">from .. import xxx
</code></pre>
<p>經常會報錯:</p>
<pre><code class="language-python3">ValueError: attempted relative import beyond top-level package
</code></pre>
<p>這是由於相對導入時，文件夾實質上充當的是package，也就是包的角色（比如我們常用的numpy、pandas都是包）。如果python解釋器沒有認同該文件夾是package，那麼這就是一個普通的文件夾，無法實現相對導入。</p>
<p>文件夾作為package需要滿足如下兩個條件：</p>
<ol>
<li>文件夾中必須存在有__init__.py文件，可以為空。</li>
<li>不能作為頂層模塊來執行該文件夾中的py文件。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="multi-processing-和multi-threading-的優缺點"><a class="header" href="#multi-processing-和multi-threading-的優缺點">Multi-processing 和Multi-threading 的優缺點：</a></h2>
<ul>
<li>Multi-processing (多處理程序/多進程)：
<ol>
<li>資料在彼此間傳遞變得更加複雜及花時間，因為一個 process 在作業系統的管理下是無法去存取別的 process 的 memory</li>
<li>適合需要 CPU 密集，像是迴圈計算</li>
</ol>
</li>
<li>Multi-threading (多執行緒/多線程)：
<ol>
<li>資料彼此傳遞簡單，因為多執行緒的 memory 之間是共用的，但也因此要避免會有 Race Condition 問題</li>
<li>適合需要 I/O 密集，像是爬蟲需要時間等待 request 回覆</li>
</ol>
</li>
</ul>
<pre><code class="language-python">import threading, logging, time
import multiprocessing


class Producer(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.stop_event = threading.Event()

    def stop(self):
        self.stop_event.set()

    def run(self):
        while not self.stop_event.is_set():
            print(&quot;Producer is working...&quot;)
            time.sleep(1)


class Consumer(multiprocessing.Process):
    def __init__(self):
        multiprocessing.Process.__init__(self)
        self.stop_event = multiprocessing.Event()

    def stop(self):
        self.stop_event.set()

    def run(self):
        while not self.stop_event.is_set():
            print(&quot;Consumer is working...&quot;)
            time.sleep(1)


def main():
    tasks = [Producer(), Consumer()]

    for t in tasks:
        t.start()

    time.sleep(3600)

    for task in tasks:
        task.stop()

    for task in tasks:
        task.join()


if __name__ == &quot;__main__&quot;:
    logging.basicConfig(
        format=&quot;%(asctime)s.%(msecs)s:%(name)s:%(thread)d:%(levelname)s:%(process)d:%(message)s&quot;,
        level=logging.INFO,
    )
    main()

</code></pre>
<hr />
<h1 id="前言-4"><a class="header" href="#前言-4">前言</a></h1>
<p>出處: https://www.wongwonggoods.com/python/python-multiprocessing/</p>
<p>在 python 中有 thread 與 multiprocess 兩種平行處理程式的方式，
若只是單純的平行需求，我們可以使用 threading 這個模組來快速完成平行處理的方式。
但是 threading 只是透過頻繁的 CPU context-switch 的方式實現，
要真正實現多核心 CPU 的平行運算，我們需要使用 multiprocessing，
將任務指派給多個核心進行操作。</p>
<blockquote>
<p>multiprocessing 在資料傳遞上，會因為需要將資料轉移至其他 CPU 上進行運算，
因此會需要考慮資料搬運的時間，
而多核心真正的實現「平行運算的功能」，當任務較為複雜時，效率一定比較好。</p>
</blockquote>
<h1 id="thread-與-multiprocess-比較"><a class="header" href="#thread-與-multiprocess-比較">thread 與 multiprocess 比較</a></h1>
<h2 id="threading-重點摘要"><a class="header" href="#threading-重點摘要">threading 重點摘要</a></h2>
<p>threading 是透過 context-switch 的方式實現
也就是說，我們是透過 CPU 的不斷切換 (context-switch)，實現平行的功能。
當大量使用 threading 執行平行的功能時，反而會因為大量的 context-switch，
「實現了程式平行的功能，但也因為大量的 context-switch ，使得程式執行速度更慢」。</p>
<h2 id="multiprocessing-重點摘要"><a class="header" href="#multiprocessing-重點摘要">multiprocessing 重點摘要</a></h2>
<p>multiprocessing 在資料傳遞上，會因為需要將資料轉移至其他 CPU 上進行運算，
因此會需要考慮資料搬運的時間，
而多核心真正的實現「平行運算的功能」，當任務較為複雜時，效率一定比較好。</p>
<h2 id="thread-與-multiprocess-比較圖"><a class="header" href="#thread-與-multiprocess-比較圖">thread 與 multiprocess 比較圖</a></h2>
<p>從下圖我們可以看到任務被完成的「概念」時間</p>
<ul>
<li>main 1~4, main-end</li>
<li>任務 A1, A2</li>
<li>任務 B1, B2</li>
<li>任務 C1, C2</li>
</ul>
<p>請留意圖中粗線的部分：
* 在 multithread 中，
CPU context-switch 會額外消耗我們程式執行的時間，程式實際完成時間可能比一般的還要慢。</p>
<ul>
<li>在 multiprocess 中，
我們需要將資料轉移至其他 CPU 會額外消耗我們程式執行的時間，如果任務過於簡單，效益可能不大。</li>
</ul>
<blockquote>
<p>雖然示意圖中明顯感覺較快，但前提是任務夠複雜
也就是說，「任務難度執行的時間 &gt; 資料轉移至其他 CPU 的時間效益」，不然只會更慢。</p>
</blockquote>
<p><img src="python/images/multiprocess-python-1-1024x333.png.webp" alt="img" /></p>
<h1 id="multiprocess-基本使用"><a class="header" href="#multiprocess-基本使用">multiprocess 基本使用</a></h1>
<p>基本的 multiprocess 使用方式，跟 thread 幾乎一樣，
如果學習過 multithread 的讀者，相信可以上手的很快。</p>
<h2 id="範例程式碼-single-multiprocess"><a class="header" href="#範例程式碼-single-multiprocess">範例程式碼 (single-multiprocess)</a></h2>
<pre><code class="language-python">import multiprocessing as mp

def task(a, b):
  print('Task in the Process.')
  print(a, b)

if __name__=='__main__': # must put thread in the main
  p1 = mp.Process(target=task, args=(1,2))
  p1.start()
  p1.join()
</code></pre>
<h2 id="運行結果"><a class="header" href="#運行結果">運行結果</a></h2>
<p><img src="python/images/multiprocess-python-2.png" alt="" /></p>
<h2 id="說明"><a class="header" href="#說明">說明</a></h2>
<ul>
<li>p1 = mp.Process(target=task, args=(1,2))
<ul>
<li>建立一個名字為 p1 的 Process，執行 task 任務，傳入參數 (1,2)</li>
</ul>
</li>
<li>p1.start()：啟動 p1 任務</li>
<li>p1.join()：等待 p1 任務結束 (一定會等到結束才執行下一行)</li>
</ul>
<h1 id="多個-process-同時平行處理保證任務結果的順序性-multi-process"><a class="header" href="#多個-process-同時平行處理保證任務結果的順序性-multi-process">多個 Process 同時平行處理，「保證」任務「結果」的順序性 (multi-process)</a></h1>
<blockquote>
<p>我們「不保證」任務執行時，「過程中」輸出的順序，但完成「結果」的順序性可用 join() 來「保證」。</p>
</blockquote>
<h2 id="範例程式碼-multi-process"><a class="header" href="#範例程式碼-multi-process">範例程式碼 (multi-process)</a></h2>
<pre><code class="language-python">import multiprocessing as mp

def task(num):
  print('This is Process: ', num)

if __name__=='__main__':
  num_process = 5
  process_list = []
  for i in range(num_process):
    process_list.append(mp.Process(target = task, args = (i,)))
    process_list[i].start()

  for i in range(num_process):
    process_list[i].join()
</code></pre>
<h2 id="運行結果-注意每次執行不一定相同"><a class="header" href="#運行結果-注意每次執行不一定相同">運行結果 (注意：每次執行不一定相同)</a></h2>
<p><img src="python/" alt="" /></p>
<p><img src="python/images/multiprocess-python-3.png" alt="img" /></p>
<blockquote>
<p>注意：該輸入的都有輸出，但有些順序搶先輸出了，這也代表不同核心接到任務的順序。
所以「每次執行不一定相同」。</p>
</blockquote>
<h2 id="說明-1"><a class="header" href="#說明-1">說明</a></h2>
<ul>
<li>process_list.append(mp.Process(target = task, args = (i,)))
<ul>
<li>建立 Process，存入，執行 task 任務，傳入參數 (i, )</li>
</ul>
</li>
<li>process_list[i].start()：啟動 process_list[i] 任務</li>
<li>process_list[i].join()：等待 process_list[i] 任務結束 (一定會等到結束才執行下一行)</li>
</ul>
<h1 id="多個-process-同時平行處理保證任務過程中的順序性-multi-process"><a class="header" href="#多個-process-同時平行處理保證任務過程中的順序性-multi-process">多個 Process 同時平行處理，「保證」任務「過程中」的順序性 (multi-process)</a></h1>
<p>答：沒有必要</p>
<p>如果是為了當任務「過程中」順序有高度要求時…你可能要想想</p>
<blockquote>
<p>如果真要確保「過程中」照順序來，才做下一件事情，那你用 multi-process 到底要幹嘛XDD。
直接寫就好了，不用想太多 multi-process 的事情!
「又要多核心」、「又要平行任務」、「又要保證過程中的順序」，
光是保證「保證過程中的順序」，你的 process 執行過程之間就會互相卡爆了
還要效率不如直接不要平行了吧。</p>
</blockquote>
<p>所以這邊就不示範了，你可能要先想清楚：為什麼都用到 multi-process ，
還需要保證任務「過程中」的順序性。(如果只是想確保執行「結果」的順序性，請見上面。)</p>
<h1 id="利用-multiprocessing-模組-查看自己的cpu有多少核心"><a class="header" href="#利用-multiprocessing-模組-查看自己的cpu有多少核心">利用 multiprocessing 模組 查看自己的CPU「有多少核心」</a></h1>
<p>我們可以利用 multiprocessing 模組內建的功能，
multiprocessing.cpu_count()，得到目前 cpu 的核心數量。</p>
<pre><code class="language-python">cpu_count = multiprocessing.cpu_count()
</code></pre>
<h2 id="結合上述的程式範例製作出依照-cpu-核心數執行任務的範例程式碼模板"><a class="header" href="#結合上述的程式範例製作出依照-cpu-核心數執行任務的範例程式碼模板">結合上述的程式範例，製作出「依照 CPU 核心數執行任務」的範例程式碼模板</a></h2>
<pre><code class="language-python">import multiprocessing as mp

def task(num):
  print('This is cpu core: ', num)

if __name__=='__main__':
  cpu_count = mp.cpu_count()
  print(&quot;cpu_count: &quot;, cpu_count)
  process_list = []
  for i in range(cpu_count):
    process_list.append(mp.Process(target = task, args = (i,)))
    process_list[i].start()

  for i in range(cpu_count):
    process_list[i].join()
</code></pre>
<p>執行結果 (依照不同電腦的 CPU 能力而有異)</p>
<p><img src="python/images/multiprocess-python-4.png" alt="img" /></p>
<p>不過這樣的感覺很不踏實對吧! 感覺都要手動指定核心數量給 Process，
能不能讓系統自動分配呢?</p>
<p>當然是可以的，我們會再另外一篇文章 multiprocessing pool 教學進階的使用，
使用 pool 就可以自動讓系統幫我們分配任務給多個核心，
並且與 Process 最大的不同是「pool 能夠取得結果」。</p>
<h1 id="reference-2"><a class="header" href="#reference-2">Reference</a></h1>
<ul>
<li>
<p>Python 多執行緒 threading 模組平行化程式設計教學</p>
</li>
<li>
<p><a href="https://iter01.com/17324.html">【莫煩】Multiprocessing 多程式</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python模塊-進程間的通信queuepipe與數據共享manager"><a class="header" href="#python模塊-進程間的通信queuepipe與數據共享manager">Python模塊-進程間的通信(Queue,Pipe)與數據共享(Manager)</a></h1>
<p>出處: http://www.taroballz.com/2018/01/11/processing_communcation/</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction:</a></h1>
<ul>
<li>進程之間<strong>互相獨立</strong>，預設為<strong>不能共享數據</strong></li>
<li>透過multiprocess模塊中的Pipe及Queue實現不同進程之間的通信
<ul>
<li>Queue(隊列)：
<ul>
<li>先進來的先出去，後進來的後出去</li>
</ul>
</li>
</ul>
</li>
<li>透過Manager實現進程之間的數據共享</li>
</ul>
<h1 id="notice"><a class="header" href="#notice">Notice:</a></h1>
<ul>
<li>使用queue.Queue()調用的方法為線程隊列不適用於進程間的通信</li>
</ul>
<h1 id="usage"><a class="header" href="#usage">Usage:</a></h1>
<h2 id="queue-"><a class="header" href="#queue-">Queue :</a></h2>
<pre><code class="language-python">from multiprocessing import Process,Queue

def func(q,name):                        #以參數的方式將對列物件以參數型式導入子進程          
    q.put('My Process_name is %s and put the data to the id %d queue'%(name,id(q)))
       
if __name__ == &quot;__main__&quot;:
    q = Queue()              #於主進程創建隊列物件
    process_list=[]
    print(&quot;main queue id: %d&quot;%id(q))
    for i in range(3):
        proc = Process(target=func,args=(q,'Process-%d'%i))
        process_list.append(proc)
        proc.start()
    print(q.get())    #往管道中取數據
    print(q.get())
    print(q.get())
    for each_process in process_list:
        each_process.join() 
</code></pre>
<ul>
<li>
<p>Queue()</p>
<p>參數可填入管道的長度</p>
<ul>
<li><code>Queue(3)</code>表示創建能存三筆資料的管道物件</li>
</ul>
</li>
<li>
<p>創建的<code>Queue</code>物件可放置任意數據類型</p>
</li>
<li>
<p>通過 Queue.get() 取數據</p>
<ul>
<li>先<code>put</code>的先取出，後<code>put</code>的後取出</li>
<li>要是<code>Queue</code>為空的情況下，還執意<code>get</code>的話，會堵塞到有數據可取出為止</li>
<li>可使用<code>Queue.get_nowait()</code>方法，要是<strong>堵塞</strong>了會直接<strong>報錯</strong></li>
</ul>
</li>
</ul>
<p>其結果如下</p>
<pre><code class="language-shell">main queue id: 52342000
My Process_name is Process-1 and put the data to the id 64566512 queue
My Process_name is Process-0 and put the data to the id 43398512 queue
My Process_name is Process-2 and put the data to the id 61551856 queue
</code></pre>
<p>從上面執行結果可知道我們所創建的Queue物件似乎為一個copy的對象並指向不同RAM地址貌似不是對同一個隊列進行操作
但是從主進程<code>get()</code>的結果卻發現的確是對同一隊列的資料進行操作，
原因應為copy後的隊列內部進行了pickle的序列化及反序列化的操作</p>
<h3 id="判斷queue是否為滿full或空empty"><a class="header" href="#判斷queue是否為滿full或空empty">判斷Queue是否為滿(full)或空(empty)</a></h3>
<pre><code class="language-python">Queue.full() #判斷管道是否為滿
Queue.empty() #判斷管道是否為空
</code></pre>
<ul>
<li>返回bool值</li>
</ul>
<h2 id="pipe-類似socket通信"><a class="header" href="#pipe-類似socket通信">Pipe (類似socket通信)</a></h2>
<pre><code class="language-python">from multiprocessing import Process,Pipe
import os

def func(conn):
    conn.send(&quot;Hi I'm your subprocess. My ID is %d&quot;%os.getpid())
    print(&quot;ID %d receive main_process message: &quot;%os.getpid(),conn.recv())
    conn.close()
       
if __name__ == &quot;__main__&quot;:
    main_conn , sub_conn = Pipe()    #使用Pipe()函數同時建立主進程及自進程兩個通信的物件
    processlist=[]
    for i in range(2):
        proc = Process(target=func,args=(sub_conn,))
        processlist.append(proc)
        proc.start()
        print(&quot;I'm mainprocess, I receive my sub_process message: &quot;,main_conn.recv())
        main_conn.send(&quot;Remember I'm your Master&quot;)
    for each_process in processlist:
        each_process.join()
</code></pre>
<p>其結果如下</p>
<pre><code class="language-shell">I'm mainprocess, I receive my sub_process message:  Hi I'm your subprocess. My ID is 8424
ID 8424 receive main_process message:  Remember I'm your Master
I'm mainprocess, I receive my sub_process message:  Hi I'm your subprocess. My ID is 13468
ID 13468 receive main_process message:  Remember I'm your Master
</code></pre>
<h2 id="manager"><a class="header" href="#manager">Manager</a></h2>
<pre><code class="language-python">from multiprocessing import Process,Manager

def func(dic,lis,n):            #對字典及列表進行操作
    dic[&quot;Process_%s&quot;%n] = &quot;1&quot;
    dic['2'] = 2
    dic[0.25] = None
    lis.append(n)

if __name__ == &quot;__main__&quot;:
    with Manager() as manager:       #創建一個Manager()的物件
        dic = manager.dict()         #透過Manager()物件創建一個空字典 此字典進程之間可以共享
        lis = manager.list(range(5)) #透過Manager()物件創建一個含0-5數字的列表 此列表進程之間可以共享
        process_list = []
        for i in range(10):
            proc = Process(target=func, args=(dic,lis,i))
            proc.start()
            process_list.append(proc)
            
        for each_process in process_list:
            each_process.join()
        print(dic)
        print(lis)
</code></pre>
<p>其結果為</p>
<pre><code class="language-shell">{0.25: None, 'Process_9': '1', '2': 2, 'Process_8': '1', 'Process_4': '1', 'Process_0': '1', 'Process_7': '1', 'Process_2': '1', 'Process_6': '1', 'Process_1': '1', 'Process_3': '1', 'Process_5': '1'}
[0, 1, 2, 3, 4, 0, 1, 2, 3, 6, 5, 4, 8, 7, 9]
</code></pre>
<p>我們可以發現使用Manager各個進程是對同一個列表及字典進行操作</p>
<h1 id="reference-3"><a class="header" href="#reference-3">Reference:</a></h1>
<p>http://www.cnblogs.com/yuanchenqi/articles/5745958.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python中的wait和notify"><a class="header" href="#python中的wait和notify">python中的wait和notify</a></h1>
<p>這次講一下python中的wait和notify</p>
<p>現在假如有如下情況：</p>
<p>小明:小紅</p>
<p>小紅:在</p>
<p>小明:我喜歡你
小紅:對不起，你是個好人。</p>
<p>對於這種一問一答的方式，我們是否也可以通過加鎖來解決呢，我們看代碼。</p>
<pre><code class="language-python">import threading

class XiaoMing(threading.Thread):
    def __init__(self,lock):
        super().__init__(name='小明')
    
    
    def run(self):
        lock.acquire()
        print('{}:小紅'.format(self.name))
        lock.release()

        lock.acquire()
        print('{}:我喜歡你'.format(self.name))
        lock.release()

class XiaoHong(threading.Thread):
    def __init__(self,lock):
        super().__init__(name='小紅')
    
    def run(self):
        lock.acquire()
        print('{}:在'.format(self.name))
        lock.release()

        lock.acquire()
        print('{}:對不起,你是個好人'.format(self.name))
        lock.release()

if __name__ == '__main__':
    lock = threading.Lock()
    xiaoming = XiaoMing(lock)
    xiaohong = XiaoHong(lock)
    
    xiaoming.start()
    xiaohong.start()
</code></pre>
<p>這個時候會出現一個現象，我們發現執行的結果是</p>
<p>小明:小紅
小明:我喜歡你
小紅:在
小紅:對不起,你是個好人</p>
<p>很顯然，這跟我們想要的結果是不一樣的，那麼為什麼會導致這樣的結果呢。</p>
<p>原因就在於我們在小明說完小紅的時候會釋放鎖，接著小明這個線程又拿到了鎖，這個時候又繼續說了我喜歡你。這就是導致結果跟預期不一致的原因。</p>
<p>因此我們在這裡引出了wait和notify這兩個方法，這兩個方法屬於threading的Condition類，condition是一個條件變量，是用來控制復雜的線程之間的同步。</p>
<p>如果看過condition的源碼，就會發現condition實現了__enter__ 和__exit__這兩個魔術方法，因此我們可以通過with語句來使用condition這個變量。</p>
<p>再說一下wait和notify，wait()只有在被notify喚醒時，才會繼續往下執行。因此會有下面這樣的代碼。</p>
<pre><code class="language-python">import threading
from threading import Condition


class XiaoMing(threading.Thread):
    def __init__(self,condition):
        super().__init__(name='小明')
        self.condition = condition
    
    def run(self):
        with self.condition:
            print('{}:小紅'.format(self.name))
            self.condition.notify()
            self.condition.wait()

            print('{}:我喜歡你'.format(self.name))
            self.condition.notify()
            self.condition.wait()


class XiaoHong(threading.Thread):
    def __init__(self,condition):
        super().__init__(name='小紅')
        self.condition = condition

    def run(self):
        with self.condition:
            self.condition.wait()
            print('{}:在'.format(self.name))
            self.condition.notify()

            self.condition.wait()
            print('{}:對不起,你是個好人'.format(self.name))
            self.condition.notify()

if __name__ == '__main__':
    condition = threading.Condition()
    xiaoming = XiaoMing(condition)
    xiaohong = XiaoHong(condition)
    
    xiaohong.start()
    xiaoming.start()
</code></pre>
<p>運行上面的代碼，我們發現執行結果按照我們預期的進行了。需要注意的一點就是start的順序改了，是小紅先start，小明才start。</p>
<p>如果是小明先start的話，那麼小紅就會在小明notify之後才start，這樣小紅的wait就收不到小明發過來的信號了，因此會導致</p>
<p>程序一直卡住。</p>
<p>其實這個condition的源碼裡面，在初始化condition的時候，就會上一把鎖，這樣另一個線程就進不去with裡面了，</p>
<p>而在調用wait的時候，會先把condition時初始化的鎖釋放掉，然後再分配一把鎖到condition的等待隊列中，等待notify的喚醒。</p>
<div style="break-before: page; page-break-before: always;"></div><p>本文主要講解生產者消費者模式，它基於執行緒之間的通訊。</p>
<p>生產者消費者模式是指一部分程式用於生產資料，一部分程式用於處理資料，兩部分分別放在兩個執行緒中來執行。</p>
<p>舉幾個例子</p>
<ul>
<li>一個程式專門往列表中新增數字，另一個程式專門提取數字進行處理，二者共同維護這樣一個列表</li>
<li>一個程式去抓取待爬取的url，另一個程式專門解析url將資料儲存到檔案中，這相當於維護一個url佇列</li>
<li>維護ip池，一個程式在消耗ip進行爬蟲，另一個程式看ip不夠用了就啟動開始抓取</li>
</ul>
<p>我們可以想象到，這種情況不使用併發機制（如多執行緒）是難以實現的。如果程式線性執行，只能做到先把所有url抓取到列表中，再遍歷列表解析資料；或者解析的過程中將新抓到的url加入列表，但是列表的增添和刪減並不是同時發生的。對於更復雜的機制，執行緒程式更是難以做到，比如維護url列表，當列表長度大於100時停止填入，小於50時再啟動開始填入。</p>
<h4 id="本文結構"><a class="header" href="#本文結構">本文結構</a></h4>
<p>本文思路如下</p>
<ul>
<li>首先，兩個執行緒維護同一個列表，需要使用鎖保證對資源修改時不會出錯</li>
<li><code>threading</code>模組提供了<code>Condition</code>物件專門處理生產者消費者問題</li>
<li>但是為了呈現由淺入深的過程，我們先用普通鎖來實現這個過程，通過考慮程式的不足，再使用<code>Condition</code>來解決，讓讀者更清楚<code>Condition</code>的用處</li>
<li>下一步，python中的<code>queue</code>模組封裝了<code>Condition</code>的特性，為我們提供了一個方便易用的佇列結構。用<code>queue</code>可以讓我們不需要了解鎖是如何設定的細節</li>
<li>執行緒安全的概念解釋</li>
<li>這個過程其實就是執行緒之間的通訊，除了<code>Condition</code>，再補充一種通訊方式<code>Event</code></li>
</ul>
<p>本文分為下面幾個部分</p>
<ul>
<li>Lock與Condition的對比</li>
<li>生產者與消費者的相互等待</li>
<li>Queue</li>
<li>執行緒安全</li>
<li>Event</li>
</ul>
<h4 id="lock與condition的對比"><a class="header" href="#lock與condition的對比">Lock與Condition的對比</a></h4>
<p>下面我們實現這樣一個過程</p>
<ul>
<li>維護一個整數列表<code>integer_list</code>，共有兩個執行緒</li>
<li><code>Producer</code>類對應一個執行緒，功能：隨機產生一個整數，加入整數列表之中</li>
<li><code>Consumer</code>類對應一個執行緒，功能：從整數列表中<code>pop</code>掉一個整數</li>
<li>通過<code>time.sleep</code>來表示兩個執行緒執行速度，設定成<code>Producer</code>產生的速度沒有<code>Consumer</code>消耗的快</li>
</ul>
<p>程式碼如下</p>
<pre><code class="language-python">import time
import threading
import random
class Producer(threading.Thread):
    # 產生隨機數，將其加入整數列表
    def __init__(self, lock, integer_list):
        threading.Thread.__init__(self)
        self.lock = lock
        self.integer_list = integer_list
    def run(self):
        while True: # 一直嘗試獲得鎖來新增整數
            random_integer = random.randint(0, 100)
            with self.lock:
                self.integer_list.append(random_integer)
                print('integer list add integer {}'.format(random_integer))
            time.sleep(1.2 * random.random()) # sleep隨機時間，通過乘1.2來減慢生產的速度
class Consumer(threading.Thread):
    def __init__(self, lock, integer_list):
        threading.Thread.__init__(self)
        self.lock = lock
        self.integer_list = integer_list
    def run(self):
        while True: # 一直嘗試去消耗整數
            with self.lock:
                if self.integer_list: # 只有列表中有元素才pop
                    integer = self.integer_list.pop()
                    print('integer list lose integer {}'.format(integer))
                    time.sleep(random.random())
                else:
                    print('there is no integer in the list')
def main():
    integer_list = []
    lock = threading.Lock()
    th1 = Producer(lock, integer_list)
    th2 = Consumer(lock, integer_list)
    th1.start()
    th2.start()
if __name__ == '__main__':
    main()
</code></pre>
<p>程式會無休止地執行下去，一個產生，另一個消耗，擷取前面一部分執行結果如下</p>
<pre><code>integer list add integer 100
integer list lose integer 100
there is no integer in the list
there is no integer in the list
... 幾百行一樣的 ...
there is no integer in the list
integer list add integer 81
integer list lose integer 81
there is no integer in the list
there is no integer in the list
there is no integer in the list
......
複製程式碼
</code></pre>
<p>我們可以看到，整數每次產生都會被迅速消耗掉，消費者沒有東西可以處理，但是依然不停地詢問是否有東西可以處理（<code>while True</code>），這樣不斷地詢問會比較浪費CPU等資源（特別是詢問之後不只是print而是加入計算等）。</p>
<p>如果可以在第一次查詢到列表為空的時候就開始等待，直到列表不為空（收到通知而不是一遍一遍地查詢），資源開銷就可以節省很多。<code>Condition</code>物件就可以解決這個問題，它與一般鎖的區別在於，除了可以<code>acquire release</code>，還多了兩個方法<code>wait notify</code>，下面我們來看一下上面過程如何用<code>Condition</code>來實現</p>
<pre><code class="language-python">import time
import threading
import random
class Producer(threading.Thread):
    def __init__(self, condition, integer_list):
        threading.Thread.__init__(self)
        self.condition = condition
        self.integer_list = integer_list
    def run(self):
        while True:
            random_integer = random.randint(0, 100)
            with self.condition:
                self.integer_list.append(random_integer)
                print('integer list add integer {}'.format(random_integer))
                self.condition.notify()
            time.sleep(1.2 * random.random())
class Consumer(threading.Thread):
    def __init__(self, condition, integer_list):
        threading.Thread.__init__(self)
        self.condition = condition
        self.integer_list = integer_list
    def run(self):
        while True:
            with self.condition:
                if self.integer_list:
                    integer = self.integer_list.pop()
                    print('integer list lose integer {}'.format(integer))
                    time.sleep(random.random())
                else:
                    print('there is no integer in the list')
                    self.condition.wait()
def main():
    integer_list = []
    condition = threading.Condition()
    th1 = Producer(condition, integer_list)
    th2 = Consumer(condition, integer_list)
    th1.start()
    th2.start()
if __name__ == '__main__':
    main()
</code></pre>
<p>相比於<code>Lock</code>，<code>Condition</code>只有兩個變化</p>
<ul>
<li>在生產出整數時<code>notify</code>通知<code>wait</code>的執行緒可以繼續了</li>
<li>消費者查詢到列表為空時呼叫<code>wait</code>等待通知（<code>notify</code>）</li>
</ul>
<p>這樣結果就井然有序</p>
<pre><code>integer list add integer 7
integer list lose integer 7
there is no integer in the list
integer list add integer 98
integer list lose integer 98
there is no integer in the list
integer list add integer 84
integer list lose integer 84
.....
複製程式碼
</code></pre>
<h4 id="生產者與消費者的相互等待"><a class="header" href="#生產者與消費者的相互等待">生產者與消費者的相互等待</a></h4>
<p>上面是最基本的使用，下面我們多實現一個功能：生產者一次產生三個數，在列表數量大於5的時候停止生產，小於4的時候再開始</p>
<pre><code class="language-python">import time
import threading
import random
class Producer(threading.Thread):
    def __init__(self, condition, integer_list):
        threading.Thread.__init__(self)
        self.condition = condition
        self.integer_list = integer_list
    def run(self):
        while True:
            with self.condition:
                if len(self.integer_list) &gt; 5:
                    print('Producer start waiting')
                    self.condition.wait()
                else:
                    for _ in range(3):
                        self.integer_list.append(random.randint(0, 100))
                    print('now {} after add '.format(self.integer_list))
                    self.condition.notify()
            time.sleep(random.random())
class Consumer(threading.Thread):
    def __init__(self, condition, integer_list):
        threading.Thread.__init__(self)
        self.condition = condition
        self.integer_list = integer_list
    def run(self):
        while True:
            with self.condition:
                if self.integer_list:
                    integer = self.integer_list.pop()
                    print('all {} lose {}'.format(self.integer_list, integer))
                    time.sleep(random.random())
                    if len(self.integer_list) &lt; 4:
                        self.condition.notify()
                        print(&quot;Producer don't need to wait&quot;)
                else:
                    print('there is no integer in the list')
                    self.condition.wait()
def main():
    integer_list = []
    condition = threading.Condition()
    th1 = Producer(condition, integer_list)
    th2 = Consumer(condition, integer_list)
    th1.start()
    th2.start()
if __name__ == '__main__':
    main()
</code></pre>
<p>可以看下面的結果體會消長過程</p>
<pre><code>now [33, 94, 68] after add
all [33, 94] lose 68
Producer don't need to wait
now [33, 94, 53, 4, 95] after add
all [33, 94, 53, 4] lose 95
all [33, 94, 53] lose 4
Producer don't need to wait
now [33, 94, 53, 27, 36, 42] after add
all [33, 94, 53, 27, 36] lose 42
all [33, 94, 53, 27] lose 36
all [33, 94, 53] lose 27
Producer don't need to wait
now [33, 94, 53, 79, 30, 22] after add
all [33, 94, 53, 79, 30] lose 22
all [33, 94, 53, 79] lose 30
now [33, 94, 53, 79, 60, 17, 34] after add
all [33, 94, 53, 79, 60, 17] lose 34
all [33, 94, 53, 79, 60] lose 17
now [33, 94, 53, 79, 60, 70, 76, 21] after add
all [33, 94, 53, 79, 60, 70, 76] lose 21
Producer start waiting
all [33, 94, 53, 79, 60, 70] lose 76
all [33, 94, 53, 79, 60] lose 70
all [33, 94, 53, 79] lose 60
all [33, 94, 53] lose 79
Producer don't need to wait
all [33, 94] lose 53
Producer don't need to wait
all [33] lose 94
Producer don't need to wait
all [] lose 33
Producer don't need to wait
there is no integer in the list
now [16, 67, 23] after add
all [16, 67] lose 23
Producer don't need to wait
now [16, 67, 49, 62, 50] after add
複製程式碼
</code></pre>
<h4 id="queue"><a class="header" href="#queue">Queue</a></h4>
<p>queue模組內部實現了<code>Condition</code>，我們可以非常方便地使用生產者消費者模式</p>
<pre><code class="language-python">import time
import threading
import random
from queue import Queue
class Producer(threading.Thread):
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue
    def run(self):
        while True:
            random_integer = random.randint(0, 100)
            self.queue.put(random_integer)
            print('add {}'.format(random_integer))
            time.sleep(random.random())
class Consumer(threading.Thread):
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue
    def run(self):
        while True:
            get_integer = self.queue.get()
            print('lose {}'.format(get_integer))
            time.sleep(random.random())
def main():
    queue = Queue()
    th1 = Producer(queue)
    th2 = Consumer(queue)
    th1.start()
    th2.start()
if __name__ == '__main__':
    main()
</code></pre>
<p><code>Queue</code>中</p>
<ul>
<li><code>get</code>方法會移除並賦值（相當於list中的<code>pop</code>），但是它在佇列為空的時候會被阻塞（wait）</li>
<li><code>put</code>方法是往裡面新增值</li>
<li>如果想設定佇列最大長度，初始化時這樣做<code>queue = Queue(10)</code>指定最大長度，超過這個長度就會被阻塞（wait）</li>
</ul>
<p>使用<code>Queue</code>，全程不需要顯式地呼叫鎖，非常簡單易用。不過內建的<code>queue</code>有一個缺點在於不是可迭代物件，不能對它迴圈也不能檢視其中的值，可以通過構造一個新的類來實現，詳見<a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F16506429%2Fcheck-if-element-is-already-in-a-queue">這裡</a>。</p>
<p>下面消防之前<code>Condition</code>方法，用<code>Queue</code>實現生產者一次加3個，消費者一次消耗1個，每次都返回當前佇列內容，改寫程式碼如下</p>
<pre><code class="language-python">import time
import threading
import random
from queue import Queue
# 為了能檢視佇列資料，繼承Queue定義一個類
class ListQueue(Queue):
    def _init(self, maxsize):
        self.maxsize = maxsize
        self.queue = [] # 將資料儲存方式改為list
    def _put(self, item):
        self.queue.append(item)
    def _get(self):
        return self.queue.pop()
class Producer(threading.Thread):
    def __init__(self, myqueue):
        threading.Thread.__init__(self)
        self.myqueue = myqueue
    def run(self):
        while True:
            for _ in range(3): # 一個執行緒加入3個，注意：條件鎖時上在了put上而不是整個迴圈上
                self.myqueue.put(random.randint(0, 100))
            print('now {} after add '.format(self.myqueue.queue))
            time.sleep(random.random())
class Consumer(threading.Thread):
    def __init__(self, myqueue):
        threading.Thread.__init__(self)
        self.myqueue = myqueue
    def run(self):
        while True:
            get_integer = self.myqueue.get()
            print('lose {}'.format(get_integer), 'now total', self.myqueue.queue)
            time.sleep(random.random())
def main():
    queue = ListQueue(5)
    th1 = Producer(queue)
    th2 = Consumer(queue)
    th1.start()
    th2.start()
if __name__ == '__main__':
    main()
</code></pre>
<p>得到結果如下</p>
<pre><code>now [79, 39, 64] after add
lose 64 now total [79, 39]
now [79, 39, 9, 42, 14] after add
lose 14 now total [79, 39, 9, 42]
lose 42 now total [79, 39, 9]
lose 27 now total [79, 39, 9, 78]
now [79, 39, 9, 78, 30] after add
lose 30 now total [79, 39, 9, 78]
lose 21 now total [79, 39, 9, 78]
lose 100 now total [79, 39, 9, 78]
now [79, 39, 9, 78, 90] after add
lose 90 now total [79, 39, 9, 78]
lose 72 now total [79, 39, 9, 78]
lose 5 now total [79, 39, 9, 78]
複製程式碼
</code></pre>
<p>上面限制佇列最大為5，有以下細節需要注意</p>
<ul>
<li>首先<code>ListQueue</code>類的構造：因為<code>Queue</code>類的原始碼中，<code>put</code>是呼叫了<code>_put</code>，<code>get</code>呼叫<code>_get</code>，<code>_init</code>也是一樣，所以我們重寫這三個方法就將資料儲存的型別和存取方式改變了。而其他部分鎖的設計都沒有變，也可以正常使用。改變之後我們就可以通過呼叫<code>self.myqueue.queue</code>來訪問這個列表資料</li>
<li>輸出結果很怪異，並不是我們想要的。這是因為<code>Queue</code>類的原始碼中，如果佇列數量達到了<code>maxsize</code>，則<code>put</code>的操作<code>wait</code>，而<code>put</code>一次插入一個元素，所以經常插入一個等一次，迴圈無法一次執行完，而<code>print</code>是在插入三個之後才有的，所以很多時候其實加進去值了卻沒有在執行結果中顯示，所以結果看起來比較怪異。所以要想靈活使用還是要自己來定義鎖的位置，不能簡單依靠<code>queue</code></li>
</ul>
<p>另外，<code>queue</code>模組中有其他類，分別實現先進先出、先進後出、優先順序等佇列，還有一些異常等，可以參考<a href="https://link.juejin.im/?target=http%3A%2F%2Fpython.jobbole.com%2F88413%2F">這篇文章</a>和<a href="https://link.juejin.im/?target=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Fqueue.html">官網</a>。</p>
<h4 id="執行緒安全"><a class="header" href="#執行緒安全">執行緒安全</a></h4>
<p>講到了<code>Queue</code>就提一提執行緒安全。執行緒安全其實就可以理解成執行緒同步。</p>
<p>官方定義是：指某個函式、函式庫在多執行緒環境中被呼叫時，能夠正確地處理多個執行緒之間的共享變數，使程式功能正確完成。</p>
<p>我們常常提到的說法是，某某某是執行緒安全的，比如<code>queue.Queue</code>是執行緒安全的，而<code>list</code>不是。</p>
<p>根本原因在於前者實現了鎖原語，而後者沒有。</p>
<p>原語指由若干個機器指令構成的完成某種特定功能的一段程式，具有不可分割性；即原語的執行必須是連續的，在執行過程中不允許被中斷。</p>
<p><code>queue.Queue</code>是執行緒安全的，即指對他進行寫入和提取的操作不會被中斷而導致錯誤，這也是在實現生產者消費者模式時，使用List就要特意去加鎖，而用這個佇列就不用的原因。</p>
<h4 id="event"><a class="header" href="#event">Event</a></h4>
<p><code>Event</code>與<code>Condition</code>的區別在於：<code>Condition = Event + Lock</code>，所以Event非常簡單，只是一個沒有帶鎖的<code>Condition</code>，也是滿足一定條件等待或者執行，這裡不想說很多，只舉一個簡單的例子來看一下</p>
<pre><code class="language-python">import threading
import time
class MyThread(threading.Thread):
    def __init__(self, event):
        threading.Thread.__init__(self)
        self.event = event
    def run(self):
        print('first')
        self.event.wait()
        print('after wait')
event = threading.Event()
MyThread(event).start()
print('before set')
time.sleep(1)
event.set()
複製程式碼
</code></pre>
<p>可以看到結果</p>
<pre><code>first
before set
複製程式碼
</code></pre>
<p>先出現，1s之後才出現</p>
<pre><code>after wait
複製程式碼
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="loguru更為優雅簡潔的-python-日誌管理模塊"><a class="header" href="#loguru更為優雅簡潔的-python-日誌管理模塊">Loguru：更為優雅、簡潔的 Python 日誌管理模塊</a></h2>
<p><img src="python/images/48110857b7da2ded984c6fd87bec.jpg" alt="img" /></p>
<p>在 Python 開發中涉及到日誌記錄，我們或許通常會想到內置標準庫 —— logging 。雖然 logging 庫採用的是模塊化設計，可以設置不同的 handler 來進行組合，但是在配置上較為繁瑣。同時在多線程或多進程的場景下，若不進行特殊處理還會導致日誌記錄會出現異常。</p>
<p>本文將介紹一個十分優雅、簡潔的日誌記錄第三方庫—— loguru ，我們可以通過導入其封裝的 logger 類的實例，即可直接進行調用。</p>
<h1 id="安裝-1"><a class="header" href="#安裝-1">安裝</a></h1>
<p>使用 pip 安裝即可，Python 3 版本的安裝如下：</p>
<pre><code>pip3 install loguru
</code></pre>
<h1 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h1>
<p>我們直接通過導入 loguru 封裝好的 logger 類的實例化對象，不需要手動創建 logger，直接進行調用不同級別的日誌輸出方法。我們先用一個示例感受下：</p>
<pre><code class="language-python">from loguru import logger

logger.debug('This is debug information')
logger.info('This is info information')
logger.warning('This is warn information')
logger.error('This is error information')
</code></pre>
<p>在 IDE 或終端運行時會發現，loguru 在輸出的不同級別信息時，帶上了不同的顏色，使得結果更加直觀，其中也包含了時間、級別、模塊名、行號以及日誌信息。</p>
<p><img src="python/images/9142c7c0c71bafa70bb8167b6c14.jpg" alt="img" /></p>
<p>loguru 中不同日誌級別與日誌記錄方法對應關係 如下：</p>
<p>eIMZOj<img src="https://www.readfog.com/assets/1a/ac/205a1e747d7688bb16fa0b0e5257.png" alt="eIMZOj" /></p>
<h1 id="loguru-配置日誌文件"><a class="header" href="#loguru-配置日誌文件">loguru 配置日誌文件</a></h1>
<p>logger 默認採用 sys.stderr 標準錯誤輸出將日誌輸出到控制檯中，假如想要將日誌同時輸出到其他的位置，比如日誌文件，此時我們只需要使用一行代碼即可實現。</p>
<p>例如，將日誌信息輸出到 2021-3-28.log 文件中，可以這麼寫：</p>
<pre><code class="language-python">from loguru import logger

logger.add(&quot;E:/PythonCode/MOC/log_2021-3-28.log&quot;,rotation=&quot;500MB&quot;, encoding=&quot;utf-8&quot;, enqueue=True, retention=&quot;10 days&quot;)

logger.info('This is info information')
</code></pre>
<p>如上，loguru 直接通過 add() 方法，完成了日誌文件的配置。</p>
<h1 id="日誌內容的字符串格式化"><a class="header" href="#日誌內容的字符串格式化">日誌內容的字符串格式化</a></h1>
<p>loguru 在輸出 日誌的時候，還提供了非常靈活的字符串格式化輸出日誌的功能，如下：</p>
<pre><code class="language-python">import platform
from loguru import logger

rounded_value = round(0.345, 2)

trace= logger.add('2021-3-28.log')

logger.info('If you are using Python {version}, prefer {feature} of course!', version=platform.python_version(), feature='f-strings')

# 執行上述代碼，輸出結果為
2021-03-28 13:43:26.232 | INFO     | __main__:&lt;module&gt;:9 - If you are using Python 3.7.6, prefer f-strings of course!
</code></pre>
<hr />
<h1 id="loguru-日誌常用參數配置解析"><a class="header" href="#loguru-日誌常用參數配置解析">loguru 日誌常用參數配置解析</a></h1>
<ul>
<li>sink：可以傳入一個 file 對象（file-like object），或一個 str 字符串或者 pathlib.Path 對象，或一個方法（coroutine function），或 logging 模塊的 Handler（logging.Handler）。</li>
<li>level (int or str, optional) ：應將已記錄消息發送到接收器的最低嚴重級別。</li>
<li>format (str or callable, optional) ：格式化模塊，在發送到接收器之前，使用模板對記錄的消息進行格式化。</li>
<li>filter (callable, str or dict, optional) ：用於決定每個記錄的消息是否應該發送到接收器。</li>
<li>colorize (bool, optional) – 是否應將格式化消息中包含的顏色標記轉換為用於終端著色的 Ansi 代碼，或以其他方式剝離。如果 None，根據水槽是否為 TTY 自動作出選擇。</li>
<li>serialize (bool, optional) ：在發送到接收器之前，記錄的消息及其記錄是否應該首先轉換為 JSON 字符串。</li>
<li>backtrace (bool, optional) ：格式化的異常跟蹤是否應該向上擴展，超出捕獲點，以顯示生成錯誤的完整堆棧跟蹤。</li>
<li>diagnose (bool, optional) ：異常跟蹤是否應該顯示變量值以簡化調試。在生產中，這應該設置為 “False”，以避免洩漏敏感數據。</li>
<li>enqueue (bool, optional) ：要記錄的消息在到達接收器之前是否應該首先通過多進程安全隊列。當通過多個進程將日誌記錄到文件中時，這是非常有用的。這還具有使日誌調用非阻塞的優點。</li>
<li>catch (bool, optional) ：是否應該自動捕獲接收器處理日誌消息時發生的錯誤。如果 True 上顯示異常消息 sys.stderr。但是，異常不會傳播到調用者，從而防止應用程序崩潰。</li>
</ul>
<p>如果當接收器（sink）是文件路徑（ pathlib.Path ）時，可以應用下列參數，同時 add() 會返回與所添加的接收器相關聯的標識符：</p>
<ul>
<li>rotation：分隔日誌文件，何時關閉當前日誌文件並啟動一個新文件的條件，; 例如，&quot;500 MB&quot;、&quot;0.5 GB&quot;、&quot;1 month 2 weeks&quot;、&quot;10h&quot;、&quot;monthly&quot;、&quot;18:00&quot;、&quot;sunday&quot;、&quot;monday at 18:00&quot;、&quot;06:15&quot;</li>
<li>retention (str, int, datetime.timedelta or callable, optional) ，可配置舊日誌的最長保留時間，例如，&quot;1 week, 3 days&quot;、&quot;2 months&quot;</li>
<li>compression (str or callable, optional) ：日誌文件在關閉時應轉換為的壓縮或歸檔格式，例如，&quot;gz&quot;、&quot;bz2&quot;、&quot;xz&quot;、&quot;lzma&quot;、&quot;tar&quot;、&quot;tar.gz&quot;、&quot;tar.bz2&quot;、&quot;tar.xz&quot;、&quot;zip&quot;</li>
<li>delay (bool, optional)：是否應該在配置了接收器之後立即創建文件，或者延遲到第一個記錄的消息。默認為'False'。</li>
<li>mode (str, optional) ：與內置 open() 函數一樣的打開模式。默認為'&quot;a&quot;(以附加模式打開文件)。</li>
<li>buffering (int, optional) ：內置 open() 函數的緩衝策略，它默認為 1(行緩衝文件)。</li>
<li>encoding (str, optional) ：文件編碼與內置的'open()'函數相同。如果'None'，它默認為'locale.getpreferredencoding() 。</li>
</ul>
<h1 id="loguru-日誌常用方式"><a class="header" href="#loguru-日誌常用方式">loguru 日誌常用方式</a></h1>
<p>停止日誌記錄到文件中</p>
<p>add 方法 添加 sink 之後我們也可以對其進行刪除， 刪除的時候根據剛剛 add 方法返回的 id 進行刪除即可，還原到標準輸出。如下：</p>
<pre><code class="language-python">from loguru import logger

trace= logger.add('2021-3-28.log')
logger.error('This is error information')

logger.remove(trace)
logger.warning('This is warn information')
</code></pre>
<p>控制檯輸出如下：</p>
<pre><code>2021-03-28 13:38:22.995 | ERROR    | __main__:&lt;module&gt;:7 - This is error information

2021-03-28 13:38:22.996 | WARNING  | __main__:&lt;module&gt;:11 - This is warn information
</code></pre>
<p>日誌文件 2021-3-28.log 內容如下：</p>
<pre><code>2021-03-28 13:38:22.995 | ERROR    | __main__:&lt;module&gt;:7 - This is error information
</code></pre>
<p>將 sink 對象移除之後，在這之後的內容不會再輸出到日誌文件中。</p>
<p>只輸出到文本，不在 console 輸出</p>
<p>通過 logger.remove(handler_id=None) 刪除以前添加的處理程序，並停止向其接收器發送日誌。然後通過 add 添加輸出日誌文件，即可 實現 只輸出到文本，不在 console 輸出，如下：</p>
<pre><code class="language-python">from loguru import logger
# 清除之前的設置
logger.remove(handler_id=None) 

trace= logger.add('2021-3-28.log')

logger.error('This is error information')
logger.warning('This is warn information')
</code></pre>
<p>filter 配置日誌過濾規則</p>
<p>如下，我們通過實現自定義方法 error_only，判斷日誌級別，當日誌級別為 ERROR，返回 TRUE，我們在 add 方法設置 filter 參數時，設置為 error_only，即可過濾掉 ERROR 以外的所有日誌 。</p>
<pre><code class="language-python">from loguru import logger

def error_only(record):
    &quot;&quot;&quot;
    error 日誌 判斷 
    Args:
        record: 

    Returns: 若日誌級別為ERROR, 輸出TRUE

    &quot;&quot;&quot;
    return record[&quot;level&quot;].name == &quot;ERROR&quot;

# ERROR以外級別日誌被過濾掉
logger.add(&quot;2021-3-28.log&quot;, filter=error_only)

logger.error('This is error information')
logger.warning('This is warn information')
</code></pre>
<p>在 2021-3-28.log 日誌中，我們可以看到僅記錄了 ERROR 級別日誌。</p>
<pre><code>2021-03-28 17:01:33.267 | ERROR    | __main__:&lt;module&gt;:11 - This is error information
</code></pre>
<p>format 配置日誌記錄格式化模板</p>
<pre><code class="language-python">from loguru import logger

def format_log():
    &quot;&quot;&quot;

    Returns:

    &quot;&quot;&quot;
    trace = logger.add('2021-3-28.log', format=&quot;{time:YYYY-MM-DD HH:mm:ss} {level} From {module}.{function} : {message}&quot;)

    logger.warning('This is warn information')

if __name__ == '__main__':
    format_log()
</code></pre>
<p>如下，我們可以看到在 2021-3-28.log 日誌文件中，如 &quot;{time:YYYY-MM-DD HH:mm:ss} {level} From {module}.{function} : {message}&quot; 格式模板進行記錄：</p>
<pre><code># 2021-3-28.log
2021-03-28 14:46:25 WARNING From 2021-3-28.format_log : This is warn information
</code></pre>
<p>其它的格式化模板屬性 如下：</p>
<p>6fMec9<img src="https://www.readfog.com/assets/31/a4/57f125c809737b77f9504cbd5f2e.png" alt="6fMec9" /></p>
<p>通過 extra bind() 添加額外屬性來為結構化日誌提供更多屬性信息，如下：</p>
<pre><code class="language-python">from loguru import logger

def format_log():
    &quot;&quot;&quot;

    Returns:

    &quot;&quot;&quot;
    trace = logger.add('2021-3-28.log', format=&quot;{time:YYYY-MM-DD HH:mm:ss} {extra[ip]}  {extra[username]} {level} From {module}.{function} : {message}&quot;)
    
    extra_logger = logger.bind(ip=&quot;192.168.0.1&quot;, user)
    extra_logger.info('This is info information')
    extra_logger.bind(user)

    extra_logger.warning('This is warn information')

if __name__ == '__main__':
    format_log()
</code></pre>
<p>如下，我們可以看到在 2021-3-28.log 日誌文件中，看到日誌按上述模板記錄，如下：</p>
<pre><code>2021-03-28 16:27:11 192.168.0.1  張三 INFO From 2021-3-28.format_log : This is info information
2021-03-28 16:27:11 192.168.0.1  李四 ERROR From 2021-3-28.format_log : This is error information
2021-03-28 16:27:11 192.168.0.1  張三 WARNING From 2021-3-28.format_log : This is warn information
</code></pre>
<p>level 配置日誌最低日誌級別</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-29.log', level='ERROR')
</code></pre>
<p>rotation 配置日誌滾動記錄的機制</p>
<p>我們想週期性的創建日誌文件，或者按照文件大小自動分隔日誌文件，我們可以直接使用 add 方法的 rotation 參數進行配置。</p>
<p>例如，每 200MB 創建一個日誌文件，避免每個 log 文件過大，如下：</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log', rotation=&quot;200 MB&quot;)
</code></pre>
<p>例如，每天 6 點 創建一個日誌文件，如下：</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log', rotation='06:00')
</code></pre>
<p>例如，每隔 2 周創建一個 日誌文件，如下：</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log', rotation='2 week')
</code></pre>
<p>retention 配置日誌保留機制</p>
<p>通常，一些久遠的日誌文件，需要週期性的去清除，避免日誌堆積，浪費存儲空間。我們可以通過 add 方法的 retention 參數可以配置日誌的最長保留時間。</p>
<p>例如，設置日誌文件最長保留 7 天，如下：</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log', retention='7 days')
</code></pre>
<p>compression 配置日誌壓縮格式</p>
<p>loguru 還可以配置文件的壓縮格式，比如使用 zip 文件格式保存，示例如下：</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log', compression='zip')
</code></pre>
<p>serialize 日誌序列化</p>
<p>如果我們希望輸出類似於 Json-line 格式的結構化日誌，我們可以通過 serialize 參數，將日誌信息序列化的 json 格式寫入 log 文件，最後可以將日誌文件導入類似於 MongoDB、ElasticSearch 中用作後續的日誌分析，代碼示例如下：</p>
<pre><code class="language-python">from loguru import logger
import platform

rounded_value = round(0.345, 2)

trace= logger.add('2021-3-28.log', serialize=True)

logger.info('If you are using Python {version}, prefer {feature} of course!', version=platform.python_version(), feature='f-strings')
</code></pre>
<p>在 2021-3-28.log 日誌文件，我們可以看到每條日誌信息都被序列化後存在日誌文件中，如下：</p>
<pre><code class="language-python">{
    &quot;text&quot;: &quot;2021-03-28 13:44:17.104 | INFO     | __main__:&lt;module&gt;:9 - If you are using Python 3.7.6, prefer f-strings of course!\n&quot;,
    &quot;record&quot;: {
        &quot;elapsed&quot;: {
            &quot;repr&quot;: &quot;0:00:00.010911&quot;,
            &quot;seconds&quot;: 0.010911
        },
        &quot;exception&quot;: null,
        &quot;extra&quot;: {
            &quot;version&quot;: &quot;3.7.6&quot;,
            &quot;feature&quot;: &quot;f-strings&quot;
        },
        &quot;file&quot;: {
            &quot;name&quot;: &quot;2021-3-28.py&quot;,
            &quot;path&quot;: &quot;F:/code/MOC/2021-3-28.py&quot;
        },
        &quot;function&quot;: &quot;&lt;module&gt;&quot;,
        &quot;level&quot;: {
            &quot;icon&quot;: &quot;\u2139\ufe0f&quot;,
            &quot;name&quot;: &quot;INFO&quot;,
            &quot;no&quot;: 20
        },
        &quot;line&quot;: 9,
        &quot;message&quot;: &quot;If you are using Python 3.7.6, prefer f-strings of course!&quot;,
        &quot;module&quot;: &quot;2021-3-28&quot;,
        &quot;name&quot;: &quot;__main__&quot;,
        &quot;process&quot;: {
            &quot;id&quot;: 22604,
            &quot;name&quot;: &quot;MainProcess&quot;
        },
        &quot;thread&quot;: {
            &quot;id&quot;: 25696,
            &quot;name&quot;: &quot;MainThread&quot;
        },
        &quot;time&quot;: {
            &quot;repr&quot;: &quot;2021-03-28 13:44:17.104522+08:00&quot;,
            &quot;timestamp&quot;: 1616910257.104522
        }
    }
}
</code></pre>
<p>Traceback 記錄（異常追溯）</p>
<p>loguru 集成了一個名為 better_exceptions 的庫，不僅能夠將異常和錯誤記錄，並且還能對異常進行追溯，如下，我們通過在遍歷列表的過程中刪除列表元素，以觸發 IndexError 異常，</p>
<p>通過 catch 裝飾器的方式實現異常捕獲，代碼示例如下：</p>
<pre><code class="language-python">from loguru import logger

trace= logger.add('2021-3-28.log')

@logger.catch
def index_error(custom_list: list):

    for index in range(len(custom_list)):
        index_value = custom_list[index]
        if custom_list[index] &lt; 2 :
            custom_list.remove(index_value)

        print(index_value)

if __name__ == '__main__':
    index_error([1,2,3])
</code></pre>
<p>運行上述代碼，我們可以發現 loguru 輸出的 Traceback 日誌信息， Traceback 日誌信息中同時輸出了當時的變量值，如下：</p>
<p><img src="python/images/71b813bfc6a87acc6db846995ef3.png" alt="img" /></p>
<p>在 2021-3-28.log 日誌文件中也同樣輸出了上述格式的異常追溯信息，如下。</p>
<pre><code>2021-03-28 13:57:13.852 | ERROR    | __main__:&lt;module&gt;:16 - An error has been caught in function '&lt;module&gt;', process 'MainProcess' (7080), thread 'MainThread' (32280):
Traceback (most recent call last):

&gt; File &quot;F:/code/MOC/2021-3-28.py&quot;, line 16, in &lt;module&gt;
    index_error([1,2,3])
    └ &lt;function index_error at 0x000001FEB84D0EE8&gt;

  File &quot;F:/code/MOC/2021-3-28.py&quot;, line 9, in index_error
    index_value = custom_list[index]
                  │           └ 2
                  └ [2, 3]

IndexError: list index out of range
</code></pre>
<hr />
<p>同時，附上對類中的類方法和靜態方法的代碼實例，以供參考</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log')

class Demo:
    @logger.catch
    def index_error(self, custom_list: list):
        for index in range(len(custom_list)):
            index_value = custom_list[index]
            if custom_list[index] &lt; 2:
                custom_list.remove(index_value)

    @staticmethod
    @logger.catch
    def index_error_static(custom_list: list):
        for index in range(len(custom_list)):
            index_value = custom_list[index]
            if custom_list[index] &lt; 2:
                custom_list.remove(index_value)


if __name__ == '__main__':
    # Demo().index_error([1, 2, 3])
    Demo.index_error_static([1, 2, 3])
</code></pre>
<p>通過 logger.exception 方法也可以實現異常的捕獲與記錄：</p>
<pre><code class="language-python">from loguru import logger

trace = logger.add('2021-3-28.log')

def index_error(custom_list: list):
    for index in range(len(custom_list)):
        try:
            index_value = custom_list[index]
        except IndexError as  err:
            logger.exception(err)
            break

        if custom_list[index] &lt; 2:
            custom_list.remove(index_value)


if __name__ == '__main__':
    index_error([1, 2, 3])
</code></pre>
<p>運行上述代碼，我們可以發現 loguru 輸出的 Traceback 日誌信息， Traceback 日誌信息中同時輸出了當時的變量值，如下：</p>
<p><img src="python/images/48110857b7da2ded984c6fd87bec1.jpg" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-websocket長連接心跳與短連接"><a class="header" href="#python-websocket長連接心跳與短連接">Python WebSocket長連接心跳與短連接</a></h1>
<p><strong>安裝</strong></p>
<pre><code>pip install websocket-client
</code></pre>
<p>先來看一下，長連接調用方式：</p>
<pre><code class="language-python">ws = websocket.WebSocketApp(
    &quot;ws://echo.websocket.org/&quot;,
    on_message=on_message,
    on_error=on_error,
    on_close=on_close,
)
ws.on_open = on_open
ws.run_forever()
</code></pre>
<p><strong>長連接，參數介紹：</strong></p>
<p>（1）url: websocket的地址。</p>
<p>（2）header: 客戶發送websocket握手請求的請求頭，{'head1:value1','head2:value2'}。</p>
<p>（3）on_open：在建立Websocket握手時調用的可調用對象，這個方法只有一個參數，就是該類本身。</p>
<p>（4）on_message：這個對像在接收到服務器返回的消息時調用。有兩個參數，一個是該類本身，一個是我們從服務器獲取的字符串（utf-8格式）。</p>
<p>（5）on_error：這個對像在遇到錯誤時調用，有兩個參數，第一個是該類本身，第二個是異常對象。</p>
<p>（6）on_close：在遇到連接關閉的情況時調用，參數只有一個，就是該類本身。</p>
<p>（7）on_cont_message：這個對像在接收到連續幀數據時被調用，有三個參數，分別是：類本身，從服務器接受的字符串（utf-8），連續標志。</p>
<p>（8）on_data：當從服務器接收到消息時被調用，有四個參數，分別是：該類本身，接收到的字符串（utf-8），數據類型，連續標志。</p>
<p>（9）keep_running：一個二進制的標志位，如果為True，這個app的主循環將持續運行，默認值為True。</p>
<p>（10）get_mask_key：用於產生一個掩碼。</p>
<p>（11）subprotocols：一組可用的子協議，默認為空。</p>
<p>**長連接關鍵方法：**ws.run_forever(ping_interval=60,ping_timeout=5)</p>
<p>如果不斷開關閉websocket連接，會一直阻塞下去。另外這個函數帶兩個參數，如果傳的話，啟動心跳包發送。</p>
<p>ping_interval:自動發送“ping”命令，每個指定的時間(秒),如果設置為0，則不會自動發送。</p>
<p>ping_timeout:如果沒有收到pong消息，則為超時(秒)。</p>
<pre><code class="language-python">ws.run_forever(ping_interval=60, ping_timeout=5)
# ping_interval心跳發送間隔時間
# ping_timeout 設置，發送ping到收到pong的超時時間
</code></pre>
<p><strong>我們看源代碼，會發現這樣一斷代碼：</strong></p>
<p>ping的超時時間，要大於ping間隔時間</p>
<pre><code class="language-python">if not ping_timeout or ping_timeout &lt;= 0:
    ping_timeout = None
if ping_timeout and ping_interval and ping_interval &lt;= ping_timeout:
    raise WebSocketException(&quot;Ensure ping_interval &gt; ping_timeout&quot;)
</code></pre>
<p><strong>長連接：</strong></p>
<p><strong>示例1：</strong></p>
<pre><code class="language-python">import websocket

try:
    import thread
except ImportError:
    import _thread as thread
import time


def on_message(ws, message):
    print(message)


def on_error(ws, error):
    print(error)


def on_close(ws):
    print(&quot;### closed ###&quot;)


def on_open(ws):
    def run(*args):
        ws.send(&quot;hello1&quot;)
        time.sleep(1)
        ws.close()

    thread.start_new_thread(run, ())


if __name__ == &quot;__main__&quot;:
    websocket.enableTrace(True)
    ws = websocket.WebSocketApp(
        &quot;ws://echo.websocket.org/&quot;,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
    )
    ws.on_open = on_open
    ws.run_forever(ping_interval=60, ping_timeout=5)
</code></pre>
<p><strong>示例2：</strong></p>
<pre><code class="language-python">import websocket
from threading import Thread
import time
import sys


class MyApp(websocket.WebSocketApp):
    def on_message(self, message):
        print(message)

    def on_error(self, error):
        print(error)

    def on_close(self):
        print(&quot;### closed ###&quot;)

    def on_open(self):
        def run(*args):
            for i in range(3):
                # send the message, then wait
                # so thread doesn't exit and socket
                # isn't closed
                self.send(&quot;Hello %d&quot; % i)
                time.sleep(1)

            time.sleep(1)
            self.close()
            print(&quot;Thread terminating...&quot;)

        Thread(target=run).start()


if __name__ == &quot;__main__&quot;:
    websocket.enableTrace(True)
    if len(sys.argv) &lt; 2:
        host = &quot;ws://echo.websocket.org/&quot;
    else:
        host = sys.argv[1]
    ws = MyApp(host)
    ws.run_forever()
</code></pre>
<p><strong>短連接：</strong></p>
<pre><code class="language-python">from websocket import create_connection
ws = create_connection(&quot;ws://echo.websocket.org/&quot;)
print(&quot;Sending 'Hello, World'...&quot;)
ws.send(&quot;Hello, World&quot;)
print(&quot;Sent&quot;)
print(&quot;Receiving...&quot;)
result =  ws.recv()
print(&quot;Received '%s'&quot; % result)
ws.close()
</code></pre>
<p>出處</p>
<p>https://www.bbsmax.com/A/pRdBKapazn/</p>
<hr />
<h2 id="python-websocket-斷線自動重連"><a class="header" href="#python-websocket-斷線自動重連">python websocket 斷線自動重連</a></h2>
<p>先定義連接函數</p>
<pre><code class="language-python">def connection_tmp(ws):
    websocket.enableTrace(True)
    ws = websocket.WebSocketApp(&quot;ws://localhost:8000/ws&quot;,
                              on_message = on_message,
                            #   on_data=on_data_test,
                              on_error = on_error,
                              on_close = on_close)
    
    ws.on_open = on_open
    try:
        ws.run_forever()
    except KeyboardInterrupt:
        ws.close()  
    except:
        ws.close() 
</code></pre>
<p>再定義錯誤函數</p>
<pre><code class="language-python">def on_error(ws, error):

    global reconnect_count
    print(type(error))
    print(error)
    if type(error)==ConnectionRefusedError or type(error)==websocket._exceptions.WebSocketConnectionClosedException:
        print(&quot;正在嘗試第%d次重連&quot;%reconnect_count)
        reconnect_count+=1
        if reconnect_count&lt;100:
            connection_tmp(ws)
    else:
        print(&quot;其他error!&quot;)
</code></pre>
<p>設置屬性全部global即可</p>
<pre><code class="language-python">global reconnect_count
global ws
ws=None
reconnect_count=0
&lt;class 'websocket._exceptions.WebSocketConnectionClosedException'&gt;
Connection is already closed.
正在嘗試第4次重連
&lt;class 'KeyboardInterrupt'&gt;

其他error!
### closed ###!
### closed ###!
### closed ###!
### closed ###!
### closed ###!
### closed ###!
</code></pre>
<p>出處</p>
<p>https://www.cxybb.com/article/u013673826/105605631</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bloomrpc"><a class="header" href="#bloomrpc">bloomrpc</a></h1>
<pre><code class="language-python"># Copyright 2015 gRPC authors.
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&quot;&quot;&quot;The Python implementation of the GRPC helloworld.Greeter server.&quot;&quot;&quot;

from concurrent import futures
import logging

import grpc
import helloworld_pb2
import helloworld_pb2_grpc


class Greeter(helloworld_pb2_grpc.GreeterServicer):

    def SayHello(self, request, context):
        return helloworld_pb2.HelloReply(message='Hello, %s!' % request.name)


def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    server.wait_for_termination()


if __name__ == '__main__':
    logging.basicConfig()
    serve()
</code></pre>
<pre><code class="language-protobuf">// Copyright 2021 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = &quot;proto3&quot;;

package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>
<pre><code class="language-shell">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. helloworld.proto 
</code></pre>
<p>客戶端就用 bloomrpc，不另外寫程式碼了。匯入對應的 <a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">proto</a> 檔案，向 localhost:50051 傳送請求驗證服務有沒有正常工作：</p>
<p><img src="python/images/BloomRPC_001.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrentfutures-平行任務處理"><a class="header" href="#concurrentfutures-平行任務處理">concurrent.futures 平行任務處理</a></h1>
<p>出處: https://steam.oxxostudio.tw/category/python/library/concurrent-futures.html</p>
<p>Python 在執行時，通常是採用同步的任務處理模式 ( 一個處理完成後才會接下去處理第二個 )，然而 Python 的標準函式「concurrent.futures」，提供了平行任務處理 ( 非同步 ) 的功能，能夠同時處理多個任務，這篇教學會介紹 concurrent.futures 的用法。</p>
<blockquote>
<p>本篇使用的 Python 版本為 3.7.12，<em>所有範例可使用 <a href="https://colab.research.google.com/notebooks/welcome.ipynb?hl=zh_tw">Google Colab</a> 實作</em>，不用安裝任何軟體 ( 參考：<a href="https://steam.oxxostudio.tw/category/python/info/online-editor.html">使用 Google Colab</a> )</p>
</blockquote>
<h2 id="同步與非同步"><a class="header" href="#同步與非同步">同步與非同步</a></h2>
<p>同步和非同步的常見說法是：「<em>同步模式下，每個任務必須按照順序執行，後面的任務必須等待前面的任務執行完成，在非同步模式下，後面的任務不用等前面的，各自執行各自的任務</em>」，也可以想像成「<em>同一個步道 vs 不同步道</em>」，透過步道的方式，會更容易明白同步和非同步。( 因為有時會將同步與非同步的中文字面意思，想成「一起走」或「不要一起走」，很容易搞錯 )</p>
<blockquote>
<ul>
<li><em>同步：「同一個步道」，只能依序排隊前進</em>。</li>
<li><em>非同步：「不 ( 非 ) 同步道」，可以各走各的</em>。</li>
</ul>
</blockquote>
<p><img src="python/images/concurrent-futures-01.webp" alt="" /></p>
<h2 id="thread-和-process"><a class="header" href="#thread-和-process">Thread 和 Process</a></h2>
<p>concurrent.futures 提供了 <em>ThreadPoolExecutor</em> 和 <em>ProcessPoolExecutor</em> 兩種可以平行處理任務的實作方法，ThreadPoolExecutor 是針對 Thread ( 執行緒 )，ProcessPoolExecutor 是針對 Process ( 程序 )，下方是 Thread 和 Process 的簡單差異說明：</p>
<table><thead><tr><th>英文</th><th>中文</th><th>說明</th></tr></thead><tbody>
<tr><td>Thread</td><td>執行緒</td><td>程式執行任務的基本單位。</td></tr>
<tr><td>Process</td><td>程序</td><td>啟動應用程式時產生的執行實體，需要一定的 CPU 與記憶體資源，Process 由一到多個 Thread 組成，同一個 Process 裡的 Thread 可以共用記憶體資源。</td></tr>
</tbody></table>
<h2 id="import-concurrentfutures"><a class="header" href="#import-concurrentfutures">import concurrent.futures</a></h2>
<p>要使用 concurrent.futures 必須先 import concurrent.futures 模組，或使用 from 的方式，單獨 import 特定的類型。</p>
<blockquote>
<p>更多資訊可以參考 Python 官方文件：<a href="https://docs.python.org/zh-tw/3/library/concurrent.futures.html">concurrent.futures 啟動平行任務</a></p>
</blockquote>
<pre><code class="language-py">import concurrent.futures
from concurrent.futures import ThreadPoolExecutor
</code></pre>
<h2 id="threadpoolexecutor"><a class="header" href="#threadpoolexecutor">ThreadPoolExecutor</a></h2>
<p><em>ThreadPoolExecutor 會透過 Thread 的方式建立多個 Executors ( 執行器 ) ，執行並處理多個任務 ( tasks )</em>，ThreadPoolExecutor 有四個參數，最常用的為 max_workers：</p>
<table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><em>max_workers</em></td><td>Thread 的數量，預設 5 ( CPU number * 5，每個 CPU 可以處理 5 個 Thread)，數量越多，運行速度會越快，如果設定小於等於 0 會發生錯誤。</td></tr>
<tr><td><em>thread_name_prefix</em></td><td>Thread 的名稱，預設 ''。</td></tr>
<tr><td><em>initializer</em></td><td>每個 Thread 啟動時調用的可調用對象，預設 None。</td></tr>
<tr><td><em>initargs</em></td><td>傳遞給初始化程序的參數，使用 tuple，預設 ()。</td></tr>
</tbody></table>
<p>使用 ThreadPoolExecutor 後，就能使用 Executors 的相關方法：</p>
<table><thead><tr><th>方法</th><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><em>submit</em></td><td>fn, *args, **kwargs</td><td>執行某個函式。</td></tr>
<tr><td><em>map</em></td><td>func, *iterables</td><td>使用 map 的方式，使用某個函式執行可迭代的內容。</td></tr>
<tr><td><em>shutdown</em></td><td>wait</td><td>完成執行後回傳信號，釋放正在使用的任何資源，wait 預設 True 會在所有對象完成後才回傳信號，wait 設定 False 則會在執行後立刻回傳。</td></tr>
</tbody></table>
<p>舉例來說，下方的程式碼執行後，會按照順序 ( 同步 ) 顯示出數字，前一個任務尚未處理完，就不會執行後續的工作。</p>
<pre><code class="language-py">import time
def test(n):
    for i in range(n):
        print(i, end=' ')
        time.sleep(0.2)

test(2)
test(3)
test(4)

# 0 1 0 1 2 0 1 2 3
</code></pre>
<p>如果改成 ThreadPoolExecutor 的方式，就會發現三個函式就會一起進行 ( 如果執行的函式大於 5，可再設定 max_workers 的數值 )。</p>
<pre><code class="language-py">import time
from concurrent.futures import ThreadPoolExecutor

def test(n):
    for i in range(n):
        print(i, end=' ')
        time.sleep(0.2)

executor = ThreadPoolExecutor()  # 設定一個執行 Thread 的啟動器

a = executor.submit(test, 2)     # 啟動第一個 test 函式
b = executor.submit(test, 3)     # 啟動第二個 test 函式
c = executor.submit(test, 4)     # 啟動第三個 test 函式
executor.shutdown()              # 關閉啟動器 ( 如果沒有使用，則啟動器會處在鎖住的狀態而無法繼續 )

# 0 0 0 1 1 1 2 2 3
</code></pre>
<p>上述的做法，可以改用 <em>with...as</em> 的方式 ( 有點類似 <a href="https://steam.oxxostudio.tw/category/python/basic/builtin-open.html#a5">open 的 with</a> )。</p>
<pre><code class="language-py">import time
from concurrent.futures import ThreadPoolExecutor

def test(n):
    for i in range(n):
        print(i, end=' ')
        time.sleep(0.2)

with ThreadPoolExecutor() as executor:    # 改用 with...as
    executor.submit(test, 2)
    executor.submit(test ,3)
    executor.submit(test, 4)

# 0 0 0 1 1 1 2 2 3
</code></pre>
<p>上述的範例，也可以改用 <em>map</em> 的做法：</p>
<pre><code class="language-py">import time
from concurrent.futures import ThreadPoolExecutor

def test(n):
    for i in range(n):
        print(i, end=' ')
        time.sleep(0.2)

with ThreadPoolExecutor() as executor:
    executor.map(test, [2,3,4])

# 0 0 0 1 1 1 2 2 3
</code></pre>
<h2 id="輸入文字停止函式執行"><a class="header" href="#輸入文字停止函式執行">輸入文字，停止函式執行</a></h2>
<p>透過平行任務處理的方法，就能輕鬆做到「輸入文字，停止正在執行的函式」，以下方的例子而言，<em>run 是一個具有「無窮迴圈」的函式，如果不使用平行任務處理，在 run 後方的程式都無法運作 ( 會被無窮迴圈卡住 )，而 keyin 是一個具有「input」指令的函式，如果不使用平行任務處理，在 keyin 後方的程式也無法運作 ( 會被 input 卡住 )</em>，因此如果使用 concurrent.futures，就能讓兩個函式同時運行，搭配全域變數的做法，就能在輸入特定指令時，停止另外函式的運作。</p>
<pre><code class="language-py">import time
from concurrent.futures import ThreadPoolExecutor

a = True               # 定義 a 為 True

def run():
    global a           # 定義 a 是全域變數
    while a:           # 如果 a 為 True
        print(123)     # 不斷顯示 123
        time.sleep(1)  # 每隔一秒

def keyin():
    global a           # 定義 a 是全域變數
    if input() == 'a':
        a = False      # 如果輸入的是 a，就讓 a 為 False，停止 run 函式中的迴圈

executor = ThreadPoolExecutor()
e1 = executor.submit(run)
e2 = executor.submit(keyin)
executor.shutdown()
</code></pre>
<h2 id="processpoolexecutor"><a class="header" href="#processpoolexecutor">ProcessPoolExecutor</a></h2>
<p><em>ProcessPoolExecutor 會透過 Process 的方式建立多個 Executors ( 執行器 )，執行並處理多個程序</em>，ProcessPoolExecutor 有四個參數，最常用的為 max_workers：</p>
<table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><em>max_workers</em></td><td>Process 的數量，預設為機器的 CPU 數量，如果 max_workers 小於等於 0 或大於等於 61 會發生錯誤。</td></tr>
<tr><td><em>thread_name_prefix</em></td><td>Thread 的名稱，預設 ''。</td></tr>
<tr><td><em>initializer</em></td><td>每個 Thread 啟動時調用的可調用對象，預設 None。</td></tr>
<tr><td><em>initargs</em></td><td>傳遞給初始化程序的參數，使用 tuple，預設 ()。</td></tr>
</tbody></table>
<p>使用 ProcessPoolExecutor 後，就能使用 Executors 的相關方法：</p>
<table><thead><tr><th>方法</th><th>參數</th><th>說明</th></tr></thead><tbody>
<tr><td><em>submit</em></td><td>fn, *args, **kwargs</td><td>執行某個函式。</td></tr>
<tr><td><em>map</em></td><td>func, *iterables</td><td>使用 map 的方式，使用某個函式執行可迭代的內容。</td></tr>
<tr><td><em>shutdown</em></td><td>wait</td><td>完成執行後回傳信號，釋放正在使用的任何資源，wait 預設 True 會在所有對象完成後才回傳信號，wait 設定 False 則會在執行後立刻回傳。</td></tr>
</tbody></table>
<p>ProcessPoolExecutor 的用法基本上和 ThreadPoolExecutor 很像，但 ProcessPoolExecutor 主要會用做處理比較需要運算的程式，ThreadPoolExecutor 會使用於等待輸入和輸出 ( I/O ) 的程式，兩者執行後也會有些差別，ProcessPoolExecutor 執行後最後是顯示運算結果，而 ThreadPoolExecutor 則是顯示過程。</p>
<pre><code class="language-py">import time
from concurrent.futures import ProcessPoolExecutor

def test(n):
    for i in range(n):
        print(i, end=' ')
        time.sleep(0.2)
    print()

with ProcessPoolExecutor() as executor:
    executor.map(test, [4,5,6])
</code></pre>
<p><img src="https://steam.oxxostudio.tw/webp/python/library/concurrent-futures-02.gif" alt="Python 教學 - concurrent.futures 平行任務處理" /></p>
<p>如果是使用 ThreadPoolExecutor 則會如下圖的結果：</p>
<p><img src="https://steam.oxxostudio.tw/webp/python/library/concurrent-futures-03.gif" alt="Python 教學 - concurrent.futures 平行任務處理" /></p>
<p>此外，Python 3.5 之後 map() 方法多了 chunksize 參數可以使用，該參數只對 ProcessPoolExecutor 有效，可以提升處理大量可迭代物件的執行效能，chunksize 預設 1，數值越大效能越好 ( 以電腦本身 CPU 的效能為主 )。</p>
<pre><code class="language-py">import time
from concurrent.futures import ProcessPoolExecutor

def test(n):
    for i in range(n):
        print(i, end=' ')
        time.sleep(0.2)
    print()

with ProcessPoolExecutor() as executor:
    executor.map(test, [4,5,6], chunksize=5)  # 設定 chunksize
</code></pre>
<h2 id="小結-3"><a class="header" href="#小結-3">小結</a></h2>
<p>Python 的 concurrent.futures 內建函式庫是一個相當方便的函式庫，不僅可以讓原本同步的執行變成非同步，大幅減少工作時間，用法上也比使用 multiprocessing、threading、asyncio 容易得多，是相當推薦的內建函式庫。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">from multiprocessing import Process
from datetime import datetime
import time
import os

from schedule import Scheduler

class MPScheduler(Scheduler):
    def __init__(self, args=None, kwargs=None):
        if args is None:
            args = ()
        if kwargs is None:
            kwargs = {}
        super(MPScheduler, self).__init__(*args, **kwargs)
        # Among other things, this object inherits self.jobs (a list of jobs)
        self.args = args
        self.kwargs = kwargs
        self.processes = list()

    def _mp_run_job(self, job_func):
        &quot;&quot;&quot;Spawn another process to run the job; multiprocessing avoids GIL issues&quot;&quot;&quot;
        job_process = Process(target=job_func, args=self.args,
            kwargs=self.kwargs)
        job_process.daemon = True
        job_process.start()
        self.processes.append(job_process)

    def run_pending(self):
        &quot;&quot;&quot;Run any jobs which are ready&quot;&quot;&quot;
        runnable_jobs = (job_obj for job_obj in self.jobs if job_obj.should_run)
        for job_obj in sorted(runnable_jobs):
            job_obj.last_run = datetime.now()   # Housekeeping
            self._mp_run_job(job_obj.job_func)
            job_obj._schedule_next_run()        # Schedule the next execution datetime

        self._retire_finished_processes()

    def _retire_finished_processes(self):
        &quot;&quot;&quot;Walk the list of processes and retire finished processes&quot;&quot;&quot;
        retirement_list = list()   # List of process objects to remove
        for idx, process in enumerate(self.processes):
            if process.is_alive():
                # wait a short time for process to finish
                process.join(0.01)
            else:
                retirement_list.append(idx)

        ## Retire finished processes
        for process_idx in sorted(retirement_list, reverse=True):
            self.processes.pop(process_idx)

def job(id, hungry=True):
    print(&quot;{} running {} and hungry={}&quot;.format(datetime.now(), id, hungry))
    time.sleep(10)   # This job runs without blocking execution of other jobs

if __name__=='__main__':
    # Build a schedule of overlapping jobs...
    mp_sched = MPScheduler()
    mp_sched.every(1).seconds.do(job, id=1, hungry=False)
    mp_sched.every(2).seconds.do(job, id=2)
    mp_sched.every(3).seconds.do(job, id=3)
    mp_sched.every(4).seconds.do(job, id=4)
    mp_sched.every(5).seconds.do(job, id=5)

    while True:
        mp_sched.run_pending()
        time.sleep(1)
</code></pre>
<h1 id="parallel-execution"><a class="header" href="#parallel-execution">Parallel execution</a></h1>
<p>https://schedule.readthedocs.io/en/stable/parallel-execution.html</p>
<p><em>am trying to execute 50 items every 10 seconds, but from the my logs it says it executes every item in 10 second schedule serially, is there a work around?</em></p>
<p>By default, schedule executes all jobs serially. The reasoning behind this is that it would be difficult to find a model for parallel execution that makes everyone happy.</p>
<p>You can work around this limitation by running each of the jobs in its own thread:</p>
<pre><code class="language-python">import threading
import time
import schedule

def job():
    print(&quot;I'm running on thread %s&quot; % threading.current_thread())

def run_threaded(job_func):
    job_thread = threading.Thread(target=job_func)
    job_thread.start()

schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)


while 1:
    schedule.run_pending()
    time.sleep(1)
</code></pre>
<p>If you want tighter control on the number of threads use a shared jobqueue and one or more worker threads:</p>
<pre><code class="language-python">import time
import threading
import schedule
import queue

def job():
    print(&quot;I'm working&quot;)


def worker_main():
    while 1:
        job_func = jobqueue.get()
        job_func()
        jobqueue.task_done()

jobqueue = queue.Queue()

schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)

worker_thread = threading.Thread(target=worker_main)
worker_thread.start()

while 1:
    schedule.run_pending()
    time.sleep(1)
</code></pre>
<p>This model also makes sense for a distributed application where the workers are separate processes that receive jobs from a distributed work queue. I like using beanstalkd with the beanstalkc Python library.</p>
<h1 id="python-任務調度之-schedule"><a class="header" href="#python-任務調度之-schedule">python 任務調度之 schedule</a></h1>
<p>http://puremonkey2010.blogspot.com/2019/05/python-python-schedule.html</p>
<p>在工作中多少都會涉及到一些定時任務，比如定時郵件提醒等.本文通過開源項目 <a href="https://github.com/dbader/schedule"><strong>schedule</strong></a> 來學習定時任務調度是如何工作的，以及基於此實現一個 web 版本的提醒工具. </p>
<pre><code class="language-py">import threading
import schedule
import time


def job():
    print(f&quot;I'm working... ThreadID:{threading.get_ident()}&quot;)


schedule.every(1).seconds.do(job)
schedule.every(10).minutes.do(job)
schedule.every().hour.do(job)
schedule.every().day.at(&quot;10:30&quot;).do(job)
schedule.every(5).to(10).minutes.do(job)
schedule.every().monday.do(job)
schedule.every().wednesday.at(&quot;13:15&quot;).do(job)
# schedule.every().day.at(&quot;12:42&quot;, &quot;Europe/Amsterdam&quot;).do(job)
schedule.every().minute.at(&quot;:17&quot;).do(job)


def job_with_argument(name):
    print(f&quot;I am {name} ThreadID:{threading.get_ident()}&quot;)


schedule.every(5).seconds.do(job_with_argument, name=&quot;Peter&quot;)

while True:
    schedule.run_pending()
    time.sleep(1)

</code></pre>
<pre><code class="language-py">import schedule  
import time  
  
def job():  
    print(&quot;I'm working...&quot;)  
  
schedule.every(10).minutes.do(job)  
schedule.every().hour.do(job)  
schedule.every().day.at(&quot;10:30&quot;).do(job)  
schedule.every().monday.do(job)  
schedule.every().wednesday.at(&quot;13:15&quot;).do(job)  
  
while True:  
    schedule.run_pending()  
    time.sleep(1)  
</code></pre>
<pre><code>每隔10分鐘執行一次任務
每隔一小時執行一次任務
每天10:30執行一次任務
每週一的這個時候執行一次任務
每週三13:15執行一次任務
</code></pre>
<pre><code class="language-py">class Scheduler(object):  
    &quot;&quot;&quot;  
    Objects instantiated by the :class:`Scheduler ` are  
    factories to create jobs, keep record of scheduled jobs and  
    handle their execution.  
    &quot;&quot;&quot;  
    def __init__(self):  
        self.jobs = []  
  
    def run_pending(self):  
        runnable_jobs = (job for job in self.jobs if job.should_run)  
        for job in sorted(runnable_jobs):  
            self._run_job(job)  
  
    def run_all(self, delay_seconds=0):  
        logger.info('Running *all* %i jobs with %is delay inbetween',  
                    len(self.jobs), delay_seconds)  
        for job in self.jobs[:]:  
            self._run_job(job)  
            time.sleep(delay_seconds)  
  
    def clear(self, tag=None):  
        if tag is None:  
            del self.jobs[:]  
        else:  
            self.jobs[:] = (job for job in self.jobs if tag not in job.tags)  
  
    def cancel_job(self, job):  
        try:  
            self.jobs.remove(job)  
        except ValueError:  
            pass  
  
    def every(self, interval=1):  
        job = Job(interval, self)  
        return job  
  
    def _run_job(self, job):  
        ret = job.run()  
        if isinstance(ret, CancelJob) or ret is CancelJob:  
            self.cancel_job(job)  
  
    @property  
    def next_run(self):  
        if not self.jobs:  
            return None  
        return min(self.jobs).next_run  
  
    @property  
    def idle_seconds(self):  
        return (self.next_run - datetime.datetime.now()).total_seconds()  

</code></pre>
<p><strong>Scheduler</strong> 作用就是在 job 可以執行的時候執行它. 這裡的函數也都比較簡單: </p>
<blockquote>
<p>*** run_pending:** 運行所有可以運行的任務
*** run_all:** 運行所有任務,不管是否應該運行
*** clear:** 刪除所有調度的任務
*** cancel_job:** 刪除一個任務
*** every:** 創建一個調度任務, 返回的是一個 <strong>Job</strong> 物件
*** _run_job:** 運行一個 <strong>Job</strong> 物件
*** next_run:** 獲取下一個要運行任務的時間, 這裡使用的是 min 去得到最近將執行的 job, 之所以這樣使用，是 <strong>Job</strong> 重載了<a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__"><strong>lt</strong></a> 方法,這樣寫起來確實很簡潔.
*** idle_seconds:** 還有多少秒即將開始運行任務.</p>
</blockquote>
<p><strong>Class Job</strong> 
<strong>Job</strong> 是整個定時任務的核心. 主要功能就是根據創建 <strong>Job</strong> 時的參數, 得到下一次運行的時間. 代碼如下,稍微有點長 (會省略部分代碼，可以看 <a href="https://github.com/dbader/schedule/blob/master/schedule/__init__.py">源碼</a>). 這個類別提供的ˊ方法也不是很多, 有很多邏輯是一樣的. 簡單介紹一下建構子的參數: </p>
<blockquote>
<p>*** interval:** 間隔多久,每 interval 秒或分等.
*** job_func:** job 執行函數
*** unit :** 間隔單元，比如 minutes, hours
*** at_time:** job 具體執行時間點,比如 10:30等
*** last_run:** job上一次執行時間
*** next_run:** job下一次即將運行時間
*** period:** 距離下次運行間隔時間
*** start_day:** 週的特殊天，也就是 monday 等的含義</p>
</blockquote>
<p>再來看一下幾個重要的方法: 
*** <strong>lt</strong>:** </p>
<blockquote>
<p>被使用在比較哪個 job 最先即將執行, <strong>Scheduler</strong> 中 next_run 方法裡使用 <a href="https://docs.python.org/3/library/functions.html#min">min</a> 會用到, 有時合適的使用 python 這些特殊方法可以簡化代碼，看起來更 pythonic.</p>
</blockquote>
<p>*** second、seconds:** </p>
<blockquote>
<p>second、seconds 的區別就是 second 時默認 interval ==1, 即 schedule.every().second 和 schedule.every(1).seconds 是等價的,作用就是設置 <em>unit</em> 為 seconds. minute 和 minutes、hour 和hours 、day 和 days、week 和 weeks 也類似.</p>
</blockquote>
<p>*** monday:** </p>
<blockquote>
<p><strong>設置 *start_day* 為 monday, unit 為 weeks, interval 為1 .</strong> 含義就是每週一執行 job. 類似 tuesday、wednesday、thursday、friday、saturday、sunday 一樣.</p>
</blockquote>
<p>*** at:** </p>
<blockquote>
<p>表示 <strong>某天的某個時間點</strong>，所以不適合 minutes、weeks 且 start_day 為空 (即單純的周) 這些 unit. 對於 unit 為 hours 時, <em>time_str</em> 中小時部分為 0.</p>
</blockquote>
<p>*** do:** </p>
<blockquote>
<p>設置 job 對應的函數以及參數, 這裡使用 <a href="https://docs.python.org/3/library/functools.html#functools.update_wrapper"><strong>functools</strong>.update_wrapper</a> 去更新函數名等信息.主要是 <a href="https://docs.python.org/3/library/functools.html#functools.partial"><strong>functools</strong>.partial</a> 返回的函數和原函數名稱不一樣.具體可以看看官網文檔. 然後調用 _schedule_next_run 去計算 job 下一次執行時間.</p>
</blockquote>
<p>*** should_run:** </p>
<blockquote>
<p>判斷 job 是否可以運行了.依據是當前時間點大於等於 job 的 <em>next_run</em></p>
</blockquote>
<p>*** _schedule_next_run:** </p>
<blockquote>
<p>這是整個 job 的定時的邏輯部分是計算 job 下次運行的時間點的. 這邊描述一下流程, 首先是計算下一次執行時間:</p>
<p><a href="http://localhost/jforum/posts/list/4399.page#">view plain</a><a href="http://localhost/jforum/posts/list/4399.page#">copy to clipboard</a><a href="http://localhost/jforum/posts/list/4399.page#">print</a><a href="http://localhost/jforum/posts/list/4399.page#">?</a></p>
<ol>
<li>self.period = datetime.timedelta(**{self.unit: interval}) </li>
<li>self.next_run = datetime.datetime.now() + self.period </li>
</ol>
<p>這裡根據 </p>
<p>unit</p>
<p>和 </p>
<p>interval</p>
<p>計算出下一次運行時間. 舉個例子,比如 </p>
<p>schedule.every().hour.do(job, message='things')</p>
<p>下一次運行時間就是當前時間加上一小時的間隔. 但是當 </p>
<p>start_day</p>
<p>不為空時，即表示某個星期. 這時 </p>
<p>period</p>
<p>就不能直接加在當前時間了. 看代碼:</p>
<p><a href="http://localhost/jforum/posts/list/4399.page#">view plain</a><a href="http://localhost/jforum/posts/list/4399.page#">copy to clipboard</a><a href="http://localhost/jforum/posts/list/4399.page#">print</a><a href="http://localhost/jforum/posts/list/4399.page#">?</a></p>
<ol>
<li>weekday = weekdays.index(self.start_day) </li>
<li>days_ahead = weekday - self.next_run.weekday() </li>
<li><strong>if</strong> days_ahead &lt;= 0: # Target day already happened <strong>this</strong> week </li>
<li>days_ahead += 7 </li>
<li>self.next_run += datetime.timedelta(days_ahead) - self.period </li>
</ol>
<p>其中 </p>
<p>days_ahead</p>
<p>表示 job 表示的星期幾與當表示的星期幾差幾天. 比如今天是 星期三，job 表示的是 星期五,那麼 </p>
<p>days_ahead</p>
<p>就為2，最終 </p>
<p>self.next_run</p>
<p>效果就是在 now 基礎上加了2天.</p>
<p>接著當 </p>
<p>at_time</p>
<p>不為空時, 需要更新執行的時間點,具體就是計算時、分、秒然後調用 replace 進行更新.</p>
</blockquote>
<p><strong>Real User Cases</strong> 
這邊介紹實際使用範例. </p>
<p><strong>在 *N* 小時/分鐘 後執行並只一次</strong> 
這個範例很像 Linux 命令 <a href="https://linux.die.net/man/1/at"><strong>at</strong></a> 的功能, 簡單來說就是延遲一段時間後再執行某個 job. 這邊我們會繼承 <strong>Job</strong> 並客製成我們需要的功能 <strong>MyJob</strong> 類別: 
<strong>- test_run_after.py</strong> </p>
<pre><code class="language-py">#!/usr/bin/env python3  
import schedule  
import logging  
import functools  
import os  
import re  
import time  
from schedule import Job, CancelJob, IntervalError  
from datetime import datetime, timedelta  
  
logging.basicConfig(level=logging.INFO)  
logger = logging.getLogger(os.path.basename(__file__))  
logger.setLevel(20)  
  
class MyJob(Job):  
    def __init__(self, scheduler=None):  
        super(MyJob, self).__init__(1, scheduler)  
        self.regex = re.compile(r'((?P\d+?)hr)?((?P\d+?)m)?((?P\d+?)s)?')  
  
    def parse_time(self, time_str):  
        # https://stackoverflow.com/questions/4628122/how-to-construct-a-timedelta-object-from-a-simple-string  
        parts = self.regex.match(time_str)  
        if not parts:  
            raise IntervalError()  
  
        parts = parts.groupdict()  
        time_params = {}  
        for (name, param) in parts.items():  
            if param:  
                time_params[name] = int(param)  
  
        return timedelta(**time_params)  
  
    def do(self, job_func, *args, **kwargs):  
        self.job_func = functools.partial(job_func, *args, **kwargs)  
        try:  
            functools.update_wrapper(self.job_func, job_func)  
        except AttributeError:  
            # job_funcs already wrapped by functools.partial won't have  
            # __name__, __module__ or __doc__ and the update_wrapper()  
            # call will fail.  
            pass  
  
        self.scheduler.jobs.append(self)  
        return self  
  
    def after(self, atime):  
        if isinstance(atime, timedelta):  
            self.next_run = datetime.now() + atime  
        elif isinstance(atime, str):  
            times = atime.split(':')  
            if len(times) == 3:  # HH:MM:SS  
                self.next_run = datetime.now() + timedelta(hours=int(times[0]), minutes=int(times[1]), seconds=int(times[2]))  
            else:  
                self.next_run = datetime.now() + self.parse_time(atime)  
        else:  
            raise IntervalError()  
  
        return self  
  
    def run(self):  
        logger.info('Running job %s', self)  
        ret = self.job_func()  
        self.last_run = datetime.now()  
        return CancelJob()  
  
def main():  
    def work():  
        logger.info('Work done at {}'.format(datetime.now()))  
  
    myjob = MyJob(schedule.default_scheduler)  
    myjob.after('2m').do(work)  # Do work after 2 minutes  
  
    logger.info('Now is {}'.format(datetime.now()))  
    while len(schedule.default_scheduler.jobs) &gt; 0:  
        schedule.run_pending()  
        time.sleep(1)  
  
    logger.info('All job done!')  
  
  
if __name__ == '__main__':  
    main()  
</code></pre>
<p>Execution result: </p>
<pre><code class="language-sh">**#** ./test_run_after.py
INFO:test_run_after.py:Now is 2019-05-23 13:57:06.289055
INFO:test_run_after.py:Running job functools.partial(.work at 0x7f7d85a43950&gt;)
INFO:test_run_after.py:Work done at 2019-05-23 13:59:06.438432
INFO:test_run_after.py:All job done!
</code></pre>
<hr />
<p>https://zhuanlan.zhihu.com/p/537722631</p>
<h2 id="安裝-2"><a class="header" href="#安裝-2">安裝</a></h2>
<pre><code class="language-text">pip install schedule
</code></pre>
<h3 id="不適合-schedule-的情況"><a class="header" href="#不適合-schedule-的情況">不適合 schedule 的情況</a></h3>
<p>說實話，<strong>Schedule</strong>不是一個“一刀切”的調度庫。此庫旨在成為簡單調度問題的簡單解決方案。如果需要以下需求，您可能應該在其他地方尋找可用方案：</p>
<ul>
<li>作業持久性（記住重新啟動之間的計畫）</li>
<li>精確計時（亞秒級精度執行）</li>
<li>並行執行（多個執行緒）</li>
<li>本地化（時區、工作日或節假日）</li>
</ul>
<p><strong>Schedule</strong>不考慮執行作業函數所需的時間。為了保證穩定的執行計畫，您需要將長時間運行的作業移出主執行緒（計畫程式執行的位置）。有關示例實現，請參閱<a href="https://link.zhihu.com/?target=https%3A//schedule.readthedocs.io/en/stable/parallel-execution.html">平行執行</a>。</p>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<p><strong>普通方法</strong></p>
<pre><code class="language-python">import schedule
import time

def job():
    print(&quot;I'm working...&quot;)

schedule.every(10).minutes.do(job) # 每十分鐘
schedule.every().hour.do(job) # 每小時
schedule.every().day.at(&quot;10:30&quot;).do(job) # 每天10：30
schedule.every().monday.do(job) # 每月
schedule.every().wednesday.at(&quot;13:15&quot;).do(job) # 每週三 13：15
schedule.every().minute.at(&quot;:17&quot;).do(job) # 每分鐘的第17秒

while True:
    schedule.run_pending()
    time.sleep(1)
</code></pre>
<p><strong>裝飾器方法</strong></p>
<pre><code class="language-python">from schedule import every, repeat, run_pending
import time

@repeat(every(10).minutes)
def job():
    print(&quot;I am a scheduled job&quot;)

while True:
    run_pending()
    time.sleep(1)
</code></pre>
<p><strong>向任務傳參</strong></p>
<pre><code class="language-python">import schedule

def greet(name):
    print('Hello', name)

schedule.every(2).seconds.do(greet, name='Alice')
schedule.every(4).seconds.do(greet, name='Bob')

from schedule import every, repeat

@repeat(every().second, &quot;World&quot;)
@repeat(every().day, &quot;Mars&quot;)
def hello(planet):
    print(&quot;Hello&quot;, planet)
</code></pre>
<p><strong>取消任務</strong></p>
<pre><code class="language-text">import schedule

def some_task():
    print('Hello world')

job = schedule.every().day.at('22:30').do(some_task)
schedule.cancel_job(job) # 取消任務
</code></pre>
<p><strong>只運行某任務一次</strong></p>
<pre><code class="language-python">import schedule
import time

def job_that_executes_once():
    # Do some work that only needs to happen once...
    return schedule.CancelJob # 通過返回schedule.CancelJob，將其在 scheduler 中取消

schedule.every().day.at('22:30').do(job_that_executes_once)

while True:
    schedule.run_pending()
    time.sleep(1)
</code></pre>
<p><strong>獲取所有任務</strong></p>
<p>要從調度程序中檢索所有作業，請使用 <code>schedule.get_jobs()</code></p>
<pre><code class="language-python">import schedule

def hello():
    print('Hello world')

schedule.every().second.do(hello)

all_jobs = schedule.get_jobs()
</code></pre>
<p><strong>取消所有任務</strong></p>
<p>要從調度程序中刪除所有作業，請使用 <code>schedule.clear()</code></p>
<pre><code class="language-text">import schedule

def greet(name):
    print('Hello {}'.format(name))

schedule.every().second.do(greet)

schedule.clear()
</code></pre>
<p><strong>獲得多個工作，按標籤過濾</strong></p>
<p>您可以從調度程序中檢索一組作業，並通過唯一識別碼選擇它們。</p>
<pre><code class="language-python">import schedule

def greet(name):
    print('Hello {}'.format(name))

schedule.every().day.do(greet, 'Andrea').tag('daily-tasks', 'friend')
schedule.every().hour.do(greet, 'John').tag('hourly-tasks', 'friend')
schedule.every().hour.do(greet, 'Monica').tag('hourly-tasks', 'customer')
schedule.every().day.do(greet, 'Derek').tag('daily-tasks', 'guest')

friends = schedule.get_jobs('friend')
</code></pre>
<p><strong>取消多個作業，按標籤過濾</strong></p>
<pre><code class="language-python">import schedule

def greet(name):
    print('Hello {}'.format(name))

schedule.every().day.do(greet, 'Andrea').tag('daily-tasks', 'friend')
schedule.every().hour.do(greet, 'John').tag('hourly-tasks', 'friend')
schedule.every().hour.do(greet, 'Monica').tag('hourly-tasks', 'customer')
schedule.every().day.do(greet, 'Derek').tag('daily-tasks', 'guest')

schedule.clear('daily-tasks')
</code></pre>
<p><strong>以隨機間隔運行作業</strong></p>
<pre><code class="language-python">def my_job():
    print('Foo')

# Run every 5 to 10 seconds.
schedule.every(5).to(10).seconds.do(my_job)
</code></pre>
<p><strong>運行作業直到特定時間</strong></p>
<pre><code class="language-python">import schedule
from datetime import datetime, timedelta, time

def job():
    print('Boo')

# run job until a 18:30 today
schedule.every(1).hours.until(&quot;18:30&quot;).do(job)

# run job until a 2030-01-01 18:33 today
schedule.every(1).hours.until(&quot;2030-01-01 18:33&quot;).do(job)

# Schedule a job to run for the next 8 hours
schedule.every(1).hours.until(timedelta(hours=8)).do(job)

# Run my_job until today 11:33:42
schedule.every(1).hours.until(time(11, 33, 42)).do(job)

# run job until a specific datetime
schedule.every(1).hours.until(datetime(2020, 5, 17, 11, 36, 20)).do(job)
</code></pre>
<p><code>until </code>方法設定作業的截止時間。 該作業將不會在截止時間之後運行。</p>
<p><strong>距離下一次執行的時間</strong></p>
<p>使用 <code>schedule.idle_seconds()</code> 獲取下一個作業計畫運行之前的秒數。 如果下一個計畫的作業計畫在過去運行，則返回值為負。 如果沒有安排作業，則返回 <code>None</code>。</p>
<pre><code class="language-python">import schedule
import time

def job():
    print('Hello')

schedule.every(5).seconds.do(job)

while 1:
    n = schedule.idle_seconds()
    if n is None:
        # no more jobs
        break
    elif n &gt; 0:
        # sleep exactly the right amount of time
        time.sleep(n)
    schedule.run_pending()
</code></pre>
<p><strong>立即運行所有作業，無論它們的日程安排如何</strong></p>
<p>要運行所有作業，無論它們是否計畫運行，請使用 <code>schedule.run_all()</code>。 完成後會重新安排作業，就像使用 <code>run_pending()</code> 執行作業一樣。</p>
<pre><code class="language-python">import schedule

def job_1():
    print('Foo')

def job_2():
    print('Bar')

schedule.every().monday.at(&quot;12:40&quot;).do(job_1)
schedule.every().tuesday.at(&quot;16:40&quot;).do(job_2)

schedule.run_all()

# Add the delay_seconds argument to run the jobs with a number
# of seconds delay in between.
schedule.run_all(delay_seconds=10)
</code></pre>
<h2 id="在背景執行"><a class="header" href="#在背景執行">在背景執行</a></h2>
<p>不可能在背景執行 <strong>schedule</strong>。 <a href="https://link.zhihu.com/?target=https%3A//idioms.thefreedictionary.com/Out-of-the-Box">Out of the box</a> it is not possible to run the schedule in the background. 但是，您可以自己建立一個執行緒並使用它來運行作業而不會阻塞主執行緒。 這是您如何執行此操作的示例：</p>
<pre><code class="language-python">import threading
import time

import schedule


def run_continuously(interval=1):
    &quot;&quot;&quot;Continuously run, while executing pending jobs at each
    elapsed time interval.
    @return cease_continuous_run: threading. Event which can
    be set to cease continuous run. Please note that it is
    *intended behavior that run_continuously() does not run
    missed jobs*. For example, if you've registered a job that
    should run every minute and you set a continuous run
    interval of one hour then your job won't be run 60 times
    at each interval but only once.
    &quot;&quot;&quot;
    cease_continuous_run = threading.Event()

    class ScheduleThread(threading.Thread):
        @classmethod
        def run(cls):
            while not cease_continuous_run.is_set():
                schedule.run_pending()
                time.sleep(interval)

    continuous_thread = ScheduleThread()
    continuous_thread.start()
    return cease_continuous_run


def background_job():
    print('Hello from the background thread')


schedule.every().second.do(background_job)

# Start the background thread
stop_run_continuously = run_continuously()

# Do some other things...
time.sleep(10)

# Stop the background thread
stop_run_continuously.set()
</code></pre>
<h2 id="平行執行"><a class="header" href="#平行執行">平行執行</a></h2>
<p>我試圖每 10 秒執行 50 個項目，但是從我的日誌中它說它在 10 秒的計畫中連續執行每個項目，有解決方法嗎？</p>
<p>默認情況下，<strong>schedule</strong>順序執行所有作業。 這背後的原因是，很難找到一個讓每個人都滿意的平行執行模型。</p>
<p>您可以通過在其自己的執行緒中運行每個作業來解決此限制：</p>
<pre><code class="language-python">import threading
import time
import schedule

def job():
    print(&quot;I'm running on thread %s&quot; % threading.current_thread())

def run_threaded(job_func):
    job_thread = threading.Thread(target=job_func)
    job_thread.start()

schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)
schedule.every(10).seconds.do(run_threaded, job)


while 1:
    schedule.run_pending()
    time.sleep(1)
</code></pre>
<p>如果您想更嚴格地控制執行緒數，請使用共享作業佇列和一個或多個工作執行緒：</p>
<pre><code class="language-python">import time
import threading
import schedule
import queue

def job():
    print(&quot;I'm working&quot;)


def worker_main():
    while 1:
        job_func = jobqueue.get()
        job_func()
        jobqueue.task_done()

jobqueue = queue.Queue()

schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)
schedule.every(10).seconds.do(jobqueue.put, job)

worker_thread = threading.Thread(target=worker_main)
worker_thread.start()

while 1:
    schedule.run_pending()
    time.sleep(1)
</code></pre>
<p>該模型對於分佈式應用程式也很有意義，其中工作人員是從分佈式工作佇列接收作業的獨立處理程序。 我喜歡將 beanstalkd 與 beanstalkc Python 庫一起使用。</p>
<h2 id="異常處理-1"><a class="header" href="#異常處理-1">異常處理</a></h2>
<p><strong>Schedule****不會</strong>捕獲作業執行期間發生的異常。 因此，<strong>在作業執行期間拋出的任何異常都會冒泡並中斷 schedule 的 run_xyz 函數</strong>。</p>
<p>如果你想防止異常，你可以<strong>將你的工作函數包裝在一個裝飾器</strong>中，如下所示：</p>
<pre><code class="language-python">import functools

def catch_exceptions(cancel_on_failure=False):
    def catch_exceptions_decorator(job_func):
        @functools.wraps(job_func)
        def wrapper(*args, **kwargs):
            try:
                return job_func(*args, **kwargs)
            except:
                import traceback
                print(traceback.format_exc())
                if cancel_on_failure:
                    return schedule.CancelJob
        return wrapper
    return catch_exceptions_decorator

@catch_exceptions(cancel_on_failure=True)
def bad_task():
    return 1 / 0

schedule.every(5).minutes.do(bad_task)
</code></pre>
<h2 id="日誌logging"><a class="header" href="#日誌logging">日誌（Logging）</a></h2>
<p>Schedule 將消息記錄到名為 schedule 在 DEBUG 等級的 Python 記錄器。 要從 Schedule 接收日誌，請將日誌（logging）記錄等級設定為 DEBUG。</p>
<pre><code class="language-python">import schedule
import logging

logging.basicConfig()
schedule_logger = logging.getLogger('schedule')
schedule_logger.setLevel(level=logging.DEBUG)

def job():
    print(&quot;Hello, Logs&quot;)

schedule.every().second.do(job)

schedule.run_all()

schedule.clear()
</code></pre>
<p>這將生成以下日誌消息：</p>
<pre><code class="language-text">DEBUG:schedule:Running *all* 1 jobs with 0s delay in between
DEBUG:schedule:Running job Job(interval=1, unit=seconds, do=job, args=(), kwargs={})
Hello, Logs
DEBUG:schedule:Deleting *all* jobs
</code></pre>
<h3 id="自訂日誌記錄"><a class="header" href="#自訂日誌記錄">自訂日誌記錄</a></h3>
<p>向作業新增<strong>可重用</strong>日誌的最簡單方法是實現一個處理日誌的裝飾器。 例如，下面的程式碼新增了 print_elapsed_time 裝飾器：</p>
<pre><code class="language-python">import functools
import time
import schedule

# This decorator can be applied to any job function to log the elapsed time of each job
def print_elapsed_time(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_timestamp = time.time()
        print('LOG: Running job &quot;%s&quot;' % func.__name__)
        result = func(*args, **kwargs)
        print('LOG: Job &quot;%s&quot; completed in %d seconds' % (func.__name__, time.time() - start_timestamp))
        return result

    return wrapper


@print_elapsed_time
def job():
    print('Hello, Logs')
    time.sleep(5)

schedule.every().second.do(job)

schedule.run_all()
</code></pre>
<p>輸出：</p>
<pre><code class="language-text">LOG: Running job &quot;job&quot;
Hello, Logs
LOG: Job &quot;job&quot; completed in 5 seconds
</code></pre>
<h2 id="多個調度器"><a class="header" href="#多個調度器">多個調度器</a></h2>
<p>您可以根據需要從單個調度程式執行任意數量的作業。 但是，對於較大的安裝，可能需要多個調度程序。 這是支援的</p>
<pre><code class="language-python">import time
import schedule

def fooJob():
    print(&quot;Foo&quot;)

def barJob():
    print(&quot;Bar&quot;)

# Create a new scheduler
scheduler1 = schedule.Scheduler()

# Add jobs to the created scheduler
scheduler1.every().hour.do(fooJob)
scheduler1.every().hour.do(barJob)

# Create as many schedulers as you need
scheduler2 = schedule.Scheduler()
scheduler2.every().second.do(fooJob)
scheduler2.every().second.do(barJob)

while True:
    # run_pending needs to be called on every scheduler
    scheduler1.run_pending()
    scheduler2.run_pending()
    time.sleep(1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-to-draw-stock-chart-with-python"><a class="header" href="#how-to-draw-stock-chart-with-python">How To Draw Stock Chart With Python</a></h2>
<p>出處: https://pythoninoffice.com/draw-stock-chart-with-python/</p>
<p>In this tutorial, we’ll learn how to draw a stock chart with Python. Static charts are so 1990s, we don’t do it here. Instead, we’ll draw fully interactive charts using plotly.</p>
<p>UPDATED April 8, 2022 – Include a correction to hide non-trading days.</p>
<h2 id="tools-required"><a class="header" href="#tools-required">Tools Required</a></h2>
<p><strong><code>plotly</code></strong> – AWESOME charting library</p>
<p><strong><code>yfinance</code></strong> – download historical market data from Yahoo Finance</p>
<pre><code class="language-bash">pip install plotly
pip install yfinance
</code></pre>
<h2 id="download-historical-price-data-from-yahoo-finance"><a class="header" href="#download-historical-price-data-from-yahoo-finance">Download Historical Price Data From Yahoo Finance</a></h2>
<p>We are going to use the <strong><code>yfinance</code></strong> library to download Tesla stock historical (1 year) price data. <strong><code>yfinance</code></strong> makes it really simple to download stock price data from Yahoo Finance.</p>
<pre><code class="language-python">import yfinance
tsla = yfinance.Ticker('TSLA')
hist = tsla.history(period='1y')
</code></pre>
<p><img src="python/plot/../images/ngcb20" alt="img" /></p>
<p>Tesla Stock Historical Price Data</p>
<h2 id="start-with-a-simple-stock-chart-using-python"><a class="header" href="#start-with-a-simple-stock-chart-using-python">Start With A Simple Stock Chart Using Python</a></h2>
<p>In a previous tutorial, we talked about how to use <a href="https://pythoninoffice.com/python-data-visualization-exploration-plotly">Plotly Express</a>. However, due to the complexity of our stock chart, we’ll need to use the regular <strong><code>plotly</code></strong> to unlock its true power.</p>
<p>It’s kinda funny that we can use the <strong><code>.Scatter()</code></strong> to draw a line chart. The following code draws a stock price chart using the daily Close price, also note the <strong><code>mode='lines'</code></strong>. It’s also important to remember to <strong><code>.show()</code></strong> the chart after plotting otherwise we can’t see them.</p>
<p>By the way, these charts are interactive, you can hover the mouse over the chart and see the price details.</p>
<pre><code class="language-python">import plotly.graph_objects as go

fig = go.Figure(data=go.Scatter(x=hist.index,y=hist['Close'], mode='lines'))
fig.show()
</code></pre>
<p><img src="python/plot/../images/ngcb19" alt="img" /></p>
<p>Tesla Stock Historical Price Data</p>
<p>If we set the <strong><code>mode='markers'</code></strong>, then we’ll have a regular scatter (dots) plot. There’s also another <strong><code>mode='lines+markers'</code></strong> that shows both dots and lines like the below.</p>
<pre><code class="language-python">fig = go.Figure(data=go.Scatter(x=hist.index,y=hist['Close'], mode='lines+markers'))
fig.show()
</code></pre>
<p><img src="python/plot/../images/ngcb18" alt="img" /></p>
<h2 id="add-trading-volume-to-the-stock-chart"><a class="header" href="#add-trading-volume-to-the-stock-chart">Add Trading Volume To The Stock Chart</a></h2>
<p>Let’s add the trading volume to the chart. To do this, we’ll need a <strong><code>subplot</code></strong> and <strong><code>secondary_y</code></strong> axis for the volume data.</p>
<p>In general, we can use the <strong><code>figure.add_trace()</code></strong> method to add a new data series into the graph. This is something the Plotly Express has difficulty with but is very easy to achieve in <strong><code>plotly_objects</code></strong>.</p>
<p>Note that for the <strong>primary y-axis</strong> i.e. the first <strong><code>figure.add_trace()</code></strong> below, we need to include <strong><code>secondary_y=False</code></strong>, or leave it blank (so that it will default to <strong><code>False</code></strong>). For the secondary y-axis, we need to specify that <strong><code>secondary_y=True</code></strong> in the <strong><code>add_trace</code></strong> method.</p>
<pre><code class="language-python">from plotly.subplots import make_subplots

fig2 = make_subplots(specs=[[{&quot;secondary_y&quot;: True}]])
fig2.add_trace(go.Scatter(x=hist.index,y=hist['Close'],name='Price'),secondary_y=False)
fig2.add_trace(go.Bar(x=hist.index,y=hist['Volume'],name='Volume'),secondary_y=True)
fig2.show()
</code></pre>
<p><img src="python/plot/../images/ngcb17" alt="img" /></p>
<p>Although the volume data is on the secondary y-axis (see the label on the right-hand side), some of the bars are way too long and are covering the stock price graph. Let’s scale the volume bars down a little bit by setting a range for the y-axis. We can use the <strong><code>figure.update_yaxes()</code></strong> method to do that. Also, I’m going to hide the number labeling for the volume data. Again, note that we need to specify that we are operating on the secondary y-axis by setting <strong><code>secondary_y=True</code></strong> in the below code.</p>
<pre><code class="language-python">fig2.update_yaxes(range=[0,7000000000],secondary_y=True)
fig2.update_yaxes(visible=False, secondary_y=True)
</code></pre>
<p><img src="python/plot/../images/ngcb16" alt="img" /></p>
<h2 id="candlestick-chart"><a class="header" href="#candlestick-chart">Candlestick Chart</a></h2>
<p>So really, who looks at a line chart for stocks? Pros look at only the candlestick chart!</p>
<p>No problem, we can do it in the candlestick style. Instead of using the <strong><code>Scatter()</code></strong> plot and passing the ‘Close’ price to the y-axis, now we need to specify each of ‘open’, ‘high’, ‘low’ and ‘close’, also known as the “ohlc”.</p>
<pre><code class="language-python">fig3 = make_subplots(specs=[[{&quot;secondary_y&quot;: True}]])
fig3.add_trace(go.Candlestick(x=hist.index,
                              open=hist['Open'],
                              high=hist['High'],
                              low=hist['Low'],
                              close=hist['Close'],
                             ))
</code></pre>
<p><img src="python/plot/../images/ngcb15" alt="img" /></p>
<p>It’s interesting because, with the Candlestick chart, we now have another smaller chart at the bottom, this is actually called a “range slider”, and we can drag either side to zoom in/out on a certain area of the chart.</p>
<p>Let’s also add back the volume information to the chart. I don’t think the range slider is particularly useful in this case, so I’m going to hide it by using the <strong><code>figure.update_layout()</code></strong> method.</p>
<pre><code class="language-python">fig3.add_trace(go.Bar(x=hist.index, y=hist['Volume'], name='Volume'),secondary_y=True)
fig3.update_layout(xaxis_rangeslider_visible=False)
</code></pre>
<h2 id="indicators"><a class="header" href="#indicators">Indicators</a></h2>
<p>We’ll draw a simple indicator 20 Day Moving Average here to show the concept, theoretically, we can plot any indicator on the chart.</p>
<p><strong><code>pandas</code></strong> provides convenient ways to calculate time series-related metrics such as the moving average. The <strong><code>df.rolling()</code></strong> method provides “moving windows” that we can operate on. To get the average of the moving window, we just need to add the <strong><code>.mean()</code></strong> at the end of the <strong><code>rolling()</code></strong> method.</p>
<pre><code class="language-python">fig3.add_trace(go.Scatter(x=hist.index,y=hist['Close'].rolling(window=20).mean(),marker_color='blue',name='20 Day MA'))
fig3.add_trace(go.Bar(x=hist.index, y=hist['Volume'], name='Volume'),secondary_y=True)
fig3.update_layout(title={'text':'TSLA', 'x':0.5})
fig3.update_yaxes(range=[0,1000000000],secondary_y=True)
fig3.update_yaxes(visible=False, secondary_y=True)
fig3.update_layout(xaxis_rangeslider_visible=False)  #hide range slider
fig3.show()
</code></pre>
<p>We are also going to modify the volume a little bit. Right now the volume bars all have the same color. We can use different colors to distinguish between an up or down day – green for up days, and red for down days.</p>
<p>To do that, we just need to calculate the daily change (positive or negative) then insert a color column into our dataframe. Then we can pass the color information into the volume data series. The <strong><code>marker</code></strong> argument dictates how our scatter plot should look like – color, shape, size, etc.</p>
<pre><code class="language-python">hist['diff'] = hist['Close'] - hist['Open']
hist.loc[hist['diff']&gt;=0, 'color'] = 'green'
hist.loc[hist['diff']&lt;0, 'color'] = 'red'
</code></pre>
<p><img src="python/plot/../images/ngcb14" alt="img" />Add a column to indicate color</p>
<p>To put everything together:</p>
<pre><code class="language-python">fig3 = make_subplots(specs=[[{&quot;secondary_y&quot;: True}]])
fig3.add_trace(go.Candlestick(x=hist.index,
                              open=hist['Open'],
                              high=hist['High'],
                              low=hist['Low'],
                              close=hist['Close'],
                              name='Price'))
fig3.add_trace(go.Scatter(x=hist.index,y=hist['Close'].rolling(window=20).mean(),marker_color='blue',name='20 Day MA'))
fig3.add_trace(go.Bar(x=hist.index, y=hist['Volume'], name='Volume', marker={'color':hist['color']}),secondary_y=True)
fig3.update_yaxes(range=[0,700000000],secondary_y=True)
fig3.update_yaxes(visible=False, secondary_y=True)
fig3.update_layout(xaxis_rangeslider_visible=False)  #hide range slider
fig3.update_layout(title={'text':'TSLA', 'x':0.5})
fig3.show()
</code></pre>
<p><img src="python/plot/../images/ngcb13" alt="img" /></p>
<p>You might notice that in the above graph, 20 D MA didn’t start from the beginning. That’s because we need 20 days to calculate the first moving average, therefore the first 19 days are essentially blank.</p>
<h2 id="hide-non-trading-days"><a class="header" href="#hide-non-trading-days">Hide Non-trading Days</a></h2>
<p>Stock markets close on weekends and holidays, so there’s no data for those periods. The above chart looks all fine but you kind of see small gaps on the bars at the bottom. If we zoom in more, you’ll see them more clearly.</p>
<p><img src="python/plot/../images/ngcb12" alt="Zoomed in chart with gaps" />Zoomed in chart with gaps</p>
<p>Thanks Dan for suggesting this correction! Let’s now fix this.</p>
<p>Plotly charts have a <strong>rangebreaks</strong> attribute that we can use to hide certain time periods. This works on both x-axis and y-axis. Also note this attribute is not unique to the candlestick chart, so you can use it to block off time periods for any type of chart with <strong>datetime</strong> data.</p>
<p>All we need is to add another <strong>update_axes(rangebreaks=[…])</strong> to the above code, just before the <strong>fig.show()</strong>.</p>
<ul>
<li><strong>bounds = [‘sat’, ‘mon’]</strong> will hide Saturdays and Sundays</li>
<li><strong>bounds = [16, 9.5]</strong> will hide between 4pm to 9:30am, which are market closed hours</li>
<li><strong>values = [“2021-12-25″,”2022-01-01”]</strong> can hide individual days</li>
</ul>
<pre><code class="language-python">fig3.update_xaxes(rangebreaks = [
                       dict(bounds=['sat','mon']), # hide weekends
                       #dict(bounds=[16, 9.5], pattern='hour'), # for hourly chart, hide non-trading hours (24hr format)
                       dict(values=[&quot;2021-12-25&quot;,&quot;2022-01-01&quot;]) #hide Xmas and New Year
                                ])
</code></pre>
<p>The result is a much smoother graph without gaps.</p>
<p><img src="python/plot/../images/ngcb1" alt="Zoomed in chart - gaps fixed!" />Zoomed in chart – gaps fixed!</p>
<h2 id="save-plotly-chart"><a class="header" href="#save-plotly-chart">Save Plotly Chart</a></h2>
<p>We can save our stock chart in HTML form, which means all the interactive features will be retained in the graph.</p>
<pre><code class="language-python">fig3.write_html(r'C:\Users\jay\Desktop\PythonInOffice\plotly_stock_chart\graph.html')
</code></pre>
<h2 id="dash"><a class="header" href="#dash">Dash</a></h2>
<p>Although our graph is interactive, it’s still lacking something. For example, if we want to draw a chart for another stock, we have to change the stock ticker inside the code and re-run it. In other words, our graph is not fully interactive yet. With Dash, we can create a graph that takes stock tickers as input and draw the chart accordingly.</p>
<hr />
<pre><code class="language-python">import yfinance as yf
import pandas as pd
import plotly as plotly
import plotly.graph_objects as go
from plotly.subplots import make_subplots

def show_plot(fig, filename):
    plotly.offline.plot(fig, filename=filename)


tsla = yf.Ticker('TSLA')
hist = tsla.history(period='1y')
fig = go.Figure(data=go.Scatter(x=hist.index,y=hist['Close'], mode='lines'))
# 只有線圖
show_plot(fig, 'test.html')

# 線圖+點
fig = go.Figure(data=go.Scatter(x=hist.index,y=hist['Close'], mode='lines+markers'))
show_plot(fig, 'test.html')


# 線圖+點+成交量柱狀圖
fig2 = make_subplots(specs=[[{&quot;secondary_y&quot;: True}]])
fig2.add_trace(go.Scatter(x=hist.index,y=hist['Close'],name='Price'),secondary_y=False)
fig2.add_trace(go.Bar(x=hist.index,y=hist['Volume'],name='Volume'),secondary_y=True)
show_plot(fig2, 'test.html')


# 線圖+點+成交量柱狀圖+nornalize
fig2.update_yaxes(range=[0,7000000000],secondary_y=True)
fig2.update_yaxes(visible=False, secondary_y=True)
show_plot(fig2, 'test.html')


# 線圖+點+成交量柱狀圖+蠟燭圖
fig3 = make_subplots(specs=[[{&quot;secondary_y&quot;: True}]])
fig3.add_trace(go.Candlestick(x=hist.index,
                              open=hist['Open'],
                              high=hist['High'],
                              low=hist['Low'],
                              close=hist['Close'],
                             ))
show_plot(fig3, 'test.html')


# 成交量柱狀圖+蠟燭圖
fig3.add_trace(go.Bar(x=hist.index, y=hist['Volume'], name='Volume'),secondary_y=True)
fig3.update_layout(xaxis_rangeslider_visible=False)
show_plot(fig3, 'test.html')


fig3.add_trace(go.Scatter(x=hist.index,y=hist['Close'].rolling(window=20).mean(),marker_color='blue',name='20 Day MA'))
fig3.add_trace(go.Bar(x=hist.index, y=hist['Volume'], name='Volume'),secondary_y=True)
fig3.update_layout(title={'text':'TSLA', 'x':0.5})
fig3.update_yaxes(range=[0,1000000000],secondary_y=True)
fig3.update_yaxes(visible=False, secondary_y=True)
fig3.update_layout(xaxis_rangeslider_visible=False)  #hide range slider
show_plot(fig3, 'test.html')

</code></pre>
<h2 id="easy-and-interactive-candlestick-charts-in-python"><a class="header" href="#easy-and-interactive-candlestick-charts-in-python">Easy and Interactive Candlestick Charts in Python</a></h2>
<p>https://medium.com/@dannygrovesn7/using-streamlit-and-plotly-to-create-interactive-candlestick-charts-a2a764ad0d8e</p>
<pre><code class="language-python">import pandas as pd
import yfinance as yf
import plotly.io as pio
import plotly.graph_objects as go
import plotly as plotly
from plotly.subplots import make_subplots

pio.renderers.default = &quot;browser&quot;


def get_candlestick_plot(df: pd.DataFrame, ma1: int, ma2: int, ticker: str):
    &quot;&quot;&quot;
    Create the candlestick chart with two moving avgs + a plot of the volume
    Parameters
    ----------
    df : pd.DataFrame
        The price dataframe
    ma1 : int
        The length of the first moving average (days)
    ma2 : int
        The length of the second moving average (days)
    ticker : str
        The ticker we are plotting (for the title).
    &quot;&quot;&quot;

    fig = make_subplots(
        rows=2,
        cols=1,
        shared_xaxes=True,
        vertical_spacing=0.1,
        subplot_titles=(f&quot;{ticker} Stock Price&quot;, &quot;Volume Chart&quot;),
        row_width=[0.3, 0.7],
    )

    fig.add_trace(
        go.Candlestick(
            # x=df[&quot;Date&quot;],
            x=df.index,
            open=df[&quot;Open&quot;],
            high=df[&quot;High&quot;],
            low=df[&quot;Low&quot;],
            close=df[&quot;Close&quot;],
            name=&quot;Candlestick chart&quot;,
        ),
        row=1,
        col=1,
    )

    fig.add_trace(
        go.Line(x=df.index, y=df[f&quot;{ma1}_ma&quot;], name=f&quot;{ma1} SMA&quot;),
        row=1,
        col=1,
    )

    fig.add_trace(
        go.Line(x=df.index, y=df[f&quot;{ma2}_ma&quot;], name=f&quot;{ma2} SMA&quot;),
        row=1,
        col=1,
    )

    fig.add_trace(
        go.Bar(x=df.index, y=df[&quot;Volume&quot;], name=&quot;Volume&quot;),
        row=2,
        col=1,
    )

    fig[&quot;layout&quot;][&quot;xaxis2&quot;][&quot;title&quot;] = &quot;Date&quot;
    fig[&quot;layout&quot;][&quot;yaxis&quot;][&quot;title&quot;] = &quot;Price&quot;
    fig[&quot;layout&quot;][&quot;yaxis2&quot;][&quot;title&quot;] = &quot;Volume&quot;

    fig.update_xaxes(
        rangebreaks=[{&quot;bounds&quot;: [&quot;sat&quot;, &quot;mon&quot;]}],
        rangeslider_visible=False,
    )

    return fig


def show_plot(fig, filename):
    plotly.offline.plot(fig, filename=filename)


if __name__ == &quot;__main__&quot;:
    stock = &quot;2630.TW&quot;
    tsla = yf.Ticker(stock)
    df = tsla.history(period=&quot;10y&quot;)

    df[&quot;10_ma&quot;] = df[&quot;Close&quot;].rolling(10).mean()
    df[&quot;20_ma&quot;] = df[&quot;Close&quot;].rolling(20).mean()
    fig = get_candlestick_plot(df[-120:], 10, 20, stock)
    # fig.show()
    show_plot(fig, &quot;tsla.html&quot;)
</code></pre>
<h2 id="子圖"><a class="header" href="#子圖">子圖</a></h2>
<pre><code class="language-python">from plotly.subplots import make_subplots
import plotly
import plotly.graph_objects as go

fig = make_subplots(
    rows=2, cols=2,
    specs=[[{&quot;type&quot;: &quot;xy&quot;, 'secondary_y': True}, {&quot;type&quot;: &quot;polar&quot;}],
           [{&quot;type&quot;: &quot;domain&quot;}, {&quot;type&quot;: &quot;scene&quot;}]],
    y_title='title'
)
'''
也可以為：specs=[[{'type': 'bar'}, {'type': 'barpolar'}],
                [{'type': 'pie'}, {'type': 'scatter3d'}]]
'''

# 使用 secondary_y 參數選擇該圖相對的 y軸座標
fig.add_trace(go.Bar(y=[2, 3, 1]),
              row=1, col=1, secondary_y=False)
fig.add_trace(go.Scatter(x=[0, 1, 2], y=[4, 10, 7]),
              row=1, col=1, secondary_y=True)

fig.add_trace(go.Barpolar(theta=[0, 45, 90], r=[2, 3, 1]),
              row=1, col=2)

fig.add_trace(go.Pie(values=[2, 3, 1]),
              row=2, col=1)

fig.add_trace(go.Scatter3d(x=[2, 3, 1], y=[0, 0, 0],
                           z=[0.5, 1, 2], mode=&quot;lines&quot;),
              row=2, col=2)

fig.update_layout(height=700, showlegend=False)

plotly.offline.plot(fig, filename='test.html')
</code></pre>
<p><img src="python/plot/../images/newplot.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="plotly-在-html-中動態更新圖表的簡單示例程序"><a class="header" href="#plotly-在-html-中動態更新圖表的簡單示例程序">Plotly 在 HTML 中動態更新圖表的簡單示例程序</a></h2>
<pre><code class="language-python">from plotly.subplots import make_subplots
import random
import dash
from dash import dcc
from dash import html


# 創建圖表
fig = make_subplots(rows=1, cols=1)
fig.add_scatter(x=[], y=[], mode=&quot;lines&quot;, name=&quot;動態更新圖表&quot;)

# 創建 Dash 應用
app = dash.Dash(__name__)

# 定義佈局
app.layout = html.Div(
    children=[
        dcc.Graph(id=&quot;live-graph&quot;, figure=fig),
        dcc.Interval(id=&quot;update-interval&quot;, interval=1000, n_intervals=0),  # 每秒更新一次
    ]
)


# 定義回調函數
@app.callback(
    dash.dependencies.Output(&quot;live-graph&quot;, &quot;figure&quot;),
    [dash.dependencies.Input(&quot;update-interval&quot;, &quot;n_intervals&quot;)],
)
def update_graph(n):
    # 生成隨機數據
    x = list(range(10))
    y = [random.randint(0, 100) for _ in range(10)]

    # 更新圖表數據
    fig.data[0].x = x
    fig.data[0].y = y

    return fig


if __name__ == &quot;__main__&quot;:
    app.run_server(debug=True)
</code></pre>
<p>了 Plotly 的 Python API 來創建了一個動態更新的折線圖，並將其嵌入到了一個 Dash 應用中。具體來說，我們使用 <code>make_subplots()</code> 函數創建了一個包含一個子圖的圖表對象，並在其中添加了一條折線。然後，我們使用 Dash 提供的 <code>dcc.Graph</code> 組件將這個圖表對象嵌入到了應用的佈局中，並使用 <code>dcc.Interval</code> 組件來定時更新圖表數據。最後，我們使用 <code>app.callback</code> 裝飾器定義了一個回調函數，該函數會在定時器觸發時被調用，並更新圖表的數據。</p>
<p>在運行上面的程序後，我們可以在瀏覽器中訪問 <code>http://localhost:8050/</code> 來查看動態更新的圖表。每秒鐘，圖表中的數據會更新一次，並自動重繪圖表。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pyo3"><a class="header" href="#pyo3">PyO3</a></h2>
<pre><code class="language-shell">https://github.com/PyO3/pyo3

pip install maturin
maturin init

src/lib.rs

maturin develop
</code></pre>
<pre><code class="language-python"># lots of progress output as maturin runs the compilation...
$ python
&gt;&gt;&gt; import string_sum
&gt;&gt;&gt; string_sum.sum_as_string(5, 20)
'25'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dataframe-成-pickle-後寫入-redis-之後取出在-unpickle"><a class="header" href="#dataframe-成-pickle-後寫入-redis-之後取出在-unpickle">dataframe 成 pickle 後寫入 redis, 之後取出在 unpickle</a></h2>
<pre><code class="language-python">from finlab import data
import redis
import pickle

# Connect to Redis
r = redis.Redis(host='localhost', port=6379, db=11)

# Get the data and save it to Redis
營業利益成長率 = data.get(&quot;price:收盤價&quot;)
r.set('test', pickle.dumps(營業利益成長率))
with open('test.bin', 'wb') as f:
    pickle.dump(營業利益成長率, f)


with open('test.bin', 'rb') as f:
    new_dict = pickle.load(f)
    print(new_dict)

# Read the data from Redis and unpickle it
unpickled_df = pickle.loads(r.get('test'))

print(unpickled_df)

with open('gg.bin', 'wb') as f:
    pickle.dump(pickle.loads(r.get('test')) , f)

with open('gg.bin', 'rb') as f:
    new_dict = pickle.load(f)
    print(new_dict)
</code></pre>
<h2 id="對一個欄位nan-使用-bfill"><a class="header" href="#對一個欄位nan-使用-bfill">對一個欄位nan 使用 bfill</a></h2>
<pre><code class="language-python">import pandas as pd
import numpy as np

# 建立範例 DataFrame
df = pd.DataFrame({'A': [1, 2, 3, np.nan, np.nan, 6, np.nan, 8]})

# 針對欄位 A 使用 backfill 填充 NaN 值
df['A'] = df['A'].fillna(method='backfill')

# 印出填充後的 DataFrame
print(df)
</code></pre>
<h2 id="兩個不同大小df-使用-fillna-方法使用後向填充法填充缺失值"><a class="header" href="#兩個不同大小df-使用-fillna-方法使用後向填充法填充缺失值">兩個不同大小DF 使用 fillna() 方法使用後向填充法填充缺失值</a></h2>
<pre><code class="language-python">import pandas as pd

# 創建第一個 dataframe
df1 = pd.DataFrame({'IsTrue': [False]},
                   index=pd.to_datetime(['2023-02-28']))

# 創建第二個 dataframe
df2 = pd.DataFrame({'close': [239.0, 241.0, 247.0, 227.5, 231.0]},
                   index=pd.to_datetime(['2023-02-17', '2023-02-20', '2023-02-21', '2023-02-22', '2023-02-23']))

# 將第一個 dataframe 轉換為一列 dataframe，然後與第二個 dataframe 進行合併
df = pd.concat([df2, df1], axis=1)  # 使用 pd.concat() 方法將兩個 dataframe 合併
df.fillna(method='bfill', inplace=True)  # 使用 bfill 方法填充缺失值
df.dropna(how=&quot;any&quot;, inplace=True)  # 使用 dropna 方法刪除仍存在的 NaN 值

print(df)
</code></pre>
<h2 id="的-concat-函數將兩個-dataframe-以-df1-為主然後指定-axis1-將-df2-以欄位的方式合併至-df1"><a class="header" href="#的-concat-函數將兩個-dataframe-以-df1-為主然後指定-axis1-將-df2-以欄位的方式合併至-df1">的 <code>concat</code> 函數將兩個 DataFrame 以 df1 為主，然後指定 <code>axis=1</code> 將 df2 以欄位的方式合併至 df1</a></h2>
<pre><code class="language-python">import pandas as pd

# 創建 True/False 值 DataFrame
df1 = pd.DataFrame({'is_buy': [True, False, True, False]}, 
                   index=pd.to_datetime(['2022-01-01', '2022-01-02', '2022-01-03', '2022-01-04']))

# 創建均價 DataFrame（日期為 2022-01-01 和 2022-01-03）
df2 = pd.DataFrame({'mean_price': [100, 300]}, 
                   index=pd.to_datetime(['2022-01-01', '2022-01-03']))

# 將 df1 和 df2 以欄位的方式合併
df_merged = pd.concat([df1, df2.reindex(df1.index)], axis=1)

# 刪除含有 NaN 值的列
df_merged = df_merged.dropna(how='any')

print(df_merged)

</code></pre>
<p><a href="https://ds.apachecn.org/#/">資料科學與分析譯文集</a></p>
<pre><code class="language-python">pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x
</code></pre>
<h2 id="python量化交易實戰之使用resample函數轉換日k數據"><a class="header" href="#python量化交易實戰之使用resample函數轉換日k數據">Python量化交易實戰之使用Resample函數轉換“日K”數據</a></h2>
<p>https://walkonnet.com/archives/138620</p>
<p>使用Resample函數轉換時間序列</p>
<h2 id="一什麼是resample函數"><a class="header" href="#一什麼是resample函數">一、什麼是resample函數？</a></h2>
<p>它是Python數據分析庫Pandas的方法函數。</p>
<p>它主要用於轉換時間序列的頻次。可以做一些統計匯總的工作。</p>
<p>什麼叫轉換時間序列的頻次呢？</p>
<p>比如說股票的日k和周k，</p>
<p>假設我隻能獲取到股票日K的數據，比如說11月1號到11月5號，那怎麼樣將它轉換為以周為單位的K線呢？</p>
<table><thead><tr><th>日期</th><th>週期</th><th>開盤價</th><th>收盤價</th><th>最高價</th><th>最低價</th></tr></thead><tbody>
<tr><td>11月1號</td><td>週一</td><td>1.11</td><td>1.11</td><td>1.11</td><td>1.12</td></tr>
<tr><td>11月2號</td><td>週二</td><td>1.12</td><td>1.12</td><td>1.11</td><td>1.12</td></tr>
<tr><td>11月3號</td><td>週三</td><td>1.13</td><td>1.13</td><td>1.11</td><td>1.12</td></tr>
<tr><td>11月4號</td><td>週四</td><td>1.15</td><td>1.14</td><td>1.11</td><td>1.12</td></tr>
<tr><td>11月5號</td><td>週五</td><td>1.14</td><td>1.15</td><td>1.11</td><td>1.12</td></tr>
</tbody></table>
<p>首先我們要明確，周K的開盤、收盤、最高、最低是什麼。每週的開盤價是當周第一天的開盤價，收盤價是當周最後一天的收盤價，它的最高價是這周最高的價格，最低價是本週所有最低價中最低的價格。所以你去看炒股平臺，它的周k都是以週五的交易日為記錄的時間點位置。開盤、收盤、最高、最低是按照我剛剛講解的這個規則來計算的。至於月K、年K的選取規則也是一樣的。月K的週期是一個月，年K的週期是一年。</p>
<p>這個計算準確性你也可以通過網上的數據進行驗證。這個計算規則，包括開盤、收盤、最高、最低的計算，收拾resample函數可以做到的事情。此外Resample還有個功能，就是做統計匯總，比如說我想計算一支股票總的周成交量，就可以使用Resample.sum函數去把週一到週五的成交量加起來。</p>
<p>為瞭方便大傢記憶 ，你也可以把resample理解為Excel表格中的透視表功能。你可以按照日期做各種篩選和匯總統計的。最重要的是他可以按照日期。</p>
<h2 id="二實戰resample函數"><a class="header" href="#二實戰resample函數">二、實戰Resample函數</a></h2>
<p>因為這2節課還是一些比較基礎的部分，所以還沒有做模塊化的內容。</p>
<p>我們會在創建股票數據庫的時候 來做真正的模塊化的工作。到這裡都是初級的腳本的形式。先提前說下。</p>
<h3 id="1日k-轉換為-周k"><a class="header" href="#1日k-轉換為-周k">1.日K 轉換為 周K</a></h3>
<p>1.1函數文檔學習</p>
<p>谷歌搜索<code>Pandas Resample</code>：第一個鏈接就是這個函數的官方文檔</p>
<p>https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html</p>
<p>這裡有介紹：Resample是屬於Pandas DataFrame下面的方法。這裡有關於參數的解釋。</p>
<p>這裡我們隻對2個常用參數講解，一個是rule，另一個是closed。</p>
<ul>
<li>rule表示的是你放一個什麼樣的週期性指標在裡面，用m代表Month，Y代表Year,w代表Week，</li>
<li>closed代表你取哪一個分界線，舉例來說，比如說我把日k轉換為周k，到底我是取週一為分界線還是週五為分界線呢？這就是通過closed來確定的。</li>
</ul>
<p>這裡有它的例子：</p>
<pre><code class="language-python">&gt;&gt;&gt;index = pd.date_range('1/1/2000', periods=9, freq='T')
&gt;&gt;&gt;series = pd.Series(range(9), index=index)
&gt;&gt;&gt;series
2000-01-01 00:00:00    0
2000-01-01 00:01:00    1
2000-01-01 00:02:00    2
2000-01-01 00:03:00    3
2000-01-01 00:04:00    4
2000-01-01 00:05:00    5
2000-01-01 00:06:00    6
2000-01-01 00:07:00    7
2000-01-01 00:08:00    8
Freq: T, dtype: int64
</code></pre>
<p>這裡首先創建瞭一個時間序列的<code>DataFrame</code>，就是這個<code>series</code>變量。你可以理解為它是一個隻有一個字段的表格樣式。接著往下看：</p>
<pre><code class="language-python">&gt;&gt;&gt;series.resample('3T').sum()
2000-01-01 00:00:00     3
2000-01-01 00:03:00    12
2000-01-01 00:06:00    21
Freq: 3T, dtype: int64
</code></pre>
<p>這裡使用瞭<code>Resample</code>方法，<code>3T</code>就是3分鐘，<code>T</code>表示分鐘。<code>sum()</code>就是匯總，也就是針對這一列數據進行匯總。</p>
<p>也就是說，每3分鐘統計依次。註意到，這個時間序列匯總的時間取的值是3分鐘的第一分鐘。如果我想取時間週期的最後一分鐘，可以將label的值改為“right”：</p>
<pre><code class="language-python">&gt;&gt;&gt;series.resample('3T', label='right').sum()
2000-01-01 00:03:00     3
2000-01-01 00:06:00    12
2000-01-01 00:09:00    21
Freq: 3T, dtype: int64
</code></pre>
<p>1.2實戰</p>
<p>獲取日K真實的數據：</p>
<pre><code class="language-python">#獲取日k
df = get_price(&quot;000001.XSHG&quot;, end_date='2021-05-30 14:00:00',count=20, frequency='1d', fields=['open','close','high','low','volume','money'])  
print(df)
</code></pre>
<p>可以看到獲取到瞭<code>4月28號</code>到<code>5月28號</code>的所有數據。為瞭更方便理解 我們再添加一列數據，就是當前日期是<code>星期幾</code>的列。</p>
<pre><code class="language-python">#獲取日k
df = get_price(&quot;000001.XSHG&quot;, end_date='2021-05-30 14:00:00',count=20, frequency='1d', fields=['open','close','high','low','volume','money'])  
df['weekday']=df.index.weekday
print(df)
</code></pre>
<p>這裡<code>0</code>代表週一，這裡如何轉換為按“<strong>周</strong>”統計呢</p>
<pre><code class="language-python">#獲取周k
import pandas as pd
df_week = pd.DataFrame()
df_week = df['open'].resample('W').first()
print(df_week)
</code></pre>
<p>可以看到這裡的<code>2021-05-30</code>是一個禮拜的最後一天。它對應的開盤價確實是這個數字。說明我們計算的周K數據是正確的。</p>
<p><strong>收盤價</strong>就是<code>每週收盤價</code>最後一天的數據。</p>
<p><strong>最高價</strong>就是<code>每週收盤價</code>的最大值。</p>
<p><strong>最低價</strong>就是<code>每週收盤價</code>的最小值。</p>
<pre><code class="language-python">#獲取周k
import pandas as pd
df_week = pd.DataFrame()
df_week['open'] = df['open'].resample('W').first()
df_week['close'] = df['close'].resample('W').last()
df_week['high'] = df['high'].resample('W').max()
df_week['low'] = df['low'].resample('W').min()
print(df_week)
</code></pre>
<p>對比數據，close是最後一天的收盤價的數據。high是當前周的每天的最高價的最高價。low是當前周的每天的最低價的最低價。</p>
<p>我們通過不到10行代碼就能將<code>日K</code>的數據轉換為<code>周K</code>的數據。</p>
<h3 id="2匯總統計功能統計月成交量成交額"><a class="header" href="#2匯總統計功能統計月成交量成交額">2.匯總統計功能（統計月成交量、成交額）</a></h3>
<p>匯總成交量和成交額</p>
<p>我想要把<code>volume</code>(成交量)和<code>money</code>(成交額)轉換為<strong>總成交量</strong>和<strong>總成交額</strong></p>
<pre><code class="language-python">#獲取周k
import pandas as pd
df_week = pd.DataFrame()
df_week['open'] = df['open'].resample('W').first()
df_week['close'] = df['close'].resample('W').last()
df_week['high'] = df['high'].resample('W').max()
df_week['low'] = df['low'].resample('W').min()
df_week['volume(sum)'] = df['volume'].resample('W').sum()
df_week['money(sum)'] = df['money'].resample('W').sum()
print(df_week)
</code></pre>
<h3 id="3日k-轉換為-月k"><a class="header" href="#3日k-轉換為-月k">3.日K 轉換為 月K</a></h3>
<p>假設我有一年的數據，如果想轉換為月K應該怎麼轉？</p>
<p>隻需要改2個地方：</p>
<ul>
<li>添加<code>start_date</code>獲取到一整年的數據</li>
<li>將<code>resample</code>的參數改為M即可，M代表Month</li>
</ul>
<pre><code class="language-python">#獲取日k
df = get_price(&quot;000001.XSHG&quot;, end_date='2021-05-30 14:00:00', start_date='2020-05-30', frequency='1d', fields=['open','close','high','low','volume','money'])  
df['weekday']=df.index.weekday
print(df)

#獲取周k
import pandas as pd
df_week = pd.DataFrame()
df_week['open'] = df['open'].resample('M').first()
df_week['close'] = df['close'].resample('M').last()
df_week['high'] = df['high'].resample('M').max()
df_week['low'] = df['low'].resample('M').min()
print(df_week)
</code></pre>
<p>以上就是Python量化交易實戰之使用Resample函數轉換“日K”數據的詳細內容，更多關於Python Resample函數轉換“日K”數據的資料請關註WalkonNet其它相關文章！</p>
<h3 id="推薦閱讀"><a class="header" href="#推薦閱讀">推薦閱讀：</a></h3>
<ul>
<li><a href="https://walkonnet.com/archives/459801">Python Pandas高級教程之時間處理</a></li>
<li><a href="https://walkonnet.com/archives/543015">python數學建模之三大模型與十大常用算法詳情</a></li>
<li><a href="https://walkonnet.com/archives/541137">Python Pandas 中的數據結構詳解</a></li>
<li><a href="https://walkonnet.com/archives/540162">python Pandas時序數據處理</a></li>
<li><a href="https://walkonnet.com/archives/541225">Python pandas索引的設置和修改方法</a></li>
</ul>
<hr />
<h1 id="pandas-shift-sum"><a class="header" href="#pandas-shift-sum">pandas shift sum</a></h1>
<pre><code class="language-py">import pandas as pd
import numpy

df = pd.DataFrame(numpy.random.randint(0, 10, (10, 2)), columns=['a','b'])
df['c'] = df.b.rolling(window = 3).sum().shift()
print(df)
</code></pre>
<pre><code class="language-py">import pandas as pd

df = pd.DataFrame(
    {
        &quot;Name&quot;: [
            &quot;A&quot;,
            &quot;B&quot;,
            &quot;C&quot;,
            &quot;D&quot;,
            &quot;E&quot;,
            &quot;F&quot;,
            &quot;G&quot;,
            &quot;H&quot;,
            &quot;I&quot;,
            &quot;J&quot;,
            &quot;K&quot;,
            &quot;L&quot;,
            &quot;M&quot;,
            &quot;N&quot;,
            &quot;O&quot;,
        ],
        &quot;Sex&quot;: [
            &quot;M&quot;,
            &quot;M&quot;,
            &quot;M&quot;,
            &quot;F&quot;,
            &quot;F&quot;,
            &quot;M&quot;,
            &quot;F&quot;,
            &quot;M&quot;,
            &quot;F&quot;,
            &quot;M&quot;,
            &quot;M&quot;,
            &quot;M&quot;,
            &quot;F&quot;,
            &quot;M&quot;,
            &quot;M&quot;,
        ],
        &quot;Age&quot;: [38, 28, 31, 34, 28, 28, 36, 33, 22, 39, 22, 24, 31, 29, 22],
        &quot;Height&quot;: [
            1.74,
            1.51,
            1.67,
            1.87,
            1.8,
            1.51,
            1.85,
            1.89,
            1.81,
            1.72,
            1.75,
            1.64,
            1.9,
            1.62,
            1.61,
        ],
        &quot;Weight&quot;: [45, 63, 39, 45, 67, 66, 53, 45, 72, 46, 58, 44, 73, 70, 51],
    }
)

df_eg1 = df.copy()
# 第 1 個用法
def BMI_1(r):
    return round(r[&quot;Weight&quot;] / (r[&quot;Height&quot;] ** 2), ndigits=2)


df_eg1[&quot;BMI_apply1&quot;] = df_eg1.apply(BMI_1, axis=1)
# 第 2 個用法
def BMI_2(weight, height):
    return round(weight / (height ** 2), ndigits=2)


df_eg1[&quot;BMI_apply2&quot;] = df_eg1.apply(lambda r: BMI_2(r[&quot;Weight&quot;], r[&quot;Height&quot;]), axis=1)
print(df_eg1)
</code></pre>
<pre><code class="language-py">import pandas as pd

def sum(x, y, z, m, df):
    for index, row in df.iterrows():
        print(row)
    return (x + y + z) * m


df = pd.DataFrame({'A': [1, 2], 'B': [10, 20]})
df1 = df.apply(sum, args=(1, 2), m=10, df=df)
print(df1)

</code></pre>
<pre><code class="language-py">import pandas as pd


def apply_func(tsC, tsD):
    return tsC.mean() + tsD.mean()


dates = pd.date_range(&quot;20130101&quot;, periods=13, freq=&quot;D&quot;)
df = pd.DataFrame(
    {
        &quot;C&quot;: [1, 9, 2, 4, 5, -1, 6, 9, 3, 5, 10, -3, -5],
        &quot;D&quot;: [3, 8, 2, 6, 9, 1, 26, 89, 4, 2, 1, -13, 75],
    },
    index=dates,
)
df.index.name = &quot;datetime&quot;
print(df)

df[&quot;rmean&quot;] = (
    df[&quot;C&quot;]
    .rolling(window=3)
    .apply(lambda x: apply_func(df.loc[x.index, &quot;C&quot;], df.loc[x.index, &quot;D&quot;]))
)

print(df)
</code></pre>
<pre><code class="language-py">stringList = [&quot;252.007&quot;, &quot;546.658&quot;, &quot;252.108&quot;]
paramValue = [&quot;252.017&quot;, &quot;546.658&quot;, &quot;252.008&quot;]

def compareList(l1, l2):
    return [i&gt;j for i, j in zip(l1, l2)]

print(compareList(stringList, paramValue)) 
</code></pre>
<pre><code class="language-py">import pandas as pd
import numpy


def test(data):
    return sum(data)


df = pd.DataFrame(numpy.random.randint(0, 10, (10, 2)), columns=[&quot;a&quot;, &quot;b&quot;])
# print(df)
c = df.b.rolling(window=3).apply(test).shift()
# df['c'] = df.b.rolling(window = 3).sum().shift(1)
# df['d'] = df.b.rolling(window = 3).sum().shift(2)
print(df, &quot;\n&quot;, c)
</code></pre>
<pre><code class="language-py">from numpy_ext import rolling_apply
import pandas as pd
import numpy


def test(a, b):
    return sum(a) + sum(b)


df = pd.DataFrame(numpy.random.randint(0, 10, (10, 2)), columns=[&quot;a&quot;, &quot;b&quot;])
df[&quot;c&quot;] = rolling_apply(test, 3, df.a.values, df.b.values)
df[&quot;c&quot;] = df[&quot;c&quot;].shift()
print(df, type(df[&quot;c&quot;]))
</code></pre>
<h3 id="resample"><a class="header" href="#resample">Resample</a></h3>
<pre><code class="language-python"># https://medium.com/uxai/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87-ai-for-trading-1-%E7%8D%B2%E5%8F%96%E5%B8%82%E5%A0%B4%E8%B3%87%E6%96%99-109791cde0f5
import yfinance as yf
import pandas as pd


def get_info_on_stock(ticker):
    stock = yf.Ticker(ticker)
    # 拿上市至今的收盤價
    hist_all = stock.history(period=&quot;max&quot;)[&quot;Close&quot;]
    # 拿近 30 天的所有資料
    hist_30 = stock.history(period=&quot;30d&quot;)
    return hist_all


def get_info_on_stocks(track_list):
    df = pd.DataFrame()
    for stock in track_list:
        stock_info = yf.Ticker(stock)
        # 拿近 10 天的資料
        hist = stock_info.history(period=&quot;360d&quot;)
        # 做一些簡單的處理後把 dataframe 接起來
        hist[&quot;Stock_id&quot;] = stock
        hist[&quot;Date&quot;] = hist.index
        hist = hist[
            [
                &quot;Date&quot;,
                &quot;Stock_id&quot;,
                &quot;Open&quot;,
                &quot;High&quot;,
                &quot;Low&quot;,
                &quot;Close&quot;,
                &quot;Volume&quot;,
                &quot;Dividends&quot;,
                &quot;Stock Splits&quot;,
            ]
        ]
        df = pd.concat([df, hist])
    return df.set_index([pd.Index([i for i in range(len(df))])]).round(1)


if __name__ == &quot;__main__&quot;:
    data = get_info_on_stock(&quot;2330.TW&quot;)
    print(data)

    # 選定我們要比較的公司
    track_list = [&quot;2330.TW&quot;, &quot;2303.TW&quot;]
    df = get_info_on_stocks(track_list)
    print(df, type(df))

    # 接下來我們可以做一些簡單的計算，利用 pandas 內建的函數來看兩者資訊的平均 (mean):
    df_mean = df.groupby(&quot;Stock_id&quot;).mean()
    print(df_mean)

    # 前面的圖可以看到我們是將同一個時間的兩個公司資訊堆疊起來，接下來我們可以試著用另一種表示方式來做比較：
    open_prices = df.pivot(index=&quot;Date&quot;, columns=&quot;Stock_id&quot;, values=&quot;Open&quot;)
    high_prices = df.pivot(index=&quot;Date&quot;, columns=&quot;Stock_id&quot;, values=&quot;High&quot;)
    low_prices = df.pivot(index=&quot;Date&quot;, columns=&quot;Stock_id&quot;, values=&quot;Low&quot;)
    close_prices = df.pivot(index=&quot;Date&quot;, columns=&quot;Stock_id&quot;, values=&quot;Close&quot;)
    volume = df.pivot(index=&quot;Date&quot;, columns=&quot;Stock_id&quot;, values=&quot;Volume&quot;)
    print(close_prices.mean())
    print(close_prices)
    # print(close_prices['2303.TW'])
    df_month_open = open_prices.resample(&quot;M&quot;).first()
    df_month_high = high_prices.resample(&quot;M&quot;).max()
    df_month_low = low_prices.resample(&quot;M&quot;).min()
    df_month_close = close_prices.resample(&quot;M&quot;).last()
    print(df_month_open)
</code></pre>
<pre><code class="language-python">from finlab import data
import datetime
import numpy as np
import pandas as pd
import finlab
import functools


class MyFinlabDataFrame(pd.DataFrame):
    &quot;&quot;&quot;回測語法糖
    除了使用熟悉的 Pandas 語法外，我們也提供很多語法糖，讓大家開發程式時，可以用簡易的語法完成複雜的功能，讓開發策略更簡潔！
    我們將所有的語法糖包裹在 `MyFinlabDataFrame` 中，用起來跟 `pd.DataFrame` 一樣，但是多了很多功能！
    只要使用 `finlab.data.get()` 所獲得的資料，皆為 `MyFinlabDataFrame` 格式，
    接下來我們就來看看， `MyFinlabDataFrame` 有哪些好用的語法糖吧！

    當資料日期沒有對齊（例如: 財報 vs 收盤價 vs 月報）時，在使用以下運算符號：`+`, `-`, `*`, `/`, `&gt;`, `&gt;=`, `==`, `&lt;`, `&lt;=`, `&amp;`, `|`, `~`，不需要先將資料對齊，因為 `MyFinlabDataFrame` 會自動幫你處理，以下是示意圖。

    &lt;img src=&quot;https://i.ibb.co/pQr5yx5/Screen-Shot-2021-10-26-at-5-32-44-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-5-32-44-AM&quot;&gt;

    以下是範例：`cond1` 與 `cond2` 分別為「每天」，和「每季」的資料，假如要取交集的時間，可以用以下語法：

    ```py
    from finlab import data
    # 取得 MyFinlabDataFrame
    close = data.get('price:收盤價')
    roa = data.get('fundamental_features:ROA稅後息前')

    # 運算兩個選股條件交集
    cond1 = close &gt; 37
    cond2 = roa &gt; 0
    cond_1_2 = cond1 &amp; cond2

    擷取 1101 臺泥 的訊號如下圖，可以看到 `cond1` 跟 `cond2` 訊號的頻率雖然不相同，但是由於 `cond1` 跟 `cond2` 是 `MyFinlabDataFrame`，所以可以直接取交集，而不用處理資料頻率對齊的問題。
    &lt;br /&gt;
    &lt;img src=&quot;https://i.ibb.co/m9chXSQ/imageconds.png&quot; alt=&quot;imageconds&quot;&gt;
    
    總結來說，MyFinlabDataFrame 與一般 dataframe 唯二不同之處：
    1. 多了一些 method，如`df.is_largest()`, `df.sustain()`...等。
    2. 在做四則運算、不等式運算前，會將 df1、df2 的 index 取聯集，column 取交集。
    &quot;&quot;&quot;
    
    @property
    def _constructor(self):
        return MyFinlabDataFrame
    
    @staticmethod
    def reshape(df1, df2):
    
        isfdf1 = isinstance(df1, MyFinlabDataFrame)
        isfdf2 = isinstance(df2, MyFinlabDataFrame)
        isdf1 = isinstance(df1, pd.DataFrame)
        isdf2 = isinstance(df2, pd.DataFrame)
    
        both_are_dataframe = (isfdf1 + isdf1) * (isfdf2 + isdf2) != 0
    
        d1_index_freq = df1.get_index_str_frequency() if isfdf1 else None
        d2_index_freq = df2.get_index_str_frequency() if isfdf2 else None
    
        if (
            (d1_index_freq or d2_index_freq)
            and (d1_index_freq != d2_index_freq)
            and both_are_dataframe
        ):
    
            df1 = df1.index_str_to_date() if isfdf1 else df1
            df2 = df2.index_str_to_date() if isfdf2 else df2
    
        if isinstance(df2, pd.Series):
            df2 = pd.DataFrame({c: df2 for c in df1.columns})
    
        if both_are_dataframe:
            index = df1.index.union(df2.index)
            columns = df1.columns.intersection(df2.columns)
    
            if len(df1.index) * len(df2.index) != 0:
                index_start = max(df1.index[0], df2.index[0])
                index = [t for t in index if index_start &lt;= t]
    
            return (
                df1.reindex(index=index, method=&quot;ffill&quot;)[columns],
                df2.reindex(index=index, method=&quot;ffill&quot;)[columns],
            )
        else:
            return df1, df2
    
    def __lt__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__lt__(df1, df2)
    
    def __gt__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__gt__(df1, df2)
    
    def __le__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__le__(df1, df2)
    
    def __ge__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__ge__(df1, df2)
    
    def __eq__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__eq__(df1, df2)
    
    def __ne__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__ne__(df1, df2)
    
    def __sub__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__sub__(df1, df2)
    
    def __add__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__add__(df1, df2)
    
    def __mul__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__mul__(df1, df2)
    
    def __truediv__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__truediv__(df1, df2)
    
    def __rshift__(self, other):
        return self.shift(-other)
    
    def __lshift__(self, other):
        return self.shift(other)
    
    def __and__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__and__(df1, df2)
    
    def __or__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__or__(df1, df2)
    
    def __getitem__(self, other):
        df1, df2 = self.reshape(self, other)
        return pd.DataFrame.__getitem__(df1, df2)
    
    def index_str_to_date(self):
        &quot;&quot;&quot;財務月季報索引格式轉換
    
        將以下資料的索引轉換成datetime格式:
    
        月營收 (ex:2022-M1) 從文字格式轉為公告截止日。
    
        財務季報 (ex:2022-Q1) 從文字格式轉為財報電子檔資料上傳日。
    
        通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
    
        Returns:
          (pd.DataFrame): data
        Examples:
    
            ```py
            data.get('monthly_revenue:當月營收').index_str_to_date()
            data.get('financial_statement:現金及約當現金').index_str_to_date()
</code></pre>
<pre><code>  &quot;&quot;&quot;
    if len(self.index) == 0 or not isinstance(self.index[0], str):
        return self

    if self.index[0].find(&quot;M&quot;) != -1:
        return self._index_str_to_date_month()
    elif self.index[0].find(&quot;Q&quot;) != -1:
        return self._index_str_to_date_season()

    return self

@staticmethod
def to_business_day(date):
    def skip_weekend(d):
        add_days = {5: 2, 6: 1}
        wd = d.weekday()
        if wd in add_days:
            d += datetime.timedelta(days=add_days[wd])
        return d

    close = data.get(&quot;price:收盤價&quot;)
    return (
        pd.Series(date)
        .apply(
            lambda d: skip_weekend(d)
            if d in close.index or d &lt; close.index[0] or d &gt; close.index[-1]
            else close.loc[d:].index[0]
        )
        .values
    )

def get_index_str_frequency(self):

    if len(self.index) == 0:
        return None

    if not isinstance(self.index[0], str):
        return None

    if (self.index.str.find(&quot;M&quot;) != -1).all():
        return &quot;month&quot;

    if (self.index.str.find(&quot;Q&quot;) != -1).all():
        return &quot;season&quot;

    return None

def _index_date_to_str_month(self):

    # index is already str
    if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
        return self

    index = (self.index - datetime.timedelta(days=30)).strftime(&quot;%Y-M%m&quot;)
    return MyFinlabDataFrame(self.values, index=index, columns=self.columns)

def _index_str_to_date_month(self):

    # index is already timestamps
    if len(self.index) == 0 or not isinstance(self.index[0], str):
        return self

    if not (self.index.str.find(&quot;M&quot;) != -1).all():
        logger.warning(
            &quot;MyFinlabDataFrame: invalid index, cannot format index to monthly timestamp.&quot;
        )
        return self

    index = (
        pd.to_datetime(self.index, format=&quot;%Y-M%m&quot;)
        + pd.offsets.MonthBegin()
        + datetime.timedelta(days=9)
    )
    # chinese new year and covid-19 impact monthly revenue deadline
    replacements = {
        datetime.datetime(2020, 2, 10): datetime.datetime(2020, 2, 15),
        datetime.datetime(2021, 2, 10): datetime.datetime(2021, 2, 15),
        datetime.datetime(2022, 2, 10): datetime.datetime(2022, 2, 14),
    }
    replacer = replacements.get
    index = [replacer(n, n) for n in index]

    index = self.to_business_day(index)

    ret = MyFinlabDataFrame(self.values, index=index, columns=self.columns)
    ret.index.name = &quot;date&quot;

    return ret

def _index_date_to_str_season(self):

    # index is already str
    if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
        return self

    q = (
        self.index.strftime(&quot;%m&quot;)
        .astype(int)
        .map({5: 1, 8: 2, 9: 2, 10: 3, 11: 3, 3: 4, 4: 4})
    )
    year = self.index.year.copy()
    year -= q == 4
    index = year.astype(str) + &quot;-Q&quot; + q.astype(str)

    return MyFinlabDataFrame(self.values, index=index, columns=self.columns)

def deadline(self):
    &quot;&quot;&quot;財務季報索引轉換成公告截止日

      將財務季報 (ex:2022Q1) 從文字格式轉為公告截止日的datetime格式，
      通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
      Returns:
        (pd.DataFrame): data
      Examples:
          ```py
          data.get('financial_statement:現金及約當現金').deadline()
          ```
    &quot;&quot;&quot;
    return self._index_str_to_date_season(detail=False)

def _index_str_to_date_season(self, detail=True):

    disclosure_dates = calc_disclosure_dates(detail).reindex_like(self).unstack()

    self.columns.name = &quot;stock_id&quot;

    unstacked = self.unstack()

    ret = (
        pd.DataFrame(
            {&quot;value&quot;: unstacked.values, &quot;disclosures&quot;: disclosure_dates.values,},
            unstacked.index,
        )
        .reset_index()
        .drop_duplicates([&quot;disclosures&quot;, &quot;stock_id&quot;])
        .pivot(index=&quot;disclosures&quot;, columns=&quot;stock_id&quot;, values=&quot;value&quot;)
        .ffill()
        .pipe(lambda df: df.loc[df.index.notna()])
        .pipe(lambda df: MyFinlabDataFrame(df))
        .rename_axis(&quot;date&quot;)
    )

    if not detail:
        ret.index = self.to_business_day(ret.index)

    return ret

def average(self, n):
    &quot;&quot;&quot;取 n 筆移動平均

    若股票在時間窗格內，有 N/2 筆 NaN，則會產生 NaN。
    Args:
      n (positive-int): 設定移動窗格數。
    Returns:
      (pd.DataFrame): data
    Examples:
        股價在均線之上
        ```py
        from finlab import data
        close = data.get('price:收盤價')
        sma = close.average(10)
        cond = close &gt; sma
        ```
        只需要簡單的語法，就可以將其中一部分的訊號繪製出來檢查：
        ```py
        import matplotlib.pyplot as plt

        close.loc['2021', '2330'].plot()
        sma.loc['2021', '2330'].plot()
        cond.loc['2021', '2330'].mul(20).add(500).plot()

        plt.legend(['close', 'sma', 'cond'])
        ```
        &lt;img src=&quot;https://i.ibb.co/Mg1P85y/sma.png&quot; alt=&quot;sma&quot;&gt;
    &quot;&quot;&quot;
    return self.rolling(n, min_periods=int(n / 2)).mean()

def is_largest(self, n):
    &quot;&quot;&quot;取每列前 n 筆大的數值

    若符合 `True` ，反之為 `False` 。用來篩選每天數值最大的股票。

    &lt;img src=&quot;https://i.ibb.co/8rh3tbt/is-largest.png&quot; alt=&quot;is-largest&quot;&gt;
    Args:
      n (positive-int): 設定每列前 n 筆大的數值。
    Returns:
      (pd.DataFrame): data
    Examples:
        每季 ROA 前 10 名的股票
        ```py
        from finlab import data

        roa = data.get('fundamental_features:ROA稅後息前')
        good_stocks = roa.is_largest(10)
        ```
    &quot;&quot;&quot;
    return (
        self.astype(float)
        .apply(lambda s: s.nlargest(n), axis=1)
        .reindex_like(self)
        .notna()
    )

def is_smallest(self, n):
    &quot;&quot;&quot;取每列前 n 筆小的數值

    若符合 `True` ，反之為 `False` 。用來篩選每天數值最小的股票。
    Args:
      n (positive-int): 設定每列前 n 筆小的數值。
    Returns:
      (pd.DataFrame): data
    Examples:
        股價淨值比最小的 10 檔股票
        ```py
        from finlab import data

        pb = data.get('price_earning_ratio:股價淨值比')
        cheap_stocks = pb.is_smallest(10)
        ```
    &quot;&quot;&quot;
    return (
        self.astype(float)
        .apply(lambda s: s.nsmallest(n), axis=1)
        .reindex_like(self)
        .notna()
    )

def is_entry(self):
    &quot;&quot;&quot;進場點

    取進場訊號點，若符合條件的值則為True，反之為False。
    Returns:
      (pd.DataFrame): data
    Examples:
      策略為每日收盤價前10高，取進場點。
        ```py
        from finlab import data
        data.get('price:收盤價').is_largest(10).is_entry()
        ```
    &quot;&quot;&quot;
    return self &amp; ~self.shift(fill_value=False)

def is_exit(self):
    &quot;&quot;&quot;出場點

    取出場訊號點，若符合條件的值則為 True，反之為 False。
    Returns:
      (pd.DataFrame): data
    Examples:
      策略為每日收盤價前10高，取出場點。
        ```py
        from finlab import data
        data.get('price:收盤價').is_largest(10).is_exit()
        ```
    &quot;&quot;&quot;
    return ~self &amp; self.shift(fill_value=False)

def rise(self, n=1):
    &quot;&quot;&quot;數值上升中

    取是否比前第n筆高，若符合條件的值則為True，反之為False。
    &lt;img src=&quot;https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-6-43-41-AM&quot;&gt;
    Args:
      n (positive-int): 設定比較前第n筆高。
    Returns:
      (pd.DataFrame): data
    Examples:
        收盤價是否高於10日前股價
        ```py
        from finlab import data
        data.get('price:收盤價').rise(10)
        ```
    &quot;&quot;&quot;
    return self &gt; self.shift(n)

def fall(self, n=1):
    &quot;&quot;&quot;數值下降中

    取是否比前第n筆低，若符合條件的值則為True，反之為False。
    &lt;img src=&quot;https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-6-43-41-AM&quot;&gt;
    Args:
      n (positive-int): 設定比較前第n筆低。
    Returns:
      (pd.DataFrame): data
    Examples:
        收盤價是否低於10日前股價
        ```py
        from finlab import data
        data.get('price:收盤價').fall(10)
        ```
    &quot;&quot;&quot;
    return self &lt; self.shift(n)

def groupby_category(self):
    &quot;&quot;&quot;資料按產業分群

    類似 `pd.DataFrame.groupby()`的處理效果。
    Returns:
      (pd.DataFrame): data
    Examples:
      半導體平均股價淨值比時間序列
        ```py
        from finlab import data
        pe = data.get('price_earning_ratio:股價淨值比')
        pe.groupby_category().mean()['半導體'].plot()
        ```
        &lt;img src=&quot;https://i.ibb.co/Tq2fKBp/pbmean.png&quot; alt=&quot;pbmean&quot;&gt;

        全球 2020 量化寬鬆加上晶片短缺，使得半導體股價淨值比衝高。
    &quot;&quot;&quot;
    categories = data.get(&quot;security_categories&quot;)
    cat = categories.set_index(&quot;stock_id&quot;).category.to_dict()
    org_set = set(cat.values())
    set_remove_illegal = set(
        o for o in org_set if isinstance(o, str) and o != &quot;nan&quot;
    )
    set_remove_illegal

    refine_cat = {}
    for s, c in cat.items():
        if c == None or c == &quot;nan&quot;:
            refine_cat[s] = &quot;其他&quot;
            continue

        if c == &quot;電腦及週邊&quot;:
            refine_cat[s] = &quot;電腦及週邊設備業&quot;
            continue

        if c[-1] == &quot;業&quot; and c[:-1] in set_remove_illegal:
            refine_cat[s] = c[:-1]
        else:
            refine_cat[s] = c

    col_categories = pd.Series(
        self.columns.map(lambda s: refine_cat[s] if s in cat else &quot;其他&quot;)
    )

    return self.groupby(col_categories.values, axis=1)

def entry_price(self, trade_at=&quot;close&quot;):

    signal = self.is_entry()
    adj = (
        data.get(&quot;etl:adj_close&quot;)
        if trade_at == &quot;close&quot;
        else data.get(&quot;etl:adj_open&quot;)
    )
    adj, signal = adj.reshape(adj.loc[signal.index[0] : signal.index[-1]], signal)
    return adj.bfill()[signal.shift(fill_value=False)].ffill()

def sustain(self, nwindow, nsatisfy=None):
    &quot;&quot;&quot;持續 N 天滿足條件

    取移動 nwindow 筆加總大於等於nsatisfy，若符合條件的值則為True，反之為False。

    Args:
      nwindow (positive-int): 設定移動窗格。
      nsatisfy (positive-int): 設定移動窗格計算後最低滿足數值。
    Returns:
      (pd.DataFrame): data
    Examples:
        收盤價是否連兩日上漲
        ```py
        from finlab import data
        data.get('price:收盤價').rise().sustain(2)
        ```
    &quot;&quot;&quot;
    nsatisfy = nsatisfy or nwindow
    return self.rolling(nwindow).sum() &gt;= nsatisfy

def industry_rank(self, categories=None):
    &quot;&quot;&quot;計算產業 ranking 排名，0 代表產業內最低，1 代表產業內最高
    Args:
      categories (list of str): 欲考慮的產業，ex: ['貿易百貨', '雲端運算']，預設為全產業，請參考 `data.get('security_industry_themes')` 中的產業項目。
    Examples:
        本意比產業排名分數
        ```py
        from finlab import data

        pe = data.get('price_earning_ratio:本益比')
        pe_rank = pe.industry_rank()
        print(pe_rank)
        ```
    &quot;&quot;&quot;

    themes = (
        data.get(&quot;security_industry_themes&quot;)
        .copy()  # 複製
        .assign(
            category=lambda self: self.category.apply(lambda s: eval(s))
        )  # 從文字格式轉成陣列格
        .explode(&quot;category&quot;)  # 展開資料
    )

    categories = categories or set(
        themes.category[themes.category.str.find(&quot;:&quot;) == -1]
    )

    def calc_rank(ind):
        stock_ids = themes.stock_id[themes.category == ind]
        return self[stock_ids].pipe(lambda self: self.rank(axis=1, pct=True))

    return (
        pd.concat([calc_rank(ind) for ind in categories], axis=1)
        .groupby(level=0, axis=1)
        .mean()
    )

def quantile_row(self, c):
    &quot;&quot;&quot;股票當天數值分位數

    取得每列c定分位數的值。
    Args:
      c (positive-int): 設定每列 n 定分位數的值。
    Returns:
      (pd.DataFrame): data
    Examples:
        取每日股價前90％分位數
        ```py
        from finlab import data
        data.get('price:收盤價').quantile_row(0.9)
        ```
    &quot;&quot;&quot;
    s = self.quantile(c, axis=1)
    return s

def exit_when(self, exit):

    df, exit = self.reshape(self, exit)

    df.fillna(False, inplace=True)
    exit.fillna(False, inplace=True)

    entry_signal = df.is_entry()
    exit_signal = df.is_exit()
    exit_signal |= exit

    # build position using entry_signal and exit_signal
    position = pd.DataFrame(np.nan, index=df.index, columns=df.columns)
    position[entry_signal] = 1
    position[exit_signal] = 0

    position.ffill(inplace=True)
    position = position == 1
    position.fillna(False)
    return position

def hold_until(
    self,
    exit,
    nstocks_limit=None,
    stop_loss=-np.inf,
    take_profit=np.inf,
    trade_at=&quot;close&quot;,
    rank=None,
):
    &quot;&quot;&quot;訊號進出場

    這大概是所有策略撰寫中，最重要的語法糖，上述語法中 `entries` 為進場訊號，而 `exits` 是出場訊號。所以 `entries.hold_until(exits)` ，就是進場訊號為 `True` 時，買入並持有該檔股票，直到出場訊號為 `True ` 則賣出。
    &lt;img src=&quot;https://i.ibb.co/PCt4hPd/Screen-Shot-2021-10-26-at-6-35-05-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-6-35-05-AM&quot;&gt;
    此函式有很多細部設定，可以讓你最多選擇 N 檔股票做輪動。另外，當超過 N 檔進場訊號發生，也可以按照客製化的排序，選擇優先選入的股票。最後，可以設定價格波動當輪動訊號，來增加出場的時機點。

    Args:
      exit (pd.Dataframe): 出場訊號。
      nstocks_limit (int)`: 輪動檔數上限，預設為None。
      stop_loss (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價下跌 10% 時產生出場訊號。
      take_profit (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價上漲 10% 時產生出場訊號。
      trade_at (str): 價格波動輪動訊號參考價，預設為'close'。可選 `close` 或 `open`。
      rank (pd.Dataframe): 當天進場訊號數量超過 nstocks_limit 時，以 rank 數值越大的股票優先進場。
    Returns:
      (pd.DataFrame): data
    Examples:
        價格 &gt; 20 日均線入場, 價格 &lt; 60 日均線出場，最多持有10檔，超過 10 個進場訊號，則以股價淨值比小的股票優先選入。

        ```python
        from finlab import data
        from finlab.backtest import sim

        close = data.get('price:收盤價')
        pb = data.get('price_earning_ratio:股價淨值比')

        sma20 = close.average(20)
        sma60 = close.average(60)

        entries = close &gt; sma20
        exits = close &lt; sma60

        ＃pb前10小的標的做輪動
        position = entries.hold_until(exits, nstocks_limit=10, rank=-pb)
        sim(position)
        ```
    &quot;&quot;&quot;
    if nstocks_limit is None:
        nstocks_limit = len(self.columns)

    union_index = self.index.union(exit.index)
    intersect_col = self.columns.intersection(exit.columns)

    if stop_loss != -np.inf or take_profit != np.inf:
        price = data.get(f&quot;etl:adj_{trade_at}&quot;)
        union_index = union_index.union(
            price.loc[union_index[0] : union_index[-1]].index
        )
        intersect_col = intersect_col.intersection(price.columns)
    else:
        price = pd.DataFrame()

    if rank is not None:
        union_index = union_index.union(rank.index)
        intersect_col = intersect_col.intersection(rank.columns)

    entry = (
        self.reindex(union_index, columns=intersect_col, method=&quot;ffill&quot;)
        .ffill()
        .fillna(False)
    )
    exit = (
        exit.reindex(union_index, columns=intersect_col, method=&quot;ffill&quot;)
        .ffill()
        .fillna(False)
    )

    if price is not None:
        price = price.reindex(union_index, columns=intersect_col, method=&quot;ffill&quot;)

    if rank is not None:
        rank = rank.reindex(union_index, columns=intersect_col, method=&quot;ffill&quot;)
    else:
        rank = pd.DataFrame(1, index=union_index, columns=intersect_col)

    max_rank = rank.max().max()
    min_rank = rank.min().min()
    rank = (rank - min_rank) / (max_rank - min_rank)
    rank.fillna(0, inplace=True)

    def rotate_stocks(
        ret,
        entry,
        exit,
        nstocks_limit,
        stop_loss=-np.inf,
        take_profit=np.inf,
        price=None,
        ranking=None,
    ):

        nstocks = 0

        ret[0][np.argsort(entry[0])[-nstocks_limit:]] = 1
        ret[0][exit[0] == 1] = 0
        ret[0][entry[0] == 0] = 0

        entry_price = np.empty(entry.shape[1])
        entry_price[:] = np.nan

        for i in range(1, entry.shape[0]):

            # regitser entry price
            if stop_loss != -np.inf or take_profit != np.inf:
                is_entry = (ret[i - 2] == 0) if i &gt; 1 else (ret[i - 1] == 1)

                is_waiting_for_entry = np.isnan(entry_price) &amp; (ret[i - 1] == 1)

                is_entry |= is_waiting_for_entry

                entry_price[is_entry == 1] = price[i][is_entry == 1]

                # check stop_loss and take_profit
                returns = price[i] / entry_price
                stop = (returns &gt; 1 + abs(take_profit)) | (
                    returns &lt; 1 - abs(stop_loss)
                )
                exit[i] |= stop

            # run signal
            rank = entry[i] * ranking[i] + ret[i - 1] * 3
            rank[exit[i] == 1] = -1
            rank[(entry[i] == 0) &amp; (ret[i - 1] == 0)] = -1

            ret[i][np.argsort(rank)[-nstocks_limit:]] = 1
            ret[i][rank == -1] = 0

        return ret

    ret = pd.DataFrame(0, index=entry.index, columns=entry.columns)
    ret = rotate_stocks(
        ret.values,
        entry.astype(int).values,
        exit.astype(int).values,
        nstocks_limit,
        stop_loss,
        take_profit,
        price=price.values,
        ranking=rank.values,
    )

    return pd.DataFrame(ret, index=entry.index, columns=entry.columns)
</code></pre>
<p>@functools.lru_cache
def calc_disclosure_dates(detail=True):</p>
<pre><code>cinfo = data.get(&quot;company_basic_info&quot;).copy()
cinfo[&quot;id&quot;] = cinfo.stock_id.str.split(&quot; &quot;).str[0]
cinfo = cinfo.set_index(&quot;id&quot;)
cinfo = cinfo[~cinfo.index.duplicated(keep=&quot;last&quot;)]

def calc_default_disclosure_dates(s):
    sid = s.name
    cat = cinfo.loc[sid].產業類別 if sid in cinfo.index else &quot;etf&quot;
    short_name = cinfo.loc[sid].公司簡稱 if sid in cinfo.index else &quot;etf&quot;

    if cat == &quot;金融業&quot;:
        calendar = {
            &quot;1&quot;: &quot;-05-15&quot;,
            &quot;2&quot;: &quot;-08-31&quot;,
            &quot;3&quot;: &quot;-11-14&quot;,
            &quot;4&quot;: &quot;-03-31&quot;,
        }
    elif cat == &quot;金融保險業&quot;:
        calendar = {
            &quot;1&quot;: &quot;-04-30&quot;,
            &quot;2&quot;: &quot;-08-31&quot;,
            &quot;3&quot;: &quot;-10-31&quot;,
            &quot;4&quot;: &quot;-03-31&quot;,
        }
    elif &quot;KY&quot; in short_name:
        calendar = {
            &quot;old&quot;: {&quot;1&quot;: &quot;-05-15&quot;, &quot;2&quot;: &quot;-08-14&quot;, &quot;3&quot;: &quot;-11-14&quot;, &quot;4&quot;: &quot;-03-31&quot;,},
            &quot;new&quot;: {&quot;1&quot;: &quot;-05-15&quot;, &quot;2&quot;: &quot;-08-31&quot;, &quot;3&quot;: &quot;-11-14&quot;, &quot;4&quot;: &quot;-03-31&quot;,},
        }
    else:
        calendar = {
            &quot;1&quot;: &quot;-05-15&quot;,
            &quot;2&quot;: &quot;-08-14&quot;,
            &quot;3&quot;: &quot;-11-14&quot;,
            &quot;4&quot;: &quot;-03-31&quot;,
        }
    get_year = (
        lambda year, season: str(year) if int(season) != 4 else str(int(year) + 1)
    )
    ky_policy_check = lambda year: &quot;new&quot; if year &gt;= &quot;2021&quot; else &quot;old&quot;
    return pd.to_datetime(
        s.index.map(
            lambda d: get_year(d[:4], d[-1])
            + calendar[ky_policy_check(d[:4])][d[-1]]
        )
        if &quot;KY&quot; in short_name
        else s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[d[-1]])
    )

def season_end(s):

    calendar = {
        &quot;1&quot;: &quot;-3-31&quot;,
        &quot;2&quot;: &quot;-6-30&quot;,
        &quot;3&quot;: &quot;-9-30&quot;,
        &quot;4&quot;: &quot;-12-31&quot;,
    }
    return pd.to_datetime(s.index.map(lambda d: d[:4] + calendar[d[-1]]))

disclosure_dates = data.get(&quot;financial_statements_upload_detail:upload_date&quot;)
disclosure_dates = disclosure_dates.apply(pd.to_datetime)

financial_season_end = disclosure_dates.apply(season_end)
default_disclosure_dates = disclosure_dates.apply(calc_default_disclosure_dates)

disclosure_dates[
    (disclosure_dates &gt; default_disclosure_dates)
    | (disclosure_dates &lt; financial_season_end)
] = pd.NaT
disclosure_dates[(disclosure_dates.diff() &lt;= datetime.timedelta(days=0))] = pd.NaT
disclosure_dates.loc[&quot;2019-Q1&quot;, &quot;3167&quot;] = pd.NaT
disclosure_dates.loc[&quot;2015-Q1&quot;, &quot;5536&quot;] = pd.NaT
disclosure_dates.loc[&quot;2018-Q1&quot;, &quot;5876&quot;] = pd.NaT

disclosure_dates = disclosure_dates.fillna(default_disclosure_dates)
disclosure_dates.columns.name = &quot;stock_id&quot;

if detail:
    return disclosure_dates
return default_disclosure_dates
</code></pre>
<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
# finlab.login(&quot;&quot;)
# close = data.get(&quot;price:收盤價&quot;)
# close = MyFinlabDataFrame(close)
# rev = data.get(&quot;monthly_revenue:當月營收&quot;)
# rev = MyFinlabDataFrame(rev)</p>
<pre><code>## 股價創年新高
# cond1 = close == close.rolling(250).max()

## 確認營收底部，近月營收脫離近年穀底(連續3月的&quot;單月營收近12月最小值/近月營收&quot; &lt; 0.8)
# cond4 = ((rev.rolling(12).min()) / (rev) &lt; 0.8).sustain(3)
# print(cond1)
# print(cond4)
# print(cond1 &amp; cond4)

df = MyFinlabDataFrame(
    np.random.randint(0, 100, size=(10, 5)), columns=list(&quot;BCDEH&quot;)
)
df1 = MyFinlabDataFrame(
    np.random.randint(0, 100, size=(5, 4)), columns=list(&quot;ABCD&quot;)
)
df = df &gt; 50
df1 = df1 &gt; 50
print(df)
print(df1)
print(df &amp; df1)
</code></pre>
<pre><code>

## pandas 找出重複的列
```python
import pandas as pd

# Example dataframes
df1 = pd.DataFrame({
    'date': ['2002-02-01', '2002-02-01', '2002-03-01', '2002-03-01', '2002-04-01'],
    'stock_id': [1101, 1101, 1101, 1101, 1101],
    'country': ['Taiwan', 'Taiwan', 'Taiwan', 'Taiwan', 'Taiwan'],
    'revenue': [2200067000, 2200067000, 1404336000, 1404336000, 2028782000],
    'revenue_month': [1, 1, 2, 2, 3],
    'revenue_year': [2002, 2002, 2002, 2002, 2002]
})

df2 = pd.DataFrame({
    'date': ['2023-02-01', '2023-03-01', '2023-03-01', '2023-04-01', '2023-04-01'],
    'stock_id': [1101, 1101, 1101, 1101, 1101],
    'country': ['Taiwan', 'Taiwan', 'Taiwan', 'Taiwan', 'Taiwan'],
    'revenue': [7325221000, 7306069000, 7306069000, 11730367000, 11730367000],
    'revenue_month': [1, 2, 2, 3, 3],
    'revenue_year': [2023, 2023, 2023, 2023, 2023]
})


print(df1, df2)
concatenated = pd.concat([df1, df2], ignore_index=True)
differences = concatenated.drop_duplicates(keep=False)
print(differences)
</code></pre>
<h2 id="兩組-dataframe-找出多餘-row-組成-dataframe"><a class="header" href="#兩組-dataframe-找出多餘-row-組成-dataframe">兩組 dataframe 找出多餘 row 組成 dataframe</a></h2>
<pre><code class="language-python">import pandas as pd

# create the DataFrame
import pandas as pd

df1 = pd.DataFrame({'A': [1, 2, 3], 'B': [1, 5, 6]})
df2 = pd.DataFrame({'A': [1, 2], 'B': [1, 5]})
df = df1 - df2
print(df1.to_markdown())
print(&quot;\n&quot;)
print(df2.to_markdown())


result = df1 - df2

indexs = []

for index, row in df.iterrows():
    if row.A != 0 or row.B != 0:
        indexs.append(index)
        

print(&quot;\n&quot;)
result_df = df1.loc[indexs]
print(result_df.to_markdown())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="async-def--await-重點整理"><a class="header" href="#async-def--await-重點整理">async def &amp; await 重點整理</a></h2>
<h2 id="sync-def--await-使用情境"><a class="header" href="#sync-def--await-使用情境"><code>sync def</code> &amp; <code>await</code> 使用情境</a></h2>
<p>我直接利用下面這個例子來展示什麼情況下可以使用 <code>async</code> 和 <code>await</code>。</p>
<pre><code class="language-python">import time

def dosomething(i):
    print(f&quot;第 {i} 次開始&quot;)
    time.sleep(2)
    print(f&quot;第 {i} 次結束&quot;)

if __name__ == &quot;__main__&quot;:
    start = time.time()
    for i in range(5):
        dosomething(i+1)
    print(f&quot;time: {time.time() - start} (s)&quot;)
</code></pre>
<p>執行後應該會像這樣。</p>
<pre><code>第 1 次開始
第 1 次結束
第 2 次開始
第 2 次結束
第 3 次開始
第 3 次結束
第 4 次開始
第 4 次結束
第 5 次開始
第 5 次結束
time: 10.048049688339233 (s)
</code></pre>
<p>這非常直覺，因為每次呼叫 <code>dosomething()</code> 時都會等待2秒，等完才會執行下一輪，所以最後執行總時間是10秒相當合理。</p>
<p><img src="python/images/pFXvFe9.png" alt="img" /></p>
<p>但仔細想想，如果那2秒是做網路請求或檔案讀寫(IO)，這2秒是不需要CPU的，但CPU就只能發呆2秒，痴痴地等待回傳結果，其他什麼事都不能做，豈不是太浪費了嗎!? (學過作業系統的人就知道，絕對不能讓CPU發呆XD)</p>
<p>因此 Python 就有了 <code>asyncio</code> 這個工具，來徹底的利用(X) 榨乾(O) CPU的效能。</p>
<p>我把剛才的例子改成 <code>asyncio</code> 的版本。</p>
<p>我把剛才的例子改成 <code>asyncio</code> 的版本。</p>
<pre><code class="language-python">import time
import asyncio

async def dosomething(i):
    print(f&quot;第 {i} 次開始&quot;)
    await asyncio.sleep(2)
    print(f&quot;第 {i} 次結束&quot;)

if __name__ == &quot;__main__&quot;:
    start = time.time()
    tasks = [dosomething(i+1) for i in range(5)]
    asyncio.run(asyncio.wait(tasks))
    print(f&quot;time: {time.time() - start} (s)&quot;)
</code></pre>
<p>執行結果會變成這樣，只需要2秒就結束了!</p>
<pre><code>第 2 次開始
第 1 次開始
第 3 次開始
第 4 次開始
第 5 次開始
第 2 次結束
第 3 次結束
第 5 次結束
第 1 次結束
第 4 次結束
time: 2.011152982711792 (s)
</code></pre>
<p>為什麼會這樣呢? 其實 <code>await</code> 就是告訴 CPU 說後面這個函數很慢，不需要等它執行完畢。因此此時 CPU 就可以先跳去執行其他的事情，只需要在這個函數結束時再回來處理就好。這就是為什麼速度會快很多。</p>
<p><img src="python/images/Xqkma61.png" alt="img" /></p>
<p>瞭解 <code>async def</code> &amp; <code>await</code> 使用情境之後，就來說明一些細節吧!</p>
<h2 id="coroutine"><a class="header" href="#coroutine">coroutine</a></h2>
<p>首先，<code>async def</code> &amp; <code>await</code> 是 Python 3.5+ 之後才出現的 <a href="https://zh.wikipedia.org/zh-tw/%E8%AA%9E%E6%B3%95%E7%B3%96">語法糖</a>，目的是讓 coroutine 之間的調度更加清楚。</p>
<p>那就要先了解什麼是 <strong>coroutine</strong>。</p>
<p>根據 Python 官方對 coroutine 定義：</p>
<blockquote>
<p>Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points. They can be implemented with the async def statement.</p>
</blockquote>
<p>簡單講 coroutine 可以在任意的時間點開始、暫停和離開，並且透過 <code>async def</code> 宣告此函數為一個 coroutine。</p>
<p>所以 <code>await</code> 的作用就是告訴 CPU 說可以暫停後面的工作，先去執行其他程式。另外 <code>await</code> 只能在 coroutine 中宣告，這就是為什麼 <code>await</code> 必須寫在 <code>async def</code> 裡面。</p>
<p>另一個要注意的點，<code>await</code> 後只能接 <code>awaitables</code> 物件，<code>awaitables</code> 物件就包括 coroutine, Task, Future 和有實作 <code>__await__()</code> 的物件。所以並不是所有函數都可以使用 <code>await</code> 加速。</p>
<h2 id="coroutine-使用範例"><a class="header" href="#coroutine-使用範例">coroutine 使用範例</a></h2>
<p>最後來講 coroutine 的使用範例吧!</p>
<pre><code class="language-python">import asyncio

async def main():
    await asyncio.sleep(1)
    print('hello')

main()
</code></pre>
<p>執行後應該會出錯：</p>
<pre><code>RuntimeWarning: coroutine 'main' was never awaited
  main()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
</code></pre>
<p>這是因為現在 <code>main()</code> 已經宣告成一個 coroutine 了，所以不能夠直接呼叫，而是要改成用 <code>asyncio.run()</code> 呼叫，所以將程式碼改成下面這樣就可以成功印出 hello 了。</p>
<pre><code class="language-python">import asyncio

async def main():
    await asyncio.sleep(1)
    print('hello')

asyncio.run(main())
</code></pre>
<p>好，<code>async def</code> &amp; <code>await</code> 就大致介紹到這邊，關於 <code>asyncio</code> 有滿多東西可以玩的，有需要歡迎看這篇 <a href="https://myapollo.com.tw/zh-tw/begin-to-asyncio/">Python asyncio 從不會到上路</a>。</p>
<h2 id="fastapi-async-def--await"><a class="header" href="#fastapi-async-def--await">FastAPI <code>async def</code> &amp; <code>await</code></a></h2>
<p>最後回來看 <a href="https://fastapi.tiangolo.com/async/">FastAPI 文件</a> 中怎麼說明 <code>async def</code> &amp; <code>await</code> 的。</p>
<p>他說如果你需要在 path operation function 中呼叫一些很慢的函數 (如: 讀取資料庫、網路請求...) 時，就可以使用 <code>async def</code> 和 <code>await</code> 來加速，就像下面的例子。</p>
<pre><code class="language-python=">@app.get('/')
async def read_results():
    results = await do_something()  # do_something() is slow
    return results
</code></pre>
<p>但如果不需要呼叫這些函數，就直接使用一般 <code>def</code> 即可。</p>
<p>現在就能明白為何 FastAPI 要使用 <code>async def</code> 和 <code>await</code> 了吧!</p>
<hr />
<pre><code class="language-python">import asyncio
import multiprocessing as mp

async def crawl_data():
    while True:
        print('Crawling data...')
        await asyncio.sleep(1)

def start_crawler():
    asyncio.run(crawl_data())

if __name__ == '__main__':
    p = mp.Process(target=start_crawler)
    p.start()
    p.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eps"><a class="header" href="#eps">EPS</a></h2>
<pre><code class="language-python">import requests
import pandas as pd

pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x


url = &quot;https://api.finmindtrade.com/api/v4/data&quot;
parameter = {
    &quot;dataset&quot;: &quot;TaiwanStockFinancialStatements&quot;,
    &quot;data_id&quot;: &quot;2330&quot;,
    &quot;start_date&quot;: &quot;2019-01-01&quot;,
    &quot;token&quot;: &quot;&quot;,  # 參考登入，獲取金鑰
}
data = requests.get(url, params=parameter)
data = data.json()
data = pd.DataFrame(data[&quot;data&quot;])
eps_data = data[data[&quot;type&quot;] == &quot;EPS&quot;]
eps_data.reset_index(drop=True, inplace=True)
print(eps_data) 
</code></pre>
<pre><code class="language-shell">pip install FinMind
</code></pre>
<h2 id="臺灣還原股價資料表-taiwanstockpriceadj"><a class="header" href="#臺灣還原股價資料表-taiwanstockpriceadj">臺灣還原股價資料表 TaiwanStockPriceAdj</a></h2>
<pre><code class="language-python">from FinMind.data import DataLoader

api = DataLoader()
# api.login_by_token(api_token='token')
# api.login(user_id='user_id',password='password')
df = api.taiwan_stock_daily_adj(
    stock_id=&quot;2330&quot;, start_date=&quot;2000-04-02&quot;, end_date=&quot;2023-04-12&quot;
)
print(df)
</code></pre>
<h2 id="股價日成交資訊-taiwanstockprice"><a class="header" href="#股價日成交資訊-taiwanstockprice">股價日成交資訊 TaiwanStockPrice<a href="https://finmind.github.io/tutor/TaiwanMarket/Technical/#taiwanstockprice">¶</a></a></h2>
<pre><code class="language-python">from FinMind.data import DataLoader

api = DataLoader()
# api.login_by_token(api_token='token')
# api.login(user_id='user_id',password='password')
df = api.taiwan_stock_daily(
    stock_id='2330',
    start_date='2020-04-02',
    end_date='2020-04-12'
)
</code></pre>
<h2 id="回測引用外部-data"><a class="header" href="#回測引用外部-data">回測(引用外部 data)</a></h2>
<pre><code class="language-python">import numpy as np
import pandas as pd
from FinMind import strategies
from FinMind.data import DataLoader
from FinMind.strategies.base import Strategy
from ta.momentum import StochasticOscillator


class ShortSaleMarginPurchaseRatio(Strategy):
    &quot;&quot;&quot;
    summary:
        策略概念: 券資比越高代表散戶看空，法人買超股票會上漲，這時候賣可以跟大部分散戶進行相反的操作，反之亦然
        策略規則: 券資比&gt;=30% 且法人買超股票, 賣
                券資比&lt;30% 且法人賣超股票 買
    &quot;&quot;&quot;

    ShortSaleMarginPurchaseTodayRatioThreshold = 0.3

    def load_taiwan_stock_margin_purchase_short_sale(self):
        self.TaiwanStockMarginPurchaseShortSale = self.data_loader.taiwan_stock_margin_purchase_short_sale(
            stock_id=self.stock_id, start_date=self.start_date, end_date=self.end_date,
        )
        self.TaiwanStockMarginPurchaseShortSale[
            [&quot;ShortSaleTodayBalance&quot;, &quot;MarginPurchaseTodayBalance&quot;]
        ] = self.TaiwanStockMarginPurchaseShortSale[
            [&quot;ShortSaleTodayBalance&quot;, &quot;MarginPurchaseTodayBalance&quot;]
        ].astype(
            int
        )
        self.TaiwanStockMarginPurchaseShortSale[&quot;ShortSaleMarginPurchaseTodayRatio&quot;] = (
            self.TaiwanStockMarginPurchaseShortSale[&quot;ShortSaleTodayBalance&quot;]
            / self.TaiwanStockMarginPurchaseShortSale[&quot;MarginPurchaseTodayBalance&quot;]
        )

    def load_institutional_investors_buy_sell(self):
        self.InstitutionalInvestorsBuySell = self.data_loader.taiwan_stock_institutional_investors(
            stock_id=self.stock_id, start_date=self.start_date, end_date=self.end_date,
        )
        self.InstitutionalInvestorsBuySell[[&quot;sell&quot;, &quot;buy&quot;]] = (
            self.InstitutionalInvestorsBuySell[[&quot;sell&quot;, &quot;buy&quot;]].fillna(0).astype(int)
        )
        self.InstitutionalInvestorsBuySell = self.InstitutionalInvestorsBuySell.groupby(
            [&quot;date&quot;, &quot;stock_id&quot;], as_index=False
        ).agg({&quot;buy&quot;: np.sum, &quot;sell&quot;: np.sum})
        self.InstitutionalInvestorsBuySell[&quot;diff&quot;] = (
            self.InstitutionalInvestorsBuySell[&quot;buy&quot;]
            - self.InstitutionalInvestorsBuySell[&quot;sell&quot;]
        )

    def create_trade_sign(self, stock_price: pd.DataFrame) -&gt; pd.DataFrame:
        stock_price = stock_price.sort_values(&quot;date&quot;)
        self.load_taiwan_stock_margin_purchase_short_sale()
        self.load_institutional_investors_buy_sell()
        stock_price = pd.merge(
            stock_price,
            self.InstitutionalInvestorsBuySell[[&quot;stock_id&quot;, &quot;date&quot;, &quot;diff&quot;]],
            on=[&quot;stock_id&quot;, &quot;date&quot;],
            how=&quot;left&quot;,
        ).fillna(0)
        stock_price = pd.merge(
            stock_price,
            self.TaiwanStockMarginPurchaseShortSale[
                [&quot;stock_id&quot;, &quot;date&quot;, &quot;ShortSaleMarginPurchaseTodayRatio&quot;]
            ],
            on=[&quot;stock_id&quot;, &quot;date&quot;],
            how=&quot;left&quot;,
        ).fillna(0)
        stock_price.index = range(len(stock_price))
        stock_price[&quot;signal&quot;] = 0
        sell_mask = (
            stock_price[&quot;ShortSaleMarginPurchaseTodayRatio&quot;]
            &gt;= self.ShortSaleMarginPurchaseTodayRatioThreshold
        ) &amp; (stock_price[&quot;diff&quot;] &gt; 0)
        stock_price.loc[sell_mask, &quot;signal&quot;] = -1
        buy_mask = (
            stock_price[&quot;ShortSaleMarginPurchaseTodayRatio&quot;]
            &lt; self.ShortSaleMarginPurchaseTodayRatioThreshold
        ) &amp; (stock_price[&quot;diff&quot;] &lt; 0)
        stock_price.loc[buy_mask, &quot;signal&quot;] = 1
        return stock_price


data_loader = DataLoader()
# data_loader.login(user_id, password) # 可選
obj = strategies.BackTest(
    stock_id=&quot;0056&quot;,
    start_date=&quot;2018-01-01&quot;,
    end_date=&quot;2019-01-01&quot;,
    trader_fund=500000.0,
    fee=0.001425,
    data_loader=data_loader,
)

obj.add_strategy(ShortSaleMarginPurchaseRatio)
obj.simulate()

print(obj.final_stats)
print(obj.trade_detail)
obj.plot()
</code></pre>
<h2 id="python-即時資料-pipeline以版塊圖x即時股市資料為例"><a class="header" href="#python-即時資料-pipeline以版塊圖x即時股市資料為例">Python 即時資料 Pipeline，以版塊圖X即時股市資料為例</a></h2>
<p>https://medium.com/finmind/python-%E5%8D%B3%E6%99%82%E8%B3%87%E6%96%99-pipeline-%E4%BB%A5%E7%89%88%E5%A1%8A%E5%9C%96x%E5%8D%B3%E6%99%82%E8%82%A1%E5%B8%82%E8%B3%87%E6%96%99%E7%82%BA%E4%BE%8B-a55de908dd5b</p>
<pre><code class="language-python">import os
import typing

import numpy as np
import pandas as pd
import plotly.express as px
import requests
from apscheduler.schedulers.background import BackgroundScheduler
from FinMind.data import DataLoader
from flask import Flask
from loguru import logger


class TreeMap:
    def __init__(self):
        self.token = os.environ.get(&quot;FINMIND_API_TOKEN&quot;)
        self.html = &quot;初始化~~~&quot;
        self.api = DataLoader()
        self.api.login_by_token(api_token=self.token)
        self.stock_info = self.api.taiwan_stock_info()
        self.data_clean()

    def data_clean(self) -&gt; typing.Tuple[pd.DataFrame, pd.DataFrame]:
        logger.info(&quot;data_clean&quot;)
        self.stock_info.drop([&quot;date&quot;, &quot;type&quot;], axis=1, inplace=True)

    def filter_top_5_stock(self, plot_df: pd.DataFrame) -&gt; pd.DataFrame:
        top_df = plot_df[[&quot;stock_id&quot;, &quot;industry_category&quot;, &quot;Trading_Money&quot;]]
        top_df = top_df.sort_values(&quot;Trading_Money&quot;, ascending=False)
        top_df = top_df.groupby(&quot;industry_category&quot;).head(5)
        top_df = top_df[[&quot;stock_id&quot;, &quot;industry_category&quot;]]
        plot_df = top_df.merge(
            plot_df, how=&quot;left&quot;, on=[&quot;stock_id&quot;, &quot;industry_category&quot;]
        )
        return plot_df

    def feature_engineer(self, snapshot_df: pd.DataFrame):
        logger.info(&quot;feature_engineer&quot;)
        last_datetime = max(snapshot_df[&quot;date&quot;])
        plot_df = snapshot_df[
            [&quot;stock_id&quot;, &quot;total_amount&quot;, &quot;change_rate&quot;, &quot;close&quot;]
        ]
        plot_df.columns = [&quot;stock_id&quot;, &quot;Trading_Money&quot;, &quot;漲跌幅%&quot;, &quot;close&quot;]
        plot_df = plot_df.merge(self.stock_info, how=&quot;inner&quot;, on=[&quot;stock_id&quot;])
        for col in [&quot;Index&quot;, &quot;大盤&quot;]:
            plot_df = plot_df[plot_df[&quot;industry_category&quot;] != col]

        index_df = plot_df.groupby([&quot;industry_category&quot;])[&quot;Trading_Money&quot;].agg(
            sum
        )
        index_df = index_df.reset_index()
        index_df.columns = [&quot;industry_category&quot;, &quot;Index_Trading_Money&quot;]
        plot_df = plot_df.merge(index_df, how=&quot;inner&quot;, on=[&quot;industry_category&quot;])
        plot_df = self.filter_top_5_stock(plot_df)
        plot_df[&quot;stock_name&quot;] = (
            plot_df[&quot;stock_id&quot;] + &quot; &quot; + plot_df[&quot;stock_name&quot;]
        )
        plot_df[&quot;spread_rate_label&quot;] = plot_df[&quot;漲跌幅%&quot;].astype(str)
        return plot_df, last_datetime

    def plot(self, plot_df: pd.DataFrame, last_datetime: str):
        logger.info(&quot;plot&quot;)
        fig = px.treemap(
            plot_df,
            path=[&quot;industry_category&quot;, &quot;stock_name&quot;],
            values=&quot;Trading_Money&quot;,
            color=&quot;漲跌幅%&quot;,
            color_continuous_scale=[[0, &quot;green&quot;], [0.5, &quot;white&quot;], [1, &quot;red&quot;]],
            color_continuous_midpoint=0,
            custom_data=[&quot;stock_name&quot;, &quot;close&quot;, &quot;spread_rate_label&quot;],
            title=f&quot;臺股交易額X漲跌幅 {last_datetime}&quot;,
            width=1350,
            height=900,
        )
        texttemplate = &quot;%{customdata[0]}&lt;br&gt;收盤價 %{customdata[1]}&lt;br&gt;漲跌幅(%) %{customdata[2]}&lt;br&gt;&quot;
        fig.update_traces(
            textposition=&quot;middle center&quot;,
            textfont_size=24,
            texttemplate=texttemplate,
        )
        # fig.data[0].labels
        fig.data[0][&quot;marker&quot;][&quot;colors&quot;] = np.round(
            fig.data[0][&quot;marker&quot;][&quot;colors&quot;], 2
        )

        html = fig.to_html()
        return html

    def get_snapshot(self) -&gt; pd.DataFrame:
        logger.info(&quot;get snapshot&quot;)
        url = &quot;https://api.finmindtrade.com/api/v4/taiwan_stock_tick_snapshot&quot;
        parameter = {
            &quot;token&quot;: self.token,  # 參考登入，獲取金鑰
        }
        resp = requests.get(url, params=parameter)
        data = resp.json()
        if data[&quot;status&quot;] != 200:
            raise Exception(data[&quot;msg&quot;])
        df = pd.DataFrame(data[&quot;data&quot;])
        return df

    def main(self):
        # load data
        snapshot_df = self.get_snapshot()
        # feature engineer
        plot_df, last_datetime = self.feature_engineer(snapshot_df)
        # plot
        self.html = self.plot(plot_df, last_datetime)


def set_scheduler():
    scheduler = BackgroundScheduler(
        timezone=&quot;Asia/Taipei&quot;, job_defaults={&quot;max_instances&quot;: 1}
    )
    scheduler.add_job(
        id=&quot;snapshot&quot;,
        func=tree_map.main,
        trigger=&quot;cron&quot;,
        day_of_week=&quot;*&quot;,
        hour=&quot;*&quot;,
        minute=&quot;*&quot;,
        second=&quot;*/5&quot;,
    )
    scheduler.start()
    logger.info(&quot;scheduler start&quot;)


app = Flask(__name__)
tree_map = TreeMap()


@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def submit():
    html = tree_map.html
    return f&quot;&quot;&quot;
        &lt;meta http-equiv=&quot;refresh&quot; content=&quot;1&quot; /&gt; 
        {html}
    &quot;&quot;&quot;


set_scheduler()
app.run(host=&quot;0.0.0.0&quot;, debug=True)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="python-telegram-bot"><a class="header" href="#python-telegram-bot">Python Telegram Bot</a></h2>
<p>https://hackmd.io/@truckski/HkgaMUc24?type=view</p>
<p>找 <a href="https://t.me/BotFather">@BotFather</a> 申請一個 Bot。</p>
<ol>
<li>/newbot</li>
<li>輸入名稱</li>
<li>輸入 username</li>
<li>記下 token</li>
</ol>
<p><img src="python/images/NqKAsLK.png" alt="New Bot" /></p>
<h2 id="hello-world-2"><a class="header" href="#hello-world-2">hello, world</a></h2>
<p>執行這個程式，注意 <code>'YOUR TOKEN HERE'</code> 的地方請填入前面得到的 Token。</p>
<pre><code class="language-python">from telegram.ext import Updater, CommandHandler

def hello(bot, update):
    update.message.reply_text(
        'hello, {}'.format(update.message.from_user.first_name))


updater = Updater('YOUR TOKEN HERE')

updater.dispatcher.add_handler(CommandHandler('hello', hello))

updater.start_polling()
updater.idle()
</code></pre>
<p>用 Bot 的 username 或是 BotFather 給的連結可以找到前面建立的 Bot。
對它輸入 <code>/hello</code>。</p>
<p><img src="python/images/eeRxLC3.png" alt="hello" /></p>
<h2 id="command-handler-可從-update-獲得的資訊"><a class="header" href="#command-handler-可從-update-獲得的資訊">Command Handler 可從 update 獲得的資訊</a></h2>
<ul>
<li>update
<ul>
<li>update_id</li>
<li>message
<ul>
<li>message_id</li>
<li>from_user：發訊人
<ul>
<li>id</li>
<li>first_name</li>
<li>last_name</li>
<li>full_name</li>
<li>username</li>
</ul>
</li>
<li>chat：訊息所在的聊天室
<ul>
<li>id</li>
<li>type</li>
</ul>
</li>
<li>text：訊息內容</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.message.html">更多資訊</a></p>
<h2 id="傳訊息"><a class="header" href="#傳訊息">傳訊息</a></h2>
<ul>
<li>bot.send_message(chat_id, text)</li>
<li>update.message.reply_text(text)：Shortcut for <code>bot.send_message(update.message.chat_id, text)</code></li>
</ul>
<p><a href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.bot.html">更多功能</a></p>
<h2 id="範例---語錄-bot"><a class="header" href="#範例---語錄-bot">範例 - 語錄 Bot</a></h2>
<pre><code class="language-python">import random, os
from telegram.ext import Updater, CommandHandler

# 把語錄檔案載入
if os.path.exists('sentences.txt'):
    with open('sentences.txt') as FILE:
        sentences = [sentence.strip() for sentence in FILE]
else:
    sentences = []

def add(bot, update):
    print('from user:', update.message.from_user.id)
    # 限制只有特定人才能新增語錄
    # if update.message.from_user.id == YOUR_USER_ID_HERE:
    if True:
        sentence = update.message.text[5:].replace('\n', ' ')
        sentences.append(sentence)
        with open('sentences.txt', 'a') as FILE:
            print(sentence, file=FILE)
        update.message.reply_text('已加入：' + sentence)

def say(bot, update):
    if sentences:
        update.message.reply_text(random.choice(sentences))
    else:
        update.message.reply_text('I have no words.')

updater = Updater('YOUR TOKEN HERE')

updater.dispatcher.add_handler(CommandHandler('add', add))
updater.dispatcher.add_handler(CommandHandler('say', say))

updater.start_polling()
updater.idle()
</code></pre>
<p><img src="python/images/G0MnIp1.png" alt="語錄" /></p>
<h2 id="互動按鈕"><a class="header" href="#互動按鈕">互動按鈕</a></h2>
<p><code>send_message</code> 加上 <code>reply_markup = InlineKeyboardMarkup(...)</code> 就會在該訊息附上按鈕。</p>
<pre><code class="language-python">from telegram.ext import Updater, CommandHandler
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

def start:
    bot.send_message(chat_id, '參考資料',
        reply_markup = InlineKeyboardMarkup([[
            InlineKeyboardButton('課程網站', url = 'https://github.com/mzshieh/pa19spring'),
            InlineKeyboardButton('Documentation', url = 'https://python-telegram-bot.readthedocs.io/en/stable/index.html')]]))

# ...
</code></pre>
<p><img src="python/images/NCuLrN6.png" alt="img" /></p>
<p>除了 <code>url</code> 以外，也可以用 <code>callback_data</code> 來讓 Bot 知道哪個按鈕被按了。</p>
<pre><code class="language-python">from random import randint
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

def start(bot, update):
    a, b = randint(1, 100), randint(1, 100)
    update.message.reply_text('{} + {} = ?'.format(a, b),
        reply_markup = InlineKeyboardMarkup([[
                InlineKeyboardButton(str(s), callback_data = '{} {} {}'.format(a, b, s)) for s in range(a + b - randint(1, 3), a + b + randint(1, 3))
            ]]))

def answer(bot, update):
    a, b, s = [int(x) for x in update.callback_query.data.split()]
    if a + b == s:
        update.callback_query.edit_message_text('你答對了！')
    else:
        update.callback_query.edit_message_text('你答錯囉！')

updater = Updater('YOUR TOKEN HERE')

updater.dispatcher.add_handler(CommandHandler('start', start))
updater.dispatcher.add_handler(CallbackQueryHandler(answer))

updater.start_polling()
updater.idle()
</code></pre>
<p><img src="python/images/ht4CPIH.png" alt="70 + 90 = ?" /></p>
<p><img src="python/images/SXfdpqZ.png" alt="你答對了！" /></p>
<h2 id="callback-query-handler-可從-update-獲得的資訊"><a class="header" href="#callback-query-handler-可從-update-獲得的資訊">Callback Query Handler 可從 update 獲得的資訊</a></h2>
<ul>
<li>update
<ul>
<li>update_id</li>
<li>callback_query
<ul>
<li>from_user
<ul>
<li>略</li>
</ul>
</li>
<li>message：按鈕依附的 message
<ul>
<li>略</li>
</ul>
</li>
<li>data：建立 InlineKeyboardButton 時傳入的 callback_data</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.callbackquery.html">更多資訊</a></p>
<h2 id="回應-callback-query"><a class="header" href="#回應-callback-query">回應 Callback Query</a></h2>
<ul>
<li>bot
<ul>
<li>answer_callback_query(callback_query_id, text)：會顯示文字在畫面中間。</li>
<li>edit_message_text(chat_id = string, message_id = string, text)：修改文字，會同時清除按鈕。</li>
</ul>
</li>
<li>update.callback_query
<ul>
<li>answer(text)：Shortcut for <code>bot.answer_callback_query(update.callback_query.id, text)</code></li>
<li>edit_message_text(text)：Shortcut for <code>bot.edit_message_text(chat_id=update.callback_query.message.chat_id, message_id=update.callback_query.message.message_id, text</code></li>
</ul>
</li>
</ul>
<p><a href="https://python-telegram-bot.readthedocs.io/en/stable/telegram.bot.html">更多功能</a></p>
<h2 id="範例---剪刀石頭布"><a class="header" href="#範例---剪刀石頭布">範例 - 剪刀石頭布</a></h2>
<pre><code class="language-python">import random
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

hands = ['rock', 'paper', 'scissors']

emoji = {
    'rock': '👊',
    'paper': '✋',
    'scissors': '✌️'
} 

def start(bot, update):
    update.message.reply_text('剪刀石頭布！',
        reply_markup = InlineKeyboardMarkup([[
                InlineKeyboardButton(emoji, callback_data = hand) for hand, emoji in emoji.items()
            ]]))

def judge(mine, yours):
    if mine == yours:
        return '平手'
    elif (hands.index(mine) - hands.index(yours)) % 3 == 1:
        return '我贏了'
    else:
        return '我輸了'

def play(bot, update):
    try:
        mine = random.choice(hands)
        yours = update.callback_query.data
        update.callback_query.edit_message_text('我出{}，你出{}，{}！'.format(emoji[mine], emoji[yours], judge(mine, yours)))
    except Exception as e:
        print(e)

updater = Updater('YOUR TOKEN HERE')

updater.dispatcher.add_handler(CommandHandler('start', start))
updater.dispatcher.add_handler(CallbackQueryHandler(play))

updater.start_polling()
updater.idle()
</code></pre>
<p><img src="python/images/WCI88EP.png" alt="剪刀石頭布！" />
<img src="python/images/Y4cNeFq.png" alt="我輸了！" /></p>
<h2 id="reference-4"><a class="header" href="#reference-4">Reference</a></h2>
<p>https://python-telegram-bot.readthedocs.io/en/stable/index.html</p>
<hr />
<h1 id="使用python寫一個telegram-notify"><a class="header" href="#使用python寫一個telegram-notify">使用Python寫一個Telegram Notify</a></h1>
<h1 id="第一步-建立你的bot名稱與代號"><a class="header" href="#第一步-建立你的bot名稱與代號">第一步: 建立你的Bot名稱與代號</a></h1>
<p><img src="python/images/1*kkNwH1-UDrQiW-X8FfMv1Q.png" alt="img" /></p>
<p>在 Telegram 世界中，管理Bot的叫做 BotFather，請認明第一位有藍勾勾的官方Bot。不要選到下面奇怪的 Bot Fater了XD</p>
<p>跟他對話之後，基本上跟他說聲Hi，他就會吐出</p>
<p><em>&quot;I can help you create and manage Telegram bots. If you’re new to the Bot API, please see the manual… &quot;</em></p>
<p>接下來，請輸入 *<strong>/newbot*</strong> 以創建新的Bot。接著幫她建立名稱跟她專屬的ID。</p>
<p><img src="https://miro.medium.com/max/647/1*DGggHpukSgKf7KmMGJN3eg.png" alt="img" /></p>
<p>黑色的部分為你這個Bot的Token，類似金鑰</p>
<h1 id="第二步-建立群組並將你的bot加入群組"><a class="header" href="#第二步-建立群組並將你的bot加入群組">第二步: 建立群組，並將你的Bot加入群組</a></h1>
<p>不過Telegram在創建群組上，至少要先加入一個真人，所以你可以加一位好友進去，然後再加入你剛剛創建的Bot，最後再跟你朋友說聲Goodbye把她Remove掉。</p>
<h1 id="第三步-取得你的chatid"><a class="header" href="#第三步-取得你的chatid">第三步: 取得你的ChatID</a></h1>
<p>前往網址 <a href="https://api.telegram.org/bot%7B">https://api.telegram.org/bot</a>{your bot token}/getUpdates</p>
<p>而{your bot token} 就是填入Bot Father賦予你的Bot Token(不用加括號)</p>
<p>如果成功前往，應該會看到像是 *<strong>{“ok”:true,”result”:[]}*</strong> 的資訊。
這時候，前往你的群組輸入 *<strong>/my_id @你的BotID*</strong>，接著再次重新整理網頁。就會看到以下的資訊。</p>
<p><img src="python/images/1*_wOm2NlJWW_5c3W6y3pMKw.png" alt="img" /></p>
<p>橘色部分為你的Chat ID</p>
<p>好了，現在有Token，也有ChatID，終於可以開始進入程式部分</p>
<h1 id="第四步-用-python發送message"><a class="header" href="#第四步-用-python發送message">第四步: 用 Python發送Message</a></h1>
<p>接者使用request.get的方式，去API上通知BOT發送訊息。
而因為可能每次Bot要打出去的訊息不同，所以將這個功能模組化，以下為範例參考。</p>
<iframe src="https://lofinancier.medium.com/media/54e6808ef82757465939590e7cb97ac1" allowfullscreen="" frameborder="0" height="228" width="680" title="tele_bot.py" class="es n gk dh bf" scrolling="auto" style="box-sizing: inherit; top: 0px; width: 680px; height: 228px; position: absolute; left: 0px;"></iframe>
<p><img src="python/images/1*MyW0dD6NTVDNiUeQ54jYcw.png" alt="img" /></p>
<h1 id="結語-5"><a class="header" href="#結語-5">結語</a></h1>
<p>以上就是利用簡單的範例來瞭解如何創建一個簡易的Telegram Notify。
應用範圍可以用來推播日常工作排程上的Error Bug或搭配Timer傳送你寫的爬蟲資料，是不是非常好用呢! (而且必要的程式碼也是非常少呢)</p>
<p>如果還有興趣開發功能更強大的Bot，我把連結放在下方，大家就參考看看囉!</p>
<hr />
<pre><code class="language-python">import os
import telebot
import requests
from loguru import logger


TELEGRAM_BOT_TOKEN = os.environ.get(&quot;TELEGRAM_BOT_TOKEN&quot;)
bot = telebot.TeleBot(TELEGRAM_BOT_TOKEN)


def get_daily_horoscope(sign: str, day: str) -&gt; dict:
    &quot;&quot;&quot;通過特定的星座獲取運勢。

    關鍵字解釋:
    sign:str - 星座
    day:str - 格式化的日期 (YYYY-MM-DD) 或 TODAY 或 TOMORROW 或 YESTERDAY
    Return:dict - JSON data
    &quot;&quot;&quot;
    url = &quot;https://horoscope-app-api.vercel.app/api/v1/get-horoscope/daily&quot;
    params = {&quot;sign&quot;: sign, &quot;day&quot;: day}
    response = requests.get(url, params)

    return response.json()


@bot.message_handler(commands=[&quot;start&quot;, &quot;hello&quot;])
def send_welcome(message):
    bot.reply_to(message, &quot;Howdy, how are you doing?&quot;)


@bot.message_handler(commands=[&quot;horoscope&quot;])
def sign_handler(message):
    text = &quot;What's your zodiac sign?\nChoose one: *Aries*, *Taurus*, *Gemini*, *Cancer,* *Leo*, *Virgo*, *Libra*, *Scorpio*, *Sagittarius*, *Capricorn*, *Aquarius*, and *Pisces*.&quot;
    sent_msg = bot.send_message(message.chat.id, text, parse_mode=&quot;Markdown&quot;)
    bot.register_next_step_handler(sent_msg, day_handler)


def day_handler(message):
    sign = message.text
    text = &quot;What day do you want to know?\nChoose one: *TODAY*, *TOMORROW*, *YESTERDAY*, or a date in format YYYY-MM-DD.&quot;
    sent_msg = bot.send_message(message.chat.id, text, parse_mode=&quot;Markdown&quot;)
    bot.register_next_step_handler(sent_msg, fetch_horoscope, sign.capitalize())


def fetch_horoscope(message, sign):
    day = message.text
    horoscope = get_daily_horoscope(sign, day)
    data = horoscope[&quot;data&quot;]
    horoscope_message = (
        f'*Horoscope:* {data[&quot;horoscope_data&quot;]}\n*Sign:* {sign}\n*Day:* {data[&quot;date&quot;]}'
    )
    bot.send_message(message.chat.id, &quot;Here's your horoscope!&quot;)
    bot.send_message(message.chat.id, horoscope_message, parse_mode=&quot;Markdown&quot;)


@bot.message_handler(func=lambda msg: True)
def echo_all(message):
    print(message, message.text)
    bot.reply_to(message, message.text)


try:
    bot.infinity_polling()
except Exception as e:
    logger.exception(e)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python之websocket介紹與實作"><a class="header" href="#python之websocket介紹與實作">Python之Websocket介紹與實作</a></h1>
<p>這幾天學了一些Websocket的知識，發現網路上中文文檔非常少，就來分享一下學習心得</p>
<ul>
<li>Websocket是應用層協議，服務器可以主動向客戶端推送信息，客戶端也可以主動向服務器發送信息，是真正的雙向平等對話(全雙工)</li>
<li>http是client去request server，然後server return response，HTTP通信只能由客戶端發起(輪巡) 輪詢的效率低，非常浪費資源（因為必須不停連接，或者HTTP 連接始終打開）</li>
</ul>
<p><img src="python/images/1*QUMrGOeNkpaJ2nqFUsMiww.png" alt="img" /></p>
<ul>
<li>是應用層的協議，建立在TCP協議上，握手時採用HTTP，只要握手一次就好</li>
<li>和AJAX不同，AJAX是為了達到&quot;推送&quot;技術 而不斷的輪巡，這種傳統的模式帶來很明顯的缺點，即瀏覽器需要不斷的向服務器發出請求，然而HTTP請求可能包含較長的header，其中真正有效的數據可能只是很小的一部分，顯然這樣會浪費很多的帶寬等資源。</li>
<li>HTML5 定義的WebSocket 協議，數據格式比較輕量，開銷小，能更好的節省服務器資源和帶寬，並且能夠更實時地進行通訊。</li>
<li>關於AJAX和Websocket的比較 可以看<a href="https://claire-chang.com/2020/02/26/html5-websocket%E8%88%87socket-io/">這篇</a></li>
</ul>
<p>接下來就是實作了，python要實作websocket的話，可以使用<a href="https://websockets.readthedocs.io/en/stable/intro.html">websockets</a> 這個函式庫，這個library比較多人用，文檔也很詳細容易上手，不過django和flask應該都有對應的lib，這大家需要再研究吧</p>
<p>備註：接下來會用到異步asyncio的概念，若不熟的可能要去看我寫的<a href="https://medium.com/@jimmy_huang/python-asyncio-%E5%8D%94%E7%A8%8B-d84b5b945b5b">這篇</a>
或者<a href="https://realpython.com/async-io-python/">real-python</a>上也寫得很好，主要大概就是async def, await, coroutine這些用法要熟就可以實作websocket了</p>
<p>記得先pip install websockets (然後python版本我用的是3.7，至少需大於3.5，否則不支持asyncio)</p>
<p>client.py</p>
<pre><code class="language-python">import asyncio
import websockets

async def hello(uri):
    async with websockets.connect(uri) as websocket:
        await websocket.send(&quot;Jimmy&quot;)
        print(f&quot;(client) send to server: Jimmy&quot;)
        name = await websocket.recv()
        print(f&quot;(client) recv from server {name}&quot;)

asyncio.get_event_loop().run_until_complete(
    hello('ws://localhost:8765'))
</code></pre>
<p>server.py (先打開這個，再打開client.py)</p>
<pre><code class="language-python">import asyncio
import websockets

async def echo(websocket, path):
    print('echo')
    async for message in websocket:
        print(message,'received from client')
        greeting = f&quot;Hello {message}!&quot;
        await websocket.send(greeting)
        print(f&quot;&gt; {greeting}&quot;)

asyncio.get_event_loop().run_until_complete(
    websockets.serve(echo, 'localhost', 8765))
asyncio.get_event_loop().run_forever()
</code></pre>
<p>整個流程大概是一開始server用websockets.serve註冊一個websocket sever，並將handler指定給echo，(echo這個function--&gt; It must be a coroutine accepting two arguments: a <code>**WebSocketServerProtocol**</code> and the request URI.)
直接看api文檔可以瞭解參數為何https://websockets.readthedocs.io/en/stable/api.html
client這邊一打開就會連至ws，然後發送字串，server收到後就會echo回去，client收完後，就會關閉client</p>
<p><img src="python/images/1*z5ex-LkJF-8RK1zTvfEOcQ.png" alt="img" /></p>
<p>實作html5(client)與python(server)之多人記數器</p>
<p>實作code就在<a href="https://websockets.readthedocs.io/en/stable/intro.html">這裡</a> ，裡面的Synchronization example
我稍微解說一下</p>
<p>start_server = websockets.serve(counter, “localhost”, 6789)註冊了counter當作handler，所以每次進來的訊息都會到counter
Global中用了USERS( set 用來計算多少用戶同時在線上) 和STATE(計算計數)
每次進來都會register(websocket)，而try的finally就會unregister(websocket)
(這邊就是用來統計使用者個數，當使用者個數產生變動，就會notify_users，[user.send(message) for user in USERS]的方式廣播變動</p>
<p>而計數也是一樣，操作加減js控件時，會透過ws去send json format
async for message in websocket: data = json.loads(message) 這段就是負責接收加減數字的訊號</p>
<p>簡單來說 counter當作handler，連線進來時增加使用者個數，並監控使用者前端操作js發出來的websocket訊息(json)，而這些異動都存在global的 USERS和STATE，<strong>異動後我就會根據目前使用者數量去notify_state &amp; notify_users 這段就是websocket的重點，Server主動推送訊息</strong></p>
<p><img src="python/images/1*IjFWGcKqdBNFNwZ0FW2QTg.png" alt="img" /></p>
<p>更進一步：基於websocket的聊天室</p>
<p>接下來有興趣的就可以去實作聊天室了(下面連結提供大陸網友實作的code)
<a href="https://zhuanlan.zhihu.com/p/112813123">python websockets 網絡聊天室V0</a></p>
<p>解說一下，其實後端的邏輯十分簡單，會根據chat 這個main function去分不同的訊息處理(switch case 像是有人發訊息，有人login，logout，然後再把msg群發給所有User) 而前端接收到訊息後再呈現</p>
<p>其他像是Flask等等也有內建flask-sockets的函式庫，有興趣的再自己研究吧
https://github.com/heroku-examples/python-websockets-chat</p>
<hr />
<h2 id="連續發送--websocket_serverpy"><a class="header" href="#連續發送--websocket_serverpy">連續發送  websocket_server.py</a></h2>
<pre><code class="language-python">import asyncio
import websockets

async def echo(websocket, path):
    print('echo')
    i = 0
    while True:
        i += 1
        greeting = f&quot;Hello {i}!&quot;
        await websocket.send(greeting)
        print(f&quot;&gt; {greeting}&quot;)
        await asyncio.sleep(1)

asyncio.get_event_loop().run_until_complete(
    websockets.serve(echo, 'localhost', 8765))
asyncio.get_event_loop().run_forever()
</code></pre>
<h2 id="websocket_clientpy-使用---websocketwebsocketapp"><a class="header" href="#websocket_clientpy-使用---websocketwebsocketapp">websocket_client.py 使用   websocket.WebSocketApp</a></h2>
<pre><code class="language-python">import threading
import time
import websocket
import queue
import rel


class ClientSocket:
    def __init__(self):
        websocket.enableTrace(True)
        self.ws = websocket.WebSocketApp(
            &quot;ws://localhost:8765/&quot;,
            # &quot;wss://api.gemini.com/v1/marketdata/BTCUSD&quot;,
            on_open=self.on_open,
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close,
        )
        # ping_interval 表示發送心跳訊息的間隔，預設為 0，表示不發送心跳訊息；
        # 而 ping_timeout 表示伺服器端的回應時間限制，預設為 20 秒。
        # 如果伺服器端在 ping_timeout 時間內沒有回應心跳訊息，則客戶端會認為伺服器端已經斷線，並關閉 WebSocket 連線。
        self.ws.run_forever(
            dispatcher=rel,
            ping_interval=10,  # 發送心跳訊息的間隔為 10 秒
            ping_timeout=5,  # 設定伺服器端的回應時間限制為 5 秒
        )
        rel.signal(2, rel.abort)  # Keyboard Interrupt
        rel.dispatch()

    def on_message(self, ws, message):
        print(message)

    def on_error(self, ws, error):
        print(error)

    def on_close(self, ws, close_status_code, close_msg):
        print(&quot;### closed ###&quot;)
        rel.abort()
        self.ws.run_forever(dispatcher=rel)
        rel.signal(2, rel.abort)
        rel.dispatch()

    def on_open(self, ws):
        print(&quot;Opened connection&quot;)


if __name__ == &quot;__main__&quot;:
    client_socket = ClientSocket()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="從零開始使用-poetry-1"><a class="header" href="#從零開始使用-poetry-1">從零開始使用 Poetry</a></h2>
<p>出處: https://blog.kyomind.tw/python-poetry/</p>
<p>本文所有的參考資料會放在文末的「參考」一欄中，不過在此還是要特別提及主要的參考對象，總共有二：</p>
<ul>
<li><a href="https://python-poetry.org/docs/">Poetry 官方文件</a></li>
<li><a href="https://realpython.com/dependency-management-python-poetry/">Dependency Management With Python Poetry</a></li>
</ul>
<p>如果在本文找不到你需要的內容，以上二處可能會有，所以主動列出。</p>
<p>另外本文主要以 macOS 和 Linux（Ubuntu）環境來進行安裝及教學，Windows 用戶如果有無法順利安裝的情況，建議參考官方文件內容修正。不過，即使有問題，應該也是集中在安裝與設定階段，本文其餘部分仍可適用。</p>
<h2 id="安裝-poetry-1"><a class="header" href="#安裝-poetry-1">安裝 Poetry</a></h2>
<p>Poetry 和 pip、git、pyenv 等工具一樣，都是典型的<strong>命令列工具</strong>，需要先安裝才能下達指令——<code>poetry</code>。</p>
<h3 id="安裝方式選擇-1"><a class="header" href="#安裝方式選擇-1">安裝方式選擇</a></h3>
<p>Poetry 主要提供了<a href="https://python-poetry.org/docs/#installation">兩種安裝方式</a>：</p>
<ol>
<li><strong>全域安裝</strong>至使用者的家目錄。</li>
<li><strong>pip 安裝</strong>至專案使用的 Python（虛擬）環境，即<code>pip install poetry</code>。</li>
</ol>
<p><strong>個人推薦使用全域安裝</strong>，官方文件也表示<a href="https://python-poetry.org/docs/#alternative-installation-methods-not-recommended">不推薦使用 pip 安裝</a>。</p>
<p>因為 pip 安裝是直接安裝到「<strong>專案所屬的 Python 虛擬環境</strong>」裡，而 Poetry 所依賴的套件非常多，<strong>總計超過 30 個，會嚴重影響專案虛擬環境的整潔度</strong>。文件中也警告這些依賴套件可能和專案本身的套件<strong>發生衝突</strong>：</p>
<blockquote>
<p>Be aware that it will also install Poetry’s dependencies which <strong>might cause conflicts with other packages.</strong></p>
</blockquote>
<h3 id="全域安裝-poetry-至家目錄"><a class="header" href="#全域安裝-poetry-至家目錄">全域安裝 Poetry 至家目錄</a></h3>
<p>所以我們就使用全域安裝吧！</p>
<h4 id="macos--linux--wslwindows-subsystem-for-linux"><a class="header" href="#macos--linux--wslwindows-subsystem-for-linux">macOS / Linux / WSL（Windows Subsystem for Linux）</a></h4>
<pre><code>curl -sSL https://install.python-poetry.org | python3 -
</code></pre>
<p>或</p>
<pre><code>curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -
</code></pre>
<h4 id="windows-1"><a class="header" href="#windows-1">Windows</a></h4>
<pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -
</code></pre>
<p>Poetry 實際安裝路徑如下：</p>
<blockquote>
<p>The installer installs the <code>poetry</code> tool to Poetry’s <code>bin</code> directory. This location depends on your system:</p>
</blockquote>
<ul>
<li><code>$HOME/.local/bin</code> for Unix</li>
<li><code>%APPDATA%\Python\Scripts</code> on Windows</li>
</ul>
<p>以 macOS 為例，如果要下<code>poetry</code>指令，就需要打完整路徑<code>$HOME/.local/bin/poetry</code>，顯然不太方便，所以我們需要設定 PATH。</p>
<h3 id="設定-path-1"><a class="header" href="#設定-path-1">設定 PATH</a></h3>
<p>新增<code>poetry</code>指令執行檔所在的路徑至 PATH。</p>
<p>在<code>.zshrc</code>或<code>.bashrc</code>或<code>.bash_profile</code>新增：</p>
<pre><code>export PATH=$PATH:$HOME/.local/bin
</code></pre>
<p>存檔後重啟 shell 即可使用。直接在命令列打上<code>poetry</code>指令測試：</p>
<pre><code>❯ poetry
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]

...
</code></pre>
<h3 id="設定-alias-1"><a class="header" href="#設定-alias-1">設定 alias</a></h3>
<p>比起<code>pip</code>，<code>poetry</code>這個指令實在太冗長了！我們還是給它一個 alias 吧！</p>
<p>基於它是我極為常用的指令，我願意賦與它**「單字母」的 alias 特權**，我使用<code>p</code>：</p>
<pre><code>alias p='poetry'
</code></pre>
<p>測試結果：</p>
<pre><code>❯ p
Poetry version 1.1.13

USAGE
  poetry [-h] [-q] [-v [&lt;...&gt;]] [-V] [--ansi] [--no-ansi] [-n] &lt;command&gt; [&lt;arg1&gt;] ... [&lt;argN&gt;]
</code></pre>
<p>alias 是方便自己使用，但本文基於表達清晰考量，下面的解說除了圖片外，原則上並不會使用 alias 表示。</p>
<hr />
<h2 id="初始化-poetry-專案-1"><a class="header" href="#初始化-poetry-專案-1">初始化 Poetry 專案</a></h2>
<p>為了方便解說，我們先建立一個全新的專案，名為<code>poetry-demo</code>。</p>
<p>指令都很簡單，但還是建議可以一步一步跟著操作。</p>
<p>就像 git 專案需要初始化，Poetry 也需要，因為每一個使用了 Poetry 的專案中一定要有一個<code>pyproject.toml</code>作為它的<strong>設定檔</strong>。否則直接使用<code>poetry</code>相關指令就會出現下列錯誤訊息：</p>
<blockquote>
<p>Poetry could not find a pyproject.toml file in {cwd} or its parents</p>
</blockquote>
<p>所以一定先初始化，使用<code>poetry init</code>：</p>
<pre><code>mkdir poetry-demo
cd poetry-demo
poetry init
</code></pre>
<p>此時會跳出一連串的互動對話，協助你建立專案的資料，大部分可以直接<code>enter</code>跳過：</p>
<pre><code>This command will guide you through creating your pyproject.toml config.

Package name [poetry-demo]:
Version [0.1.0]:
Description []:
Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:
License []:
Compatible Python versions [^3.8]:

Would you like to define your main dependencies interactively? (yes/no) [yes]
</code></pre>
<p>直到出現「<code>Would you like to define your main dependencies interactively? (yes/no) [yes]</code>」，我們先選擇「<strong>no</strong>」後，會讓你確認本次產生的<code>toml</code>檔內容：</p>
<pre><code>Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file

[tool.poetry]
name = &quot;poetry-demo&quot;
version = &quot;0.1.0&quot;
description = &quot;&quot;
authors = [&quot;kyo &lt;odinxp@gmail.com&gt;&quot;]

[tool.poetry.dependencies]
python = &quot;^3.8&quot;

[tool.poetry.dev-dependencies]

[build-system]
requires = [&quot;poetry-core&gt;=1.0.0&quot;]
build-backend = &quot;poetry.core.masonry.api&quot;
</code></pre>
<p>並詢問你「<code>Do you confirm generation? (yes/no) [yes]</code>」，按<code>enter</code>使用預設選項「yes」或直接回答「yes」，則<code>pyproject.toml</code>建立完成。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
└── pyproject.toml

0 directories, 1 file
</code></pre>
<h2 id="管理-poetry-虛擬環境-1"><a class="header" href="#管理-poetry-虛擬環境-1">管理 Poetry 虛擬環境</a></h2>
<p>我覺得學習 Poetry 的<strong>第一道關卡</strong>，就是它對於虛擬環境的管理。</p>
<h3 id="強制虛擬環境-1"><a class="header" href="#強制虛擬環境-1">「強制」虛擬環境</a></h3>
<p>Poetry 預設上（可透過<code>poetry config</code>修改）會強制套件都要安裝在虛擬環境中，以免汙染全域，所以它整合了<code>virtualenv</code>。</p>
<p>所以在執行<code>poetry add、install</code>等指令時，Poetry 都會自動檢查<strong>當下是否正在使用虛擬環境：</strong></p>
<ul>
<li>如果<strong>是</strong>，則會直接安裝套件至<strong>當前</strong>的虛擬環境。</li>
<li>如果<strong>否</strong>，則會自動幫你建立一個<strong>新的</strong>虛擬環境，再進行套件安裝。</li>
</ul>
<h3 id="容易混淆的虛擬環境-1"><a class="header" href="#容易混淆的虛擬環境-1">容易混淆的虛擬環境</a></h3>
<p>Poetry 主動納入虛擬環境管理算是立意良善，相當於把<code>pip</code>+<code>venv</code>兩者的功能直接整合在一起，<strong>但也帶來一定的複雜度</strong>，尤其在你已經自行使用了<code>venv</code>、<code>virtualenv</code>或 <code>pyenv-virtualenv</code>或<code>conda</code>等工具來管理虛擬環境的情況下！</p>
<p><strong>沒錯，Python 的虛擬環境管理就是這麼麻煩！</strong></p>
<p>個人建議，對新手而言，於 Poetry 的專案中，<strong>一律使用 Poetry</strong> 來管理虛擬環境即可。我目前也是這樣，省得麻煩。</p>
<h3 id="以指令建立虛擬環境-1"><a class="header" href="#以指令建立虛擬環境-1">以指令建立虛擬環境</a></h3>
<p>使用指令<code>poetry env use python</code>：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo-IEWSZKSE-py3.8 in /Users/kyo/Library/Caches/pypoetry/virtualenvs
Using virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>可以看出 Poetry 為我們建立了名為<code>poetry-demo-IEWSZKSE-py3.8</code>的虛擬環境。</p>
<h3 id="重點說明"><a class="header" href="#重點說明">重點說明</a></h3>
<ul>
<li><code>poetry env use python</code>建立虛擬環境所使用的 Python 版本，取決於<code>python</code>指令在你的 PATH 是連結到哪個版本。同理，你也可以將指令明示為<code>use python3</code>或<code>use python3.8</code>，只要這些指令確實存在 PATH 中。</li>
<li>預設上，Poetry 會統一將虛擬環境建立在「<strong>特定目錄</strong>」裡，比如本例中存放的路徑是<code>/Users/kyo/Library/Caches/pypoetry/virtualenvs</code>。</li>
<li>虛擬環境的<strong>命名模式為<code>專案名稱-亂數-Python版本</code>。</strong></li>
</ul>
<p>老實說我個人不是很喜歡這樣的做法，因為這意味著單一專案允許建立複數個虛擬環境（比如 Python 3.7、3.8、3.9 可以各來一個），<strong>彈性之餘也增加了混亂的可能</strong>，而且這命名模式我也不太欣賞，顯得過於僵化且冗長。</p>
<p>既然 Python 的虛擬環境理論上都是<strong>高度綁定專案本身</strong>的，我更偏好<code>venv</code>式的做法，也就是<strong>把虛擬環境放到專案目錄內</strong>，而非統一放在獨立的目錄，讓虛擬環境與專案呈現<strong>直觀的一對一關係</strong>。</p>
<p>所幸，Poetry 具備這樣的選項。</p>
<hr />
<h3 id="修改config建立專案內的venv虛擬環境-1"><a class="header" href="#修改config建立專案內的venv虛擬環境-1">修改<code>config</code>，建立專案內的<code>.venv</code>虛擬環境</a></h3>
<p>我們先使用<code>poetry config</code>指令來查看 Poetry 目前幾個主要的設定，需要<code>--list</code>這個參數：</p>
<pre><code>❯ poetry config --list
cache-dir = &quot;/Users/kyo/Library/Caches/pypoetry&quot;
experimental.new-installer = true
installer.parallel = true
virtualenvs.create = true
virtualenvs.in-project = false
virtualenvs.path = &quot;{cache-dir}/virtualenvs&quot;
</code></pre>
<p>其中<code>virtualenvs.create = true</code>若改成<code>false</code>，則可以停止 Poetry 在「偵測不到虛擬環境時會自行建立」的行為模式，但建議還是不要更動。</p>
<p>而<code>virtualenvs.in-project = false</code>就是我們要修改的目標，使用指令：</p>
<pre><code>poetry config virtualenvs.in-project true
</code></pre>
<p>好，我們先把之前建立的虛擬環境刪除：</p>
<pre><code>❯ poetry env remove python
Deleted virtualenv: /Users/kyo/Library/Caches/pypoetry/virtualenvs/poetry-demo-IEWSZKSE-py3.8
</code></pre>
<p>重新建立，看看行為有何差異：</p>
<pre><code>❯ poetry env use python
Creating virtualenv poetry-demo in /Users/kyo/Documents/code/poetry-demo/.venv
Using virtualenv: /Users/kyo/Documents/code/poetry-demo/.venv
</code></pre>
<p>可以看出：</p>
<ul>
<li>虛擬環境的路徑改為「<strong>專案的根目錄</strong>」。</li>
<li>名稱固定為<code>.venv</code>。</li>
</ul>
<p>我覺得這樣的設定更加簡潔。</p>
<h3 id="啟動與退出虛擬環境-1"><a class="header" href="#啟動與退出虛擬環境-1">啟動與退出虛擬環境</a></h3>
<p>啟動虛擬環境，需移至專案目錄底下，使用指令<code>poetry shell</code>：</p>
<pre><code>❯ poetry shell
Spawning shell within /Users/kyo/Documents/code/poetry-demo/.venv
❯ . /Users/kyo/Documents/code/poetry-demo/.venv/bin/activate
</code></pre>
<p><code>poetry shell</code>指令會偵測當前目錄或所屬上層目錄是否存在<code>pyproject.toml</code>來確定所要啟動的虛擬環境，所以如果不移至專案目錄，則會出現下列錯誤：</p>
<pre><code>❯ poetry shell

  RuntimeError

  Poetry could not find a pyproject.toml file in /Users/kyo/Documents/code or its parents

  at ~/Library/Application Support/pypoetry/venv/lib/python3.8/site-packages/poetry/core/factory.py:369 in locate
      365│             if poetry_file.exists():
      366│                 return poetry_file
      367│
      368│         else:
    → 369│             raise RuntimeError(
      370│                 &quot;Poetry could not find a pyproject.toml file in {} or its parents&quot;.format(
      371│                     cwd
      372│                 )
      373│             )
</code></pre>
<p>可以看到，Poetry 的錯誤訊息非常清楚，讓你很容易知曉修正的方向，這是作為一個優秀命令列工具的必要條件。</p>
<p>退出就簡單多了，只需要<code>exit</code>即可。</p>
<hr />
<h2 id="poetry-常用指令-1"><a class="header" href="#poetry-常用指令-1">Poetry 常用指令</a></h2>
<p>Poetry 是一個獨立的命令列工具，就像 pyenv，它有自己的指令，需要花費額外的心力學習，且較 pip 更加複雜，這可能是使用 Poetry 的<strong>第二道關卡</strong>。好在常用的指令，其實也不超過 10 個，下面就來一一介紹。</p>
<p>在此我們繼續使用前面提過的 Flask 和 Black 套件，來示範並說明 Poetry 的優勢以及它和 pip 的不同之處。</p>
<h2 id="poetry-新增套件-1"><a class="header" href="#poetry-新增套件-1">Poetry 新增套件</a></h2>
<p>使用指令：</p>
<pre><code>poetry add
</code></pre>
<p>相當於<code>pip install</code>，我們來試著安裝 Flask 看看會有什麼變化：</p>
<p><a href="https://i.imgur.com/H7pPtsk.png"><img src="https://i.imgur.com/H7pPtsk.png" alt="img" /></a></p>
<p>圖中可以看出 Poetry 漂亮的命令列資訊呈現，會清楚告知總共新增了幾個套件。</p>
<p>此時專案中的<code>pyproject.toml</code>也會發生變化：</p>
<pre><code>...
[tool.poetry.dependencies]
python = &quot;^3.8&quot;
Flask = &quot;^2.1.1&quot;  # 新增部分

[tool.poetry.dev-dependencies]

[build-system]
...
</code></pre>
<p>這裡要說明，安裝 Flask，則<code>pyproject.toml</code>就只會新增記載<code>Flask = &quot;^2.1.1&quot;</code>這個 <strong>top-level</strong> 的 package 項目，其餘的依賴套件<strong>不會</strong>直接記錄在<code>toml</code>檔中。</p>
<p>我覺得這是一大優點，方便區分哪些是你<strong>主動安裝</strong>的主要套件，而哪些又是基於套件的依賴關係而一併安裝的依賴套件。</p>
<h3 id="poetrylock-與更新順序-1"><a class="header" href="#poetrylock-與更新順序-1">poetry.lock 與更新順序</a></h3>
<p>除了更新<code>pyproject.toml</code>，此時專案中還會新增一個檔案，名為<code>poetry.lock</code>，它實際上就相當於 pip 的<code>requirements.txt</code>，詳細記載了所有安裝的套件與版本。</p>
<p>當你使用<code>poetry add</code>指令時，Poetry 會<strong>自動依序</strong>幫你做完這三件事：</p>
<ol>
<li>更新<code>pyproject.toml</code>。</li>
<li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。</li>
<li>依照<code>poetry.lock</code>的內容，更新虛擬環境。</li>
</ol>
<p>由此可見，<code>poetry.lock</code>的內容是取決於<code>pyproject.toml</code>，但兩者並不會自己連動，一定要基於特定指令才會進行同步與更新，<code>poetry add</code>就是一個典型案例。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
└── pyproject.toml

0 directories, 2 files
</code></pre>
<h3 id="更新-poetrylock-1"><a class="header" href="#更新-poetrylock-1">更新 poetry.lock</a></h3>
<p>當你自行修改了<code>pyproject.toml</code>內容，比如變更特定套件的版本（這是有可能的，尤其在手動處理版本衝突的時候），此時<code>poetry.lock</code>的內容與<code>pyproject.toml</code>出現了「<strong>脫鉤</strong>」，必須讓它依照新的<code>pyproject.toml</code>內容更新、同步，使用指令：</p>
<pre><code>poetry lock
</code></pre>
<p>如此一來，才能確保手動修改的內容，也更新到<code>poetry.lock</code>中，畢竟虛擬環境如果要重新建立，是基於<code>poetry.lock</code>的內容來安裝套件，而非<code>pyproject.toml</code>。</p>
<p>還是那句話：<code>poetry.lock</code>相當於 Poetry 的<code>requirements.txt</code>。</p>
<hr />
<h3 id="安裝套件至-dev-dependencies-1"><a class="header" href="#安裝套件至-dev-dependencies-1">安裝套件至 dev-dependencies</a></h3>
<p>有些套件，比如<code>pytest</code>、<code>flake8</code>等等，<strong>只會在開發環境中使用</strong>，產品的<strong>部署環境</strong>並不需要。</p>
<p>Poetry 允許你<strong>區分</strong>這兩者，將上述的套件安裝至<code>dev-dependencies</code>區塊，方便讓你<strong>輕鬆建立一份「不包含」<code>dev-dependencies</code>開發套件的安裝清單</strong>。</p>
<p>在此以 Black 為例，安裝方式如下：</p>
<pre><code>poetry add black -D
</code></pre>
<p>或</p>
<pre><code>poetry add black --dev
</code></pre>
<p>結果的區別顯示在<code>pyproject.toml</code>裡：</p>
<pre><code>...
[tool.poetry.dependencies]
python = &quot;^3.8&quot;
Flask = &quot;^2.1.1&quot;

[tool.poetry.dev-dependencies]
black = &quot;^22.3.0&quot;
...
</code></pre>
<p>可以看到<code>black</code>被列在不同區塊：<code>tool.poetry.dev-dependencies</code>。</p>
<h3 id="強烈建議善用-dev-dependencies"><a class="header" href="#強烈建議善用-dev-dependencies">強烈建議：善用 dev-dependencies</a></h3>
<p>善用<code>-D</code>參數，明確區分<strong>開發環境專用</strong>的套件，我認為<strong>非常必要</strong>。</p>
<p>首先，這些套件常常屬於「<strong>檢測型</strong>」工具，相關的<strong>依賴套件</strong>著實不少！比如<code>flake8</code>，它依賴了<code>pycodestyle</code>、<code>pyflakes</code>、<code>mccabe</code>等等，還有<code>black</code>、<code>pre-commit</code>，依賴套件數量也都很可觀。</p>
<p>其次，既然它們都只在開發階段才需要，則完全可以從部署環境中<strong>缺席</strong>。如果不分青紅皂白一律安裝到<code>dependencies</code>區塊，部署環境容易顯得過於<strong>臃腫</strong>。</p>
<p>常見的<code>dev-dependencies</code>區塊項目，例示如下：</p>
<pre><code>[tool.poetry.dev-dependencies]
flake8 = &quot;4.0.1&quot;
yapf = &quot;0.32.0&quot;
pytest = &quot;7.1.2&quot;
pytest-django = &quot;4.5.2&quot;
pytest-cov = &quot;3.0.0&quot;
pytest-env = &quot;0.6.2&quot;
pytest-sugar = &quot;0.9.4&quot;
pre-commit = &quot;2.20.0&quot;
</code></pre>
<hr />
<h2 id="列出全部套件清單"><a class="header" href="#列出全部套件清單">列出全部套件清單</a></h2>
<p>類似<code>pip list</code>，這裡要使用<code>poetry show</code>：</p>
<pre><code>❯ poetry show
black              22.3.0 The uncompromising code formatter.
click              8.1.3  Composable command line interface toolkit
flask              2.1.2  A simple framework for building complex web applications.
importlib-metadata 4.11.4 Read metadata from Python packages
itsdangerous       2.1.2  Safely pass data to untrusted environments and back.
jinja2             3.1.2  A very fast and expressive template engine.
markupsafe         2.1.1  Safely add untrusted strings to HTML/XML markup.
mypy-extensions    0.4.3  Experimental type system extensions for programs checked...
pathspec           0.9.0  Utility library for gitignore style pattern matching of ...
platformdirs       2.5.2  A small Python module for determining appropriate platfo...
...
</code></pre>
<p>特別提醒的是，這裡的清單內容<strong>並不是來自於虛擬環境</strong>，這點和 pip 不同，而是來自於<code>poetry.lock</code>的內容。</p>
<p>你可能會想，來自於<code>poetry.lock</code>或虛擬環境，有差嗎？兩者不是應該要一致？</p>
<p>沒錯，理論上是，但也有不一致的時候，比如你使用了<code>pip install</code>指令安裝套件，就不會記載在<code>poetry.lock</code>中，那<code>poetry show</code>自然也不會顯示。</p>
<h3 id="樹狀顯示套件依賴層級"><a class="header" href="#樹狀顯示套件依賴層級">「樹狀」顯示套件依賴層級</a></h3>
<p>Poetry 最為人津津樂道的就是它的樹狀顯示——<code>poetry show --tree</code>。</p>
<pre><code>❯ poetry show --tree
flask 2.1.1 A simple framework for building complex web applications.
├── click &gt;=8.0
│   └── colorama *
├── importlib-metadata &gt;=3.6.0
│   └── zipp &gt;=0.5
├── itsdangerous &gt;=2.0
├── jinja2 &gt;=3.0
│   └── markupsafe &gt;=2.0
└── werkzeug &gt;=2.0
black 22.3.0 The uncompromising code formatter.
├── click &gt;=8.0.0
│   └── colorama *
├── mypy-extensions &gt;=0.4.3
├── pathspec &gt;=0.9.0
├── platformdirs &gt;=2
├── tomli &gt;=1.1.0
└── typing-extensions &gt;=3.10.0.0
</code></pre>
<p>讓主要套件與其依賴套件的<strong>關係與層次，一目瞭然</strong>。</p>
<p>而且很貼心的是，它也可以**只顯示「指定套件」**的依賴層級，以<code>celery</code>為例：</p>
<pre><code>❯ poetry show celery --tree
celery 4.4.0 Distributed Task Queue.
├── billiard &gt;=3.6.1,&lt;4.0
├── kombu &gt;=4.6.7,&lt;4.7
│   ├── amqp &gt;=2.6.0,&lt;2.7
│   │   └── vine &gt;=1.1.3,&lt;5.0.0a1
│   └── importlib-metadata &gt;=0.18
│       ├── typing-extensions &gt;=3.6.4
│       └── zipp &gt;=0.5
├── pytz &gt;0.0-dev
└── vine 1.3.0
</code></pre>
<hr />
<h2 id="poetry-移除套件-1"><a class="header" href="#poetry-移除套件-1">Poetry 移除套件</a></h2>
<p>使用<code>poetry remove</code>指令。和<code>poetry add</code>一樣，可以加上<code>-D</code>參數來移除置於開發區的套件。</p>
<p>而移除套件時的「<strong>依賴解析（相依性管理）</strong>」能力，正是 Poetry 遠優於 pip 的主要環節，因為 pip 沒有嘛！也是我提議改用 Poetry 的關鍵理由——<strong>為了順利移除套件</strong>。</p>
<p>前面已經提過，pip 的<code>pip uninstall</code>只會移除你所指定的套件，而不會連同依賴套件一起移除。</p>
<p>這是基於安全考量，因為 pip 沒有「依賴解析」功能。如果貿然移除所有「安裝時一併安裝」的依賴套件，可能會造成巨大災難，讓別的套件失去效用。</p>
<p>前面也舉了 Flask 和 Black 都共同依賴<code>click</code>這個套件的例子，在手動移除套件的情況下，你可能未曾注意 Black 也依賴了<code>click</code>，結果為了「徹底移除」Flask 的所有相關套件，不小心把<code>click</code>也移除掉了。</p>
<p>所以，使用 pip 時，我們鮮少會去移除已經不再使用的套件。畢竟<strong>依賴關係錯綜複雜</strong>，移除套件可能造成許多「<strong>副作用</strong>」，實在是太麻煩了。</p>
<h3 id="poetry-remove的依賴解析"><a class="header" href="#poetry-remove的依賴解析"><code>poetry remove</code>的依賴解析</a></h3>
<p>好，解釋了很多，接下來就是 Poetry 的表演了，它會幫你處理這些棘手的「套件相依性」難題，讓你輕鬆移除 Flask 而不影響 Black：</p>
<p><a href="https://i.imgur.com/79TycuL.png"><img src="https://i.imgur.com/79TycuL.png" alt="poetry remove flask" /></a>poetry remove flask</p>
<p>可以對比上面安裝 Flask 時的截圖，那時總共安裝了 8 個套件，但現在移除的卻只有 7 個——沒錯，因為有依賴解析，<strong>Poetry 知道 Black 還需要</strong><code>click</code>！所以不能移除：</p>
<pre><code>❯ poetry show --tree
black 22.3.0 The uncompromising code formatter.
├── click &gt;=8.0.0
│   └── colorama *
├── mypy-extensions &gt;=0.4.3
├── pathspec &gt;=0.9.0
├── platformdirs &gt;=2
├── tomli &gt;=1.1.0
└── typing-extensions &gt;=3.10.0.0
</code></pre>
<p>一個套件直到環境中的<strong>其餘套件都不再依賴它</strong>，Poetry 才會安心讓它被移除。</p>
<hr />
<h2 id="輸出-poetry-虛擬環境的-requirementstxt-1"><a class="header" href="#輸出-poetry-虛擬環境的-requirementstxt-1">輸出 Poetry 虛擬環境的 requirements.txt</a></h2>
<p>理論上，全面改用 Poetry 後，專案中是不需要存在<code>requirements.txt</code>，因為它的角色已經完全被<code>poetry.lock</code>所取代。</p>
<p>但事實是，你可能<strong>還是需要它</strong>，甚至希望它隨著<code>poetry.lock</code>的內容更新！至少對我而言就是如此，我在 Docker 部署環境中並不使用 Poetry，所以我需要一份完全等價於<code>poetry.lock</code>的<code>requirements.txt</code>，用於 Docker 部署。</p>
<p>你可能想說，那我就在 Poetry 的虛擬環境下，使用以往熟悉的指令<code>pip freeze &gt; requirements.txt</code>來產生一份就可以了吧？我本來也是這麼想，但實際的產出卻是如此：（提醒：目前 poetry-demo 專案中<strong>僅剩下 Black 和它的依賴套件</strong>）</p>
<pre><code>black @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/11/4c/fc/cd6d885e9f5be135b161e365b11312cff5920d7574c8446833d7a9b1a3/black-22.3.0-cp38-cp38-macosx_10_9_x86_64.whl
click @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/f0/23/09/b13d61d1fa8b3cd7c26f67505638d55002e7105849de4c4432c28e1c0d/click-8.1.2-py3-none-any.whl
mypy-extensions @ file:///Users/kyo/Library/Caches/pypoetry/artifacts/b6/a0/b0/a5dc9acd6fd12aba308634f21bb7cf0571448f20848797d7ecb327aa12/mypy_extensions-0.4.3-py2.py3-none-any.whl
...
</code></pre>
<p>這呈現好像不是我們以前熟悉的那樣：</p>
<pre><code>black==22.3.0
click==8.1.2
mypy_extensions==0.4.3
...
</code></pre>
<p>沒錯，只要是使用<code>poetry add</code>安裝的套件，在<code>pip freeze</code>就會變成這樣。此時想輸出類似<code>requirements.txt</code>的格式，需要使用<code>poetry export</code>。</p>
<p>預設的輸出結果會有 hash 值，很乾擾閱讀。不想納入 hash 則要<strong>加上參數</strong>去除。<strong>以下就是我固定用來輸出<code>requirements.txt</code>的指令與參數：</strong></p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes
</code></pre>
<p><code>2022/08/24</code>補充：網友提醒，<strong>hash 有其價值，並建議保留</strong>，詳見<a href="https://github.com/kyomind/blog-reply/issues/5#issuecomment-1195904820">留言區</a>。</p>
<p>我們再看一下輸出結果，雖然不盡相同，但也相去不遠了……嗎？等等，怎麼是空白？</p>
<h3 id="輸出-dev-dependencies"><a class="header" href="#輸出-dev-dependencies">輸出 dev-dependencies</a></h3>
<p>因為<code>poetry export</code><strong>預設</strong>只會輸出<code>toml</code>中的<code>[tool.poetry.dependencies]</code>區塊的套件！還記得上面我們把 Black 安裝到<code>[tool.poetry.dev-dependencies]</code>了嗎？</p>
<p>顯然 Poetry 認為你 export 基本上就為了部署，並不需要開發區的套件。</p>
<p>這倒是沒錯，不過基於演示需求，我們必須輸出<code>[tool.poetry.dev-dependencies]</code>的套件，才能看到 Black。</p>
<p>加上<code>--dev</code>參數即可：</p>
<pre><code>poetry export -f requirements.txt -o requirements.txt --without-hashes --dev
</code></pre>
<p>輸出的<code>requirements.txt</code>內容：</p>
<pre><code>black==22.3.0; python_full_version &gt;= &quot;3.6.2&quot;
click==8.1.2; python_version &gt;= &quot;3.7&quot; and python_full_version &gt;= &quot;3.6.2&quot;
colorama==0.4.4; python_version &gt;= &quot;3.7&quot; and python_full_version &gt;= &quot;3.6.2&quot; and platform_system == &quot;Windows&quot;
...
</code></pre>
<p>雖然長得有點不一樣，但這個檔案確實是可以<code>pip install</code>的。</p>
<p>從這裡也可以看出先前一再提及「<strong>區分開發、部署套件</strong>」的價值——大部分時候我們並不需要輸出開發用套件。</p>
<p><code>poetry export</code>所有參數用法與說明，請參考<a href="https://python-poetry.org/docs/cli/#export">文件</a>。</p>
<p>此時專案目錄結構如下：</p>
<pre><code>poetry-demo
├── poetry.lock
├── pyproject.toml
└── requirements.txt

0 directories, 3 files
</code></pre>
<hr />
<h2 id="poetry-常用指令清單"><a class="header" href="#poetry-常用指令清單">Poetry 常用指令清單</a></h2>
<p>算來算去，Poetry 的常用指令主要有下面幾個：</p>
<ul>
<li><code>poetry add</code></li>
<li><code>poetry remove</code></li>
<li><code>poetry export</code></li>
<li><code>poetry env use</code></li>
<li><code>poetry shell</code></li>
<li><code>poetry show</code></li>
<li><code>poetry init</code></li>
<li><code>poetry install</code></li>
</ul>
<p>其中一半，單一專案可能只會用個一兩次而已，比如<code>init</code>、<code>install</code>和<code>env use</code>，實際上需要學習的指令並不多。</p>
<p>那麼，只要知曉這些指令，就可以順利運用 Poetry 了嗎？可能是，也可能否，所以我下面還會再補充 Poetry 的常見使用情境與操作方式，讓你接納 Poetry 的阻力可以進一步下降！</p>
<hr />
<h2 id="poetry-常見使用情境與操作-qa-1"><a class="header" href="#poetry-常見使用情境與操作-qa-1">Poetry 常見使用情境與操作 QA</a></h2>
<p>這部分會以「<strong>使用場景</strong>」的角度切入，介紹 Poetry 應用情境與操作說明，還包括一些自問自答：</p>
<ol>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%80%E3%80%81%E6%96%B0%E5%A2%9E%E5%B0%88%E6%A1%88%E4%B8%A6%E4%BD%BF%E7%94%A8-Poetry">新增專案並使用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%8C%E3%80%81%E7%8F%BE%E6%9C%89%E5%B0%88%E6%A1%88%E6%94%B9%E7%94%A8-Poetry">現有專案改用 Poetry</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%B8%89%E3%80%81%E5%9C%A8%E5%88%A5%E8%87%BA%E4%B8%BB%E6%A9%9F%E5%9B%9E%E5%BE%A9%E5%B0%88%E6%A1%88%E7%8B%80%E6%85%8B">在別臺主機回復專案狀態</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%9B%9B%E3%80%81%E6%88%91%E6%83%B3%E8%A6%81%E9%87%8D%E5%BB%BA%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83">我想要重建虛擬環境</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">為什麼我不在 Docker 環境中使用 Poetry？</a></li>
<li><a href="https://blog.kyomind.tw/python-poetry/#%E5%85%AD%E3%80%81%E6%88%91%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%BF%92%E6%85%A3%E7%9A%84-virtualenv-%E5%97%8E%EF%BC%9F">我可以使用自己習慣的 virtualenv 嗎？</a></li>
</ol>
<h3 id="一新增專案並使用-poetry-1"><a class="header" href="#一新增專案並使用-poetry-1">一、新增專案並使用 Poetry</a></h3>
<p>這是最理想的狀態，沒有過去的「包袱」，可謂是最能輕鬆採用 Poetry 的情境。</p>
<p>使用順序不外乎是：</p>
<ol>
<li><code>poetry init</code>：初始化，建立<code>pyproject.toml</code>。</li>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。</li>
<li><code>poetry shell</code>：進入專案但虛擬環境還未啟動，以這個指令啟動。如果使用本指令時虛擬環境<strong>尚未建立或已移除</strong>，則會<strong>直接自動幫你建立虛擬環境</strong>並使用。</li>
<li><code>poetry add</code>：新增套件並寫入虛擬環境。必要時使用<code>-D</code>參數新增至 dev 區塊。</li>
<li><code>poetry remove</code>：移除套件，若是移除 dev 區塊的套件，需要加上<code>-D</code>參數。</li>
</ol>
<p>這部分和前面內容沒有差別，因為前面內容就是以全新專案作為基礎。</p>
<h3 id="二現有專案改用-poetry-1"><a class="header" href="#二現有專案改用-poetry-1">二、現有專案改用 Poetry</a></h3>
<p>極為常見的需求，但並沒有很正式的做法，因為不存在<code>poetry import</code>之類的指令。</p>
<p>首先要考量的就是：要怎麼把<code>requirements.txt</code>的所有項目加到<code>pyproject.toml</code>中呢？經過一番 Google，基本上<a href="https://stackoverflow.com/questions/62764148/how-to-import-requirements-txt-from-an-existing-project-using-poetry">只能土法煉鋼</a>：</p>
<pre><code>cat requirements.txt | xargs poetry add
</code></pre>
<p>然而這樣做是有可能遇到一些問題的，因為 Poetry <strong>對套件的版本衝突比較敏感</strong>，所以即便用<code>pip install -r requirements.txt</code>都能正常安裝，透過上述指令的遷移過程卻仍有機會出現錯誤。</p>
<p>那怎麼辦？只能照著錯誤訊息手動修正<code>requirements.txt</code>中的套件版本。</p>
<p>只能說這個「<strong>手動 import</strong>」做法實在是不得已，因為我們最早介紹<code>pyproject.toml</code>時有提到，<code>poetry add</code>只會在<code>pyproject.toml</code>中寫入「主套件」，但這樣的 import 方式相當於把<code>requirements.txt</code>中的<strong>所有套件，都當作主套件</strong>來<code>add</code>了！</p>
<p>畢竟在<code>requirements.txt</code>中<strong>無從區分</strong>主套件與依賴套件，都是「一視同仁」地列出。</p>
<p>但如此做法也讓專案的套件<strong>失去主從之分</strong>，這樣會有什麼<strong>壞處</strong>？日後要移除主套件時，<strong>需要花額外的心力去區分主從</strong>（因為僅僅移除依賴套件<strong>並不會有移除效果</strong>），比如使用<code>poetry show --tree</code>去一個一個檢視，終究是件麻煩事。</p>
<p>完成轉換後，為保險起見，建議透過新的<code>pyproject.toml</code>來重建一個虛擬環境。</p>
<h3 id="三在別臺主機上重現專案的-poetry-虛擬環境"><a class="header" href="#三在別臺主機上重現專案的-poetry-虛擬環境">三、在別臺主機上重現專案的 Poetry 虛擬環境</a></h3>
<p>這也是非常常見的需求。</p>
<p>第一步當然是<code>git clone</code>專案，此時專案中已經有 Poetry 所需的必要資訊了——也就是<code>pyproject.toml</code>和<code>poetry.lock</code>。</p>
<p>你還缺少的僅僅是虛擬環境。如果是全新的主機，則還得先安裝、設定好 Poetry。</p>
<p>確定 Poetry 可正常使用後，移至專案目錄底下，依序執行指令：</p>
<ol>
<li><code>poetry env use python</code>：建立專案虛擬環境並使用。如果你懶得打這麼長的指令，直接<code>poetry shell</code>也是可以。此時我們會有一個「<strong>空的</strong>」虛擬環境。</li>
<li><code>poetry install</code>：因為是舊專案，不需要<code>init</code>，會直接依<code>poetry.lock</code>記載的套件版本安裝到虛擬環境中！類似<code>npm install</code>。</li>
</ol>
<h3 id="四我想要重建虛擬環境-1"><a class="header" href="#四我想要重建虛擬環境-1">四、我想要重建虛擬環境</a></h3>
<p>在使用專案內虛擬環境方案，也就是<code>.venv</code>的前提下，想要刪除這個虛擬環境並加以重建，也不需要使用<code>poetry env remove python</code>指令了，因為會出錯。</p>
<p>還有更簡單暴力的方式，是什麼呢？——直接刪除<code>.venv</code>資料夾即可。</p>
<p>然後再<code>poetry env use python</code>或<code>poetry shell</code>建一個新的就好。</p>
<h3 id="五為什麼我不在-docker-環境中使用-poetry-1"><a class="header" href="#五為什麼我不在-docker-環境中使用-poetry-1">五、為什麼我不在 Docker 環境中使用 Poetry？</a></h3>
<p>因為啟動容器後需要先安裝 Poetry 到全域，或打包一個帶有 Poetry 的 image，兩者都會<strong>增加新的耦合與依賴</strong>，我覺得並不妥當。</p>
<p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用這個舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p>
<h3 id="六我可以使用自己習慣的-virtualenv-嗎"><a class="header" href="#六我可以使用自己習慣的-virtualenv-嗎">六、我可以使用自己習慣的 virtualenv 嗎？</a></h3>
<p>當然可以。</p>
<p>不過我本來也繼續使用<code>pyenv</code>的<code>virtualenv</code>，但兩者有時候也是會小小打架，後來還是索性用 Poetry 的虛擬環境就好。</p>
<p>一個專案對應一個虛擬環境，應該還是比較簡潔的做法，我的觀察啦！😎</p>
<hr />
<h2 id="結語井然有序的複雜"><a class="header" href="#結語井然有序的複雜">結語：井然有序的複雜</a></h2>
<p>總的來說，Poetry 是一款優秀的套件管理工具，但並不像 pip 那般簡單、好上手。</p>
<p>使用 Poetry 來管理專案的套件與虛擬環境，需要一定的學習成本，但帶來的效益還是相當可觀的，尤其在你希望能夠乾淨且安心地移除套件之際，可謂莫它莫屬。</p>
<p>所以，別再猶豫，從今天起，加入 Poetry 的行列吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="實戰-fil-改善-python-記憶體用量"><a class="header" href="#實戰-fil-改善-python-記憶體用量">實戰 Fil 改善 Python 記憶體用量</a></h1>
<p>https://myapollo.com.tw/blog/fil-memory-usage-profiler/</p>
<p><a href="https://myapollo.com.tw/blog/python-resource-module-peak-memory/">用 Python resource 模組找出尖峰記憶體用量</a> 一文介紹如何透過 Python <a href="https://docs.python.org/3/library/resource.html">resource</a> 模組瞭解尖峰記憶體用量(peak memory usage), 不過該模組並無法提供更詳細的記憶體統計資料，無法得知具體哪部分的 Python 程式消耗大量記憶體，因此我們需要透過工具剖析(profiling)詳細的記憶體用量，以幫助定位問題之所在。</p>
<p>本文將介紹如何使用 <a href="https://pythonspeed.com/fil/docs/index.html">Fil</a> 剖析 Python 程式的記憶體用量，並透過 1 個簡單的範例，實際定位程式中耗用記憶體的部分，並進行改善優化。</p>
<h3 id="本文環境-1"><a class="header" href="#本文環境-1">本文環境</a></h3>
<ul>
<li>macOS 11.6</li>
<li>Python 3.7</li>
<li>pandas 1.0.3</li>
<li><a href="https://pythonspeed.com/fil/docs/index.html">Fil</a></li>
</ul>
<pre><code class="language-undefined">$ pip install pandas==1.0.3 filprofiler
</code></pre>
<h3 id="測試資料"><a class="header" href="#測試資料">測試資料</a></h3>
<p>本文需要使用以下資料集進行測試，該資料集包含至少 200MB 以上的財經新聞 CSV 檔，我們用該資料來模擬實際處理大量資料時，記憶體被耗用的情況：</p>
<p><a href="https://www.kaggle.com/miguelaenlle/massive-stock-news-analysis-db-for-nlpbacktests">Daily Financial News for 6000+ Stocks</a></p>
<h3 id="fil-aka-fil-profiler"><a class="header" href="#fil-aka-fil-profiler">Fil (aka Fil profiler)</a></h3>
<p><a href="https://pythonspeed.com/fil/docs/index.html">Fil</a> 是 1 套十分易於使用的 Python 記憶體剖析工具，該工具運作原理為透過作業系統所提供的 <code>LD_PRELOAD</code> / <code>DYLD_INSERT_LIBRARIES</code> 機制，在程式啟動之前載入開發者指定的共享函式庫(shared library), 該函式庫可以覆寫(override)某些重要的系統 API, 使得開發者可透過該共享函式庫攔截(intercept)某些 API 的呼叫，例如 <a href="https://pythonspeed.com/fil/docs/fil/what-it-tracks.html">Fil 透過覆寫記憶體相關的底層 API</a>, 使得 Fil 得以攔截並統計記憶體分配以及使用情況，達成記憶體剖析的功能。</p>
<p>如果想了解 Fil 會攔截哪些 API, 可以參考 <a href="https://pythonspeed.com/fil/docs/fil/what-it-tracks.html">What Fil tracks</a> 一文。</p>
<h3 id="fil-初體驗"><a class="header" href="#fil-初體驗">Fil 初體驗</a></h3>
<p>以下範例載入測試資料集中的 <code>raw_partner_headlines.csv</code>, 並查詢多少新聞標題中含有 <strong>J.P. Morgan</strong> 以及該新聞中所提到的股票代號，並且匯總股票代號出現的總次數，最後只顯示超過 5 次的股票代號：</p>
<pre><code class="language-python">import pandas as pd


def load_data():
    return pd.read_csv('&lt;path to&gt;/raw_partner_headlines.csv')


def main():
    df = load_data()
    df = df.query('headline.str.contains(&quot;J.P. Morgan&quot;)', engine='python')
    df = df.groupby(by='stock').count()
    for r in df.sort_values(by='headline', ascending=False).itertuples():
        if r.url &gt; 5:
            print(r.Index, r.url)


main()
</code></pre>
<p>上述範例執行結果如下，可以看到被 J.P. Morgan 提到最多次的股票代號為 JPM, 其次為 ARNA:</p>
<pre><code class="language-undefined">$ python test.py
JPM 15
ARNA 10
ZIOP 8
BMRN 8
AVEO 8
TEX 6
MDVN 6
NKTR 6
REGN 6
VVUS 6
</code></pre>
<p>接著我們實際用 Fil 剖析上述範例會用到多少記憶體，以下是呼叫 <code>fil-profile</code> 對 <code>test.py</code> 進行記憶體用量剖析的指令：</p>
<pre><code class="language-bash">$ fil-profile run test.py
=fil-profile= Memory usage will be written out at exit, and opened automatically in a browser.
...(略)...
</code></pre>
<p>一旦 <code>fil-profile</code> 指令完成記憶體剖析的工作， Fil 就會打開 1 個瀏覽器視窗，並且將分析報告以網頁方式呈現：</p>
<p><img src="python/images/peak-memory-usage-1.png" alt="img" /></p>
<p>上圖顯示前文的範例用了 <strong>732.6 MiB</strong> 的記憶體，相較於 <code>raw_partner_headlines.csv</code> 檔案大小 <strong>400MB</strong> 而言，多耗用將近 1 倍的記憶體，理想情況是載入資料之後只佔用 400MB的記憶體空間，但由於 Python 的物件化設計，記憶體耗用的情況是預料之中的事，可以想見一旦 <code>raw_partner_headlines.csv</code> 檔案越大，就需要記憶體越大的機器進行運算，最終勢必對成本（例如機器租用成本）造成影響，所以我們需要優化記憶體的使用。</p>
<p>接著，我們可以循著報告往下找到記憶體耗用的癥結點：</p>
<p><img src="python/images/peak-memory-usage-2.png" alt="img" /></p>
<p>上圖可以發現 <code>main()</code> 函式佔了約 <strong>84.59%</strong> 的記憶體用量，但具體在 <code>main()</code> 函式的哪部分，可以繼續往下追蹤：</p>
<p><img src="python/images/peak-memory-usage-3.png" alt="img" /></p>
<p>上圖顯示 <code>main()</code> 函式中的 <code>load_data()</code> 函式佔用約 <strong>66.38%</strong> 的記憶體用量，看來 <code>load_data()</code> 的記憶體用量優化，是 1 個可以進行的方向。</p>
<h3 id="實戰優化"><a class="header" href="#實戰優化">實戰優化</a></h3>
<p><a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html#pandas.read_csv">pandas.read_csv()</a> 預設會載入整份資料到記憶體之中，如果能夠分批載入計算將可以有效降低記憶體用量，所以我們可以為 <code>read_csv()</code> 設定 <code>chunksize</code> 參數，讓其分批載入資料，不過分批載入資料的缺點是無法一次計算好最終結果，必須將每批資料的計算結果加總儲存，也就是下列範例中的 <code>counter[r.Index] += r.url</code> 部分，最終再將加總後的結果列印：</p>
<pre><code class="language-python">import pandas as pd

from collections import Counter


def load_data():
    return pd.read_csv(
        '&lt;path to&gt;/raw_partner_headlines.csv',
        chunksize=1000
    )


def main():
    counter = Counter()
    for df in load_data():
        df = df.query('headline.str.contains(&quot;J.P. Morgan&quot;)', engine='python')
        df = df.groupby(by='stock').count()
        for r in df.itertuples():
            counter[r.Index] += r.url

    for stock, count in counter.items():
        if count &gt; 5:
            print(stock, count)


main()
</code></pre>
<p>上述範例執行結果如下：</p>
<pre><code class="language-undefined">$ python test.py
ARNA 10
AVEO 8
BMRN 8
JPM 15
MDVN 6
NKTR 6
REGN 6
TEX 6
VVUS 6
ZIOP 8
</code></pre>
<p>其記憶體剖析報告如下：</p>
<p><img src="python/images/peak-memory-usage-4.png" alt="img" /></p>
<p>上述報告可以看到，僅僅只是加個參數，就能夠讓記憶體用量從 <strong>732.6 MiB</strong> 下降至 <strong>150.2 MiB</strong>, 下降幅度相當可觀，對於更大的資料也不須擔心記憶體不足的問題，如果是租用雲端機器，也只需要相當低規格的機器即可達成。</p>
<p>以上就是透過 Fil 實際改善記憶體用量的實戰過程。</p>
<p>Happy coding!</p>
<h3 id="references-2"><a class="header" href="#references-2">References</a></h3>
<p>https://pythonspeed.com/fil/docs/index.html</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="臺股個股線圖繪製"><a class="header" href="#臺股個股線圖繪製">臺股個股線圖繪製</a></h2>
<p>https://hackmd.io/@s02260441/Hki9NN5jL</p>
<pre><code class="language-python">import pandas as pd
import datetime as datetime
import matplotlib
import mplfinance as mpf
import pandas_datareader as pdr

# 導入pandas、matplotlib、mplfinance模組，將mplfinance模組縮寫為mpf
# 這邊要導入matplotlib的原因是因為mplfinance繪圖時需要調用mptplotlib模組

target_stock = &quot;2330.TW&quot;  # 設定要繪製走勢圖的股票
start = datetime.datetime(2018, 4, 1)
df = pdr.DataReader(&quot;2330.TW&quot;, &quot;yahoo&quot;, start=start)
print(df)


mc = mpf.make_marketcolors(up=&quot;r&quot;, down=&quot;g&quot;, inherit=True)
s = mpf.make_mpf_style(base_mpf_style=&quot;yahoo&quot;, marketcolors=mc)
# 針對線圖的外觀微調，將上漲設定為紅色，下跌設定為綠色，符合臺股表示習慣
# 接著把自訂的marketcolors放到自訂的style中，而這個改動是基於預設的yahoo外觀

kwargs = dict(
    type=&quot;candle&quot;,
    mav=(5, 20, 60),
    volume=True,
    figratio=(10, 8),
    figscale=0.75,
    title=target_stock,
    style=s,
)
# 設定可變參數kwargs，並在變數中填上繪圖時會用到的設定值

mpf.plot(df, **kwargs)
# 選擇df資料表為資料來源，帶入kwargs參數，畫出目標股票的走勢圖
</code></pre>
<p>https://yhhuang1966.blogspot.com/2022/09/python-mplfinance.html</p>
<pre><code class="language-py"># https://python.plainenglish.io/plot-stock-chart-using-mplfinance-in-python-9286fc69689
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
import mplfinance as mpf

# download stock price data
symbol = &quot;AAPL&quot;
df = yf.download(symbol, period=&quot;6mo&quot;)

# Add MACD as subplot
def MACD(df, window_slow, window_fast, window_signal):
    macd = pd.DataFrame()
    macd[&quot;ema_slow&quot;] = df[&quot;Close&quot;].ewm(span=window_slow).mean()
    macd[&quot;ema_fast&quot;] = df[&quot;Close&quot;].ewm(span=window_fast).mean()
    macd[&quot;macd&quot;] = macd[&quot;ema_slow&quot;] - macd[&quot;ema_fast&quot;]
    macd[&quot;signal&quot;] = macd[&quot;macd&quot;].ewm(span=window_signal).mean()
    macd[&quot;diff&quot;] = macd[&quot;macd&quot;] - macd[&quot;signal&quot;]
    macd[&quot;bar_positive&quot;] = macd[&quot;diff&quot;].map(lambda x: x if x &gt; 0 else 0)
    macd[&quot;bar_negative&quot;] = macd[&quot;diff&quot;].map(lambda x: x if x &lt; 0 else 0)
    return macd


macd = MACD(df, 12, 26, 9)
macd_plot = [
    mpf.make_addplot(
        (macd[&quot;macd&quot;]), color=&quot;#606060&quot;, panel=2, ylabel=&quot;MACD&quot;, secondary_y=False
    ),
    mpf.make_addplot((macd[&quot;signal&quot;]), color=&quot;#1f77b4&quot;, panel=2, secondary_y=False),
    mpf.make_addplot((macd[&quot;bar_positive&quot;]), type=&quot;bar&quot;, color=&quot;#4dc790&quot;, panel=2),
    mpf.make_addplot((macd[&quot;bar_negative&quot;]), type=&quot;bar&quot;, color=&quot;#fd6b6c&quot;, panel=2),
]

mpf.plot(df, type=&quot;candle&quot;, volume=True, addplot=macd_plot)
</code></pre>
<pre><code class="language-py">import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
import mplfinance as mpf
import talib as ta

# download stock price data
symbol = &quot;AAPL&quot;
df = yf.download(symbol, start=&quot;2021-01-01&quot;, end=&quot;2022-05-01&quot;)
for num in [10, 120]:
    df[f&quot;SMA{num}&quot;] = ta.SMA(df[&quot;Close&quot;], timeperiod=num)

df[&quot;CLOSE_LINEARREG_ANGLE&quot;] = ta.LINEARREG_ANGLE(df[&quot;Close&quot;], timeperiod=14)
df[&quot;SMA_LINEARREG_ANGLE&quot;] = ta.LINEARREG_ANGLE(df[&quot;SMA10&quot;], timeperiod=14)
df = df.dropna()

add_plot = [
    mpf.make_addplot(df[&quot;CLOSE_LINEARREG_ANGLE&quot;]),
    mpf.make_addplot(df[&quot;SMA_LINEARREG_ANGLE&quot;]),
]
mc = mpf.make_marketcolors(up=&quot;r&quot;, down=&quot;g&quot;, inherit=True)
mpf.plot(
    df,
    type=&quot;candle&quot;,
    volume=True,
    style=mpf.make_mpf_style(base_mpf_style=&quot;yahoo&quot;, marketcolors=mc),
    addplot=add_plot,
)
</code></pre>
<pre><code class="language-py">from binance.client import Client
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
import talib as ta
import datetime as dt
import json
import os


class binanceAPI:
    def __init__(self, configPath):
        with open(configPath, &quot;r&quot;) as f:
            self.kw_login = json.loads(f.read())
        self.api = self.__login(self.kw_login[&quot;PUBLIC&quot;], self.kw_login[&quot;SECRET&quot;])

    def __login(self, PUBLIC, SECRET):
        return Client(api_key=PUBLIC, api_secret=SECRET)


def build_df(klines):
    cols = [
        &quot;timestamp&quot;,
        &quot;open&quot;,
        &quot;high&quot;,
        &quot;low&quot;,
        &quot;close&quot;,
        &quot;volume&quot;,
        &quot;close_time&quot;,
        &quot;quote_av&quot;,
        &quot;trades&quot;,
        &quot;tb_base_av&quot;,
        &quot;tb_quote_av&quot;,
        &quot;ignore&quot;,
    ]
    df = pd.DataFrame(klines, columns=cols)
    df[&quot;timestamp&quot;] = [dt.datetime.fromtimestamp(x / 1000.0) for x in df[&quot;timestamp&quot;]]
    df.set_index(&quot;timestamp&quot;, inplace=True)
    df = df[[&quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot;]]
    df[[&quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot;]] = df[
        [&quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot;]
    ].astype(float)
    for num in [5, 10, 120]:
        df[f&quot;SMA{num}&quot;] = ta.SMA(df[&quot;close&quot;], timeperiod=num)
    df[&quot;SMA_LINEARREG_ANGLE&quot;] = ta.LINEARREG_ANGLE(df[&quot;SMA5&quot;], timeperiod=14)
    df[&quot;CLOSE_LINEARREG_ANGLE&quot;] = ta.LINEARREG_ANGLE(df[&quot;close&quot;], timeperiod=14)
    df = df.dropna()
    df[&quot;idx&quot;] = range(0, len(df))
    return df


if __name__ == &quot;__main__&quot;:
    client = binanceAPI(os.environ[&quot;HOME&quot;] + f&quot;/.mybin/jason/binance_login.txt&quot;)
    KLINE_INTERVAL = Client.KLINE_INTERVAL_30MINUTE
    start_time = dt.datetime(2022, 11, 1, hour=8, minute=00, second=0)
    end_time = dt.datetime.now()

    klines = client.api.get_historical_klines(
        symbol=&quot;BTCUSDT&quot;,
        interval=KLINE_INTERVAL,
        start_str=start_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;),
        end_str=end_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;),
    )
    df = build_df(klines)
    print(df.to_markdown())
    input()
    add_plot = [
        mpf.make_addplot(df[&quot;CLOSE_LINEARREG_ANGLE&quot;]),
        mpf.make_addplot(df[&quot;SMA_LINEARREG_ANGLE&quot;]),
    ]
    mc = mpf.make_marketcolors(up=&quot;r&quot;, down=&quot;g&quot;, inherit=True)
    mpf.plot(
        df,
        type=&quot;candle&quot;,
        volume=True,
        style=mpf.make_mpf_style(base_mpf_style=&quot;yahoo&quot;, marketcolors=mc),
        addplot=add_plot,
    )
</code></pre>
<hr />
<pre><code class="language-py"># Function.py
# 載入套件
import yfinance as yf
import mplfinance as mpf
import numpy as np

# 透過Yfinance取得K棒歷史資料
def GetKBar(SDate, EDate, Prod, Kind, Cycle):
    # 轉換日期格式
    SDate = SDate[:4] + &quot;-&quot; + SDate[4:6] + &quot;-&quot; + SDate[6:]
    EDate = EDate[:4] + &quot;-&quot; + EDate[4:6] + &quot;-&quot; + EDate[6:]
    # 指數前面要加 ^ 符號
    if Kind == &quot;Index&quot;:
        Prod = &quot;^&quot; + Prod
    # 從 yahoo finance 下載資料
    Data = yf.download(Prod, start=SDate, end=EDate, interval=Cycle)
    # 將欄位名稱改為英文小寫
    Data.columns = [i.lower() for i in Data.columns]
    # 因python會有小數點精確度問題，故將股價取到小數後兩位
    Data.open = [round(i, 2) for i in Data.open]
    Data.high = [round(i, 2) for i in Data.high]
    Data.low = [round(i, 2) for i in Data.low]
    Data.close = [round(i, 2) for i in Data.close]
    return Data


# 圖片物件
class DrawKBar:
    # 初始設定
    def __init__(self, KBar):
        self.KBar = KBar
        self.TableList = []

    # 新增附圖
    def Add(
        self,
        data,
        panel=0,
        type=&quot;line&quot;,
        marker=&quot;.&quot;,
        color=&quot;black&quot;,
        scatter=False,
        ylabel=&quot;&quot;,
    ):
        # Table = mpf.make_addplot(data,panel=panel,type=type,color=color)
        Table = mpf.make_addplot(
            data,
            panel=panel,
            type=type,
            marker=marker,
            color=color,
            scatter=scatter,
            ylabel=ylabel,
            secondary_y=False,
        )
        self.TableList.append(Table)

    # 顯示圖片
    def Show(self):
        KBar_color = mpf.make_marketcolors(
            up=&quot;red&quot;, down=&quot;green&quot;, edge=&quot;inherit&quot;, wick=&quot;inherit&quot;, volume=&quot;inherit&quot;
        )
        KBar_style = mpf.make_mpf_style(
            base_mpf_style=&quot;yahoo&quot;, edgecolor=&quot;black&quot;, marketcolors=KBar_color
        )
        mpf.plot(
            self.KBar,
            type=&quot;candle&quot;,
            style=KBar_style,
            volume=True,
            addplot=self.TableList,
        )


# 計算績效KPI
def GetKPI(ProfitList):
    # 將 List 轉為 numpy array 格式
    ProfitList = np.array(ProfitList)
    print()

    # 交易次數
    TotalNum = len(ProfitList)
    print(&quot;交易次數:&quot;, TotalNum, &quot;次&quot;)

    # 總損益
    TotalProfit = round(sum(ProfitList), 2)
    print(&quot;總損益:&quot;, TotalProfit, &quot;元&quot;)

    # 平均損益
    if TotalNum == 0:
        AvgProfit = None
    else:
        AvgProfit = round(TotalProfit / TotalNum, 2)
    print(&quot;平均損益:&quot;, AvgProfit, &quot;元&quot;)

    # 總勝率
    Win = [i for i in ProfitList if i &gt; 0]  # 獲利的部分
    Loss = [i for i in ProfitList if i &lt; 0]  # 虧損的部分
    if TotalNum == 0:
        WinRate = None
    else:
        WinRate = round(len(Win) / TotalNum * 100, 2)
    print(&quot;總勝率:&quot;, WinRate, &quot;%&quot;)

    # 平均獲利
    if len(Win) == 0:
        AvgWin = None
    else:
        AvgWin = round(np.mean(Win), 2)
    print(&quot;平均獲利:&quot;, AvgWin, &quot;元&quot;)

    # 平均虧損
    if len(Loss) == 0:
        AvgLoss = None
    else:
        AvgLoss = round(np.mean(Loss), 2)
    print(&quot;平均虧損:&quot;, AvgLoss, &quot;元&quot;)

    # 獲利因子
    if sum(Loss) == 0:
        ProfitFactor = None
    else:
        ProfitFactor = round(sum(Win) / abs(sum(Loss)), 2)
    print(&quot;獲利因子:&quot;, ProfitFactor, &quot;倍&quot;)

    # 最大資金回落
    MaxCapital = 0
    Capital = 0
    MDD = 0
    DD = 0
    for i in ProfitList:
        Capital += i
        MaxCapital = max(MaxCapital, Capital)
        DD = round(MaxCapital - Capital, 2)
        MDD = max(MDD, DD)
    print(&quot;最大資金回落:&quot;, abs(MDD), &quot;元&quot;)
</code></pre>
<pre><code class="language-py"># python 8-2.py &quot;20210101&quot; &quot;20220501&quot;  &quot;AAPL&quot; &quot;&quot;  &quot;1D&quot;
# 載入套件
from plotly.offline import plot
import talib as ta
import plotly.graph_objs as go
import sys, Function

# 資料參數 (可自行調整)
SDate = sys.argv[1]  # 資料起始日
EDate = sys.argv[2]  # 資料結束日
Prod = sys.argv[3]  # 商品代碼
Kind = sys.argv[4]  # 商品種類
Cycle = sys.argv[5]  # K棒週期

# 取得K棒資料
KBar = Function.GetKBar(SDate, EDate, Prod, Kind, Cycle)
print(KBar)

# 計算技術指標
flag = False
KBar[&quot;CDL3BLACKCROWS&quot;] = ta.CDL3BLACKCROWS(
    KBar[&quot;open&quot;], KBar[&quot;high&quot;], KBar[&quot;low&quot;], KBar[&quot;close&quot;]
)
print(KBar)
print(KBar[&quot;CDL3BLACKCROWS&quot;].tolist(), len(KBar[&quot;CDL3BLACKCROWS&quot;]))
for i in range(0, len(KBar[&quot;CDL3BLACKCROWS&quot;])):
    signal = KBar.iloc[0][&quot;CDL3BLACKCROWS&quot;]
    if float(signal) &lt; 0:
        print(KBar.index[i], signal)
        flag = True

if flag == False:
    print(&quot;期間內無觸發此型態訊號&quot;)

trace = go.Candlestick(  # x= pd.to_datetime(dfohlc.index.values),
    open=KBar[&quot;open&quot;], high=KBar[&quot;high&quot;], low=KBar[&quot;low&quot;], close=KBar[&quot;close&quot;]
)
data = [trace]

plot(data, filename=&quot;go_candle1.html&quot;)
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="取得目前週選擇代號"><a class="header" href="#取得目前週選擇代號">取得目前週選擇代號</a></h2>
<pre><code class="language-python">from multiprocessing import Process, Queue
from shioaji.contracts import Contract
from shioaji import Exchange
from time import sleep
from line_notify import LineNotify

import sys
import platform
import signal
import datetime
import shioaji as sj
import os
import json
import pandas as pd


token_list = {

}


def line_notify(message):
    for _, token in token_list.items():
        LineNotify(token).send(message)


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


def get_previous_wednesday():
    today = datetime.datetime.today()
    wednesday = (
        today - datetime.timedelta(days=today.weekday()) + datetime.timedelta(days=2)
    )
    previous_wednesday = wednesday - datetime.timedelta(days=7)
    return previous_wednesday.date()


def get_this_week_wednesday():
    today = datetime.datetime.today()
    wednesday = (today + datetime.timedelta(days=(2 - today.weekday()))).date()
    return wednesday


def get_next_week_wednesday():
    today = datetime.datetime.today()
    wednesday = (today + datetime.timedelta(days=(2 - today.weekday() + 7))).date()
    return wednesday


def get_option_symbol(api):
    for option in api.Contracts.Options:
        for contract in option:
            if &quot;TX&quot; in contract.category:
                now = datetime.datetime.now()
                wednesday_time = get_this_week_wednesday()
                wednesday_time = datetime.datetime.combine(
                    wednesday_time, datetime.datetime.min.time()
                ) + datetime.timedelta(
                    hours=14
                )  # 因為程式是14:50啟動計算所以改設定14:00
                # 根據當前時間判斷是否在星期三 15:00之前。如果在此時間之前，則列印上週三和本週三的日期；否則列印本週三和下週三的日期：
                if now &lt; wednesday_time:
                    if datetime.datetime.strptime(
                        contract.update_date, &quot;%Y/%m/%d&quot;
                    ).date() &gt;= get_previous_wednesday() and contract.delivery_date == get_this_week_wednesday().strftime(
                        &quot;%Y/%m/%d&quot;
                    ):
                        print(
                            contract.symbol,
                            contract.name,
                            contract.update_date,
                            contract.delivery_date,
                        )
                        return contract.symbol
                else:
                    if datetime.datetime.strptime(
                        contract.update_date, &quot;%Y/%m/%d&quot;
                    ).date() &gt;= get_this_week_wednesday() and contract.delivery_date == get_next_week_wednesday().strftime(
                        &quot;%Y/%m/%d&quot;
                    ):
                        print(
                            contract.symbol,
                            contract.name,
                            contract.update_date,
                            contract.delivery_date,
                        )
                        return contract.symbol


if __name__ == &quot;__main__&quot;:
    if platform.system().lower() == &quot;linux&quot;:
        Watcher()

    with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_token.txt&quot;, &quot;r&quot;) as f:
        api = sj.Shioaji()
        kw_login = json.loads(f.read())
        print(kw_login)
        api.login(**kw_login, contracts_timeout=300000)
        # api.fetch_contracts(contract_download=True)
        print(get_option_symbol(api))
        api.logout()

</code></pre>
<h2 id="取得週選週三換約1500-後各履約價第一筆成交價"><a class="header" href="#取得週選週三換約1500-後各履約價第一筆成交價">取得週選週三換約15:00 後各履約價第一筆成交價</a></h2>
<pre><code class="language-python">import platform
import shioaji as sj
import datetime as dt
import pandas as pd
import signal
import os
import sys
import json

from line_notify import LineNotify


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


# 取得大臺期貨開盤價
def getOpenPrice(api, year, month, day, open_time):
    try:
        TXF = (
            sorted([x for x in dir(api.Contracts.Futures.TXF) if x.startswith(&quot;TXF&quot;)])
        )[0]
        date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
        kbars = api.kbars(api.Contracts.Futures.TXF[TXF], date)
        df = pd.DataFrame({**kbars})
        if not df.empty:
            df.ts = pd.to_datetime(df.ts)
            df.set_index(&quot;ts&quot;, inplace=True)
            return df.iloc[df.index.get_loc(open_time, method=&quot;nearest&quot;)][&quot;Open&quot;]
        else:
            return None
    except:
        return None


def getOptionsDealts(api, OP, year, month, day):
    date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
    try:
        # print(OP[:3], OP, date)
        ticks = api.ticks(api.Contracts.Options[OP[:3]][OP], date)
        df = pd.DataFrame({**ticks})
        if df.empty:
            return pd.DataFrame()
        df.ts = pd.to_datetime(df.ts)
        df[&quot;OP&quot;] = OP
    except:
        # print(OP)
        return pd.DataFrame()
    return df


# {1: buy deal, 2: sell deal, 0: can't judge}
def set_tick_type(df):
    if df[&quot;close&quot;] == df[&quot;bid_price&quot;]:
        return 1
    elif df[&quot;close&quot;] == df[&quot;ask_price&quot;]:
        return 2
    else:
        return 0


def get_options_contracts(api):
    option_contracts = {&quot;week&quot;: [], &quot;month&quot;: []}
    symbols = sorted([x.symbol for x in api.Contracts.Options.TXO])
    near_option_symbol = symbols[0][3:9]

    for option in api.Contracts.Options:
        for contract in option:
            if &quot;TX&quot; in contract.category and near_option_symbol in contract.symbol:
                if contract.category == &quot;TXO&quot;:
                    option_contracts[&quot;month&quot;].append(contract)
                else:
                    option_contracts[&quot;week&quot;].append(contract)

    return option_contracts


def main():
    api = sj.Shioaji(simulation=False)
    with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_token.txt&quot;, &quot;r&quot;) as f:
        # with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/login.txt&quot;, &quot;r&quot;) as f:
        kw_login = json.loads(f.read())
        api.login(**kw_login, contracts_timeout=300000)

    options_contracts = get_options_contracts(api)

    week_options = []
    for c in options_contracts[&quot;week&quot;]:
        week_options.append(c[&quot;symbol&quot;])

    today = dt.date.today()
    last_thursday = today - dt.timedelta(days=(today.weekday() + 1) % 7 + 3)

    first_row_list = []
    for OP in week_options:
        df = getOptionsDealts(
            api, OP, last_thursday.year, last_thursday.month, last_thursday.day
        )
        if not df.empty:
            columns = [
                &quot;OP&quot;,
                &quot;ts&quot;,
                &quot;close&quot;,
                &quot;volume&quot;,
                &quot;ask_price&quot;,
                &quot;ask_volume&quot;,
                &quot;bid_price&quot;,
                &quot;bid_volume&quot;,
            ]
            df = df[columns]
            df = df.assign(tick_type=df.apply(set_tick_type, axis=1))
            # 假設日期時間欄位名稱為 'datetime'
            df[&quot;ts&quot;] = pd.to_datetime(df[&quot;ts&quot;])  # 將欄位轉換為日期時間格式
            # 選擇15:00之後的時間
            df = df[df[&quot;ts&quot;].dt.hour &gt;= 15]
            df[&quot;OP_close&quot;] = df[&quot;OP&quot;].str.extract(r&quot;(\d{5})[PC]&quot;)
            df[&quot;OP_close&quot;] = df[&quot;OP_close&quot;].astype(int)
            df[&quot;OP_close&quot;] = df[&quot;OP_close&quot;] + df[&quot;close&quot;]

            if not df.empty:
                df.reset_index(drop=True, inplace=True)
                first_row_list.append(df.iloc[0])
                # print(df, df.iloc[0], type(df.iloc[0]))

    df_new = pd.DataFrame(
        first_row_list,
        columns=[
            &quot;OP&quot;,
            &quot;ts&quot;,
            &quot;close&quot;,
            &quot;volume&quot;,
            &quot;ask_price&quot;,
            &quot;ask_volume&quot;,
            &quot;bid_price&quot;,
            &quot;bid_volume&quot;,
            &quot;tick_type&quot;,
            &quot;OP_close&quot;,
        ],
    )
    df_new.sort_values(&quot;OP&quot;, ascending=False, inplace=True)
    df_new = df_new.reset_index(drop=True)
    print(df_new)
    api.logout()


if __name__ == &quot;__main__&quot;:
    if platform.system().lower() == &quot;linux&quot;:
        Watcher()
    main()
</code></pre>
<h3 id="取得最近期貨合約代號"><a class="header" href="#取得最近期貨合約代號">取得最近期貨合約代號</a></h3>
<pre><code class="language-python">def getOpenPrice(api, year, month, day, open_time):
    TXF = (sorted([x for x in dir(api.Contracts.Futures.TXF) if x.startswith('TXF')]))[0]
    date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
    kbars = api.kbars(api.Contracts.Futures.TXF[TXF], date)
    df = pd.DataFrame({**kbars})
    df.ts = pd.to_datetime(df.ts)
    df.set_index(&quot;ts&quot;, inplace=True)
    return df.iloc[df.index.get_loc(open_time, method=&quot;nearest&quot;)][&quot;Open&quot;]
</code></pre>
<h3 id="取得週跟月選擇權合約"><a class="header" href="#取得週跟月選擇權合約">取得週跟月選擇權合約</a></h3>
<pre><code class="language-python">import shioaji as sj
import os
import json


def get_options_contracts(api):
    option_contracts = {&quot;week&quot;: [], &quot;month&quot;: []}
    symbols = sorted([x.symbol for x in api.Contracts.Options.TXO])
    near_option_symbol = symbols[0][3:9]

    for option in api.Contracts.Options:
        for contract in option:
            if &quot;TX&quot; in contract.category and near_option_symbol in contract.symbol:
                if contract.category == &quot;TXO&quot;:
                    option_contracts[&quot;month&quot;].append(contract)
                else:
                    option_contracts[&quot;week&quot;].append(contract)

    return option_contracts


if __name__ == &quot;__main__&quot;:
    with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_token.txt&quot;, &quot;r&quot;) as f:
        api = sj.Shioaji()
        kw_login = json.loads(f.read())
        api.login(**kw_login, contracts_timeout=300000)
        options_contracts = get_options_contracts(api)
        print(&quot;Month option contracts:&quot;, options_contracts[&quot;month&quot;])
        print(&quot;Week option contracts:&quot;, options_contracts[&quot;week&quot;])
</code></pre>
<h3 id="使用-token-版本"><a class="header" href="#使用-token-版本">使用 Token 版本</a></h3>
<pre><code class="language-python">#
#
# 用來記錄 選擇權的 tick和報價
#
#

from multiprocessing import Process, Queue
from shioaji.contracts import Contract
from shioaji import contracts
from time import sleep


import datetime
import shioaji as sj
import os
import json
import queue


class shioaji_proxy:
    def __init__(self, queue: Queue, bool_call: bool, bool_TSE: bool):
        self.queue = queue
        self.bool_call = bool_call

        with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_token.txt&quot;, &quot;r&quot;) as f:
            self.api = sj.Shioaji()
            kw_login = json.loads(f.read())
            self.api.login(**kw_login, contracts_timeout=300000)

        # 之後改版會修正就不需要
        # self.api.fetch_contracts(contract_download=True)

        self.api.quote.set_on_bidask_fop_v1_callback(self.quote_callback)
        self.api.quote.set_on_tick_fop_v1_callback(self.quote_callback)
        option_contracts = self.get_options_contracts()

        c: Contract
        for c in option_contracts[&quot;week&quot;]:
            if c.symbol[-1] == (&quot;C&quot; if self.bool_call else &quot;P&quot;):
                print(c)
                self.api.quote.subscribe(
                    c,
                    quote_type=sj.constant.QuoteType.Tick,
                    # version=sj.constant.QuoteVersion.v1,
                )
                self.api.quote.subscribe(
                    c,
                    quote_type=sj.constant.QuoteType.BidAsk,
                    # version=sj.constant.QuoteVersion.v1,
                )

        # self.contract: Contract = self.api.Contracts.Options.TXO.TXO202206016600C if bool_call else self.api.Contracts.Options.TXO.TXO202206016600P

        # if bool_TSE:
        #    self.api.quote.subscribe(
        #        self.api.Contracts.Indexs.TSE.TSE001,
        #        quote_type=sj.constant.QuoteType.Tick,
        #    )

    def get_options_contracts(self):
        option_contracts = {&quot;week&quot;: [], &quot;month&quot;: []}
        symbols = sorted([x.symbol for x in self.api.Contracts.Options.TXO])
        near_option_symbol = symbols[0][3:9]

        for option in self.api.Contracts.Options:
            for contract in option:
                if &quot;TX&quot; in contract.category and near_option_symbol in contract.symbol:
                    if contract.category == &quot;TXO&quot;:
                        option_contracts[&quot;month&quot;].append(contract)
                    else:
                        option_contracts[&quot;week&quot;].append(contract)

        return option_contracts

    def quote_callback(self, topic: str, quote: dict):
        # print(topic, quote)
        self.queue.put((topic, quote))


def shioaji_subscriber(queue, bool_call, bool_TSE):
    proxy = shioaji_proxy(queue, bool_call, bool_TSE)

    while True:
        sleep(1)
        queue.put(f&quot;{proxy} {datetime.datetime.now()}&quot;)


if __name__ == &quot;__main__&quot;:
    q = Queue()  # 於主進程創建隊列物件
    process_list = []
    print(&quot;main queue id: %d&quot; % id(q))

    proc = Process(target=shioaji_subscriber, args=(q, True, True))
    process_list.append(proc)
    proc.start()
    proc = Process(target=shioaji_subscriber, args=(q, False, False))
    process_list.append(proc)
    proc.start()

    bool_AM = (
        True
        if datetime.datetime.now().time() &lt; datetime.time(hour=12, minute=0)
        else False
    )

    with open(
        f'TXO-{datetime.datetime.now().date()}-{&quot;AM&quot; if bool_AM else &quot;PM&quot;}.txt', &quot;w+&quot;
    ) as fp:
        ret_count = 0
        while True:
            try:
                ret = q.get(timeout=1)
            except queue.Empty:
                print(datetime.datetime.now())
            else:
                fp.write(f&quot;{datetime.datetime.now()}\t{ret[0]}\t{ret[1]}\n&quot;)
                ret_count += 1

            # Check if we have written 100 records, then write to file and reset count
            if ret_count == 100:
                fp.flush()  # flush the file buffer to disk
                ret_count = 0

            # Check if current time is between 13:46 and 14:00, or between 5:01 and 5:10, then exit loop
            if (
                datetime.time(hour=13, minute=46)
                &lt; datetime.datetime.now().time()
                &lt; datetime.time(hour=14, minute=0)
            ) or (
                datetime.time(hour=5, minute=1)
                &lt; datetime.datetime.now().time()
                &lt; datetime.time(hour=5, minute=10)
            ):
                break

    for p in process_list:
        p.terminate()
        p.join()
        p.close()
        print(f&quot;{p} joined&quot;)
</code></pre>
<h3 id="用來記錄-選擇權的-tick和報價"><a class="header" href="#用來記錄-選擇權的-tick和報價">用來記錄 選擇權的 tick和報價</a></h3>
<pre><code class="language-python">from multiprocessing import Process, Queue

import datetime
import shioaji as sj
from shioaji import contracts
from shioaji.contracts import Contract
import os
import json
from time import sleep
import queue


class shioaji_proxy:
    def __init__(self, queue: Queue, bool_call: bool, bool_TSE: bool):
        self.queue = queue
        self.bool_call = bool_call

        with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/login.txt&quot;, &quot;r&quot;) as f:
            self.api = sj.Shioaji()
            kw_login = json.loads(f.read())
            self.api.login(**kw_login, contracts_timeout=300000)

        self.api.quote.set_quote_callback(self.quote_callback)

        symbols = []
        for x in self.api.Contracts.Options.TXO:
            symbols.append(x.symbol)
        symbols.sort()
        str_option_near = symbols[0][:9]

        contracts = []
        for x in self.api.Contracts.Options.TXO:
            if x.symbol.startswith(str_option_near):
                contracts.append(x)

        c: Contract
        for c in contracts:
            if c.symbol[-1] == (&quot;C&quot; if self.bool_call else &quot;P&quot;):
                self.api.quote.subscribe(c, quote_type=sj.constant.QuoteType.Tick)
                self.api.quote.subscribe(c, quote_type=sj.constant.QuoteType.BidAsk)

        # self.contract: Contract = self.api.Contracts.Options.TXO.TXO202206016600C if bool_call else self.api.Contracts.Options.TXO.TXO202206016600P

        if bool_TSE:
            self.api.quote.subscribe(
                self.api.Contracts.Indexs.TSE.TSE001,
                quote_type=sj.constant.QuoteType.Tick,
            )

    def quote_callback(self, topic: str, quote: dict):
        # print(topic, quote)
        self.queue.put((topic, quote))


def shioaji_subscriber(queue, bool_call, bool_TSE):
    proxy = shioaji_proxy(queue, bool_call, bool_TSE)

    while True:
        sleep(1)
        queue.put(f&quot;{proxy} {datetime.datetime.now()}&quot;)


if __name__ == &quot;__main__&quot;:
    q = Queue()  # 於主進程創建隊列物件
    process_list = []
    print(&quot;main queue id: %d&quot; % id(q))

    # shioaji_subscriber(q, True, True)

    proc = Process(target=shioaji_subscriber, args=(q, True, True))
    process_list.append(proc)
    proc.start()
    proc = Process(target=shioaji_subscriber, args=(q, False, False))
    process_list.append(proc)
    proc.start()

    bool_AM = (
        True
        if datetime.datetime.now().time() &lt; datetime.time(hour=12, minute=0)
        else False
    )

    with open(
        f'TXO-{datetime.datetime.now().date()}-{&quot;AM&quot; if bool_AM else &quot;PM&quot;}.txt', &quot;w+&quot;
    ) as fp:
        while True:
            try:
                ret = q.get(timeout=1)
            except queue.Empty:
                pass
                print(datetime.datetime.now())
            else:
                # print(ret)
                fp.write(f&quot;{datetime.datetime.now()}\t{ret[0]}\t{ret[1]}\n&quot;)

            if (
                datetime.time(hour=13, minute=46)
                &lt; datetime.datetime.now().time()
                &lt; datetime.time(hour=14, minute=0)
            ):
                break

            if (
                datetime.time(hour=5, minute=1)
                &lt; datetime.datetime.now().time()
                &lt; datetime.time(hour=5, minute=10)
            ):
                break

    for p in process_list:
        p.terminate()
        p.join()
        p.close()
        print(f&quot;{p} joined&quot;)
</code></pre>
<h2 id="選擇權最近合約排序"><a class="header" href="#選擇權最近合約排序">選擇權最近合約排序</a></h2>
<pre><code class="language-python">import shioaji as sj
import os
import json

with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/login.txt&quot;, &quot;r&quot;) as f:
    api = sj.Shioaji()
    kw_login = json.loads(f.read())
    api.login(**kw_login, contracts_timeout=300000)

symbols = []
for x in api.Contracts.Options.TXO:
    symbols.append(x.symbol)

symbols.sort()
str_option_near = symbols[0][:9]

contracts = []
for x in api.Contracts.Options.TXO:
    if x.symbol.startswith(str_option_near):
        contracts.append(x)

for c in contracts:
    print(c, c.symbol)
    # if c.symbol[-1] == (&quot;C&quot; if bool_call else &quot;P&quot;):
    # print(x)
</code></pre>
<pre><code class="language-python">from shioaji import TickSTKv1, TickFOPv1, BidAskSTKv1, BidAskFOPv1, Exchange


def order_callback(stat, msg: dict):
    print(f&quot;\n\033[1;33morder_callback: {stat} {msg}\033[0m\n&quot;)


def event_callback(resp_code, event, info, event_str):
    print(
        f&quot;\n\033[1;33mevent_callback: {resp_code} {event} {info} {event_str}\033[0m\n&quot;
    )


def quote_callback(topic: str, quote: dict):
    print(f&quot;\n\033[1;33mquote_callback: {topic} {quote}\033[0m\n&quot;)


def stk_tick_callback_v1(exchange: Exchange, tick: TickSTKv1):
    print(f&quot;stk_tick_callback_v1: {exchange} {tick}&quot;)
    print(json.dumps(tick))


def stk_bidask_callback_v1(exchange: Exchange, bidask: BidAskSTKv1):
    print(f&quot;stk_bidask_callback_v1: {exchange} {bidask}&quot;)


# {'code': 'TXFG2', 'datetime': '2022-06-23T21:52:32.489000', 'bid_total_vol': 74, 'ask_total_vol': 44, 'bid_price': ['14933', '14932', '14931', '14930', '14929'], 'bid_volume': [3, 11, 20, 31, 9], 'diff_bid_vol': [-4, 0, -5, 4, -1], 'ask_price': ['14935', '14936', '14937', '14938', '14939'], 'ask_volume': [5, 8, 8, 11, 12], 'diff_ask_vol': [3, 3, 0, 0, 0], 'first_derived_bid_price': '0', 'first_derived_ask_price': '14939', 'first_derived_bid_vol': 0, 'first_derived_ask_vol': 1, 'underlying_price': '15176.44', 'simtrade': 0}
# {'code': 'TXFG2', 'datetime': '2022-06-23T21:52:32.407000', 'open': '14904', 'underlying_price': '15176.44', 'bid_side_total_vol': 29991, 'ask_side_total_vol': 29864, 'avg_price': '14949.592158', 'close': '14934', 'high': '15041', 'low': '14849', 'amount': '29868', 'total_amount': '695828767', 'volume': 2, 'total_volume': 46545, 'tick_type': 2, 'chg_type': 4, 'price_chg': '-5', 'pct_chg': '-0.033469', 'simtrade': 0}


def fop_tick_callback_v1(exchange: Exchange, tick: TickFOPv1):
    # print(f'fop_tick_callback_v1: {exchange} {tick}')
    print(tick.to_dict(raw=True))


def fop_bidask_callback_v1(exchange: Exchange, bidask: BidAskFOPv1):
    # print(f'fop_bidask_callback_v1: {exchange} {bidask}')
    print(bidask.to_dict(raw=True))


api.set_order_callback(order_callback)
api.quote.set_event_callback(event_callback)
api.quote.set_quote_callback(quote_callback)
api.quote.set_on_tick_stk_v1_callback(stk_tick_callback_v1)
api.quote.set_on_bidask_stk_v1_callback(stk_bidask_callback_v1)
api.quote.set_on_tick_fop_v1_callback(fop_tick_callback_v1)
api.quote.set_on_bidask_fop_v1_callback(fop_bidask_callback_v1)
</code></pre>
<pre><code class="language-python">if timestamp.time() &lt; datetime.time(13, 25, 0):
    # 最後一盤 13:25:00 前下回補單。一率市價單回補
    self.order_cover = sdt.api.Order(
        price=0,
        quantity=current_number_to_cover,
        action=&quot;Buy&quot;,
        price_type=&quot;MKT&quot;,
        order_type=&quot;ROD&quot;,
        order_lot=&quot;Common&quot;,
        first_sell=&quot;false&quot;,
        account=sdt.api.stock_account,
    )
else:
    # 13:25 後回補，最後一盤，只能用：限價＋漲停價格 來確保一定會補回來
    self.order_cover = sdt.api.Order(
        price=self.today_limit_up,
        quantity=current_number_to_cover,
        action=&quot;Buy&quot;,
        price_type=&quot;LMT&quot;,
        order_type=&quot;ROD&quot;,
        order_lot=&quot;Common&quot;,
        first_sell=&quot;false&quot;,
        account=sdt.api.stock_account,
    )

# 下限價單 或是 下市價單
if sdt.config[w.order_setting][w.order_limited] == w.Yes:
    self.order_put = sdt.api.Order(
        price=self.today_put_order_price,
        quantity=abs(units),
        action=&quot;Sell&quot;,
        price_type=&quot;LMT&quot;,
        order_type=&quot;ROD&quot;,
        order_lot=&quot;Common&quot;,
        first_sell=&quot;true&quot;,
        account=sdt.api.stock_account,
    )
else:
    self.order_put = sdt.api.Order(
        price=0,
        quantity=abs(units),
        action=&quot;Sell&quot;,
        price_type=&quot;MKT&quot;,
        order_type=&quot;ROD&quot;,
        order_lot=&quot;Common&quot;,
        first_sell=&quot;true&quot;,
        account=sdt.api.stock_account,
    )

self.trade_put = sdt.place_order(self.__contract__, self.order_put)

</code></pre>
<h2 id="apiactivate_ca-啟動電子憑證"><a class="header" href="#apiactivate_ca-啟動電子憑證">api.activate_ca 啟動電子憑證</a></h2>
<p>官方說明文件：
https://sinotrade.github.io/tutor/order/CA/
在下單之前，需要先下載永豐證券帳戶的下單電子憑證，下載方式請參考官方說明
https://www.sinotrade.com.tw/CSCenter/CSCenter_13_1?tab=2
下載完成後，可以透過api.activate_ca來啟用下單電子憑證，範例如下：</p>
<pre><code class="language-python">from dotenv import load_dotenv
import os
import shioaji as sj

load_dotenv('D:\\python\\shioaji\\.env') #讀取.env中的環境變數
api = sj.Shioaji()
api.login(
    person_id=os.getenv('YOUR_PERSON_ID'), 
    passwd=os.getenv('YOUR_PASSWORD')
)

result = api.activate_ca(
    ca_path=os.getenv('YOUR_CA_PATH'), # 下單電子憑證路徑及檔案名稱
    ca_passwd=os.getenv('YOUR_CA_PASS'), # 下單電子憑證密碼
    person_id=os.getenv('YOUR_PERSON_ID'), # 身份證字號
)
print(result)

api.logout()
</code></pre>
<h2 id="下單電子憑證及stock股票order建立"><a class="header" href="#下單電子憑證及stock股票order建立">下單電子憑證及Stock股票Order建立</a></h2>
<p>出處 ： https://ithelp.ithome.com.tw/articles/10272506?sc=iThelpR</p>
<p>啟用下單電子憑證前要先執行api.login進行登入。在這裡一樣把電子憑證相關資訊先儲存在env檔案中，再透過os.getenv()取得資訊並傳入activate_ca中，若電子憑證啟用成功，則回傳的result就會是True。</p>
<blockquote>
<p>若你要用虛擬帳戶登入並練習或測試下單功能，不必啟動電子憑證，可跳過這個步驟。</p>
</blockquote>
<h2 id="order物件建立說明"><a class="header" href="#order物件建立說明">Order物件建立說明</a></h2>
<p>官方說明文件：https://sinotrade.github.io/tutor/order/Stock/#making-order-object
在發送委託單前，要先產生一個Order物件。
Order物件建立的參數說明如下：</p>
<table><thead><tr><th style="text-align: center">參數</th><th style="text-align: center">參數說明</th><th style="text-align: center">參數範例</th></tr></thead><tbody>
<tr><td style="text-align: center">price</td><td style="text-align: center">委託價格</td><td style="text-align: center">18.5</td></tr>
<tr><td style="text-align: center">quantity</td><td style="text-align: center">委託數量</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">action</td><td style="text-align: center">委託單動作</td><td style="text-align: center">{Buy, Sell}</td></tr>
<tr><td style="text-align: center">price_type</td><td style="text-align: center">價格類型</td><td style="text-align: center">{LMT, MKT, MKP} (限價、市價、範圍市價)</td></tr>
<tr><td style="text-align: center">order_type</td><td style="text-align: center">委託單類型</td><td style="text-align: center">{ROD, IOC, FOK} (當日有效、立即成交否則取消、全部成交否則取消)</td></tr>
<tr><td style="text-align: center">order_cond</td><td style="text-align: center">委託單種類</td><td style="text-align: center">{Cash, MarginTrading, ShortSelling} (現股、融資、融券)</td></tr>
<tr><td style="text-align: center">order_lot</td><td style="text-align: center">委託單交易單位</td><td style="text-align: center">{Common, Fixing, Odd, IntradayOdd} (整股、盤後定價、盤後零股、盤中零股)</td></tr>
<tr><td style="text-align: center">first_sell</td><td style="text-align: center">是否為現沖先賣</td><td style="text-align: center">{true, false}</td></tr>
<tr><td style="text-align: center">octype</td><td style="text-align: center">倉別</td><td style="text-align: center">{Auto, NewPosition, Cover, DayTrade} (自動、新倉、平倉、當沖)</td></tr>
<tr><td style="text-align: center">OptionRight</td><td style="text-align: center">選擇權類別</td><td style="text-align: center">{Call, Put}</td></tr>
<tr><td style="text-align: center">account</td><td style="text-align: center">交易帳戶</td><td style="text-align: center">可由API取得account物件</td></tr>
</tbody></table>
<blockquote>
<p>order_cond、order_lot及first_sell，為股票Order物件特有屬性
octype，為期貨或選擇權Order物件特有屬性
OptionRight為選擇權Order物件特有屬性</p>
</blockquote>
<h3 id="現股買進order範例"><a class="header" href="#現股買進order範例">現股買進，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Buy, #買進
    price_type=sj.constant.StockPriceType.LMT, 
    order_type=sj.constant.TFTOrderType.ROD, 
    order_lot=sj.constant.TFTStockOrderLot.Common, 
    account=api.stock_account
)
</code></pre>
<h3 id="現股賣出order範例"><a class="header" href="#現股賣出order範例">現股賣出，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Sell, #賣出
    price_type=sj.constant.StockPriceType.LMT, 
    order_type=sj.constant.TFTOrderType.ROD, 
    order_lot=sj.constant.TFTStockOrderLot.Common, 
    account=api.stock_account
)
</code></pre>
<h3 id="現沖先賣order範例"><a class="header" href="#現沖先賣order範例">現沖先賣，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Sell,
    price_type=sj.constant.StockPriceType.LMT,
    order_type=sj.constant.TFTOrderType.ROD,
    order_lot=sj.constant.TFTStockOrderLot.Common,
    first_sell=sj.constant.StockFirstSell.Yes, #現沖先賣，設定為StockFirstSell.Yes or True
    account=api.stock_account
)
</code></pre>
<h3 id="盤中零股order範例"><a class="header" href="#盤中零股order範例">盤中零股，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Buy, #買進
    price_type=sj.constant.StockPriceType.LMT, 
    order_type=sj.constant.TFTOrderType.ROD, 
    order_lot=sj.constant.TFTStockOrderLot.IntradayOdd, #指定盤中零股
    account=api.stock_account
)
</code></pre>
<h3 id="盤中零股order範例-1"><a class="header" href="#盤中零股order範例-1">盤中零股，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Buy, #買進
    price_type=sj.constant.StockPriceType.LMT, 
    order_type=sj.constant.TFTOrderType.ROD, 
    order_lot=sj.constant.TFTStockOrderLot.IntradayOdd, #指定盤中零股
    account=api.stock_account
)
</code></pre>
<h3 id="盤後定價order範例"><a class="header" href="#盤後定價order範例">盤後定價，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Buy, #買進
    price_type=sj.constant.StockPriceType.LMT, 
    order_type=sj.constant.TFTOrderType.ROD, 
    order_lot=sj.constant.TFTStockOrderLot.Fixing, #指定盤後定價
    account=api.stock_account
)
</code></pre>
<h3 id="盤後零股order範例"><a class="header" href="#盤後零股order範例">盤後零股，Order範例</a></h3>
<pre><code class="language-python">order = api.Order(
    price=12, 
    quantity=1, 
    action=sj.constant.Action.Buy, #買進
    price_type=sj.constant.StockPriceType.LMT, 
    order_type=sj.constant.TFTOrderType.ROD, 
    order_lot=sj.constant.TFTStockOrderLot.Odd, #指定盤後零股
    account=api.stock_account
)
</code></pre>
<p>以上為現股Order的建立及下單相關操作，若是要使用融資或融券，只要在建立Order時指定order_cond為StockOrderCond.MarginTrading(融資)或是StockOrderCond.ShortSelling(融券)即可；若在建立Order時沒有指定order_cond，預設都是以StockOrderCond.Cash建立。</p>
<hr />
<pre><code class="language-python">from Jlab.watcher import Watcher
import shioaji as sj
import json
import os
import sys


def login(simulation=False):
    api = sj.Shioaji(simulation=simulation)
    token_file = os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_tokens.json&quot;
    with open(token_file, &quot;r&quot;) as f:
        users = json.load(f)
        print(&quot;All users: &quot; + &quot;, &quot;.join(users.keys()))

        user = input(&quot;Select a user from the list above: &quot;)
        if user not in users:
            print(&quot;User not found.&quot;)
            sys.exit()

        api.login(
            users[user][&quot;api_key&quot;], users[user][&quot;secret_key&quot;], fetch_contract=False
        )
        api.fetch_contracts(contract_download=True)
        print(f&quot;Logged in as {user}&quot;)
        return api


def get_near_month_txf_contract(api):
    contract = min(
        [x for x in api.Contracts.Futures.TXF if x.code[-2:] not in [&quot;R1&quot;, &quot;R2&quot;]],
        key=lambda x: x.delivery_date,
    )
    return contract


def simulation(api):
    contract = api.Contracts.Stocks.TSE[&quot;2890&quot;]
    # order - edit it
    order = api.Order(
        action=sj.constant.Action.Buy,
        price=20,
        quantity=1,
        price_type=sj.constant.StockPriceType.LMT,
        order_type=sj.constant.OrderType.ROD,
        account=api.stock_account,
    )

    # place order
    trade = api.place_order(contract, order, timeout=0)
    print(trade)


if __name__ == &quot;__main__&quot;:
    Watcher()
    # 設置參數以決定是使用模擬還是實際交易
    SIMULATION = False
    api = login(simulation=SIMULATION)
    if SIMULATION:
        simulation(api)
    else:
        contract = get_near_month_txf_contract(api)
        print(contract)

        # print(api.account_balance())
        # print(api.list_positions(api.stock_account))
        contracts = [api.Contracts.Stocks[&quot;2330&quot;], api.Contracts.Stocks[&quot;2317&quot;]]
        snapshots = api.snapshots(contracts)
        print(snapshots)
        # Stock default account  證券目前的預設帳戶
    print(api.stock_account)

    # Futures default account 期貨目前的預設帳戶
    print(api.futopt_account)

    api.logout()
</code></pre>
<hr />
<pre><code class="language-python">accounts = api.list_accounts()
</code></pre>
<p>若你登入虛擬環境後，執行print(accounts)，會顯示以下內容</p>
<pre><code>[FutureAccount(person_id='QBCCAIGJBJ', broker_id='F002000', account_id='9100020', signed=True, username='PAPIUSER01'), StockAccount(person_id='QBCCAIGJBJ', broker_id='9A95', account_id='0504350', signed=True, username='PAPIUSER01')]
</code></pre>
<p>可以看到虛擬環境帳號底下，分別有FutureAccount期貨帳戶及StockAccount股票帳戶，相關變數說明如下：</p>
<table><thead><tr><th style="text-align: left">變數名稱</th><th style="text-align: left">說明</th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left">person_id</td><td style="text-align: left">身份證號碼</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">broker_id</td><td style="text-align: left">券商分點號碼</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">account_id</td><td style="text-align: left">帳戶號碼</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><strong>signed</strong></td><td style="text-align: left">是否已簽署API下單</td><td style="text-align: left">若帳號資訊無此變數，表示此帳戶尚未簽署API下單</td></tr>
<tr><td style="text-align: left">username</td><td style="text-align: left">使用者名稱</td><td style="text-align: left">若使用個人帳號登入，此欄位顯示你的姓名</td></tr>
</tbody></table>
<p>若你的帳戶尚未簽署API下單，可開啟永豐金iLeader，找到「數位e櫃臺」並開啟</p>
<p>https://github.com/eyelash500/2021_ironman_Shioaji</p>
<pre><code class="language-py">import threading
import time
from datetime import datetime

import shioaji as sj


class trader:
    &quot;&quot;&quot;The Shioaji Object&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self.simulation = True  # 是否為測試環境
        self.id = &quot;PAPIUSER07&quot;
        self.pwd = &quot;2222&quot;
        self.api = sj.Shioaji()
        self.diff = 0  # 大臺的點數差

    def login(self, id=None, pwd=None, simulation=True):
        &quot;&quot;&quot;Login to Shioaji.
        Args:
            id(str): user ID
            pwd(str): the login password
        Returns:
            bool: True is login successfully, False is not.
        &quot;&quot;&quot;

        print(f&quot;=start login-{datetime.now().strftime('%Y%m%d')}&quot;)
        if id and pwd:
            self.id = id
            self.pwd = pwd

        try:
            # 登入 shioaji
            self.api = sj.Shioaji(simulation=simulation)
            self.api.login(person_id=self.id, passwd=self.pwd)
        except Exception as exc:
            print(f&quot;id={self.id}, pwd={self.pwd}...{exc}&quot;)
            return False

        return True

    def _get_subscribe(self) -&gt; bool:
        &quot;&quot;&quot;Get the subscibe format.&quot;&quot;&quot;

        print(self.api.quote.subscribe)

        return True

    def subscribe(self, contract):
        &quot;&quot;&quot;subscribe the contract quote.&quot;&quot;&quot;

        print(&quot;=Subscribe=&quot;)
        self.api.quote.subscribe(contract, quote_type=sj.constant.QuoteType.Tick)

    def unsubscribe(self, contract):
        &quot;&quot;&quot;unsubscribe the contract.&quot;&quot;&quot;

        print(&quot;unsubscribe&quot;)
        self.api.quote.unsubscribe(contract, quote_type=sj.constant.QuoteType.Tick)

    def quote_callback(self, topic: str, quote: dict):
        &quot;&quot;&quot;Get the quote info and change the oder price.
        The quote's format is v0: quote is a dict and the value is a list.
        &quot;&quot;&quot;

        print(
            f&quot;{topic}-Price:[{quote['Close']}]Diff:[{quote['DiffPrice']}]volumn:[{quote['Volume']}]&quot;
        )

        if topic.find(&quot;TFE/TXF&quot;) &gt; 0:
            self.diff = quote[&quot;DiffPrice&quot;][0]
        elif topic.find(&quot;OPT/TX&quot;) &gt; 0:
            reduced_point = 1

            # 設定要減少的點數
            if self.diff &lt; quote[&quot;Close&quot;][0]:
                reduced_point = self.diff  # 比市價還要低的數字
            else:
                # 當變動很多時，要剪去的價格會比較大，但比現價還要小
                reduced_point = quote[&quot;Close&quot;][0] - reduced_point

            self.change_price(quote[&quot;Close&quot;], True, reduced_point)  # 價格比現價還要低，

    def change_price(self, price, diff, points):
        &quot;&quot;&quot;Simulate to change the price of the order.&quot;&quot;&quot;

        self.mxf_price = price[0] - points if diff else price[0] + points
        print(f&quot;選擇權：current price:{price[0]}-new price:{self.mxf_price}&quot;)


def sleeper():
    &quot;&quot;&quot;For sleeping... Let us get the quote and change the price.&quot;&quot;&quot;

    print(&quot;-start sleep...&quot;)
    time.sleep(60)
    print(&quot;-Wake up!!!!&quot;)


timer = threading.Thread(target=sleeper)  # 建立執行緒

t = trader()
t.login()

t.subscribe(t.api.Contracts.Futures.TXF[&quot;TXF202110&quot;])  # 訂閱臺指期-2021/10
t.subscribe(t.api.Contracts.Options.TX2.TX2202110016300C)  # 訂閱臺指選擇權10W2月 16300C

t.api.quote.set_quote_callback(t.quote_callback)  # 設定處理回報的功能

timer.start()  # 執行thread
timer.join()  # 等待結束thread

t.unsubscribe(t.api.Contracts.Futures.TXF[&quot;TXF202110&quot;])  # 取消訂閱臺指期-2021/10
t.unsubscribe(t.api.Contracts.Options.TX2.TX2202110016300C)  # 取消訂閱臺指選擇權10W2月 16300C
</code></pre>
<ul>
<li><a href="https://gist.github.com/ypochien/ecc4abb7e18d21fc988c75a09e4df6e4#file-positionaid-py"><strong>PositionAid.py</strong></a></li>
<li>https://gist.github.com/ypochien</li>
</ul>
<pre><code class="language-py"># 先透過 createPositionFromPnl 建立當下部位狀態，後面透過 Shioaji 成交回報 即時更新股票持倉部位

from loguru import logger
from dataclasses import dataclass
from typing import Optional, Dict, List
import math
import shioaji as sj
from shioaji.constant import OrderState, Action, StockOrderCond


@dataclass
class StockPosition:
    symbol: str
    action: Action
    quantity: int
    cost: int
    ordercond: StockOrderCond


class PositionAid:
    def __init__(self, api: sj.Shioaji):
        self.api = api
        self.api.set_order_callback(self.onOrderStatusChange)
        self.position: Dict[str, StockPosition] = {}

    def onOrderStatusChange(self, state: OrderState, data: Dict):
        if state == OrderState.TFTOrder:
            pass
        elif state == OrderState.TFTDeal:
            self.updatePosition(data)

    def createPositionFromPnl(self):
        &quot;&quot;&quot;
        從 api list_position 損益建立 Position 資訊
        &quot;&quot;&quot;
        all_pnl = self.api.list_positions()
        for pnl in all_pnl:
            position = StockPosition(
                symbol=pnl.code,
                action=pnl.direction,
                quantity=pnl.quantity,
                cost=math.floor(pnl.price * pnl.quantity * 1000),
                ordercond=pnl.cond,
            )
            self.position[position.symbol] = position

    def getAllPosition(self) -&gt; List[StockPosition]:
        return list(self.position.values())

    def updatePosition(self, deal: Dict):
        code = deal[&quot;code&quot;]
        action = deal[&quot;action&quot;]
        order_cond = deal[&quot;order_cond&quot;]
        quantity = deal[&quot;quantity&quot;]
        cost = math.floor(deal[&quot;price&quot;] * deal[&quot;quantity&quot;] * 1000)

        position = self.getPosition(code)
        if position == None:
            position = StockPosition(
                symbol=code,
                action=action,
                quantity=quantity,
                cost=cost,
                ordercond=order_cond,
            )
        else:
            if position.action == action:
                position.quantity += quantity
                position.cost += cost
            else:
                position.quantity -= quantity
                position.cost -= cost
        self.position[code] = position
        logger.info(
            f&quot;{code} {self.api.Contracts.Stocks[code].name} {action} {deal['price']} 元 {quantity}張  -&gt; {position}&quot;
        )

    def getPosition(self, code: str) -&gt; Optional[StockPosition]:
        &quot;&quot;&quot;code: 股票代碼
        透過 股票代碼 取得 StockPosition 資訊
        沒有此檔股票 則回傳 = None
        &quot;&quot;&quot;
        return self.position.get(code, None)


if __name__ == &quot;__main__&quot;:
    # 建立 Shioaji 並登入
    api = sj.Shioaji() 
    api.login(&quot;SJ_USER&quot;,&quot;SJ_PASSWORD&quot;)

    # 建立 PositionAid
    aid = PositionAid(api) # 自動接手 SJ 主動回報 並處理 成交資訊
    aid.createPositionFromPnl() # 從 api list_position 損益建立 Position 資訊
    
    aid.getPosition(&quot;2330&quot;) # 取得 2330 持倉資訊 (如果沒有 2330 則得到 None)

</code></pre>
<p><a href="https://gist.github.com/ypochien/272f062d249e057322afbd6db0b51dce#file-cancelallorder-py"><strong>CancelAllOrder.py</strong></a></p>
<pre><code class="language-py"># 刪除全部的委託單
api.update_status()
for idx,t in enumerate(api.list_trades()):
    if t.status.status in [shioaji.constant.Status.PreSubmitted,shioaji.constant.Status.Submitted,shioaji.constant.Status.PartFilled] :
        api.cancel_order(t,timeout=0)
</code></pre>
<p><a href="https://gist.github.com/ypochien/d0236f4b9b89bf74a392118066d40d4c"><strong>clear_all.py</strong></a></p>
<pre><code class="language-py"># 13:25之後用漲跌停價格反向出場
def clear_all():
    &quot;&quot;&quot;13:25之後用漲跌停價格反向出場&quot;&quot;&quot;
    #只處理今天新增的現股 (現股當沖、不含興櫃)
    pnls = [one for one in api.list_positions() if abs(one.quantity) - one.yd_quantity!=0]
    for one_pnl in pnls:
        contract = api.Contracts.Stocks[one_pnl.code]
        if contract == None:
            print(f&quot;無此商品 {one_pnl.code}&quot;)
            continue
        action = &quot;Buy&quot;
        price = contract.limit_up
        if one_pnl.direction=='Buy':
            action = &quot;Sell&quot;
            price = contract.limit_down
        quantity = abs(one_pnl.quantity) - one_pnl.yd_quantity
        if quantity &gt; 0 and contract.exchange!=&quot;OES&quot;:
            order = api.Order(price=price, quantity=quantity, action=action, price_type=&quot;LMT&quot;, order_type=&quot;ROD&quot;, order_lot=&quot;Common&quot;,first_sell=&quot;false&quot;)
            for _ in range(0,quantity // 499):
                order.quantity = 499
                api.place_order(api.Contracts.Stocks[one_pnl.code],order)
                print(f&quot;{one_pnl.code} {[pnl.pnl for pnl in pnls if pnl.code==one_pnl.code]} {order.action.value} {order.quantity} 張 {order.price} 元&quot;)
            left = quantity % 499
            if left &gt; 0:
                order.quantity = left
                api.place_order(api.Contracts.Stocks[one_pnl.code],order)
                print(f&quot;{one_pnl.code} {[pnl.pnl for pnl in pnls if pnl.code==one_pnl.code]} {order.action.value} {order.quantity} 張 {order.price} 元&quot;)
</code></pre>
<p><a href="https://ithelp.ithome.com.tw/users/20140938/ironman/4335">永豐金API之30天不中斷Q&amp;A 系列</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="創立每列"><a class="header" href="#創立每列">創立每列</a></h2>
<pre><code class="language-python">import pandas as pd

# 創建空的 DataFrame
df = pd.DataFrame(columns=['Technology', 'Consumer', 'Healthcare', 'Energy'])

# 股票字典
stocks = {
    'GOOG': ['Technology', 'Healthcare'],
    'AAPL': ['Consumer']
}

# 遍歷股票字典並將 DataFrame 中相應的單元格設置為 True
for stock, industries in stocks.items():
    for industry in industries:
        df.loc[stock, industry] = True

# 將缺失值（即 False）替換為 False
df.fillna(False, inplace=True)

print(df)
</code></pre>
<h2 id="抓取美股分k歷史數據"><a class="header" href="#抓取美股分k歷史數據">抓取美股分K歷史數據</a></h2>
<pre><code class="language-python">import yfinance as yf
import pandas as pd
import datetime as dt

# 設置股票代碼和時間範圍
ticker = 'AAPL'
end_date = dt.datetime.now()
start_date = end_date - dt.timedelta(days=30)

# 將時間範圍拆分成多個時間段，每個時間段為 7 天
date_ranges = pd.date_range(start=start_date, end=end_date, freq='7d')

# 獲取歷史數據
dataframes = []
for i in range(len(date_ranges) - 1):
    start = date_ranges[i].strftime('%Y-%m-%d')
    end = date_ranges[i+1].strftime('%Y-%m-%d')
    df = yf.download(ticker, start=start, end=end, interval='1m')
    dataframes.append(df)

# 合併為一個 DataFrame 對象
data = pd.concat(dataframes)

# 打印 DataFrame 對象
print(data)
</code></pre>
<h2 id="keyvalue-sqlite"><a class="header" href="#keyvalue-sqlite">keyvalue-sqlite</a></h2>
<pre><code class="language-python"># pip install keyvalue-sqlite
from keyvalue_sqlite import KeyValueSqlite

DB_PATH = './db.sqlite'

db = KeyValueSqlite(DB_PATH, 'table-name')

# Now use standard dictionary operators
db.set('0', {&quot;1101&quot;:23, &quot;2330&quot;: 100})
actual_value = db.get('0')
print(actual_value)
db.set('0', '211')
actual_value = db.get('0')
print(actual_value)
db.remove('0')
actual_value = db.get('0')
print(actual_value)
</code></pre>
<h2 id="sched-定時"><a class="header" href="#sched-定時">sched 定時</a></h2>
<pre><code class="language-python">import sched
import time
import datetime

'''
導入 sched 模塊和 time 模塊。
定義一個 main() 函數，用於執行程序的主要邏輯。
定義一個 run_main() 函數，用於在指定時間執行 main() 函數。
獲取當前時間，並計算距離下一個執行時間的時間差 delta。
使用 sched 模塊的 enter() 方法，將 run_main() 函數添加到調度隊列中，並設置下一次執行的時間為當前時間加上 delta。
使用 sched 模塊的 run() 方法，啟動調度器。
'''

def main():
    # 在這裡編寫程序的主要邏輯
    print(&quot;Hello, world!&quot;)

def run_main():
    # 獲取當前時間
    now = datetime.datetime.now()

    # 計算距離下一個執行時間的時間差
    next_time = now.replace(hour=8, minute=45, second=0, microsecond=0)
    if next_time &lt; now:
        next_time += datetime.timedelta(days=1)
    delta = next_time - now

    # 計算下一個執行時間，並輸出日誌
    next_time_str = next_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
    print(f&quot;Next run time: {next_time_str}&quot;)

    # 在指定時間執行程序的主要邏輯
    scheduler = sched.scheduler(time.time, time.sleep)
    scheduler.enter(delta.total_seconds(), 1, main, ())
    scheduler.run()

if __name__ == &quot;__main__&quot;:
    run_main()
</code></pre>
<h2 id="pdf-分割"><a class="header" href="#pdf-分割">pdf 分割</a></h2>
<pre><code class="language-python">from PyPDF2 import PdfReader, PdfWriter


# PDF文件分割
def split_pdf(read_file, out_detail):
    try:
        fp_read_file = open(read_file, &quot;rb&quot;)
        pdf_input = PdfReader(fp_read_file)  # 將要分割的PDF內容格式話
        page_count = pdf_input.pages  # 獲取PDF頁數
        print(page_count)  # 打印頁數

        with open(out_detail, &quot;r&quot;, True, &quot;utf-8&quot;) as fp:
            # print(fp)
            txt = fp.readlines()
            # print(txt)
            for detail in txt:  # 打開分割標準文件
                # print(type(detail))
                pages = detail.strip()  # 空格分組
                #  write_file, write_ext = os.path.splitext(write_file)  # 用於返回文件名和擴展名元組
                pdf_file = f&quot;{pages}.pdf&quot;
                # liststr=list(map(int, pages.split('-')))
                # print(type(liststr))
                start_page, end_page = list(map(int, pages.split(&quot;-&quot;)))  # 將字符串數組轉換成整形數組
                start_page -= 1
                try:
                    print(f&quot;開始分割{start_page}頁-{end_page}頁，保存為{pdf_file}......&quot;)
                    pdf_output = PdfWriter()  # 實例一個 PDF文件編寫器
                    for i in range(start_page, end_page):
                        pdf_output.add_page(pdf_input.pages[i])
                    with open(pdf_file, &quot;wb&quot;) as sub_fp:
                        pdf_output.write(sub_fp)
                    print(f&quot;完成分割{start_page}頁-{end_page}頁，保存為{pdf_file}!&quot;)
                except IndexError:
                    print(f&quot;分割頁數超過了PDF的頁數&quot;)
        # fp.close()
    except Exception as e:
        print(e)
    finally:
        fp_read_file.close()


split_pdf(&quot;./The Art of Writing Efficient Programs An advanced programmers guide to efficient hardware utilization and compiler... (Fedor G. Pikus) (Z-Library).pdf&quot;, &quot;config.txt&quot;)
</code></pre>
<h2 id="使用-urllibparse-模組的-unquote-函數將編碼過的-url-字符串解碼"><a class="header" href="#使用-urllibparse-模組的-unquote-函數將編碼過的-url-字符串解碼">使用 <code>urllib.parse</code> 模組的 <code>unquote()</code> 函數將編碼過的 URL 字符串解碼</a></h2>
<pre><code class="language-python">import urllib.parse

url = &quot;https://www.finlab.tw/wp-content/uploads/2022/07/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8B%E5%8D%8812.42.21-1536x431.png&quot;
decoded_url = urllib.parse.unquote(url)

print(decoded_url)
</code></pre>
<h2 id="dataframe-寫到csv-再從csv-讀回dataframe"><a class="header" href="#dataframe-寫到csv-再從csv-讀回dataframe">dataFrame 寫到csv, 再從csv 讀回dataframe</a></h2>
<pre><code class="language-python">import pandas as pd

# Create a sample DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie'], 
        'Age': [25, 30, 35], 
        'City': ['New York', 'Paris', 'London']}
df = pd.DataFrame(data)

# Write the DataFrame to a CSV file
df.to_csv('data.csv', index=False)

# Read the CSV file back into a DataFrame
new_df = pd.read_csv('data.csv')

# Print the original and new DataFrames
print('Original DataFrame:\n', df)
print('\nNew DataFrame:\n', new_df)
</code></pre>
<h2 id="顯示-datafrmae-index-跟--欄位型態"><a class="header" href="#顯示-datafrmae-index-跟--欄位型態">顯示 datafrmae index 跟  欄位型態</a></h2>
<pre><code class="language-python">import pandas as pd
import numpy as np

df = pd.DataFrame({
    'col1': [1, 2, 3],
    'col2': ['a', 'b', 'c']
}, index=pd.date_range('2022-01-01', periods=3))

print(df.index)
print(df.dtypes)
</code></pre>
<h2 id="已經在-sqlite-的-primary_keys-不-insert-data"><a class="header" href="#已經在-sqlite-的-primary_keys-不-insert-data">已經在 sqlite 的 primary_keys 不 insert data</a></h2>
<pre><code class="language-python">import pandas as pd
import sqlite3


class FinmindAPI:
    db_path = &quot;example.db&quot;

    @staticmethod
    def insert_db(data):
        conn = sqlite3.connect(FinmindAPI.db_path)
        create_table = &quot;&quot;&quot;
    CREATE TABLE IF NOT EXISTS TaiwanStockMonthRevenue (
        stock_id TEXT,
        date TEXT,
        revenue INTEGER
    );&quot;&quot;&quot;

        conn.execute(create_table)
        # Check if data already exists in the database
        primary_keys = [&quot;stock_id&quot;, &quot;date&quot;]
        existing_data = pd.read_sql_query(
            f&quot;SELECT {', '.join(primary_keys)} FROM TaiwanStockMonthRevenue&quot;, con=conn
        )
        if (
            existing_data.set_index(primary_keys)
            .index.isin(data.set_index(primary_keys).index)
            .any()
        ):
            print(&quot;Data already exists in database, skipping insertion&quot;)
            conn.close()
            return

        # Insert data into database
        data.to_sql(
            name=&quot;TaiwanStockMonthRevenue&quot;, con=conn, if_exists=&quot;append&quot;, index=False
        )
        conn.close()
        print(f&quot;Data inserted to database successfully.&quot;)


if __name__ == &quot;__main__&quot;:
    # Create example data
    data1 = pd.DataFrame(
        {
            &quot;stock_id&quot;: [&quot;2330&quot;, &quot;2454&quot;, &quot;2382&quot;],
            &quot;date&quot;: [&quot;2020-01&quot;, &quot;2020-01&quot;, &quot;2020-01&quot;],
            &quot;revenue&quot;: [1000, 2000, 3000],
        }
    )
    data2 = pd.DataFrame(
        {
            &quot;stock_id&quot;: [&quot;2330&quot;, &quot;2454&quot;, &quot;2382&quot;],
            &quot;date&quot;: [&quot;2020-02&quot;, &quot;2020-02&quot;, &quot;2020-02&quot;],
            &quot;revenue&quot;: [4000, 5000, 6000],
        }
    )

    # Insert first set of data
    print(&quot;Inserting first set of data ...&quot;)
    FinmindAPI.insert_db(data1)
    # Insert same data again
    print(&quot;Inserting same data again ...&quot;)
    FinmindAPI.insert_db(data1)
    # Insert new set of data
    print(&quot;Inserting new set of data ...&quot;)
    FinmindAPI.insert_db(data2)
</code></pre>
<h2 id="產生num組加總為1的小數數值"><a class="header" href="#產生num組加總為1的小數數值">產生num組加總為1的小數數值</a></h2>
<pre><code class="language-python">import random

def generate_random_decimals(num):
    &quot;&quot;&quot;
    產生num組加總為1的小數數值

    Args:
        num: 需要產生的小數數值的組數

    Returns:
        一個包含num組小數數值的列表，每組小數數值都是一個長度為3的列表
    &quot;&quot;&quot;
    result = []
    # 初始化三個數值
    for i in range(num):
        data = [0.0] * 3
        # 隨機產生兩個小數數值
        data[0] = round(random.uniform(0, 1), 2)
        data[1] = round(random.uniform(0, 1 - data[0]), 2)
        # 計算第三個小數數值
        data[2] = round(1 - data[0] - data[1], 2)
        result.append(data)
    return result

if __name__ == '__main__':
    data = generate_random_decimals(2)
    print(data)
</code></pre>
<h2 id="讀檔正則取圖下載"><a class="header" href="#讀檔正則取圖下載">讀檔正則取圖下載</a></h2>
<pre><code class="language-python">import os
import re
import requests
import cv2
import numpy as np

# 設置要讀取的文件路徑
file_path = &quot;./learn_network.md&quot;

# 設置下載目標目錄
target_dir = &quot;images&quot;

# 設置轉換後的圖檔格式
target_ext = &quot;.jpg&quot;

# 創建目標目錄
if not os.path.exists(target_dir):
    os.makedirs(target_dir)

# 定義正則表達式來匹配圖像URL
with open(file_path, &quot;r&quot;) as f:
    text = f.read()
    pattern = r&quot;\!\[.*?\]\((.*?)\)&quot;
    image_urls = re.findall(pattern, text)

    for img in image_urls:
        print(img)
    input()

    for url in image_urls:
        try:
            print(url)
            response = requests.get(url, stream=True)
            if response.status_code == 200:
                # 取得圖像的文件名和擴展名
                filename = url.split(&quot;/&quot;)[-1]
                ext = os.path.splitext(filename)[1].lower()
                img_array = np.asarray(bytearray(response.content), dtype=np.uint8)
                img = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
                filename = os.path.splitext(filename)[0] + target_ext
                filepath = os.path.join(target_dir, filename)
                cv2.imwrite(filepath, img)
                print(filename + &quot; 下載成功&quot;)
            else:
                print(filename + &quot; 下載失敗&quot;)
        except Exception as e:
            print(f&quot;下載圖像失敗: {e}&quot;)
</code></pre>
<h2 id="函數插入log"><a class="header" href="#函數插入log">函數插入log</a></h2>
<pre><code class="language-python">import os
import sys

def insert_to_func(lines, func_lines, file_name):
    for i in func_lines:
        for j in range(i-1, len(lines)):
            if str(lines[j]).find(';') != -1:
                break

            if str(lines[j]).find('{') != -1:
                if str(lines[j]).find('}') != -1:
                    break

                if str(file_name).find('.java') != -1:
                    lines.insert(j+1, '\tSystem.out.println(&quot;YAO [&quot; + Thread.currentThread().getStackTrace()[2].getClassName() + &quot;|&quot; + Thread.currentThread().getStackTrace()[2].getMethodName() + &quot;|&quot; + Thread.currentThread().getStackTrace()[2].getFileName() + &quot;:&quot; + Thread.currentThread().getStackTrace()[2].getLineNumber()+&quot;]&quot;);\n')
                elif str(file_name).find('.cpp') != -1 or str(file_name).find('.c') != -1 or str(file_name).find('.cc') != -1:
                    lines.insert(j+1, '::printf (&quot;This is line %d of file %s (function %s)\\n&quot;, __LINE__, __FILE__, __func__);')
                elif str(file_name).find('.go'): 
                    lines.insert(j+1,'\tutils.Trace(&quot;&quot;)')

                break

    return lines

def main():
    if len(sys.argv) &lt; 2:
        print(&quot;please input python test.py filename&quot;)
        return

    file_name = sys.argv[1]
    print(file_name)
 
    if str(file_name).find('.java') != -1:
        os.system(&quot;ctags-exuberant -x &quot; + file_name + &quot; | ack -o -w 'method\s+.*' | ack -o '\d+\s+.*' | ack -o '^\d+\s+' | sort -k 1 -nr &gt; /tmp/test.txt&quot;)
    elif str(file_name).find('.cpp') != -1 or str(file_name).find('.c') != -1:
        os.system(&quot;ctags-exuberant -x &quot; + file_name + &quot; | ack -o -w 'function\s+.*' | ack -o '\d+\s+.*' | ack -o '^\d+\s+' | sort -k 1 -nr &gt; /tmp/test.txt&quot;)
    elif str(file_name).find('.go') != -1:
        os.system(&quot;ctags-exuberant -x &quot; + file_name + &quot; | ack -o -w 'func.*'  | ack -o '\d+\s+.*' | ack -o '^\d+\s+' | sort -k 1 -nr &gt; /tmp/test.txt&quot;)
    else:
        print('unknown file type')
        return

    with open('/tmp/test.txt', 'r+') as f:
        func_lines = [int(i) for i in f.read().splitlines()]

    with open(file_name, 'r+') as f:
        lines = f.read().splitlines()

    insert_list_finish = insert_to_func(lines, func_lines, file_name)

    with open(file_name, &quot;w+&quot;) as new_file:
        for l in insert_list_finish:
            new_file.write(l + '\n')

if __name__=='__main__':
    main()

</code></pre>
<h2 id="輸入日期取得上週五日期"><a class="header" href="#輸入日期取得上週五日期">輸入日期取得上週五日期</a></h2>
<pre><code class="language-python">from datetime import date, datetime, timedelta

#today = date.today()  # 取得今天日期
today = datetime(2023, 3, 10)
last_friday = today - timedelta(days=today.weekday() + 3)  # 回推到上週五
last_friday_str = last_friday.strftime('%Y/%m/%d')  # 轉換成指定格式的字串

print(last_friday_str)  # 印出上週五的日期
</code></pre>
<h2 id="模擬程式執行一段時間後出現問題需要重啟"><a class="header" href="#模擬程式執行一段時間後出現問題需要重啟">模擬程式執行一段時間後出現問題需要重啟</a></h2>
<pre><code class="language-python">import os
import sys
import time
import threading

def main():
    while True:
        # 模擬程式執行一段時間後出現問題需要重啟
        time.sleep(5)
        if should_restart():
            restart_program()

def should_restart():
    try:
        a = 1 / 0
        return False
    except Exception as err:
        print(err)
        return True

def restart_program():
    python = sys.executable
    print(&quot;Restarting program with PID {} and TID {}&quot;.format(os.getpid(), threading.get_ident()))
    os.execl(python, python, *sys.argv)

if __name__ == '__main__':
    print(&quot;Starting program with PID {} and TID {}&quot;.format(os.getpid(), threading.get_ident()))
    main()
</code></pre>
<h2 id="輸入日期取得上個月最後一天日期"><a class="header" href="#輸入日期取得上個月最後一天日期">輸入日期取得上個月最後一天日期</a></h2>
<pre><code class="language-python">import datetime

def get_last_day_of_month(date):
    first_day = datetime.datetime(date.year, date.month, 1)  # 當月份的第一天
    last_day = first_day.replace(month=first_day.month+1, day=1) - datetime.timedelta(days=1)  # 當月份的最後一天
    return last_day.strftime('%Y-%m-%d')  # 格式化輸出日期

# 呼叫函數並輸出結果
date = datetime.datetime(2023, 3, 12)  # 要計算的日期
print(get_last_day_of_month(date))
</code></pre>
<h2 id="找出-pct_change_12m-和-volume_12m-都為true的月份"><a class="header" href="#找出-pct_change_12m-和-volume_12m-都為true的月份">找出 Pct_Change_12M 和 Volume_12M 都為True的月份</a></h2>
<pre><code class="language-python">import pandas as pd
import yfinance as yf
from datetime import timedelta

# 下載資料
# df = yf.download(&quot;2324.TW&quot;, start=&quot;2000-01-01&quot;, end=&quot;2023-01-01&quot;)
df = yf.download(&quot;8299.TWO&quot;, start=&quot;2000-01-01&quot;, end=&quot;2023-01-01&quot;)

# 計算月K資料
monthly_df = df.resample(&quot;M&quot;).apply(
    {&quot;Open&quot;: &quot;first&quot;, &quot;High&quot;: &quot;max&quot;, &quot;Low&quot;: &quot;min&quot;, &quot;Close&quot;: &quot;last&quot;, &quot;Volume&quot;: &quot;sum&quot;}
)

# 將日期轉換為月初的日期
monthly_df.index = monthly_df.index.to_period(&quot;M&quot;).to_timestamp(&quot;M&quot;)

# 計算月漲幅
monthly_df[&quot;Pct_Change&quot;] = monthly_df[&quot;Close&quot;].pct_change() * 100

# 計算成交量12個月移動平均
monthly_df[&quot;Volume_MA12&quot;] = monthly_df[&quot;Volume&quot;].rolling(window=12).mean()

# 計算是否股價創下過去12個月新高
monthly_df[&quot;New_High_12M&quot;] = (
    monthly_df[&quot;High&quot;] == monthly_df[&quot;High&quot;].rolling(window=12).max()
)

# 判斷當月漲幅、成交量和股價是否都超過過去12個月移動平均和最高價格
monthly_df[&quot;Pct_Change_12M&quot;] = (
    monthly_df[&quot;Pct_Change&quot;] &gt; monthly_df[&quot;Pct_Change&quot;].rolling(window=12).mean()
)
monthly_df[&quot;Volume_12M&quot;] = monthly_df[&quot;Volume&quot;] &gt; monthly_df[&quot;Volume_MA12&quot;]
monthly_df[&quot;All_12M&quot;] = (
    monthly_df[&quot;Pct_Change_12M&quot;] &amp; monthly_df[&quot;Volume_12M&quot;] &amp; monthly_df[&quot;New_High_12M&quot;]
)

# 找出 Pct_Change_12M、Volume_12M、New_High_12M 和 within_3_months 都為 True 的月份
entries = monthly_df.loc[monthly_df[&quot;All_12M&quot;]]


# 將 index 日期加 3 個月，並命名為 'Next_3_Months'
entries[&quot;Next_3_Months&quot;] = entries.index + pd.DateOffset(months=3)

# 往下 shift 一列
entries[&quot;Next_3_Months&quot;] = entries[&quot;Next_3_Months&quot;].shift(1)

entries[&quot;Within_3_Months&quot;] = entries[&quot;Next_3_Months&quot;] &gt;= entries.index


print(entries)
</code></pre>
<h2 id="永豐期貨選擇權計算周選代號"><a class="header" href="#永豐期貨選擇權計算周選代號">永豐期貨/選擇權計算周選代號</a></h2>
<pre><code class="language-python">from multiprocessing import Process, Queue
from shioaji.contracts import Contract
from shioaji import Exchange
from time import sleep
from line_notify import LineNotify
from datetime import datetime, timedelta

import re
import redis
import sys
import platform
import signal
import shioaji as sj
import os
import json


def get_option_week(api):
    def get_previous_wednesday():
        today = datetime.today()
        wednesday = today - timedelta(days=today.weekday()) + timedelta(days=2)
        previous_wednesday = wednesday - timedelta(days=7)
        return previous_wednesday.date()

    def get_this_week_wednesday():
        today = datetime.today()
        wednesday = (today + timedelta(days=(2 - today.weekday()))).date()
        return wednesday

    def get_next_week_wednesday():
        today = datetime.today()
        wednesday = (today + timedelta(days=(2 - today.weekday() + 7))).date()
        return wednesday

    option_symbols = (str(api.Contracts.Options))[1:-1].split(&quot;, &quot;)
    near_week_option_symbol = [string for string in option_symbols if &quot;TX&quot; in string]
    print(near_week_option_symbol)

    symbols = sorted([x.symbol for x in api.Contracts.Options.TXO])
    near_option_symbol_date = symbols[0][3:9]

    for option in api.Contracts.Options:
        for contract in option:
            if &quot;TX&quot; in contract.category and near_option_symbol_date in contract.symbol:
                now = datetime.now()
                wednesday_time = get_this_week_wednesday()
                wednesday_time = datetime.combine(
                    wednesday_time, datetime.min.time()
                ) + timedelta(hours=15)

                # 根據當前時間判斷是否在星期三 15:00之前。如果在此時間之前，則列印上週三和本週三的日期；否則列印本週三和下週三的日期：
                if now &lt; wednesday_time:
                    if datetime.strptime(
                        contract.update_date, &quot;%Y/%m/%d&quot;
                    ).date() &gt;= get_previous_wednesday() and contract.delivery_date == get_this_week_wednesday().strftime(
                        &quot;%Y/%m/%d&quot;
                    ):
                        print(
                            contract.symbol,
                            contract.name,
                            contract.update_date,
                            contract.delivery_date,
                        )
                        return contract.symbol
                else:
                    if datetime.strptime(
                        contract.update_date, &quot;%Y/%m/%d&quot;
                    ).date() &gt;= get_this_week_wednesday() and contract.delivery_date == get_next_week_wednesday().strftime(
                        &quot;%Y/%m/%d&quot;
                    ):
                        print(
                            contract.symbol,
                            contract.name,
                            contract.update_date,
                            contract.delivery_date,
                        )
                        return contract.symbol


with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_token.txt&quot;, &quot;r&quot;) as f:
    api = sj.Shioaji()
    kw_login = json.loads(f.read())
    api.login(**kw_login, contracts_timeout=300000)

    print(get_option_week(api))

    S = get_option_week(api)[:3]

    for option in api.Contracts.Options[S]:
        print(option)

</code></pre>
<pre><code class="language-python">import datetime

def get_option_week():
    # 設定選擇權到期時間
    expiration_time = datetime.time(15, 0, 0)

    # 取得當前日期的年份和月份
    today = datetime.date.today()
    year = today.year
    month = today.month

    # 找到本月的第一個星期三
    first_wednesday = datetime.date(year, month, 1)
    while first_wednesday.weekday() != 2:
        first_wednesday = first_wednesday.replace(day=first_wednesday.day+1)

    # 計算今天是第幾週
    today_year, today_week, _ = today.isocalendar()
    first_wednesday_year, first_wednesday_week, _ = first_wednesday.isocalendar()
    week_num = today_week - first_wednesday_week + 1

    # 判斷是否過了選擇權到期時間
    if datetime.datetime.now().time() &gt;= expiration_time:
        week_num += 1

    return week_num
</code></pre>
<pre><code class="language-python">import cv2
import glob
import os

# 變更到指定尺寸，長寬邊不足者補黑色
def process_image(img, min_side=608):
    size = img.shape
    h, w = size[0], size[1]
    scale = max(w, h) / float(min_side)
    new_w, new_h = int(w / scale), int(h / scale)
    resize_img = cv2.resize(img, (new_w, new_h), cv2.INTER_AREA)  # 變更尺寸
    if new_w % 2 != 0 and new_h % 2 == 0:
        top, bottom, left, right = (
            (min_side - new_h) // 2,
            (min_side - new_h) // 2,
            (min_side - new_w) // 2 + 1,
            (min_side - new_w) // 2,
        )
    elif new_h % 2 != 0 and new_w % 2 == 0:
        top, bottom, left, right = (
            (min_side - new_h) // 2 + 1,
            (min_side - new_h) // 2,
            (min_side - new_w) // 2,
            (min_side - new_w) // 2,
        )
    elif new_h % 2 == 0 and new_w % 2 == 0:
        top, bottom, left, right = (
            (min_side - new_h) // 2,
            (min_side - new_h) // 2,
            (min_side - new_w) // 2,
            (min_side - new_w) // 2,
        )
    else:
        top, bottom, left, right = (
            (min_side - new_h) // 2 + 1,
            (min_side - new_h) // 2,
            (min_side - new_w) // 2 + 1,
            (min_side - new_w) // 2,
        )
    pad_img = cv2.copyMakeBorder(
        resize_img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0, 0, 0]
    )
    return pad_img


# 讀寫目錄
inputPath = &quot;video&quot;
outputPath = &quot;images&quot;

files = os.path.join(inputPath, &quot;*.mp4&quot;)
files_grabbed = []
files_grabbed.extend(sorted(glob.iglob(files)))

for videoId in range(len(files_grabbed)):
    print(files_grabbed[videoId])
    raw = cv2.VideoCapture(files_grabbed[videoId])
    fIndex = 1
    fCount = 0

    while 1:
        # 影片轉圖片
        ret, frame = raw.read()
        fCount += 1
        if ret == True:
            if (fCount % 5) == 0:
                img_pad = process_image(frame, min_side=608)
                cv2.imwrite(
                    &quot;%s/%02d-frame-608x608-%04d.jpg&quot; % (outputPath, videoId, fIndex),
                    img_pad,
                )
                fIndex += 1
        else:
            break
</code></pre>
<h2 id="目前主機時區跟-taipei-時區差多少-offset"><a class="header" href="#目前主機時區跟-taipei-時區差多少-offset">目前主機時區跟 Taipei 時區差多少 offset?</a></h2>
<p>使用 Python 標準庫的 <code>datetime</code> 模組的 <code>now</code> 方法，並使用 <code>pytz</code> 模組的 <code>timezone</code> 方法，得到目前的本地時間，然後再使用 <code>astimezone</code> 方法，轉換為 Taipei 時間，並通過計算得到 offset：</p>
<pre><code class="language-python">from datetime import datetime
import pytz

local_time = datetime.now()
local_time = pytz.timezone('UTC').localize(local_time)
taipei_time = local_time.astimezone(pytz.timezone('Asia/Taipei'))
offset = int((taipei_time - local_time).total_seconds() / 3600)
print(f&quot;Local time is {local_time}. Taipei time is {taipei_time}. Offset is {offset} hours.&quot;)
</code></pre>
<h2 id="裝飾器傳遞參數-args-和-kwargs"><a class="header" href="#裝飾器傳遞參數-args-和-kwargs">裝飾器傳遞參數 *args 和 **kwargs</a></h2>
<pre><code class="language-python">def funA(fn):
    # 定義一個嵌套函數
    def say(*args,**kwargs):
        print(args, kwargs)
        fn(*args,**kwargs)
    return say
@funA
def funB(arc):
    print(&quot;C語言中文網：&quot;,arc)

@funA
def other_funB(name,arc):
    print(name,arc)

funB(&quot;http://c.biancheng.net&quot;)
other_funB(&quot;Python教程：&quot;,&quot;http://c.biancheng.net/python&quot;)
</code></pre>
<h2 id="python-line_profiler--memory_profiler分析每一行程式碼的耗時及記憶體佔用情況"><a class="header" href="#python-line_profiler--memory_profiler分析每一行程式碼的耗時及記憶體佔用情況">【Python line_profiler &amp; memory_profiler】分析每一行程式碼的耗時及記憶體佔用情況</a></h2>
<p>https://codeantenna.com/a/XoAFyhqZ2B</p>
<pre><code class="language-sh">pip install line_profiler
</code></pre>
<pre><code class="language-python">from line_profiler import LineProfiler


def func_line_time(follow=[]):
    def decorate(func):
        @wraps(func)
        def profiled_func(*args, **kwargs):
            try:
                profiler = LineProfiler()
                profiler.add_function(func)  # 增加每列的行數
                for f in follow:
                    profiler.add_function(f)
                profiler.enable_by_count()  # enable_by_count進行執行以獲取消耗的時間
                return func(*args, **kwargs)
            finally:
                profiler.print_stats()  # 顯示結果

        return profiled_func

    return decorate


@func_line_time()
def process(self, params):
    import pandas as pd`在這裡插入程式碼片`
    pass
</code></pre>
<ul>
<li>Hit：程式碼運行次數；</li>
<li>%Time：程式碼佔了它所在函數的消耗的時間百分比，通常直接看這一列。</li>
<li>在這裡我們主要觀察%Time 所佔用的百分比，對百分比較高的行數進行最佳化為第一選擇。</li>
</ul>
<h2 id="藉助記憶體分析庫-memory_profiler-查看每一行消耗了多少記憶體"><a class="header" href="#藉助記憶體分析庫-memory_profiler-查看每一行消耗了多少記憶體">藉助記憶體分析庫 memory_profiler 查看每一行消耗了多少記憶體？</a></h2>
<pre><code class="language-sh">pip install memory_profiler
</code></pre>
<pre><code class="language-python"># 2. 藉助記憶體分析庫 memory_profiler 查看每一行消耗了多少記憶體？
from memory_profiler import profile


# precision 精確到小數點後幾位
# stream 此模組分析結果保存到‘memory_profiler.log’ 記錄檔。如果沒有此參數，分析結果會在控制檯輸出
# @profile(precision=4, stream=open('memory_profiler.log', 'w+'))
@profile(precision=4)
def process():
    print('memory analysis------------')
    pass

process()
pri
</code></pre>
<p>Mem 是總消耗的記憶體</p>
<ul>
<li>Increment 是第幾行程式碼運行完後增加的記憶體</li>
<li>通過memory_profiler 我們可以分析到每一行運行完後佔用的記憶體。這部分記憶體在處理程序沒結束的時候是不好被回收掉的，因此在這裡如果有哪一行邏輯運行一直在增加記憶體消耗，則這行可能是罪魁禍首。</li>
</ul>
<hr />
<h2 id="simple--memory_profiler--example"><a class="header" href="#simple--memory_profiler--example">simple  memory_profiler  example</a></h2>
<pre><code class="language-python">from memory_profiler import profile

@profile
def my_func():
    a = [1] * (10 ** 6)
    b = [2] * (2 * 10 ** 7)
    del b
    return a

if __name__ == '__main__':
    my_func()

</code></pre>
<h2 id="python-引用放掉記憶體"><a class="header" href="#python-引用放掉記憶體">python 引用放掉記憶體</a></h2>
<pre><code class="language-python">from memory_profiler import profile
import time
import gc

'''
在上面的程式碼中，我們創建了兩個類 A 和 B，並使用這些類創建了一個實例。由於類 B 引用了類 A 的實例，因此類 A 的實例將不能被內存管理器自動回收。因此，這將導致無法釋放內存的情況。
'''
# Example of un-collectable memory in Python
class A:
    def __init__(self, data):
        self.data = data
        self.b = B(self)

class B:
    def __init__(self, a):
        self.large_memory = bytearray(1024 * 1024)
        self.a = a

 
@profile
def call():
    a = A(10)
    del a
 
def main():
    while True:
        time.sleep(1)
        call()
 
if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h2 id="test-memory-leak"><a class="header" href="#test-memory-leak">Test memory leak</a></h2>
<pre><code class="language-python">from memory_profiler import profile
import datetime as dt
import requests
import time
import httpx
import gc
 
@profile
def call():
    url = &quot;https://api.bitopro.com/v3/provisioning/trading-pairs&quot;
    response = httpx.get(url)
    if response.status_code == 200:
        data = response.json()
        print(response.status_code, dt.datetime.now())
        response.close()
        gc.collect()
    else:
        print(&quot;Request failed with status code:&quot;, response.status_code)
    
 
def main():
    while True:
        time.sleep(1)
        call()
 
if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="每5秒委託成交統計"><a class="header" href="#每5秒委託成交統計"><a href="https://www.twse.com.tw/zh/page/trading/exchange/MI_5MINS.html">每5秒委託成交統計</a></a></h2>
<pre><code class="language-python">from datetime import timedelta
import time
import polars as pl
import datetime as dt 
import requests
import json


def get_webmsg(year, month, day):
    print(year, month, day)
    date = str(year) + &quot;{0:0=2d}&quot;.format(month) + &quot;{0:0=2d}&quot;.format(day)
    url_twse = (
        &quot;http://www.twse.com.tw/exchangeReport/MI_5MINS?response=json&amp;date=&quot; + date
    )
    print(url_twse)
    res = requests.post(url_twse)
    data_json = json.loads(res.text)
    if data_json != {'stat': '很抱歉，沒有符合條件的資料!'}:
        df = pl.DataFrame(
            data_json[&quot;data&quot;],
            schema=[
                &quot;時間&quot;,
                &quot;累積委託買進筆數&quot;,
                &quot;累積委託買進數量&quot;,
                &quot;累積委託賣出筆數&quot;,
                &quot;累積委託賣出數量&quot;,
                &quot;累積成交筆數&quot;,
                &quot;累積成交數量&quot;,
                &quot;累積成交金額&quot;,
            ],
        )
        return df
    return pl.DataFrame()


if __name__ == '__main__':
    start_date = dt.datetime(2019, 1, 1) #.strftime(&quot;%Y-%m-%d&quot;)
    end_date = dt.datetime(2023, 1, 20) #.strftime(&quot;%Y-%m-%d&quot;)

    while start_date &lt; end_date:
        time.sleep(1)
        print(get_webmsg(start_date.year, start_date.month, start_date.day))
        start_date = start_date + timedelta(days=1)
</code></pre>
<h2 id="polars"><a class="header" href="#polars">polars</a></h2>
<p>https://github.com/pola-rs/polars</p>
<pre><code class="language-sh">pip install polars
</code></pre>
<pre><code class="language-python">import polars as pl

df = pl.DataFrame(
    {
        &quot;A&quot;: [1, 2, 3, 4, 5],
        &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &quot;B&quot;: [5, 4, 3, 2, 1],
        &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
    }
)

print(df)
df = df.sort(&quot;fruits&quot;).select(
    [
        &quot;fruits&quot;,
        &quot;cars&quot;,
        pl.lit(&quot;fruits&quot;).alias(&quot;literal_string_fruits&quot;),
        pl.col(&quot;B&quot;).filter(pl.col(&quot;cars&quot;) == &quot;beetle&quot;).sum(),
        pl.col(&quot;A&quot;).filter(pl.col(&quot;B&quot;) &gt; 2).sum().over(&quot;cars&quot;).alias(&quot;sum_A_by_cars&quot;),
        pl.col(&quot;A&quot;).sum().over(&quot;fruits&quot;).alias(&quot;sum_A_by_fruits&quot;),
        pl.col(&quot;A&quot;).reverse().over(&quot;fruits&quot;).alias(&quot;rev_A_by_fruits&quot;),
        pl.col(&quot;A&quot;).sort_by(&quot;B&quot;).over(&quot;fruits&quot;).alias(&quot;sort_A_by_B_by_fruits&quot;),
    ]
)
print(df)
</code></pre>
<h2 id="multiprocessing-queue-with-non-blocking"><a class="header" href="#multiprocessing-queue-with-non-blocking">multiprocessing queue with non blocking</a></h2>
<pre><code class="language-python">from loguru import logger
import multiprocessing
import time


def processFun(conn):
    while True:
        try:
            print(conn.get(timeout=5)) # 等5秒沒數據就丟異常
        except Exception as e:
            logger.exception(e)
        print(&quot;接收到數據了&quot;, conn.qsize())


if __name__ == &quot;__main__&quot;:
    # 創建管道
    conn = multiprocessing.Queue(10)
    # 創建子進程
    process = multiprocessing.Process(target=processFun, args=(conn,))
    # 啟動子進程
    process.start()
    i = 0
    while True:
        time.sleep(6)
        print(i)
        conn.put(i)
        i += 1
</code></pre>
<h2 id="dispatching-multiple-websocketapps---long-lived-connection"><a class="header" href="#dispatching-multiple-websocketapps---long-lived-connection">Dispatching Multiple WebSocketApps - Long-lived Connection</a></h2>
<pre><code class="language-python"># import websocket, rel
#
# addr = &quot;wss://api.gemini.com/v1/marketdata/%s&quot;
# for symbol in [&quot;BTCUSD&quot;, &quot;ETHUSD&quot;, &quot;ETHBTC&quot;]:
#    ws = websocket.WebSocketApp(addr % (symbol,), on_message=lambda w, m : print(m))
#    ws.run_forever(dispatcher=rel, reconnect=3)
#
#
# rel.signal(2, rel.abort) # Keyboard Interrupt
# rel.dispatch()

from multiprocessing import Process
import time
import websocket
import rel
import signal
import os


def on_message(ws, message):
    print(message)


def on_error(ws, error):
    print(error)


def on_close(ws, close_status_code, close_msg):
    print(&quot;### closed ###&quot;)


def on_open(ws):
    print(&quot;Opened connection&quot;)


def receive_signal(signum, stack):
    print(&quot;Received:&quot;, signum, os.getpid())
    ws.close()
    rel.abort()
    ws.run_forever(dispatcher=rel, reconnect=5)  # Set dispatcher to automatic␣
    rel.signal(2, rel.abort)  # Keyboard Interrupt
    rel.dispatch()


def monitor(pid, ws):
    print(&quot;Waiting ...&quot;)
    time.sleep(3)
    os.kill(pid, signal.SIGUSR1)


if __name__ == &quot;__main__&quot;:
    print(os.getpid())
    # websocket.enableTrace(True)
    ws = websocket.WebSocketApp(
        &quot;wss://api.gemini.com/v1/marketdata/BTCUSD&quot;,
        on_open=on_open,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
    )
    signal.signal(signal.SIGUSR1, receive_signal)
    monitor_task = Process(target=monitor, args=(os.getpid(), ws),)

    monitor_task.start()
    ws.run_forever(dispatcher=rel, reconnect=5)  # Set dispatcher to automatic␣
    rel.signal(2, rel.abort)  # Keyboard Interrupt
    rel.dispatch()
    monitor_task.join()
</code></pre>
<h2 id="how-can-i-send-a-signal-from-a-python-program"><a class="header" href="#how-can-i-send-a-signal-from-a-python-program">How can I send a signal from a python program?</a></h2>
<pre><code class="language-python">import signal
import os
import time

def receive_signal(signum, stack):
    print('Received:', signum)

signal.signal(signal.SIGUSR1, receive_signal)
signal.signal(signal.SIGUSR2, receive_signal)

print('My PID is:', os.getpid())

while True:
    print('Waiting...')
    time.sleep(3)
    os.kill(os.getpid(), signal.SIGUSR1) 
</code></pre>
<h2 id="記憶體監控"><a class="header" href="#記憶體監控">記憶體監控</a></h2>
<pre><code class="language-python">from loguru import logger
import os
import time
import platform
import psutil
import signal
import sys


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


logger.add(
    f&quot;{__file__}.log&quot;,
    encoding=&quot;utf-8&quot;,
    enqueue=True,
    retention=&quot;10 days&quot;,
    # filter=error_only,
)


def getListOfProcessSortedByMemory():
    &quot;&quot;&quot;
    Get list of running process sorted by Memory Usage
    &quot;&quot;&quot;
    listOfProcObjects = []
    # Iterate over the list
    for proc in psutil.process_iter():
        try:
            # Fetch process details as dict
            pinfo = proc.as_dict(attrs=[&quot;pid&quot;, &quot;name&quot;, &quot;username&quot;])
            pinfo[&quot;vms&quot;] = proc.memory_info().vms / (1024 * 1024)
            # Append dict to list
            listOfProcObjects.append(pinfo)
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    # Sort list of dict by key vms i.e. memory usage
    listOfProcObjects = sorted(
        listOfProcObjects, key=lambda procObj: procObj[&quot;vms&quot;], reverse=True
    )
    return listOfProcObjects


def get_all_memory_usage():
    # Getting all memory using os.popen()
    total_memory, used_memory, free_memory = map(
        int, os.popen(&quot;free -t -m&quot;).readlines()[-1].split()[1:]
    )

    # Memory usage
    logger.info(f&quot;RAM memory % used: {round((used_memory / total_memory) * 100, 2)}&quot;)
    return round((used_memory / total_memory) * 100, 2)


if __name__ == &quot;__main__&quot;:
    if platform.system().lower() == &quot;linux&quot;:
        Watcher()

    while True:
        time.sleep(10)
        listOfRunningProcess = getListOfProcessSortedByMemory()
        if get_all_memory_usage() &gt; 50:
            for elem in listOfRunningProcess[:20]:
                # print(elem)
                logger.info(elem)
</code></pre>
<pre><code class="language-python">import datetime as dt
from datetime import timedelta

print(dt.datetime(year=2022, month=12, day=2, hour=18, minute=0, second=0, microsecond=0) - timedelta(hours=8))
</code></pre>
<h2 id="視化神器highcharts"><a class="header" href="#視化神器highcharts">視化神器Highcharts</a></h2>
<pre><code class="language-python">from highcharts import Highchart
import datetime
from IPython.display import HTML, display
import yfinance as yf
import os

# 取得股價歷史資料(含臺股\美股\加密貨幣)

symbol = &quot;2330.TW&quot;  # 臺股上市:TW 臺股上櫃:TWO
start = &quot;2018-01-01&quot;  # 起始時間
end = &quot;2022-12-31&quot;  # 結束時間

ohlcv = yf.Ticker(symbol).history(&quot;max&quot;).loc[start:end]


# 客製化調整參數
color = &quot;#4285f4&quot;  # 線的顏色 (red/green/blue/purple)
linewidth = 2  # 線的粗細
title = symbol  # 標題名稱
width = 800  # 圖的寬度
height = 500  # 圖的高度

# 繪圖設定
H = Highchart(width=width, height=height)

x = ohlcv.index
y = round(ohlcv.Close, 2)

data = [[index, s] for index, s in zip(x, y)]
H.add_data_set(data, &quot;line&quot;, &quot;data&quot;, color=color)

H.set_options(&quot;xAxis&quot;, {&quot;type&quot;: &quot;datetime&quot;})
H.set_options(&quot;title&quot;, {&quot;text&quot;: title, &quot;style&quot;: {&quot;color&quot;: &quot;black&quot;}})  # 設定title
H.set_options(
    &quot;plotOptions&quot;, {&quot;line&quot;: {&quot;lineWidth&quot;: linewidth, &quot;dataLabels&quot;: {&quot;enabled&quot;: False}}}
)  # 設定線的粗度
H.set_options(&quot;tooltip&quot;, {&quot;shared&quot;: True, &quot;crosshairs&quot;: True})  # 設定為可互動式

# 顯示圖表
H.save_file(&quot;chart&quot;)
display(HTML(&quot;chart.html&quot;))
os.remove(&quot;chart.html&quot;)
</code></pre>
<h2 id="test-redis"><a class="header" href="#test-redis">Test Redis</a></h2>
<pre><code class="language-python">import redis

botID = 101
r = redis.StrictRedis(host=&quot;localhost&quot;, port=6379, db=2)

r.hset(
    f&quot;BOT_INFO:{botID}&quot;, mapping={&quot;grid_step&quot;: &quot;50&quot;},
)

fee = 0.1
r.hset(
    f&quot;BOT_INFO:{botID}&quot;, mapping={&quot;spotman_grid_fee&quot;: str(fee)},
)

print(r.exists(&quot;BOT_INFO:28&quot;))
if not r.hexists(f&quot;BOT_INFO:{botID}&quot;, &quot;spotman_grid_fee&quot;) or (
    r.hexists(f&quot;BOT_INFO:{botID}&quot;, &quot;spotman_grid_fee&quot;)
    and float(r.hget(f&quot;BOT_INFO:{botID}&quot;, &quot;spotman_grid_fee&quot;)) == 0.0
):
    spotman_grid_fee = 0.0
else:
    spotman_grid_fee = fee

print(spotman_grid_fee)

# r.set(&quot;foo&quot;, &quot;bar&quot;)
## print(r.get('foo'))
#
# botID = 28
# r.hset(
#    f&quot;BOT_INFO:{botID}&quot;, mapping={&quot;spotman_grid_fee&quot;: 0},
# )
#
# spotman_grid_fee = float(r.hget(f&quot;BOT_INFO:{botID}&quot;, &quot;spotman_grid_fee&quot;))yy
# print(spotman_grid_fee == 0.0)
#
# print(r.hexists(f&quot;BOT_INFO:{botID}&quot;, &quot;spotman_grid_fee&quot;))
# print(r.hget(f&quot;BOT_INFO:{botID}&quot;, &quot;grid_step&quot;))


# if r.hexists(
#    f&quot;BOT_INFO:{botID}&quot;, &quot;bot_id&quot;
# ):

# botID = 6804
# r = redis.StrictRedis(
#    host=&quot;staging-redis-trading.ruv0v5.ng.0001.apne1.cache.amazonaws.com&quot;,
#    port=6379,
#    db=1,
# )
# print(r.hget(f&quot;BOT_INFO:{botID}&quot;, &quot;grid_step&quot;))
# print(not r.hexists(f&quot;BOT_INFO:{botID}&quot;, &quot;spotman_grid_fee&quot;))
</code></pre>
<h2 id="python爬蟲教學有效利用python網頁爬蟲爬取免費的proxy-ip清單"><a class="header" href="#python爬蟲教學有效利用python網頁爬蟲爬取免費的proxy-ip清單">[Python爬蟲教學]有效利用Python網頁爬蟲爬取免費的Proxy IP清單</a></h2>
<pre><code class="language-python">import requests
import re


def get_proxy():
    # https://www.learncodewithmike.com/2021/10/python-scrape-free-proxy-ip.html?m=1
    response = requests.get(&quot;https://www.sslproxies.org/&quot;)
    proxy_ips = re.findall(&quot;\d+\.\d+\.\d+\.\d+:\d+&quot;, response.text)  # 「\d+」代表數字一個位數以上
    valid_ips = []

    for ip in proxy_ips:
        try:
            result = requests.get(
                &quot;https://ip.seeip.org/jsonip?&quot;,
                proxies={&quot;http&quot;: ip, &quot;https&quot;: ip},
                timeout=5,
            )
            print(result.json())
            valid_ips.append(ip)
        except:
            print(f&quot;{ip} invalid&quot;)

    with open(&quot;proxy_list.txt&quot;, &quot;w&quot;) as file:
        for ip in valid_ips:
            file.write(ip + &quot;\n&quot;)
        file.close()


if __name__ == &quot;__main__&quot;:
    # get_proxy()
    proxy_dict = {}
    with open(&quot;./proxy_list.txt&quot;) as f:
        proxy_list = f.read().splitlines()
        # print(proxy_list, type(proxy_list))
    &quot;&quot;&quot;代理IP地址（高匿）&quot;&quot;&quot;
    #proxys = {
    #    &quot;http&quot;: &quot;http://118.27.113.167:8080&quot;,
    #    &quot;https&quot;: &quot;https://118.27.113.167:8080&quot;,
    #}
    &quot;&quot;&quot;head 資訊&quot;&quot;&quot;
    head = {
        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&quot;,
        &quot;Connection&quot;: &quot;keep-alive&quot;,
    }
    &quot;&quot;&quot;http://icanhazip.com會返回當前的IP地址&quot;&quot;&quot;
    for proxy in proxy_list:
        proxy_dict[&quot;http&quot;] = &quot;http://&quot; + proxy
        proxy_dict[&quot;https&quot;] = &quot;https://&quot; + proxy
        try:
            p = requests.get(&quot;http://icanhazip.com&quot;, headers=head, proxies=proxy_dict, timeout=5)
            print(p.text)
        except Exception as e:
            print(e)
            continue
</code></pre>
<h2 id="同學你的多線程可別再亂-join-了"><a class="header" href="#同學你的多線程可別再亂-join-了">同學,你的多線程可別再亂 join 了!</a></h2>
<p>如果你在網上搜索「Python 多線程」，那麼你會看到很多文章裡面用到了一個關鍵詞，叫做.join()。但是很多人的代碼裡面都在亂用 join()，例如：</p>
<pre><code class="language-python">import time
import threading

def sleep_5_seconds():
    time.sleep(5)
    print('睡眠5秒結束')

def sleep_3_seconds():
    time.sleep(3)
    print('睡眠3秒結束')



def sleep_8_seconds():
    time.sleep(8)
    print('睡眠8秒結束')


thread_1 = threading.Thread(target=sleep_8_seconds)
thread_2 = threading.Thread(target=sleep_5_seconds)
thread_3 = threading.Thread(target=sleep_5_seconds)
thread_1.start()
thread_2.start()
thread_3.start()
thread_1.join()
thread_2.join()
thread_3.join()


</code></pre>
<p>運行效果如下圖所示：</p>
<p>更有甚者，這樣寫代碼：</p>
<p>thread_1.start()
thread_1.join()
thread_2.start()
thread_2.join()
thread_3.start()
thread_3.join()</p>
<p>運行效果如下圖所示：</p>
<p>發現三個線程是串行執行的，要運行一共8+5+3=16秒才能結束，於是得出結論——Python 由於有 GIL 鎖的原因，所以多線程是一個線程運行完才運行另一個線程。</p>
<p>抱有這種想法的人，是根本不知道.join()有什麼用，就在跟著別人亂用，以為只要使用多線程，那麼每個線程都必須要 join。</p>
<p>實際上，根本不是這樣的，你只需要 join運行時間最長的那個線程就可以了：</p>
<p>你會發現這樣的運行效果，跟每個線程 join 一次是完全一樣的。</p>
<p>要理解這個問題，我們需要知道，join 有什麼作用。</p>
<p>當我們沒有 join 的時候，我們會發現子線程似乎也能正常運行，如下圖所示：</p>
<p>三個子線程啟動以後，主線程會繼續運行後面的代碼。</p>
<p>那 join 到底有什麼用呢？join 會卡住主線程，並讓當前已經 start 的子線程繼續運行，直到調用.join的這個線程運行完畢。</p>
<p>所以，如果代碼寫為：</p>
<p>thread_1.start()
thread_1.join()
thread_2.start()
thread_2.join()
thread_3.start()
thread_3.join()</p>
<p>當代碼運行到thread_1.join()時，主線程就卡住了，後面的thread_2.start()根本沒有執行。此時當前只有 thread_1執行過.start()方法，所以此時只有 thread_1再運行。這個線程需要執行8秒鐘。等8秒過後，thread_1結束，於是主線程才會運行到thread_2.start()，第二個線程才會開始運行。所以這個例子裡面，三個線程串行運行，完全是寫代碼的人有問題，而不是什麼 GIL 鎖的問題。</p>
<p>而當我們把代碼寫為：</p>
<p>thread_1.start()
thread_2.start()
thread_3.start()
thread_1.join()
thread_2.join()
thread_3.join()</p>
<p>當代碼執行到thread_1.join()時，當前三個子線程均已經執行過.start()方法了，所以此時主線程雖然卡住了，但是三個子線程會繼續運行。其中線程3先結束，然後線程2結束。此時線程1還剩3秒鐘，所以此時thread_1.join()依然是卡住的狀態，直到線程1結束，thread_1.join()解除阻塞，代碼運行到thread_2.join()中，但由於thread_2早就結束了，所以這行代碼一閃而過，不會卡住。同理，thread_3.join()也是一閃而過。所以整個過程中，thread_2.join()和thread_3.join()根本沒有起到任何作用。直接就結束了。</p>
<p>所以，你只需要 join 時間最長的這個線程就可以了。時間短的線程沒有 join 的必要。根本不需要把這麼多個 join 堆在一起。</p>
<p>為什麼會有 join 這個功能呢？我們設想這樣一個場景。你的爬蟲使用10個線程爬取100個 URL，主線程需要等到所有URL 都已經爬取完成以後，再來分析數據。此時就可以通過 join 先把主線程卡住，等到10個子線程全部運行結束了，再用主線程進行後面的操作。</p>
<p>那麼可能有人會問，如果我不知道哪個線程先運行完，那個線程後運行完怎麼辦？這個時候是不是就要每個線程都執行 join 操作了呢？</p>
<p>確實，這種情況下，每個線程使用 join是合理的：</p>
<pre><code class="language-python">thread_list = []
for _ in range(10):
    thread = threading.Thread(target=xxx, args=(xxx, xxx)) 換行thread.start()
    thread_list.append(thread)

for thread in thread_list:
    thread.join()
</code></pre>
<h2 id="監控指定process狀態"><a class="header" href="#監控指定process狀態">監控指定Process狀態</a></h2>
<pre><code class="language-py">import threading, logging, time
import multiprocessing
import psutil


class Producer(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.stop_event = threading.Event()

    def stop(self):
        self.stop_event.set()

    def run(self):
        while not self.stop_event.is_set():
            # print(&quot;Producer is working...&quot;)
            time.sleep(1)


class Consumer(multiprocessing.Process):
    def __init__(self):
        multiprocessing.Process.__init__(self)
        self.stop_event = multiprocessing.Event()

    def stop(self):
        self.stop_event.set()

    def run(self):
        while not self.stop_event.is_set():
            print(&quot;Consumer is working...&quot;)
            time.sleep(10)
            try:
                a = 1 / 0
            except Exception as ex:
                print(ex)
                continue


class Monitor(multiprocessing.Process):
    def __init__(self, target_pid):
        multiprocessing.Process.__init__(self)
        self.stop_event = multiprocessing.Event()
        self.target_pid = target_pid

    def stop(self):
        self.stop_event.set()

    def run(self):
        while not self.stop_event.is_set():
            p = psutil.Process(self.target_pid)
            print(&quot;Monitor is working...&quot;, self.target_pid, p.status)
            time.sleep(1)


def main():
    tasks = [Producer(), Consumer()]

    for t in tasks:
        t.start()

    print(tasks[1].pid)
    t = Monitor(tasks[1].pid)
    t.start()
    time.sleep(3600)

    for task in tasks:
        task.stop()

    for task in tasks:
        task.join()


if __name__ == &quot;__main__&quot;:
    logging.basicConfig(
        format=&quot;%(asctime)s.%(msecs)s:%(name)s:%(thread)d:%(levelname)s:%(process)d:%(message)s&quot;,
        level=logging.INFO,
    )
    main()
</code></pre>
<h2 id="檔案拆成15g-一個資料夾"><a class="header" href="#檔案拆成15g-一個資料夾">檔案拆成1.5G 一個資料夾</a></h2>
<pre><code class="language-py">#!/bin/env python3

from pathlib import Path
import os
import shutil

number = 0
current_size = 0
pattern = &quot;new-folder-%03d&quot;

new_directory = pattern % number
Path(pattern % number).mkdir(parents=True, exist_ok=True)

# 預設抓 /path/picture/* 該目錄內檔案，若是要包含子目錄，請使用像是 rglob('*.jpg') 替代
for item in Path(&quot;Camera&quot;).rglob(&quot;*&quot;):
    current_size += item.stat().st_size
    if current_size &gt;= 1024 * 1024 * 1500:
        number += 1
        current_size = 0
        new_directory = pattern % number
        Path(new_directory).mkdir(parents=True, exist_ok=True)
    shutil.move(
        os.path.join(item.parent, item.name), os.path.join(new_directory, item.name)
    )
</code></pre>
<h2 id="刪除指定日期之前的row"><a class="header" href="#刪除指定日期之前的row">刪除指定日期之前的Row</a></h2>
<pre><code class="language-python">import pandas as pd

csiti = 23454
units = list(range(0, 400))
begin_date = '2019-10-16'

df = pd.DataFrame({'csiti':csiti, 
                   'units':units,
                   'forecast_date':pd.date_range(begin_date, periods=len(units), freq='1S')})


df.set_index(&quot;forecast_date&quot;, inplace=True)


df.index = pd.to_datetime(df.index)
print(df)

res = df[~(df.index &lt; '2019-10-16 00:06')]
print(id(res))
# print(res, type(res.index.tolist()[-1]))


# Insert row to dataframe
res.loc[res.index.tolist()[-1]] = [12345, 362]
print(res)
print(id(res))

# Check if a date index exist in Pandas dataframe
print(pd.to_datetime('2019-10-16 00:06') not in df.index)
print(pd.to_datetime('2019-10-16 00:07') not in df.index)
</code></pre>
<h2 id="yfinance"><a class="header" href="#yfinance">yfinance</a></h2>
<pre><code class="language-py">import yfinance as yf

dji_data = yf.download(tickers = &quot;^DJI&quot;, interval = &quot;1d&quot;, period = &quot;10d&quot;)
dji_data['Rets'] = round(dji_data['Close'].pct_change() * 100, 2)
print(dji_data)

sox_data = yf.download(tickers=&quot;^SOX&quot;, interval = &quot;1d&quot;, period=&quot;10d&quot;)
sox_data['Rets'] = round(sox_data['Close'].pct_change() * 100, 2)
print(sox_data)

ixic_data = yf.download(tickers=&quot;^IXIC&quot;, interval = &quot;1d&quot;, period=&quot;10d&quot;)
ixic_data['Rets'] = round(ixic_data['Close'].pct_change() * 100, 2)
print(ixic_data)
</code></pre>
<h2 id="plotly--畫k-bars"><a class="header" href="#plotly--畫k-bars">plotly  畫K bars</a></h2>
<pre><code class="language-python"># Raw Package
import numpy as np
import pandas as pd
from pandas_datareader import data as pdr

# Market Data 
import yfinance as yf

#Graphing/Visualization
import datetime as dt 
import plotly.graph_objs as go 

# Override Yahoo Finance 
yf.pdr_override()

# Create input field for our desired stock 
stock=input(&quot;Enter a stock ticker symbol: &quot;)

# Retrieve stock data frame (df) from yfinance API at an interval of 1m 
df = yf.download(tickers=stock,period='1d',interval='1m')

print(df)

# Declare plotly figure (go)
fig=go.Figure()

fig.add_trace(go.Candlestick(x=df.index,
                open=df['Open'],
                high=df['High'],
                low=df['Low'],
                close=df['Close'], name = 'market data'))

fig.update_layout(
    title= str(stock)+' Live Share Price:',
    yaxis_title='Stock Price (USD per Shares)')               

fig.update_xaxes(
    rangeslider_visible=True,
    rangeselector=dict(
        buttons=list([
            dict(count=15, label=&quot;15m&quot;, step=&quot;minute&quot;, stepmode=&quot;backward&quot;),
            dict(count=45, label=&quot;45m&quot;, step=&quot;minute&quot;, stepmode=&quot;backward&quot;),
            dict(count=1, label=&quot;HTD&quot;, step=&quot;hour&quot;, stepmode=&quot;todate&quot;),
            dict(count=3, label=&quot;3h&quot;, step=&quot;hour&quot;, stepmode=&quot;backward&quot;),
            dict(step=&quot;all&quot;)
        ])
    )
)

fig.show()
</code></pre>
<pre><code class="language-python">import asyncio
import aiohttp
import multiprocessing
import threading


async def get_thread_id():
    return (multiprocessing.current_process().pid, threading.get_ident())


def get_exchange_rate(url, exchange_name, conn):
    if exchange_name == &quot;RYBIT&quot;:
        asyncio.run(handle_rybit_exchange(url, conn))
    elif exchange_name == &quot;ACE&quot;:
        asyncio.run(handle_ace_exchange(url, conn))
    elif exchange_name == &quot;MAX&quot;:
        asyncio.run(handle_max_exchange(url, conn))
    elif exchange_name == &quot;BITOPRO&quot;:
        asyncio.run(handle_bitopro_exchange(url, conn))
    else:
        print(f&quot;Unknown exchange: {exchange_name}&quot;)


async def handle_rybit_exchange(url, conn):
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    buy_rate = data.get(&quot;data&quot;).get(&quot;buy_rate&quot;)
                    sell_rate = data.get(&quot;data&quot;).get(&quot;sell_rate&quot;)
                    process_id, thread_id = await get_thread_id()
                    print(f&quot;RYBIT Process ID:{process_id}, Thread ID:{thread_id}&quot;)
                    print(&quot;RYBIT 買入匯率:&quot;, buy_rate)
                    print(&quot;RYBIT 賣出匯率:&quot;, sell_rate)
                    conn.send((&quot;RYBIT&quot;, buy_rate, sell_rate))
                else:
                    print(&quot;RYBIT 發生錯誤，HTTP 狀態碼為:&quot;, response.status)
        await asyncio.sleep(1)


async def handle_ace_exchange(url, conn):
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    process_id, thread_id = await get_thread_id()
                    print(f&quot;ACE Process ID:{process_id}, Thread ID:{thread_id}&quot;)
                    print(f&quot;ACE USDT/TWD 買入委託價格: {data['orderbook']['bids'][0][1]}&quot;)
                    print(f&quot;ACE USDT/TWD 賣出委託價格: {data['orderbook']['asks'][0][1]}&quot;)
                    conn.send((&quot;ACE&quot;, data[&quot;orderbook&quot;][&quot;bids&quot;][0][1], data[&quot;orderbook&quot;][&quot;asks&quot;][0][1]))
                else:
                    print(&quot;ACE 發生錯誤，HTTP 狀態碼為:&quot;, response.status)
        await asyncio.sleep(1)


async def handle_max_exchange(url, conn):
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    usdt_twd = data.get(&quot;usdttwd&quot;)
                    buy_price = usdt_twd.get(&quot;buy&quot;)
                    sell_price = usdt_twd.get(&quot;sell&quot;)
                    process_id, thread_id = await get_thread_id()
                    print(f&quot;MAX Process ID:{process_id}, Thread ID:{thread_id}&quot;)
                    print(f&quot;MAX USDT/TWD buy: {buy_price}&quot;)
                    print(f&quot;MAX USDT/TWD sell: {sell_price}&quot;)
                    conn.send((&quot;MAX&quot;, buy_price, sell_price))
                else:
                    print(&quot;MAX 發生錯誤，HTTP 狀態碼為:&quot;, response.status)
        await asyncio.sleep(1)


async def handle_bitopro_exchange(url, conn):
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    bid_price = data[&quot;bids&quot;][0][&quot;price&quot;]
                    ask_price = data[&quot;asks&quot;][0][&quot;price&quot;]
                    process_id, thread_id = await get_thread_id()
                    print(f&quot;BITOPRO Process ID:{process_id}, Thread ID:{thread_id}&quot;)
                    print(f&quot;BITOPRO 買入委託價格：{bid_price}&quot;)
                    print(f&quot;BITOPRO 賣出委託價格：{ask_price}&quot;)
                    conn.send((&quot;BITOPRO&quot;, bid_price, ask_price))
                else:
                    print(&quot;BITOPRO 發生錯誤，HTTP 狀態碼為:&quot;, response.status)
        await asyncio.sleep(1)


def collect_exchange_rates(conn):
    exchange_rates = {}
    while True:
        exchange_name, buy_rate, sell_rate = conn.recv()
        exchange_rates[exchange_name] = {&quot;buy&quot;: buy_rate, &quot;sell&quot;: sell_rate}
        print(f&quot;Exchange rates: {exchange_rates}&quot;)

async def main():
    exchanges = [
        {
            &quot;name&quot;: &quot;RYBIT&quot;,
            &quot;url&quot;: &quot;https://www.rybit.com/wallet-api/v1/kgi/exchange-rates/?symbol=USDT_TWD&quot;,
        },
        {
            &quot;name&quot;: &quot;ACE&quot;,
            &quot;url&quot;: &quot;https://ace.io/polarisex/oapi/list/orderBooks/USDT/TWD&quot;,
        },
        {&quot;name&quot;: &quot;MAX&quot;, &quot;url&quot;: &quot;https://max-api.maicoin.com/api/v2/tickers&quot;},
        {&quot;name&quot;: &quot;BITOPRO&quot;, &quot;url&quot;: &quot;https://api.bitopro.com/v3/order-book/usdt_twd&quot;},
    ]
    parent_conn, child_conn = multiprocessing.Pipe()
    processes = []
    for exchange in exchanges:
        p = multiprocessing.Process(
            target=get_exchange_rate, args=(exchange[&quot;url&quot;], exchange[&quot;name&quot;], child_conn)
        )
        processes.append(p)
        p.start()

    collector = multiprocessing.Process(target=collect_exchange_rates, args=(parent_conn,))
    collector.start()

    for p in processes:
        p.join()


if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mermaid"><a class="header" href="#mermaid">mermaid</a></h1>
<ul>
<li>https://mermaid-js.github.io/mermaid/#/</li>
<li>https://mermaid-js.github.io/mermaid-live-editor/</li>
<li>https://github.com/mermaid-js/mermaid</li>
</ul>
<h2 id="flowchart"><a class="header" href="#flowchart">Flowchart</a></h2>
<pre><code class="language-mermaid">flowchart LR
A[Hard] --&gt;|Text| B(Round)
B --&gt; C{Decision}
C --&gt;|One| D[Result 1]
C --&gt;|Two| E[Result 2]
</code></pre>
<h2 id="sequence-diagram"><a class="header" href="#sequence-diagram">Sequence diagram</a></h2>
<pre><code class="language-mermaid">sequenceDiagram
Alice-&gt;&gt;John: Hello John, how are you?
loop Healthcheck
    John-&gt;&gt;John: Fight against hypochondria
end
Note right of John: Rational thoughts!
John--&gt;&gt;Alice: Great!
John-&gt;&gt;Bob: How about you?
Bob--&gt;&gt;John: Jolly good!
</code></pre>
<h2 id="class-diagram"><a class="header" href="#class-diagram">Class diagram</a></h2>
<pre><code class="language-mermaid">classDiagram
Class01 &lt;|-- AveryLongClass : Cool
&lt;&lt;Interface&gt;&gt; Class01
Class09 --&gt; C2 : Where am i?
Class09 --* C3
Class09 --|&gt; Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
class Class10 {
  &lt;&lt;service&gt;&gt;
  int id
  size()
}
</code></pre>
<h2 id="state-diagram"><a class="header" href="#state-diagram">State diagram</a></h2>
<pre><code class="language-mermaid">stateDiagram-v2
[*] --&gt; Still
Still --&gt; [*]
Still --&gt; Moving
Moving --&gt; Still
Moving --&gt; Crash
Crash --&gt; [*]
</code></pre>
<h2 id="pie-chart"><a class="header" href="#pie-chart">Pie chart</a></h2>
<pre><code class="language-mermaid">pie
&quot;Dogs&quot; : 386
&quot;Cats&quot; : 85
&quot;Rats&quot; : 15
</code></pre>
<h2 id="user-journey-diagram"><a class="header" href="#user-journey-diagram">User Journey diagram</a></h2>
<pre><code class="language-mermaid">  journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 3: Me
</code></pre>
<h2 id="gantt-chart"><a class="header" href="#gantt-chart">Gantt chart</a></h2>
<pre><code class="language-mermaid">gantt
    section Section
    Completed :done,    des1, 2014-01-06,2014-01-08
    Active        :active,  des2, 2014-01-07, 3d
    Parallel 1   :         des3, after des1, 1d
    Parallel 2   :         des4, after des1, 1d
    Parallel 3   :         des5, after des3, 1d
    Parallel 4   :         des6, after des4, 1d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-效能分析工具-perf"><a class="header" href="#linux-效能分析工具-perf">Linux 效能分析工具: Perf</a></h1>
<h2 id="簡介-1"><a class="header" href="#簡介-1">簡介</a></h2>
<p><a href="https://perf.wiki.kernel.org/index.php/Main_Page">Perf</a> 全名是 Performance Event，是在 Linux 2.6.31 以後內建的系統效能分析工具，它隨著核心一併釋出。藉由 perf，應用程式可以利用 PMU (Performance Monitoring Unit), tracepoint 和核心內部的特殊計數器 (counter) 來進行統計，另外還能同時分析運行中的核心程式碼，從而更全面瞭解應用程式中的效能瓶頸。</p>
<p>相較於 <a href="https://en.wikipedia.org/wiki/OProfile">OProfile</a> 和 <a href="https://sourceware.org/binutils/docs/gprof/">GProf</a> ，perf 的優勢在於與 Linux Kernel 緊密結合，並可受益於最先納入核心的新特徵。perf 基本原理是對目標進行取樣，紀錄特定的條件下所偵測的事件是否發生以及發生的次數。例如根據 tick 中斷進行取樣，即在 tick 中斷內觸發取樣點，在取樣點裡判斷行程 (process) 當時的 context。假如一個行程 90% 的時間都花費在函式 foo() 上，那麼 90% 的取樣點都應該落在函式 foo() 的上下文中。</p>
<p>Perf 可取樣的事件非常多，可以分析 Hardware event，如 cpu-cycles、instructions 、cache-misses、branch-misses …等等。可以分析 Software event，如 page-faults、context-switches …等等，另外一種就是 Tracepoint event。知道了 cpu-cycles、instructions 我們可以瞭解 Instruction per cycle 是多少，進而判斷程式碼有沒有好好利用 CPU，cache-misses 可以曉得是否有善用 Locality of reference ，branch-misses 多了是否導致嚴重的 pipeline hazard？另外 Perf 還可以對函式進行採樣，瞭解效能卡在哪邊。</p>
<h2 id="安裝-3"><a class="header" href="#安裝-3">安裝</a></h2>
<p>首先利用以下指令查看目前的 Kernel config 有沒有啟用 Perf。如果 PC 上是裝一般 Linux distro，預設值應該都有開啟。</p>
<pre><code class="language-sh">＄ cat &quot;/boot/config-`uname -r`&quot; | grep &quot;PERF_EVENT&quot;
</code></pre>
<p>如果自己編譯核心可以參照<a href="http://www.carbondesignsystems.com/virtual-prototype-blog/using-the-arm-performance-monitor-unit-pmu-linux-driver">這篇文章</a>來啟用 perf。</p>
<p>參考的環境是 Ubuntu 14.04，kernel 版本 3.16.0。有兩種方法可以安裝</p>
<ol>
<li>前面講到，perf 是 Linux 內建支持的效能優化工具，在 2.6.31 版本之後，我們可以直接到 <a href="https://www.kernel.org/">Linux Kernel Archives</a> 下載對應版本的程式碼，解壓縮後到 <code>tools/perf</code> 裡面去編譯，通常過程中會有相依的套件需要安裝，依指示完成安裝後，編譯即可成功，最後再把編譯完成的 perf 移至 <code>/usr/bin</code> 中就可以使用了。 這種方法通常適用於更新過 kernel 的使用者，因為更新過 kernel 後會造成 distribution package 與 kernel version 不相符。一般使用者採用第二種方法即可。</li>
<li>使用 apt-get 進行安裝。</li>
</ol>
<pre><code class="language-sh">$ sudo apt-get install linux-tools-common
</code></pre>
<p>接著輸入 perf list 或 perf top 檢查一下 perf 可不可以使用。</p>
<p>如果出現以下的訊息，表示還漏了些東西。</p>
<pre><code>WARNING: perf not found for kernel 3.16.0-50
You may need to install the following packages for this specific kernel:
    linux-tools-3.16.0-50-generic
    linux-cloud-tools-3.16.0-50-generic
</code></pre>
<p>上面的 Kernel 版本可能和你不一樣，根據指示安裝起來即可。不放心的話可以使用<code>＄ uname -r</code>確認。</p>
<pre><code class="language-sh">$ sudo apt-get install linux-tools-3.16.0-50-generic linux-cloud-tools-3.16.0-50-generic
</code></pre>
<ol>
<li>到這裡 perf 的安裝就完成了。不過這裡我再稍微補充一下，如果你不是切換到 root 的情況下輸入</li>
</ol>
<pre><code class="language-sh">$ perf top
</code></pre>
<p>其實會出現以下錯誤畫面。</p>
<p><img src="linux_system/images/perf_top_error.png" alt="img" /></p>
<p>kernel.perf_event_paranoid 是用來決定你在沒有 root 權限下 (Normal User) 使用 perf 時，你可以取得哪些 event data。預設值是 1 ，你可以輸入</p>
<pre><code class="language-sh">$ cat /proc/sys/kernel/perf_event_paranoid
</code></pre>
<p>來查看權限值。一共有四種權限值:</p>
<p><code>2</code> : 不允許任何量測。但部份用來查看或分析已存在的紀錄的指令仍可使用，如 perf ls、perf report、perf timechart、 perf trace。</p>
<p><code>1</code> : 不允許 CPU events data。但可以使用 perf stat、perf record 並取得 Kernel profiling data。</p>
<p><code>0</code> : 不允許 raw tracepoint access。但可以使用 perf stat、perf record 並取得 CPU events data。</p>
<p><code>-1</code>: 權限全開。</p>
<p>最後如果要檢測 cache miss event ，需要先取消 kernel pointer 的禁用。</p>
<pre><code class="language-sh">$ sudo sh -c &quot; echo 0 &gt; /proc/sys/kernel/kptr_restrict&quot;
</code></pre>
<h2 id="先來個範例暖身吧"><a class="header" href="#先來個範例暖身吧">先來個範例暖身吧！</a></h2>
<p>一開始，我們先使用第一次作業 「計算圓周率」 的程式來體會一下 perf 使用。 [perf_top_example.c]</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

double compute_pi_baseline(size_t N) {
    double pi = 0.0;
    double dt = 1.0 / N;
    for (size_t i = 0; i &lt; N; i++) {
        double x = (double) i / N;
        pi += dt / (1.0 + x * x);
    }
    return pi * 4.0;
}
int main() {
    printf(&quot;pid: %d\n&quot;, getpid());
    sleep(10);
    compute_pi_baseline(50000000);
    return 0;
}
</code></pre>
<p>將上述程式存檔為 perf_top_example.c，並執行：</p>
<pre><code class="language-sh">g++ -c perf_top_example.c
g++ perf_top_example.o -o example
./example
</code></pre>
<p>執行上述程式後，可以取得一個 pid 值，再根據 pid 輸入</p>
<pre><code class="language-sh">perf top -p $pid
</code></pre>
<p>應該會得到類似下面的結果：</p>
<p><img src="linux_system/images/perf_computepi_example.png" alt="img" /></p>
<p>預設的 performance event 是 「cycles」，所以這條指令可以分析出消耗 CPU 週期最多的部份，結果顯示函式 compute_pi_baseline() 佔了近 99.9％，跟預期一樣，此函式是程式中的「熱點」！有了一些感覺後，後面會詳細一點介紹 perf 用法。</p>
<h2 id="背景知識"><a class="header" href="#背景知識">背景知識</a></h2>
<p>以下節錄上海交大通信與電子工程系的劉明寫的文章：</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">Perf – Linux下的系統性能調優工具</a></p>
<p><a href="https://zh.wikipedia.org/zh-tw/Wikipedia:%E7%B9%81%E7%B0%A1%E5%88%86%E6%AD%A7%E8%A9%9E%E8%A1%A8#.E7.A7.91.E6.8A.80">簡繁體中文詞彙對照：科技纇</a> (本課程斟酌修改詞彙，<code>==&gt;</code> 開頭表示補充)</p>
<ul>
<li><strong>背景知識</strong></li>
</ul>
<p>有些背景知識是分析性能問題時需要瞭解的。比如硬件 cache；再比如作業系統核心。應用程式的行為細節往往是和這些東西互相牽扯的，這些底層的東西會以意想不到的方式影響應用程式的性能，比如某些程式無法充分利用 cache，從而導致性能下降。比如不必要地呼叫過多的系統呼叫，造成頻繁的核心 / 使用者層級的切換 …等等。這裡只是為本文的後續內容做些概述，關於效能調校還有很多東西。</p>
<ul>
<li><strong>效能相關的處理器硬體特性，PMU 簡介</strong></li>
</ul>
<p>當演算法已趨於最佳化，程式碼不斷精簡，人們調到最後，便需要斤斤計較了。cache、pipeline 等平時不大注意的東西也必須精打細算了。</p>
<ul>
<li><strong>硬體特性之 cache</strong></li>
</ul>
<p>記憶體存取很快，但仍無法和處理器的指令執行速度相提並論。為了從記憶體中讀取指令 (instruction) 和資料 (data)，處理器需要等待，用處理器的時間來衡量，這種等待非常漫長。cache 是一種 SRAM，它的存取速率非常快，與處理器處理速度較為接近。因此將常用的資料保存在 cache 中，處理器便無須等待，從而提高效能。cache 的尺寸一般都很小，充分利用 cache 是軟體效能改善過程中，非常重要的部分。</p>
<ul>
<li><strong>硬體特性之 pipeline, superscalar, out-ot-order execution</strong></li>
</ul>
<p>提昇效能最有效的方式之一就是平行 (parallelism)。處理器在設計時也儘可能地平行，比如 pipeline, superscalar, out-of-execution。</p>
<p>處理器處理一條指令需要分多個步驟完成，比如 fetch 指令，然後完成運算，最後將計算結果輸出到匯流排 (bus) 上。在處理器內部，這可以看作一個三級 pipeline，如下圖處理器 pipeline 所示：</p>
<p><img src="linux_system/images/3stage_pipeline.gif" alt="img" /></p>
<p>指令從左邊進入處理器，上圖中的 pipeline 有三級，一個時鐘週期內可以同時處理三條指令，分別被 pipeline 的不同部分處理。</p>
<p>Superscalar 指一個時鐘週期觸發 (issue) 多條指令的 pipeline機器架構，比如 Intel 的 Pentium 處理器，內部有兩個執行單元，在一個時鐘週期內允許執行兩條指令。</p>
<p>==&gt; 這樣稱為 dual-issue，可想像為一個 packet 裡同時有兩組 pipelined 的 instruction</p>
<p>==&gt; 比方說，<a href="http://www.arm.com/products/processors/cortex-a/cortex-a5.php">Cortex-A5</a> 和 Cortex-A8 一樣採用 ARMv7-A 指令集，但是 Cortex-A5 是 Cortext-A8/A9 的精簡版，有以下差異：</p>
<p>1.pipeline 自 13 stages 減為 8 stages 2.instruction 自 dual-issue 減為 single-issue 3.NEON/FPU 為選配 4.不具有 L2 Cache</p>
<p>此外，在處理器內部，不同指令所需要的執行時間和時鐘週期是不同的，如果嚴格按照程序的執行順序執行，那麼就無法充分利用處理器的 pipeline。因此指令有可能被亂序執行 (out-of-order execution)。</p>
<p>上述三種平行技術對所執行的指令有一個基本要求，即相鄰的指令相互沒有依賴關係。假如某條指令需要依賴前面一條指令的執行結果數據，那麼 pipeline 便失去作用，因為第二條指令必須等待第一條指令完成。因此好的軟體必須儘量避免產生這種程式碼。</p>
<ul>
<li><strong>硬體特性之 branch prediction</strong></li>
</ul>
<p>branch prediction 指令對軟體效能影響較大。尤其是當處理器採用流水線設計之後，假設 pipeline 有三級，且目前進入 pipeline 的第一道指令為分支 (branch) 指令。假設處理器順序讀取指令，那麼如果分支的結果是跳躍到其他指令，那麼被處理器 pipeline 所 fetch 的後續兩條指令勢必被棄置 (來不及執行)，從而影響性能。為此，很多處理器都提供了 branch prediction，根據同一條指令的歷史執行記錄進行預測，讀取最可能的下一條指令，而並非順序讀取指令。</p>
<p>==&gt; 搭配簡報: <a href="http://www.cs.ucr.edu/%7Egupta/teaching/203A-09/My6.pdf">Branch Prediction</a></p>
<p>branch prediction 對軟體架構有些要求，對於重複性的分支指令序列，branch prediction 硬體才能得到較好的預測結果，而對於類似 switch-case 一類的程式結構，則往往不易得到理想的預測結果。</p>
<p>==&gt; 對照閱讀: <a href="http://igoro.com/archive/fast-and-slow-if-statements-branch-prediction-in-modern-processors/">Fast and slow if-statements: branch prediction in modern processors</a></p>
<p>==&gt; 編譯器提供的輔助機制: <a href="http://cellperformance.beyond3d.com/articles/2006/04/branch-patterns-using-gcc.html">Branch Patterns, Using GCC</a></p>
<p>上面介紹的幾種處理器特性對軟體效能影響很大，然而依賴時鐘進行定期採樣的 profiler 模式無法闡述程式對這些處理器硬體特性的使用情況。處理器廠商針對這種情況，在硬體中加入了 PMU (performance monitor unit)。PMU 允許硬體針對某種事件設置 counter，此後處理器便開始統計該事件的發生次數，當發生的次數超過 counter 內設定的數值後，便產生中斷。比如 cache miss 達到某個值後，PMU 便能產生相應的中斷。一旦捕獲這些中斷，便可分析程式對這些硬體特性的使用率了。</p>
<ul>
<li><strong>Tracepoints</strong></li>
</ul>
<p>Tracepoint 是散落在核心原始程式碼的一些 hook，一旦使能，在指定的程式碼被運行時，tracepoint 就會被觸發，這樣的特性可被各種 trace/debug 工具所使用，perf 就是這樣的案例。若你想知道在應用程式執行時期，核心記憶體管理模組的行為，即可透過潛伏在 slab 分配器中的 tracepoint。當核心運行到這些 tracepoint 時，便會通知 perf。</p>
<p>Perf 將 tracepoint 產生的事件記錄下來，生成報告，通過分析這些報告，效能分析調校的工程人員便可瞭解程式執行時期的核心種種細節，也能做出針對效能更準確的診斷。</p>
<h2 id="perf-基本使用"><a class="header" href="#perf-基本使用">Perf 基本使用</a></h2>
<p>前面有提到，Perf 能觸發的事件分為三類：</p>
<ul>
<li><strong>hardware</strong> : 由 PMU 產生的事件，比如 cache-misses、cpu-cycles、instructions、branch-misses …等等，通常是當需要瞭解程序對硬體特性的使用情況時會使用。</li>
<li><strong>software</strong> : 是核心程式產生的事件，比如 context-switches、page-faults、cpu-clock、cpu-migrations …等等。</li>
<li><strong>tracepoint</strong> : 是核心中的靜態 tracepoint 所觸發的事件，這些 tracepoint 用來判斷在程式執行時期，核心的行為細節，比如 slab 記憶體配置器的配置次數等。</li>
</ul>
<p>Perf 包含 20 幾種子工具集，不過我還沒碰過很多，我根據目前理解先介紹以下。 如果想看第一手資料</p>
<pre><code class="language-sh">$ perf help &lt;command&gt;
</code></pre>
<p>###perf list 這應該是大部分的人第一次安裝 perf 後所下的第一個指令，它能印出 perf 可以觸發哪些 event，不同 CPU 可能支援不同 hardware event，不同 kernel 版本支援的 software、tracepoint event 也不同。我的 perf 版本是<code>3.19.8</code>，所支援的 event 已經超過 1400 項（另外要列出 Tracepoint event 必須開啟 root 權限）。</p>
<pre><code class="language-sh">$ perf list
</code></pre>
<p><img src="linux_system/images/perf_list.png" alt="img" /></p>
<h3 id="perf-top"><a class="header" href="#perf-top">perf top</a></h3>
<p>perf top 其實跟平常 Linux 內建的 top 指令很相似。它能夠「即時」的分析各個函式在某個 event 上的熱點，找出拖慢系統的兇手，就如同上面那個範例一樣。甚至，即使沒有特定的程序要觀察，你也可以直接下達 <code>$ perf top</code> 指令來觀察是什麼程序吃掉系統效能，導致系統異常變慢。譬如我執行一個無窮迴圈：</p>
<pre><code class="language-c">int main() {
    long int i = 0;
    while(1) {
        i++;
        add(i);
        div(i);
    }
    return 0;
}
</code></pre>
<p>可以發現紅色熱點就出現了。右邊第一列為各函式的符號，左邊第一行是該符號引發的 event 在整個「監視域」中佔的比例，我們稱作該符號的熱度，監視域指的是 perf 監控的所有符號，預設值包括系統所有程序、核心以及核心 module 的函式，左邊第二行則為該符號所在的 Shared Object 。若符號旁顯示<code>[.]</code>表示其位於 User mode，<code>[k]</code>則為 kernel mode。</p>
<p><img src="linux_system/images/perf_top_while.png" alt="img" /></p>
<p>（當你關掉該程序之後，這個監視畫面 (tui 界面) 裡的該程序不會「馬上」消失，而是其 overhead 的比例一直減少然後慢慢離開列表）。</p>
<p>按下 <code>h</code>可以呼叫 help ，它會列出 perf top 的所有功能和對應按鍵。 我們來試看看 Annotate（註解），這功能可以進一步深入分析某個符號。使用方向鍵移到你有興趣的符號按下<code>a</code>。 它會顯示各條指令的 event 取樣率（耗時較多的部份就容易被 perf 取樣到）。</p>
<p><img src="linux_system/images/perf_top_annotate.png" alt="img" /></p>
<p>最後若你想要觀察其他 event ( 預設 cycles ) 和指定取樣頻率 ( 預設每秒4000次 ) :</p>
<pre><code>$ perf top -e cache-misses -c 5000
</code></pre>
<h3 id="perf-stat"><a class="header" href="#perf-stat">perf stat</a></h3>
<p>相較於 top，使用 perf stat 往往是你已經有個要優化的目標，對這個目標進行特定或一系列的 event 檢查，進而瞭解該程序的效能概況。（event 沒有指定的話，預設會有十種常用 event。） 我們來對以下程式使用 perf stat 工具 分析 cache miss 情形</p>
<pre><code class="language-c">static char array[10000][10000];
int main (void){
  int i, j;
  for (i = 0; i &lt; 10000; i++)
    for (j = 0; j &lt; 10000; j++)
       array[j][i]++;
  return 0;
}
</code></pre>
<pre><code class="language-sh">$ perf stat --repeat 5 -e cache-misses,cache-references,instructions,cycles ./perf_stat_cache_miss
    Performance counter stats for './perf_stat_cache_miss' (5 runs):
    4,416,226        cache-misses        #    3.437 % of all cache refs    ( +-  0.27% )
    128,483,262      cache-references                                      ( +-  0.02% )
    2,123,281,496    instructions        #    0.65  insns per cycle        ( +-  0.02% )
    3,281,498,034    cycles                                                ( +-  0.21% )
        1.299352302 seconds time elapsed                                   ( +-  0.19% )
</code></pre>
<p><code>--repeat &lt;n&gt;</code>或是<code>-r &lt;n&gt;</code> 可以重複執行 n 次該程序，並顯示每個 event 的變化區間。 <code>cache-misses,cache-references</code>和 <code>instructions,cycles</code>類似這種成對的 event，若同時出現 perf 會很貼心幫你計算比例。</p>
<p>根據這次 perf stat 結果可以明顯發現程序有很高的 cache miss，連帶影響 IPC 只有<code>0.65</code>。</p>
<p>如果我們善用一下存取的局部性，將 <code>i，j</code>對調改成<code>array[i][j]++</code>。</p>
<pre><code>    Performance counter stats for './perf_stat_cache_miss' (5 runs):
    2,263,131        cache-misses        #   93.742 % of all cache refs    ( +-  0.53% )
    2,414,202        cache-references                                      ( +-  1.82% )
    2,123,275,176    instructions        #    1.98  insns per cycle        ( +-  0.03% )
    1,074,868,730    cycles                                                ( +-  1.96% )
        0.432727146 seconds time elapsed                                   ( +-  1.99% )
</code></pre>
<p>cache-references 從 <code>128,483,262</code>下降到 <code>2,414,202</code>，差了五十幾倍，執行時間也縮短為原來的三分之一！</p>
<p>###perf record &amp; perf report 有別於 stat，record 可以針對函式級別進行 event 統計，方便我們對程序「熱點」作更精細的分析和優化。 我們來對以下程式，使用 perf record 進行 branch 情況分析</p>
<pre><code class="language-c">#define N 5000000
static int array[N] = { 0 };
void normal_loop(int a) {
    int i;
    for (i = 0; i &lt; N; i++)
        array[i] = array[i]+a;
}
void unroll_loop(int a) {
    int i;
    for (i = 0; i &lt; N; i+=5){
        array[i] = array[i]+1;
        array[i+1] = array[i+1]+a;
        array[i+2] = array[i+2]+a;
        array[i+3] = array[i+3]+a;
        array[i+4] = array[i+4]+a;
    }
}
int main() {
    normal_loop(1);
    unroll_loop(1);
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example
$ perf report
</code></pre>
<p><code>:u</code>是讓 perf 只統計發生在 user space 的 event。最後可以觀察到迴圈展開前後 branch-instructions 的差距。</p>
<p>另外，使用 record 有可能會碰到的問題是取樣頻率太低，有些函式的訊息沒有沒顯示出來（沒取樣到），這時可以使用 <code>-F &lt;frequcncy&gt;</code>來調高取樣頻率，可以輸入以下查看最大值，要更改也沒問題，但能調到多大可能還要查一下。</p>
<pre><code class="language-sh">$ cat /proc/sys/kernel/perf_event_max_sample_rate
</code></pre>
<h2 id="參考資料-5"><a class="header" href="#參考資料-5">參考資料</a></h2>
<ul>
<li><a href="http://www.brendangregg.com/linuxperf.html">Linux Performance</a></li>
<li><a href="https://perf.wiki.kernel.org/index.php/Tutorial#Sample_analysis_with_perf_report">Tutorial - Linux kernel profiling with perf</a> [Perf wiki]</li>
<li>Perf - Linux下的系統性能調優工具 / 劉明 [IBM developerWorks]
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">第一部分 - 簡介、背景知識、基本使用</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/index.html">第二部分 - tracepoint、probe、sched、bench、lock、Kmem、timechart、使用 Script 增強 perf 的功能</a></li>
</ul>
</li>
<li><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Performance_Monitoring_Unit.pdf">A Study of Performance Monitoring Unit, perf and perf_events subsystem</a> [PDF]</li>
<li><a href="http://kernel.taobao.org/index.php?title=Documents/Perf_FAQ">Perf FAQ</a> [kernel.taobao.org]</li>
<li><a href="http://unix.stackexchange.com/questions/14227/do-i-need-root-admin-permissions-to-run-userspace-perf-tool-perf-events-ar">Do I need root (admin) permissions to run userspace ‘perf’ tool?</a></li>
<li><a href="http://www.carbondesignsystems.com/virtual-prototype-blog/using-the-arm-performance-monitor-unit-pmu-linux-driver">Using the ARM Performance Monitor Unit (PMU) Linux Driver</a></li>
<li><a href="http://blog.csdn.net/trochiluses/article/details/17346803">perf 性能分析實例——使用perf優化cache利用率</a> [CSDN]</li>
</ul>
<h2 id="context-switches"><a class="header" href="#context-switches">Context Switches</a></h2>
<p>Context Switches  上下文切換，有時也被稱為處理程序切換(process switch)或任務切換。是一個重要的性能指標。</p>
<p>CPU從一個執行緒切換到另外一個執行緒，需要保存當前任務的運行環境，恢復將要運行任務的運行環境，必然帶來性能消耗。</p>
<p>Context Switches 上下文切換簡介</p>
<p>作業系統可以同時運行多個處理程序， 然而一顆CPU同時只能執行一項任務，作業系統利用時間片輪轉的方式，讓使用者感覺這些任務正在同時進行。 CPU給每個任務都服務一定的時間, 然後把當前任務的狀態保存下來, 在載入下一任務的狀態後, 繼續服務下一任務。任務的狀態保存及再載入, 這段過程就叫做上下文切換。</p>
<p>時間片輪轉的方式使多個任務在同一顆CPU上執行變成了可能, 但同時也帶來了保存現場和載入現場的直接消耗。</p>
<p>上下文切換的性能消耗</p>
<p>Context Switchs過高，導致CPU就像個搬運工一樣，頻繁在暫存器(CPU Register)和運行佇列(run queue)之間奔波，系統更多的時間都花費線上程切換上，而不是花在真正做有用工作的執行緒上。</p>
<p>直接消耗包括: CPU暫存器需要保存和載入, 系統調度器的程式碼需要執行, TLB實例需要重新載入, CPU 的pipeline需要刷掉。</p>
<p>間接消耗：多核的cache之間得共享資料。間接消耗對於程序的影響要看執行緒工作區運算元據的大小。</p>
<p>性能分析查看Context Switches的方法</p>
<p>Linux中可以通過工具vmstat, dstat, pidstat來觀察CS的切換情況。vmstat, dstat只能觀察整個系統的切換情況，而pidstat可以更精確地觀察某個處理程序的上下文切換情況。</p>
<p>最常見的，在一些<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E7%A8%8B">排程</a>（scheduling）<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">演算法</a>內，其中行程有時候需要暫時離開CPU，讓另一個行程進來CPU運作。在先佔式多工系統中，每一個行程都將輪流執行不定長度的時間，這些時間段落稱為<a href="https://zh.wikipedia.org/wiki/%E6%99%82%E9%96%93%E7%89%87">時間片</a>。如果行程並非自願讓出CPU(例如執行<a href="https://zh.wikipedia.org/wiki/I/O">I/O</a>操作時，行程就需放棄CPU使用權)，當時限到時，系統將產生一個定時中斷，<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%B5%B1">作業系統</a>將排定由其它的行程來執行。此機制用以確保CPU不致被較依賴處理器<a href="https://zh.wikipedia.org/wiki/%E9%81%8B%E7%AE%97">運算</a>的行程壟斷。若無定時中斷，除非行程自願讓出CPU，否則該行程將持續執行。對於擁有較多I/O<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>的行程，往往執行不了多久，便需要讓出CPU；而較依賴處理器的行程相對而言I/O操作較少，反而能一直持續使用CPU，便形成了<a href="https://zh.wikipedia.org/wiki/%E7%8D%A8%E4%BD%94">壟斷</a>現象。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1天玩轉c-socket通信技術"><a class="header" href="#1天玩轉c-socket通信技術">1天玩轉c++ socket通信技術</a></h2>
<p>socket是什麼意思
在計算機通信領域，socket 被翻譯為“套接字”，它是計算機之間進行通信的一種約定或一種方式。通過 socket 這種約定，一臺計算機可以接收其他計算機的數據，也可以向其他計算機發送數據。</p>
<p>socket 的典型應用就是 Web 服務器和瀏覽器：瀏覽器獲取用戶輸入的URL，向服務器發起請求，服務器分析接收到的URL，將對應的網頁內容返回給瀏覽器，瀏覽器再經過解析和渲染，就將文字、圖片、視頻等元素呈現給用戶。</p>
<p><strong>學習 socket，也就是學習計算機之間如何通信，並編寫出實用的程序。</strong></p>
<p>IP地址（IP Address）</p>
<p>計算機分佈在世界各地，要想和它們通信，必須要知道確切的位置。確定計算機位置的方式有多種，IP 地址是最常用的，例如，114.114.114.114 是國內第一個、全球第三個開放的 DNS 服務地址，127.0.0.1 是本機地址。</p>
<p>其實，我們的計算機並不知道 IP 地址對應的地理位置，當要通信時，只是將 IP 地址封裝到要發送的數據包中，交給路由器去處理。路由器有非常智能和高效的算法，很快就會找到目標計算機，並將數據包傳遞給它，完成一次單向通信。</p>
<p>目前大部分軟件使用 IPv4 地址，但 IPv6 也正在被人們接受，尤其是在教育網中，已經大量使用。
端口（Port）</p>
<p>有了 IP 地址，雖然可以找到目標計算機，但仍然不能進行通信。一臺計算機可以同時提供多種網絡服務，例如Web服務、FTP服務（文件傳輸服務）、SMTP服務（郵箱服務）等，僅有 IP 地址，計算機雖然可以正確接收到數據包，但是卻不知道要將數據包交給哪個網絡程序來處理，所以通信失敗。</p>
<p>為了區分不同的網絡程序，計算機會為每個網絡程序分配一個<strong>獨一無二的端口號（Port Number）</strong>，例如，Web服務的端口號是 80，FTP 服務的端口號是 21，SMTP 服務的端口號是 25。</p>
<p>**端口（Port）是一個虛擬的、**邏輯上的概念。可以將端口理解為一道門，數據通過這道門流入流出，每道門有不同的編號，就是端口號。如下圖所示：</p>
<p><img src="linux_system/images/66281a4d983e05b518813d57f836ea2aee1a6f1c.jpg@204w_278h_progressive.webp" alt="" /></p>
<p>協議（Protocol）</p>
<p>協議（Protocol）就是網絡通信的約定，通信的雙方必須都遵守才能正常收發數據。協議有很多種，例如 TCP、UDP、IP 等，通信的雙方必須使用同一協議才能通信。協議是一種規範，由計算機組織制定，規定了很多細節，例如，如何建立連接，如何相互識別等。
協議僅僅是一種規範，必須由計算機軟件來實現。例如 IP 協議規定了如何找到目標計算機，那麼各個開發商在開發自己的軟件時就必須遵守該協議，不能另起爐灶。
所謂協議族（Protocol Family），就是一組協議（多個協議）的統稱。最常用的是 TCP/IP 協議族，它包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百個互為關聯的協議，由於 TCP、IP 是兩種常用的底層協議，所以把它們統稱為 TCP/IP 協議族。
數據傳輸方式</p>
<p>計算機之間有很多數據傳輸方式，各有優缺點，常用的有兩種：SOCK_STREAM 和 SOCK_DGRAM。</p>
<ol>
<li>
<p>SOCK_STREAM 表示面向連接的數據傳輸方式。數據可以準確無誤地到達另一臺計算機，如果損壞或丟失，可以重新發送，但效率相對較慢。常見的 http 協議就使用 SOCK_STREAM 傳輸數據，因為要確保數據的正確性，否則網頁不能正常解析。</p>
</li>
<li>
<p>SOCK_DGRAM 表示無連接的數據傳輸方式。計算機只管傳輸數據，不作數據校驗，如果數據在傳輸中損壞，或者沒有到達另一臺計算機，是沒有辦法補救的。也就是說，數據錯了就錯了，無法重傳。因為 SOCK_DGRAM 所做的校驗工作少，所以效率比 SOCK_STREAM 高。</p>
</li>
</ol>
<p>QQ 視頻聊天和語音聊天就使用 SOCK_DGRAM 傳輸數據，因為首先要保證通信的效率，儘量減小延遲，而數據的正確性是次要的，即使丟失很小的一部分數據，視頻和音頻也可以正常解析，最多出現噪點或雜音，不會對通信質量有實質的影響。
注意：SOCK_DGRAM 沒有想象中的糟糕，不會頻繁的丟失數據，數據錯誤只是小概率事件。
有可能多種協議使用同一種數據傳輸方式，所以在 socket 編程中，需要同時指明數據傳輸方式和協議。</p>
<p>綜上所述：IP地址和端口能夠在廣袤的互聯網中定位到要通信的程序，協議和數據傳輸方式規定了如何傳輸數據，有了這些，兩臺計算機就可以通信了。</p>
<p>網路程式設計就是編寫程序使兩臺聯網的電腦相互交換資料。這就是全部內容了嗎？是的！網路程式設計要比想像中的簡單許多。</p>
<p>那麼，這兩臺電腦之間用什麼傳輸資料呢？首先需要物理連接。如今大部分電腦都已經連接到網際網路，因此不用擔心這一點。</p>
<p>在此基礎上，只需要考慮如何編寫資料傳輸程序。但實際上這點也不用愁，因為作業系統已經提供了 <a href="http://c.biancheng.net/socket/">socket</a>。即使對網路資料傳輸的原理不太熟悉，我們也能通過 socket 來程式設計。</p>
<h2 id="什麼是-socket"><a class="header" href="#什麼是-socket">什麼是 socket？</a></h2>
<p>socket 的原意是“插座”，在電腦通訊領域，socket 被翻譯為“套接字”，它是電腦之間進行通訊的一種約定或一種方式。通過 socket 這種約定，一臺電腦可以接收其他電腦的資料，也可以向其他電腦傳送資料。</p>
<p>我們把插頭插到插座上就能從電網獲得電力供應，同樣，為了與遠端電腦進行資料傳輸，需要連接到網際網路，而 socket 就是用來連接到網際網路的工具。</p>
<p><img src="linux_system/images/1-1Z1231A00X07.jpg" alt="socket是什麼？" /></p>
<p>socket 的典型應用就是 Web 伺服器和瀏覽器：瀏覽器獲取使用者輸入的 URL，向伺服器發起請求，伺服器分析接收到的 URL，將對應的網頁內容返回給瀏覽器，瀏覽器再經過解析和渲染，就將文字、圖片、視訊等元素呈現給使用者。</p>
<p>學習 socket，也就是學習電腦之間如何通訊，並編寫出實用的程序。</p>
<h2 id="unixlinux-中的-socket-是什麼"><a class="header" href="#unixlinux-中的-socket-是什麼">UNIX/Linux 中的 socket 是什麼？</a></h2>
<p>在 UNIX/Linux 系統中，為了統一對各種硬體的操作，簡化介面，不同的硬體裝置也都被看成一個檔案。對這些檔案的操作，等同於對磁碟上普通檔案的操作。</p>
<p>你也許聽很多高手說過，UNIX/Linux 中的一切都是檔案！那個傢伙說的沒錯。</p>
<p>為了表示和區分已經打開的檔案，UNIX/Linux 會給每個檔案分配一個 ID，這個 ID 就是一個整數，被稱為檔案描述符（File Descriptor）。例如：</p>
<ul>
<li>通常用 0 來表示標準輸入檔案（stdin），它對應的硬體裝置就是鍵盤；</li>
<li>通常用 1 來表示標準輸出檔案（stdout），它對應的硬體裝置就是顯示器。</li>
</ul>
<p>UNIX/Linux 程序在執行任何形式的 I/O 操作時，都是在讀取或者寫入一個檔案描述符。一個檔案描述符只是一個和打開的檔案相關聯的整數，它的背後可能是一個硬碟上的普通檔案、FIFO、管道、終端、鍵盤、顯示器，甚至是一個網路連線。</p>
<p>請注意，網路連線也是一個檔案，它也有檔案描述符！你必須理解這句話。</p>
<p>我們可以通過 socket() 函數來建立一個網路連線，或者說打開一個網路檔案，socket() 的返回值就是檔案描述符。有了檔案描述符，我們就可以使用普通的檔案操作函數來傳輸資料了，例如：</p>
<ul>
<li>用 read() 讀取從遠端電腦傳來的資料；</li>
<li>用 write() 向遠端電腦寫入資料。</li>
</ul>
<p>你看，只要用 socket() 建立了連接，剩下的就是檔案操作了，網路程式設計原來就是如此簡單！</p>
<h2 id="window-系統中的-socket-是什麼"><a class="header" href="#window-系統中的-socket-是什麼">Window 系統中的 socket 是什麼？</a></h2>
<p>Windows 也有類似“檔案描述符”的概念，但通常被稱為“檔案控制代碼”。因此，本教學如果涉及 Windows 平臺將使用“控制代碼”，如果涉及 Linux 平臺則使用“描述符”。</p>
<p>與 UNIX/Linux 不同的是，Windows 會區分 socket 和檔案，Windows 就把 socket 當做一個網路連線來對待，因此需要呼叫專門針對 socket 而設計的資料傳輸函數，針對普通檔案的輸入輸出函數就無效了。</p>
<h1 id="套接字有哪些類型socket有哪些類型"><a class="header" href="#套接字有哪些類型socket有哪些類型">套接字有哪些類型？socket有哪些類型？</a></h1>
<p>這個世界上有很多種套接字（<a href="http://c.biancheng.net/socket/">socket</a>），比如 DARPA Internet 地址（Internet 套接字）、本地節點的路徑名（Unix套接字）、CCITT X.25地址（X.25 套接字）等。但本教學只講第一種套接字——Internet 套接字，它是最具代表性的，也是最經典最常用的。以後我們提及套接字，指的都是 Internet 套接字。</p>
<p>根據資料的傳輸方式，可以將 Internet 套接字分成兩種類型。通過 socket() 函數建立連接時，必須告訴它使用哪種資料傳輸方式。</p>
<blockquote>
<p>Internet 套接字其實還有很多其它資料傳輸方式，但是我可不想嚇到你，本教學只講常用的兩種。</p>
</blockquote>
<h2 id="流格式套接字sock_stream"><a class="header" href="#流格式套接字sock_stream">流格式套接字（SOCK_STREAM）</a></h2>
<p>流格式套接字（Stream Sockets）也叫“面向連接的套接字”，在程式碼中使用 SOCK_STREAM 表示。</p>
<p>SOCK_STREAM 是一種可靠的、雙向的通訊資料流，資料可以精準無誤地到達另一臺電腦，如果損壞或丟失，可以重新傳送。</p>
<blockquote>
<p>流格式套接字有自己的糾錯機制，在此我們就不討論了。</p>
</blockquote>
<p>SOCK_STREAM 有以下幾個特徵：</p>
<ul>
<li>資料在傳輸過程中不會消失；</li>
<li>資料是按照順序傳輸的；</li>
<li>資料的傳送和接收不是同步的（有的教學也稱“不存在資料邊界”）。</li>
</ul>
<p>可以將 SOCK_STREAM 比喻成一條傳送帶，只要傳送帶本身沒有問題（不會斷網），就能保證資料不丟失；同時，較晚傳送的資料不會先到達，較早傳送的資料不會晚到達，這就保證了資料是按照順序傳遞的。</p>
<p><img src="linux_system/images/1-1Z1232154153L.gif" alt="將面向連接的套接字比喻成傳送帶" /></p>
<p>為什麼流格式套接字可以達到高品質的資料傳輸呢？這是因為它使用了 TCP 協議（The Transmission Control Protocol，傳輸控制協議），TCP 協議會控制你的資料按照順序到達並且沒有錯誤。</p>
<p>你也許見過 TCP，是因為你經常聽說“TCP/IP”。TCP 用來確保資料的正確性，IP（Internet Protocol，網路協議）用來控制資料如何從源頭到達目的地，也就是常說的“路由”。</p>
<p>那麼，“資料的傳送和接收不同步”該如何理解呢？</p>
<p>假設傳送帶傳送的是水果，接收者需要湊齊 100 個後才能裝袋，但是傳送帶可能把這 100 個水果分批傳送，比如第一批傳送 20 個，第二批傳送 50 個，第三批傳送 30 個。接收者不需要和傳送帶保持同步，只要根據自己的節奏來裝袋即可，不用管傳送帶傳送了幾批，也不用每到一批就裝袋一次，可以等到湊夠了 100 個水果再裝袋。</p>
<p>流格式套接字的內部有一個緩衝區（也就是字元陣列），通過 socket 傳輸的資料將保存到這個緩衝區。接收端在收到資料後並不一定立即讀取，只要資料不超過緩衝區的容量，接收端有可能在緩衝區被填滿以後一次性地讀取，也可能分成好幾次讀取。</p>
<p>也就是說，不管資料分幾次傳送過來，接收端只需要根據自己的要求讀取，不用非得在資料到達時立即讀取。傳送端有自己的節奏，接收端也有自己的節奏，它們是不一致的。</p>
<p>流格式套接字有什麼實際的應用場景嗎？瀏覽器所使用的 http 協議就基於面向連接的套接字，因為必須要確保資料精準無誤，否則載入的 HTML 將無法解析。</p>
<h2 id="資料報格式套接字sock_dgram"><a class="header" href="#資料報格式套接字sock_dgram">資料報格式套接字（SOCK_DGRAM）</a></h2>
<p>資料報格式套接字（Datagram Sockets）也叫“無連接的套接字”，在程式碼中使用 SOCK_DGRAM 表示。</p>
<p>電腦只管傳輸資料，不作資料校驗，如果資料在傳輸中損壞，或者沒有到達另一臺電腦，是沒有辦法補救的。也就是說，資料錯了就錯了，無法重傳。</p>
<p>因為資料報套接字所做的校驗工作少，所以在傳輸效率方面比流格式套接字要高。</p>
<p>可以將 SOCK_DGRAM 比喻成高速移動的摩托車快遞，它有以下特徵：</p>
<ul>
<li>強調快速傳輸而非傳輸順序；</li>
<li>傳輸的資料可能丟失也可能損毀；</li>
<li>限制每次傳輸的資料大小；</li>
<li>資料的傳送和接收是同步的（有的教學也稱“存在資料邊界”）。</li>
</ul>
<p>眾所周知，速度是快遞行業的生命。用摩托車發往同一地點的兩件包裹無需保證順序，只要以最快的速度交給客戶就行。這種方式存在損壞或丟失的風險，而且包裹大小有一定限制。因此，想要傳遞大量包裹，就得分配傳送。</p>
<p><img src="linux_system/images/1-1Z123222015527.gif" alt="將無連接套接字比喻成摩托車快遞" /></p>
<p>另外，用兩輛摩托車分別傳送兩件包裹，那麼接收者也需要分兩次接收，所以“資料的傳送和接收是同步的”；換句話說，接收次數應該和傳送次數相同。</p>
<p>總之，資料報套接字是一種不可靠的、不按順序傳遞的、以追求速度為目的的套接字。</p>
<p>資料報套接字也使用 IP 協議作路由，但是它不使用 TCP 協議，而是使用 UDP 協議（User Datagram Protocol，使用者資料報協議）。</p>
<p>QQ 視訊聊天和語音聊天就使用 SOCK_DGRAM 來傳輸資料，因為首先要保證通訊的效率，儘量減小延遲，而資料的正確性是次要的，即使丟失很小的一部分資料，視訊和音訊也可以正常解析，最多出現噪點或雜音，不會對通訊質量有實質的影響。</p>
<h1 id="osi網路七層模型"><a class="header" href="#osi網路七層模型">OSI網路七層模型</a></h1>
<p>如果你讀過電腦專業，或者學習過網路通訊，那你一定聽說過 OSI 模型，它曾無數次讓你頭大。OSI 是 Open System Interconnection 的縮寫，譯為“開放式系統互聯”。</p>
<p>OSI 模型把網路通訊的工作分為 7 層，從下到上分別是物理層、資料鏈路層、網路層、傳輸層、會話層、表示層和應用層。</p>
<p>OSI 只是存在於概念和理論上的一種模型，它的缺點是分層太多，增加了網路工作的複雜性，所以沒有大規模應用。後來人們對 OSI 進行了簡化，合併了一些層，最終只保留了 4 層，從下到上分別是介面層、網路層、傳輸層和應用層，這就是大名鼎鼎的 TCP/IP 模型。</p>
<p><img src="linux_system/images/1-1Z1241445324H.jpg" alt="OSI 七層網路模型和 TCP/IP 四層網路模型的對比" />
圖1：OSI 七層網路模型和 TCP/IP 四層網路模型的對比</p>
<p>這個網路模型究竟是幹什麼呢？簡而言之就是進行資料封裝的。</p>
<p>我們平常使用的程序（或者說軟體）一般都是通過應用層來訪問網路的，程序產生的資料會一層一層地往下傳輸，直到最後的網路介面層，就通過網線傳送到網際網路上去了。資料每往下走一層，就會被這一層的協議增加一層包裝，等到傳送到網際網路上時，已經比原始資料多了四層包裝。整個資料封裝的過程就像俄羅斯套娃。</p>
<p>當另一臺電腦接收到封包時，會從網路介面層再一層一層往上傳輸，每傳輸一層就拆開一層包裝，直到最後的應用層，就得到了最原始的資料，這才是程序要使用的資料。</p>
<p>給資料加包裝的過程，實際上就是在資料的頭部增加一個標誌（一個資料區塊），表示資料經過了這一層，我已經處理過了。給資料拆包裝的過程正好相反，就是去掉資料頭部的標誌，讓它逐漸現出原形。</p>
<p>你看，在網際網路上傳輸一份資料是多麼地複雜啊，而我們卻感受不到，這就是網路模型的厲害之處。我們只需要在程式碼中呼叫一個函數，就能讓下面的所有網路層為我們工作。</p>
<p>我們所說的 <a href="http://c.biancheng.net/socket/">socket</a> 程式設計，是站在傳輸層的基礎上，所以可以使用 TCP/UDP 協議，但是不能幹「訪問網頁」這樣的事情，因為訪問網頁所需要的 http 協議位於應用層。</p>
<p>兩臺電腦進行通訊時，必須遵守以下原則：</p>
<ul>
<li>必須是同一層次進行通訊，比如，A 電腦的應用層和 B 電腦的傳輸層就不能通訊，因為它們不在一個層次，資料的拆包會遇到問題。</li>
<li>每一層的功能都必須相同，也就是擁有完全相同的網路模型。如果網路模型都不同，那不就亂套了，誰都不認識誰。</li>
<li>資料只能逐層傳輸，不能躍層。</li>
<li>每一層可以使用下層提供的服務，並向上層提供服務。</li>
</ul>
<h1 id="tcpip協議族"><a class="header" href="#tcpip協議族">TCP/IP協議族</a></h1>
<p>上節《OSI網路七層模型》中講到，目前實際使用的網路模型是 TCP/IP 模型，它對 OSI 模型進行了簡化，只包含了四層，從上到下分別是應用層、傳輸層、網路層和鏈路層（網路介面層），每一層都包含了若干協議。</p>
<p>協議（Protocol）就是網路通訊過程中的約定或者合同，通訊的雙方必須都遵守才能正常收發資料。協議有很多種，例如 TCP、UDP、IP 等，通訊的雙方必須使用同一協議才能通訊。協議是一種規範，由電腦組織制定，規定了很多細節，例如，如何建立連接，如何相互識別等。</p>
<blockquote>
<p>協議僅僅是一種規範，必須由電腦軟體來實現。例如 IP 協議規定了如何找到目標電腦，那麼各個開發商在開發自己的軟體時就必須遵守該協議，不能另起爐灶。</p>
</blockquote>
<p>TCP/IP 模型包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百個互為關聯的協議，其中 TCP 和 IP 是最常用的兩種底層協議，所以把它們統稱為“TCP/IP 協議族”。</p>
<p>也就是說，“TCP/IP模型”中所涉及到的協議稱為“TCP/IP協議族”，你可以區分這兩個概念，也可以認為它們是等價的，隨便你怎麼想。</p>
<p>本教學所講的 <a href="http://c.biancheng.net/socket/">socket</a> 程式設計是基於 TCP 和 UDP 協議的，它們的層級關係如下圖所示：</p>
<p><img src="linux_system/images/1-1Z126104435N0.gif" alt="TCP/IP協議的層次圖" /></p>
<h2 id="擴展閱讀開放式系統open-system"><a class="header" href="#擴展閱讀開放式系統open-system">【擴展閱讀】開放式系統（Open System）</a></h2>
<p>把協議分成多個層次有哪些優點？協議設計更容易？當然這也足以成為優點之一。但是還有更重要的原因，就是為了通過標準化操作設計成開放式系統。</p>
<p>標準本身就是對外公開的，會引導更多的人遵守規範。以多個標準為依據設計的系統稱為開放式系統（Open System），我們現在學習的 TCP/IP 協議族也屬於其中之一。</p>
<p>接下來瞭解一下開放式系統具有哪些優點。</p>
<p>路由器用來完成 IP 層的互動任務。某個網路原來使用 A 公司的路由器，現要將其替換成 B 公司的，是否可行？這並非難事，並不一定要換成同一公司的同一型號路由器，因為所有生產商都會按照 IP 層標準製造。</p>
<p>再舉個例子。大家的電腦是否裝有網路介面卡，也就是所謂的網路卡？尚未安裝也無妨，其實很容易買到，因為所有網路卡製造商都會遵守鏈路層的協議標準。這就是開放式系統的優點。</p>
<p>標準的存在意味著高速的技術發展，這也是開放式系統設計最大的原因所在。實際上，軟體工程中的“物件導向（Object Oriented）”的誕生背景中也有標準化的影子。也就是說，標準對於技術發展起著舉足輕重的作用。</p>
<h1 id="ipmac和連接埠號網路通訊中確認身份資訊的三要素"><a class="header" href="#ipmac和連接埠號網路通訊中確認身份資訊的三要素">IP、MAC和連接埠號——網路通訊中確認身份資訊的三要素</a></h1>
<p>在茫茫的網際網路海洋中，要找到一臺電腦非常不容易，有三個要素必須具備，它們分別是 IP 地址、MAC 地址和連接埠號。</p>
<h2 id="ip地址"><a class="header" href="#ip地址">IP地址</a></h2>
<p>IP地址是 Internet Protocol Address 的縮寫，譯為“網際協議地址”。</p>
<p>目前大部分軟體使用 IPv4 地址，但 IPv6 也正在被人們接受，尤其是在教育網中，已經大量使用。</p>
<p>一臺電腦可以擁有一個獨立的 IP 地址，一個區域網路也可以擁有一個獨立的 IP 地址（對外就好像只有一臺電腦）。對於目前廣泛使用 IPv4 地址，它的資源是非常有限的，一臺電腦一個 IP 地址是不現實的，往往是一個區域網路才擁有一個 IP 地址。</p>
<p>在網際網路上進行通訊時，必須要知道對方的 IP 地址。實際上封包中已經附帶了 IP 地址，把封包傳送給路由器以後，路由器會根據 IP 地址找到對方的地裡位置，完成一次資料的傳遞。路由器有非常高效和智能的演算法，很快就會找到目標電腦。</p>
<h2 id="mac地址"><a class="header" href="#mac地址">MAC地址</a></h2>
<p>現實的情況是，一個區域網路往往才能擁有一個獨立的 IP；換句話說，IP 地址只能定位到一個區域網路，無法定位到具體的一臺電腦。這可怎麼辦呀？這樣也沒法通訊啊。</p>
<p>其實，真正能唯一標識一臺電腦的是 MAC 地址，每個網路卡的 MAC 地址在全世界都是獨一無二的。電腦出廠時，MAC 地址已經被寫死到網路卡裡面了（當然通過某些“奇巧淫技”也是可以修改的）。區域網路中的路由器/交換機會記錄每臺電腦的 MAC 地址。</p>
<blockquote>
<p>MAC 地址是 Media Access Control Address 的縮寫，直譯為“媒體存取控制地址”，也稱為區域網路地址（LAN Address），乙太網路地址（Ethernet Address）或實體位址（Physical Address）。</p>
</blockquote>
<p>封包中除了會附帶對方的 IP 地址，還會附帶對方的 MAC 地址，當封包達到區域網路以後，路由器/交換機會根據封包中的 MAC 地址找到對應的電腦，然後把封包轉交給它，這樣就完成了資料的傳遞。</p>
<h2 id="連接埠號"><a class="header" href="#連接埠號">連接埠號</a></h2>
<p>有了 IP 地址和 MAC 地址，雖然可以找到目標電腦，但仍然不能進行通訊。一臺電腦可以同時提供多種網路服務，例如 Web 服務（網站）、FTP 服務（檔案傳輸服務）、SMTP 服務（信箱服務）等，僅有 IP 地址和 MAC 地址，電腦雖然可以正確接收到封包，但是卻不知道要將封包交給哪個網路程序來處理，所以通訊失敗。</p>
<p>為了區分不同的網路程序，電腦會為每個網路程序分配一個獨一無二的連接埠號（Port Number），例如，Web 服務的連接埠號是 80，FTP 服務的連接埠號是 21，SMTP 服務的連接埠號是 25。</p>
<p>連接埠（Port）是一個虛擬的、邏輯上的概念。可以將連接埠理解為一道門，資料通過這道門流入流出，每道門有不同的編號，就是連接埠號。如下圖所示：</p>
<p><img src="linux_system/images/15060130Z-0.jpg" alt="img" /></p>
<h1 id="linux下的socket演示程序"><a class="header" href="#linux下的socket演示程序">Linux下的socket演示程序</a></h1>
<p>我們從一個簡單的“Hello World!”程序切入 <a href="http://c.biancheng.net/socket/">socket</a> 程式設計。</p>
<p>本節演示了 Linux 下的程式碼，server.cpp 是伺服器端程式碼，client.cpp 是客戶端程式碼，要實現的功能是：客戶端從伺服器讀取一個字串並列印出來。</p>
<p>伺服器端程式碼 server.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main()
{
    //建立套接字
    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    //將套接字和IP、連接埠繫結
    struct sockaddr_in serv_addr;
    memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每個位元組都用0填充
    serv_addr.sin_family = AF_INET;  //使用IPv4地址
    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具體的IP地址
    serv_addr.sin_port = htons(1234);  //連接埠
    bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));

    //進入監聽狀態，等待使用者發起請求
    listen(serv_sock, 20);

    //接收客戶端請求
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);
    int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr,
                           &amp;clnt_addr_size);

    //向客戶端傳送資料
    char str[] = &quot;http://c.biancheng.net/socket/&quot;;
    write(clnt_sock, str, sizeof(str));

    //關閉套接字
    close(clnt_sock);
    close(serv_sock);

    return 0;
}
</code></pre>
<p>客戶端程式碼 client.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;

int main()
{
    //建立套接字
    int sock = socket(AF_INET, SOCK_STREAM, 0);

    //向伺服器（特定的IP和連接埠）發起請求
    struct sockaddr_in serv_addr;
    memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每個位元組都用0填充
    serv_addr.sin_family = AF_INET;  //使用IPv4地址
    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具體的IP地址
    serv_addr.sin_port = htons(1234);  //連接埠
    connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));

    //讀取伺服器傳回的資料
    char buffer[40];
    read(sock, buffer, sizeof(buffer) - 1);

    printf(&quot;Message form server: %s\n&quot;, buffer);

    //關閉套接字
    close(sock);

    return 0;
}
</code></pre>
<p>啟動一個終端（Shell），先編譯 server.cpp 並運行：</p>
<p>[admin@localhost ~]$ g++ server.cpp -o server
[admin@localhost ~]$ ./server
#等待請求的到來</p>
<p>正常情況下，程式執行到 accept() 函數就會被阻塞，等待客戶端發起請求。</p>
<p>接下再啟動一個終端，編譯 client.cpp 並運行：</p>
<p>[admin@localhost ~]$ g++ client.cpp -o client
[admin@localhost ~]$ ./client
Message form server: http://c.biancheng.net/socket/</p>
<p>client 接收到從 server傳送過來的字串就運行結束了，同時，server 完成傳送字串的任務也運行結束了。大家可以通過兩個打開的終端來觀察。</p>
<p>client 運行後，通過 connect() 函數向 server 發起請求，處於監聽狀態的 server 被啟動，執行 accept() 函數，接受客戶端的請求，然後執行 write() 函數向 client 傳回資料。client 接收到傳回的資料後，connect() 就運行結束了，然後使用 read() 將資料讀取出來。</p>
<blockquote>
<p>server 只接受一次 client 請求，當 server 向 client 傳回資料後，程序就運行結束了。如果想再次接收到伺服器的資料，必須再次運行 server，所以這是一個非常簡陋的 socket 程序，不能夠一直接受客戶端的請求。</p>
</blockquote>
<h2 id="原始碼解析"><a class="header" href="#原始碼解析">原始碼解析</a></h2>
<ul>
<li>
<p>先說一下 server.cpp 中的程式碼。</p>
<ul>
<li>第 11 行通過 socket() 函數建立了一個套接字，參數 AF_INET 表示使用 IPv4 地址，SOCK_STREAM 表示使用面向連接的套接字，IPPROTO_TCP 表示使用 TCP 協議。在 Linux 中，socket 也是一種檔案，有檔案描述符，可以使用 write() / read() 函數進行 I/O 操作，這一點已在《<a href="http://c.biancheng.net/view/2123.html">socket是什麼</a>》中進行了講解。</li>
<li>第 19 行通過 bind() 函數將套接字 serv_sock 與特定的 IP 地址和連接埠繫結，IP 地址和連接埠都保存在 sockaddr_in 結構體中。</li>
<li>socket() 函數確定了套接字的各種屬性，bind() 函數讓套接字與特定的IP地址和連接埠對應起來，這樣客戶端才能連接到該套接字。</li>
<li>第 22 行讓套接字處於被動監聽狀態。所謂被動監聽，是指套接字一直處於“睡眠”中，直到客戶端發起請求才會被“喚醒”。</li>
<li>第 27 行的 accept() 函數用來接收客戶端的請求。程序一旦執行到 accept() 就會被阻塞（暫停運行），直到客戶端發起請求。</li>
<li>第 31 行的 write() 函數用來向套接字檔案中寫入資料，也就是向客戶端傳送資料。</li>
<li>和普通檔案一樣，socket 在使用完畢後也要用 close() 關閉。</li>
</ul>
</li>
<li>
<p>再說一下 client.cpp 中的程式碼。client.cpp 中的程式碼和 server.cpp 中有一些區別。</p>
<ul>
<li>第 19 行程式碼通過 connect() 向伺服器發起請求，伺服器的IP地址和連接埠號保存在 sockaddr_in 結構體中。直到伺服器傳回資料後，connect() 才運行結束。</li>
<li>第 23 行程式碼通過 read() 從套接字檔案中讀取資料。</li>
</ul>
</li>
</ul>
<h1 id="windows下的socket演示程序"><a class="header" href="#windows下的socket演示程序">Windows下的socket演示程序</a></h1>
<p>這節來看一下 Windows 下的 socket 程序。同樣，server.cpp 為伺服器端程式碼，client 為客戶端程式碼。</p>
<p>伺服器端程式碼 server.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#pragma comment (lib, &quot;ws2_32.lib&quot;)  //載入 ws2_32.dll

int main()
{
    //初始化 DLL
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    //建立套接字
    SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

    //繫結套接字
    struct sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;  //使用IPv4地址
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具體的IP地址
    sockAddr.sin_port = htons(1234);  //連接埠
    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));

    //進入監聽狀態
    listen(servSock, 20);

    //接收客戶端請求
    SOCKADDR clntAddr;
    int nSize = sizeof(SOCKADDR);
    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);

    //向客戶端傳送資料
    char* str = &quot;Hello World!&quot;;
    send(clntSock, str, strlen(str) + sizeof(char), NULL);

    //關閉套接字
    closesocket(clntSock);
    closesocket(servSock);

    //終止 DLL 的使用
    WSACleanup();

    return 0;
}
</code></pre>
<p>客戶端程式碼 client.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;WinSock2.h&gt;
#pragma comment(lib, &quot;ws2_32.lib&quot;)  //載入 ws2_32.dll

int main()
{
    //初始化DLL
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    //建立套接字
    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

    //向伺服器發起請求
    struct sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
    sockAddr.sin_port = htons(1234);
    connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));

    //接收伺服器傳回的資料
    char szBuffer[MAXBYTE] = {0};
    recv(sock, szBuffer, MAXBYTE, NULL);

    //輸出接收到的資料
    printf(&quot;Message form server: %s\n&quot;, szBuffer);

    //關閉套接字
    closesocket(sock);

    //終止使用 DLL
    WSACleanup();

    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>將 server.cpp 和 client.cpp 分別編譯為 server.exe 和 client.exe，先運行 server.exe，再運行 client.exe，輸出結果為：
Message form server: Hello World!</p>
<p>Windows 下的 socket 程序和 Linux 思路相同，但細節有所差別：</p>
<ul>
<li>Windows 下的 socket 程序依賴 Winsock.dll 或 ws2_32.dll，必須提前載入。DLL 有兩種載入方式，請查看：<a href="http://c.biancheng.net/cpp/html/2754.html">動態連結庫DLL的載入</a></li>
<li>Linux 使用“檔案描述符”的概念，而 Windows 使用“檔案控制代碼”的概念；Linux 不區分 socket 檔案和普通檔案，而 Windows 區分；Linux 下 socket() 函數的返回值為 int 類型，而 Windows 下為 SOCKET 類型，也就是控制代碼。</li>
<li>Linux 下使用 read() / write() 函數讀寫，而 Windows 下使用 recv() / send() 函數傳送和接收。</li>
<li>關閉 socket 時，Linux 使用 close() 函數，而 Windows 使用 closesocket() 函數。</li>
</ul>
<h1 id="socket函數用法詳解建立套接字"><a class="header" href="#socket函數用法詳解建立套接字">socket()函數用法詳解：建立套接字</a></h1>
<p>不管是 Windows 還是 Linux，都使用 <a href="http://c.biancheng.net/socket/">socket</a>() 函數來建立套接字。socket() 在兩個平臺下的參數是相同的，不同的是返回值。</p>
<p>在《<a href="http://c.biancheng.net/view/2123.html">socket是什麼</a>》一節中我們講到了 Windows 和 Linux 在對待 socket 方面的區別。</p>
<p>Linux 中的一切都是檔案，每個檔案都有一個整數類型的檔案描述符；socket 也是一個檔案，也有檔案描述符。使用 socket() 函數建立套接字以後，返回值就是一個 int 類型的檔案描述符。</p>
<p>Windows 會區分 socket 和普通檔案，它把 socket 當做一個網路連線來對待，呼叫 socket() 以後，返回值是 SOCKET 類型，用來表示一個套接字。</p>
<h2 id="linux-下的-socket-函數"><a class="header" href="#linux-下的-socket-函數">Linux 下的 socket() 函數</a></h2>
<p>在 Linux 下使用 &lt;sys/socket.h&gt; 標頭檔中 socket() 函數來建立套接字，原型為：</p>
<pre><code class="language-cpp">int socket(int af, int type, int protocol);
</code></pre>
<ul>
<li>af 為地址族（Address Family），也就是 IP 地址類型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的簡寫，INET是“Inetnet”的簡寫。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</li>
</ul>
<p>大家需要記住<code>127.0.0.1</code>，它是一個特殊IP地址，表示本機地址，後面的教學會經常用到。</p>
<blockquote>
<p>你也可以使用 PF 前綴，PF 是“Protocol Family”的簡寫，它和 AF 是一樣的。例如，PF_INET 等價於 AF_INET，PF_INET6 等價於 AF_INET6。</p>
</blockquote>
<ul>
<li>
<p>type 為資料傳輸方式/套接字類型，常用的有 SOCK_STREAM（流格式套接字/面向連接的套接字） 和 SOCK_DGRAM（資料報套接字/無連接的套接字），我們已經在《<a href="http://c.biancheng.net/view/2124.html">套接字有哪些類型</a>》一節中進行了介紹。</p>
</li>
<li>
<p>protocol 表示傳輸協議，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分別表示 TCP 傳輸協議和 UDP 傳輸協議。</p>
</li>
</ul>
<p>有了地址類型和資料傳輸方式，還不足以決定採用哪種協議嗎？為什麼還需要第三個參數呢？</p>
<p>正如大家所想，一般情況下有了 af 和 type 兩個參數就可以建立套接字了，作業系統會自動推演出協議類型，除非遇到這樣的情況：有兩種不同的協議支援同一種地址類型和資料傳輸類型。如果我們不指明使用哪種協議，作業系統是沒辦法自動推演的。</p>
<p>本教學使用 IPv4 地址，參數 af 的值為 PF_INET。如果使用 SOCK_STREAM 傳輸資料，那麼滿足這兩個條件的協議只有 TCP，因此可以這樣來呼叫 socket() 函數：</p>
<pre><code class="language-cpp">int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  //IPPROTO_TCP表示TCP協議
</code></pre>
<p>這種套接字稱為 TCP 套接字。</p>
<p>如果使用 SOCK_DGRAM 傳輸方式，那麼滿足這兩個條件的協議只有 UDP，因此可以這樣來呼叫 socket() 函數：</p>
<pre><code class="language-cpp">int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);  //IPPROTO_UDP表示UDP協議
</code></pre>
<p>這種套接字稱為 UDP 套接字。</p>
<p>上面兩種情況都只有一種協議滿足條件，可以將 protocol 的值設為 0，系統會自動推演出應該使用什麼協議，如下所示：</p>
<pre><code class="language-cpp">int tcp_socket = socket(AF_INET, SOCK_STREAM, 0);  //建立TCP套接字
int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);  //建立UDP套接字
</code></pre>
<p>後面的教學中多採用這種簡化寫法。</p>
<h2 id="在windows下建立socket"><a class="header" href="#在windows下建立socket">在Windows下建立socket</a></h2>
<p>Windows 下也使用 socket() 函數來建立套接字，原型為：</p>
<pre><code class="language-cpp">SOCKET socket(int af, int type, int protocol);
</code></pre>
<p>除了返回值類型不同，其他都是相同的。Windows 不把套接字作為普通檔案對待，而是返回 SOCKET 類型的控制代碼。請看下面的例子：</p>
<pre><code class="language-cpp">SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);  //建立TCP套接字
</code></pre>
<h1 id="bind和connect函數繫結套接字並建立連接"><a class="header" href="#bind和connect函數繫結套接字並建立連接">bind()和connect()函數：繫結套接字並建立連接</a></h1>
<p><a href="http://c.biancheng.net/socket/">socket</a>() 函數用來建立套接字，確定套接字的各種屬性，然後伺服器端要用 bind() 函數將套接字與特定的 IP 地址和連接埠繫結起來，只有這樣，流經該 IP 地址和連接埠的資料才能交給套接字處理。類似地，客戶端也要用 connect() 函數建立連接。</p>
<h2 id="bind-函數"><a class="header" href="#bind-函數">bind() 函數</a></h2>
<p>bind() 函數的原型為：</p>
<pre><code class="language-cpp">int bind(int sock, struct sockaddr *addr, socklen_t addrlen);  //Linux
int bind(SOCKET sock, const struct sockaddr *addr, int addrlen);  //Windows
</code></pre>
<blockquote>
<p>下面以 Linux 為例進行講解，Windows 與此類似。</p>
</blockquote>
<p>sock 為 socket 檔案描述符，addr 為 sockaddr 結構體變數的指針，addrlen 為 addr 變數的大小，可由 sizeof() 計算得出。</p>
<p>下面的程式碼，將建立的套接字與IP地址 127.0.0.1、連接埠 1234 繫結：</p>
<pre><code class="language-cpp">//建立套接字
int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

//建立sockaddr_in結構體變數
struct sockaddr_in serv_addr;
memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每個位元組都用0填充
serv_addr.sin_family = AF_INET;  //使用IPv4地址
serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具體的IP地址
serv_addr.sin_port = htons(1234);  //連接埠

//將套接字和IP、連接埠繫結
bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));
</code></pre>
<p>這裡我們使用 sockaddr_in 結構體，然後再強制轉換為 sockaddr 類型，後邊會講解為什麼這樣做。</p>
<h4 id="sockaddr_in-結構體"><a class="header" href="#sockaddr_in-結構體">sockaddr_in 結構體</a></h4>
<p>接下來不妨先看一下 sockaddr_in 結構體，它的成員變數如下：</p>
<pre><code class="language-cpp">struct sockaddr_in {
    sa_family_t
    sin_family;   //地址族（Address Family），也就是地址類型
    uint16_t        sin_port;     //16位的連接埠號
    struct in_addr  sin_addr;     //32位IP地址
    char            sin_zero[8];  //不使用，一般用0填充
};
</code></pre>
<ul>
<li>
<p>sin_family 和 socket() 的第一個參數的含義相同，取值也要保持一致。</p>
</li>
<li>
<p>sin_prot 為連接埠號。uint16_t 的長度為兩個位元組，理論上連接埠號的取值範圍為 0~65536，但 0~1023 的連接埠一般由系統分配給特定的服務程序，例如 Web 服務的連接埠號為 80，FTP 服務的連接埠號為 21，所以我們的程序要儘量在 1024~65536 之間分配連接埠號。連接埠號需要用 htons() 函數轉換，後面會講解為什麼。</p>
</li>
<li>
<p>sin_addr 是 struct in_addr 結構體類型的變數，下面會詳細講解。</p>
</li>
<li>
<p>sin_zero[8] 是多餘的8個位元組，沒有用，一般使用 memset() 函數填充為 0。上面的程式碼中，先用 memset() 將結構體的全部位元組填充為 0，再給前3個成員賦值，剩下的 sin_zero 自然就是 0 了。</p>
</li>
</ul>
<h4 id="in_addr-結構體"><a class="header" href="#in_addr-結構體">in_addr 結構體</a></h4>
<p>sockaddr_in 的第3個成員是 in_addr 類型的結構體，該結構體只包含一個成員，如下所示：</p>
<pre><code class="language-cpp">struct in_addr {
    in_addr_t  s_addr;  //32位的IP地址
};
</code></pre>
<p>in_addr_t 在標頭檔 &lt;netinet/in.h&gt; 中定義，等價於 unsigned long，長度為4個位元組。也就是說，s_addr 是一個整數，而IP地址是一個字串，所以需要 inet_addr() 函數進行轉換，例如：</p>
<pre><code class="language-cpp">unsigned long ip = inet_addr(&quot;127.0.0.1&quot;);
printf(&quot;%ld\n&quot;, ip);
</code></pre>
<p>運行結果：
16777343</p>
<p><img src="linux_system/images/112P63295-0.jpg" alt="img" />
圖解 sockaddr_in 結構體</p>
<p>為什麼要搞這麼複雜，結構體中巢狀結構體，而不用 sockaddr_in 的一個成員變數來指明IP地址呢？socket() 函數的第一個參數已經指明瞭地址類型，為什麼在 sockaddr_in 結構體中還要再說明一次呢，這不是囉嗦嗎？</p>
<p>這些繁瑣的細節確實給初學者帶來了一定的障礙，我想，這或許是歷史原因吧，後面的介面總要相容前面的程式碼。各位讀者一定要有耐心，暫時不理解沒有關係，根據教學中的程式碼“照貓畫虎”即可，時間久了自然會接受。</p>
<h4 id="為什麼使用-sockaddr_in-而不使用-sockaddr"><a class="header" href="#為什麼使用-sockaddr_in-而不使用-sockaddr">為什麼使用 sockaddr_in 而不使用 sockaddr</a></h4>
<p>bind() 第二個參數的類型為 sockaddr，而程式碼中卻使用 sockaddr_in，然後再強制轉換為 sockaddr，這是為什麼呢？</p>
<pre><code class="language-cpp">struct sockaddr {
    sa_family_t  sin_family;   //地址族（Address Family），也就是地址類型
    char         sa_data[14];  //IP地址和連接埠號
};
</code></pre>
<p>下圖是 sockaddr 與 sockaddr_in 的對比（括號中的數字表示所佔用的位元組數）：
<img src="linux_system/images/112PA615-1.jpg" alt="img" /></p>
<p>sockaddr 和 sockaddr_in 的長度相同，都是16位元組，只是將IP地址和連接埠號合併到一起，用一個成員 sa_data 表示。要想給 sa_data 賦值，必須同時指明IP地址和連接埠號，例如”127.0.0.1:80“，遺憾的是，沒有相關函數將這個字串轉換成需要的形式，也就很難給 sockaddr 類型的變數賦值，所以使用 sockaddr_in 來代替。這兩個結構體的長度相同，強制轉換類型時不會丟失位元組，也沒有多餘的位元組。</p>
<p>可以認為，sockaddr 是一種通用的結構體，可以用來保存多種類型的IP地址和連接埠號，而 sockaddr_in 是專門用來保存 IPv4 地址的結構體。另外還有 sockaddr_in6，用來保存 IPv6 地址，它的定義如下：</p>
<pre><code class="language-cpp">struct sockaddr_in6 {
    sa_family_t sin6_family;  //(2)地址類型，取值為AF_INET6
    in_port_t sin6_port;  //(2)16位連接埠號
    uint32_t sin6_flowinfo;  //(4)IPv6流資訊
    struct in6_addr sin6_addr;  //(4)具體的IPv6地址
    uint32_t sin6_scope_id;  //(4)介面範圍ID
};
</code></pre>
<p>正是由於通用結構體 sockaddr 使用不便，才針對不同的地址類型定義了不同的結構體。</p>
<h2 id="connect-函數"><a class="header" href="#connect-函數">connect() 函數</a></h2>
<p>connect() 函數用來建立連接，它的原型為：</p>
<pre><code class="language-cpp">int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen);  //Linux
int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen);  //Windows
</code></pre>
<p>各個參數的說明和 bind() 相同，不再贅述。</p>
<h1 id="listen和accept函數讓套接字進入監聽狀態並響應客戶端請求"><a class="header" href="#listen和accept函數讓套接字進入監聽狀態並響應客戶端請求">listen()和accept()函數：讓套接字進入監聽狀態並響應客戶端請求</a></h1>
<p>對於伺服器端程序，使用 bind() 繫結套接字後，還需要使用 listen() 函數讓套接字進入被動監聽狀態，再呼叫 accept() 函數，就可以隨時響應客戶端的請求了。</p>
<h2 id="listen-函數"><a class="header" href="#listen-函數">listen() 函數</a></h2>
<p>通過 listen() 函數可以讓套接字進入被動監聽狀態，它的原型為：</p>
<pre><code class="language-cpp">int listen(int sock, int backlog);  //Linux
int listen(SOCKET sock, int backlog);  //Windows
</code></pre>
<p>sock 為需要進入監聽狀態的套接字，backlog 為請求佇列的最大長度。</p>
<p>所謂被動監聽，是指當沒有客戶端請求時，套接字處於“睡眠”狀態，只有當接收到客戶端請求時，套接字才會被“喚醒”來響應請求。</p>
<h4 id="請求佇列"><a class="header" href="#請求佇列">請求佇列</a></h4>
<p>當套接字正在處理客戶端請求時，如果有新的請求進來，套接字是沒法處理的，只能把它放進緩衝區，待當前請求處理完畢後，再從緩衝區中讀取出來處理。如果不斷有新的請求進來，它們就按照先後順序在緩衝區中排隊，直到緩衝區滿。這個緩衝區，就稱為請求佇列（Request Queue）。</p>
<p>緩衝區的長度（能存放多少個客戶端請求）可以通過 listen() 函數的 backlog 參數指定，但究竟為多少並沒有什麼標準，可以根據你的需求來定，並行量小的話可以是10或者20。</p>
<p>如果將 backlog 的值設定為 SOMAXCONN，就由系統來決定請求佇列長度，這個值一般比較大，可能是幾百，或者更多。</p>
<p>當請求佇列滿時，就不再接收新的請求，對於 Linux，客戶端會收到 ECONNREFUSED 錯誤，對於 Windows，客戶端會收到 WSAECONNREFUSED 錯誤。</p>
<p>注意：listen() 只是讓套接字處於監聽狀態，並沒有接收請求。接收請求需要使用 accept() 函數。</p>
<h2 id="accept-函數"><a class="header" href="#accept-函數">accept() 函數</a></h2>
<p>當套接字處於監聽狀態時，可以通過 accept() 函數來接收客戶端請求。它的原型為：</p>
<pre><code class="language-cpp">int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);  //Linux
SOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen);  //Windows
</code></pre>
<p>它的參數與 listen() 和 connect() 是相同的：sock 為伺服器端套接字，addr 為 sockaddr_in 結構體變數，addrlen 為參數 addr 的長度，可由 sizeof() 求得。</p>
<p>accept() 返回一個新的套接字來和客戶端通訊，addr 保存了客戶端的IP地址和連接埠號，而 sock 是伺服器端的套接字，大家注意區分。後面和客戶端通訊時，要使用這個新生成的套接字，而不是原來伺服器端的套接字。</p>
<p>最後需要說明的是：listen() 只是讓套接字進入監聽狀態，並沒有真正接收客戶端請求，listen() 後面的程式碼會繼續執行，直到遇到 accept()。accept() 會阻塞程序執行（後面程式碼不能被執行），直到有新的請求到來。</p>
<h1 id="sendrecv和writeread傳送資料和接收資料"><a class="header" href="#sendrecv和writeread傳送資料和接收資料">send()/recv()和write()/read()：傳送資料和接收資料</a></h1>
<p>在 Linux 和 Windows 平臺下，使用不同的函數傳送和接收 <a href="http://c.biancheng.net/socket/">socket</a> 資料，下面我們分別講解。</p>
<h2 id="linux下資料的接收和傳送"><a class="header" href="#linux下資料的接收和傳送">Linux下資料的接收和傳送</a></h2>
<p>Linux 不區分套接字檔案和普通檔案，使用 write() 可以向套接字中寫入資料，使用 read() 可以從套接字中讀取資料。</p>
<p>前面我們說過，兩臺電腦之間的通訊相當於兩個套接字之間的通訊，在伺服器端用 write() 向套接字寫入資料，客戶端就能收到，然後再使用 read() 從套接字中讀取出來，就完成了一次通訊。</p>
<p>write() 的原型為：</p>
<pre><code class="language-cpp">ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre>
<p>fd 為要寫入的檔案的描述符，buf 為要寫入的資料的緩衝區地址，nbytes 為要寫入的資料的位元組數。</p>
<blockquote>
<p>size_t 是通過 typedef 聲明的 unsigned int 類型；ssize_t 在 &quot;size_t&quot; 前面加了一個&quot;s&quot;，代表 signed，即 ssize_t 是通過 typedef 聲明的 signed int 類型。</p>
</blockquote>
<p>write() 函數會將緩衝區 buf 中的 nbytes 個位元組寫入檔案 fd，成功則返回寫入的位元組數，失敗則返回 -1。</p>
<p>read() 的原型為：</p>
<pre><code class="language-cpp">ssize_t read(int fd, void *buf, size_t nbytes);
</code></pre>
<p>fd 為要讀取的檔案的描述符，buf 為要接收資料的緩衝區地址，nbytes 為要讀取的資料的位元組數。</p>
<p>read() 函數會從 fd 檔案中讀取 nbytes 個位元組並保存到緩衝區 buf，成功則返回讀取到的位元組數（但遇到檔案結尾則返回0），失敗則返回 -1。</p>
<h2 id="windows下資料的接收和傳送"><a class="header" href="#windows下資料的接收和傳送">Windows下資料的接收和傳送</a></h2>
<p>Windows 和 Linux 不同，Windows 區分普通檔案和套接字，並定義了專門的接收和傳送的函數。</p>
<p>從伺服器端傳送資料使用 send() 函數，它的原型為：</p>
<pre><code class="language-cpp">int send(SOCKET sock, const char *buf, int len, int flags);
</code></pre>
<p>sock 為要傳送資料的套接字，buf 為要傳送的資料的緩衝區地址，len 為要傳送的資料的位元組數，flags 為傳送資料時的選項。</p>
<p>返回值和前三個參數不再贅述，最後的 flags 參數一般設定為 0 或 NULL，初學者不必深究。</p>
<p>在客戶端接收資料使用 recv() 函數，它的原型為：</p>
<pre><code class="language-cpp">int recv(SOCKET sock, char *buf, int len, int flags);
</code></pre>
<h1 id="使用socket程式設計實現回聲客戶端"><a class="header" href="#使用socket程式設計實現回聲客戶端">使用socket程式設計實現回聲客戶端</a></h1>
<p>所謂“回聲”，是指使用者端向伺服器傳送一條資料，伺服器再將資料原樣返回給使用者端，就像聲音一樣，遇到障礙物會被“反彈回來”。</p>
<p>對！使用者端也可以使用 write() / send() 函數向伺服器傳送資料，伺服器也可以使用 read() / recv() 函數接收資料。</p>
<p>考慮到大部分初學者使用 Windows 作業系統，本節將實現 Windows 下的回聲程式，Linux 下稍作修改即可，不再給出程式碼。</p>
<p>伺服器端 server.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#pragma comment (lib, &quot;ws2_32.lib&quot;)  //載入 ws2_32.dll

#define BUF_SIZE 100

int main(){
    WSADATA wsaData;
    WSAStartup( MAKEWORD(2, 2), &amp;wsaData);

    //建立通訊端
    SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);

    //系結通訊端
    sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;  //使用IPv4地址
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具體的IP地址
    sockAddr.sin_port = htons(1234);  //埠
    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));

    //進入監聽狀態
    listen(servSock, 20);

    //接收使用者端請求
    SOCKADDR clntAddr;
    int nSize = sizeof(SOCKADDR);
    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);
    char buffer[BUF_SIZE];  //緩衝區
    int strLen = recv(clntSock, buffer, BUF_SIZE, 0);  //接收使用者端發來的資料
    send(clntSock, buffer, strLen, 0);  //將資料原樣返回

    //關閉通訊端
    closesocket(clntSock);
    closesocket(servSock);

    //終止 DLL 的使用
    WSACleanup();

    return 0;
}
</code></pre>
<p>使用者端 client.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;WinSock2.h&gt;
#pragma comment(lib, &quot;ws2_32.lib&quot;)  //載入 ws2_32.dll

#define BUF_SIZE 100

int main(){
    //初始化DLL
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    //建立通訊端
    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

    //向伺服器發起請求
    sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
    sockAddr.sin_port = htons(1234);
    connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));
    //獲取使用者輸入的字串並行送給伺服器
    char bufSend[BUF_SIZE] = {0};
    printf(&quot;Input a string: &quot;);
    scanf(&quot;%s&quot;, bufSend);
    send(sock, bufSend, strlen(bufSend), 0);
    //接收伺服器傳回的資料
    char bufRecv[BUF_SIZE] = {0};
    recv(sock, bufRecv, BUF_SIZE, 0);

    //輸出接收到的資料
    printf(&quot;Message form server: %sn&quot;, bufRecv);

    //關閉通訊端
    closesocket(sock);

    //終止使用 DLL
    WSACleanup();

    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>先執行伺服器端，再執行使用者端，執行結果為：
Input a string: c-language java cpp↙
Message form server: c-language</p>
<p>scanf() 讀取到空格時認為一個字串輸入結束，所以只能讀取到“c-language”；如果不希望把空格作為字串的結束符，可以使用 gets() 函數。</p>
<p>通過本程式可以發現，使用者端也可以向伺服器端傳送資料，這樣伺服器端就可以根據不同的請求作出不同的響應，http 伺服器就是典型的例子，請求的網址不同，返回的頁面也不同。</p>
<h1 id="如何讓伺服器端持續監聽客戶端的請求"><a class="header" href="#如何讓伺服器端持續監聽客戶端的請求">如何讓伺服器端持續監聽客戶端的請求？</a></h1>
<p>前面的程序，不管伺服器端還是客戶端，都有一個問題，就是處理完一個請求立即退出了，沒有太大的實際意義。能不能像Web伺服器那樣一直接受客戶端的請求呢？能，使用 while 循環即可。</p>
<p>修改前面的回聲程序，使伺服器端可以不斷響應客戶端的請求。</p>
<p>伺服器端 server.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#pragma comment (lib, &quot;ws2_32.lib&quot;) //載入 ws2_32.dll

#define BUF_SIZE 100

int main()
{
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    //建立套接字
    SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);

    //繫結套接字
    sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每個位元組都用0填充
    sockAddr.sin_family = PF_INET; //使用IPv4地址
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //具體的IP地址
    sockAddr.sin_port = htons(1234); //連接埠
    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));

    //進入監聽狀態
    listen(servSock, 20);

    //接收客戶端請求
    SOCKADDR clntAddr;
    int nSize = sizeof(SOCKADDR);
    char buffer[BUF_SIZE] = {0}; //緩衝區

    while (1) {
        SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);
        int strLen = recv(clntSock, buffer, BUF_SIZE,
                          0); //接收客戶端發來的資料
        send(clntSock, buffer, strLen, 0); //將資料原樣返回

        closesocket(clntSock); //關閉套接字
        memset(buffer, 0, BUF_SIZE); //重設緩衝區
    }

    //關閉套接字
    closesocket(servSock);

    //終止 DLL 的使用
    WSACleanup();
    return 0;
}
</code></pre>
<p>客戶端 client.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;WinSock2.h&gt;
#include &lt;windows.h&gt;
#pragma comment(lib, &quot;ws2_32.lib&quot;) //載入 ws2_32.dll

#define BUF_SIZE 100

int main()
{
    //初始化DLL
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    //向伺服器發起請求
    sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
    sockAddr.sin_port = htons(1234);

    char bufSend[BUF_SIZE] = {0};
    char bufRecv[BUF_SIZE] = {0};

    while (1) {
        //建立套接字
        SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
        connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));
        //獲取使用者輸入的字串並行送給伺服器
        printf(&quot;Input a string: &quot;);
        gets(bufSend);
        send(sock, bufSend, strlen(bufSend), 0);
        //接收伺服器傳回的資料
        recv(sock, bufRecv, BUF_SIZE, 0);
        //輸出接收到的資料
        printf(&quot;Message form server: %s\n&quot;, bufRecv);

        memset(bufSend, 0, BUF_SIZE); //重設緩衝區
        memset(bufRecv, 0, BUF_SIZE); //重設緩衝區
        closesocket(sock); //關閉套接字
    }

    WSACleanup(); //終止使用 DLL
    return 0;
}
</code></pre>
<p>先運行伺服器端，再運行客戶端，結果如下：
Input a string: c language
Message form server: c language
Input a string: <a href="http://c.biancheng.net/c/">C語言</a>中文網
Message form server: C語言中文網
Input a string: 學習C/<a href="http://c.biancheng.net/cplus/">C++</a>程式設計的好網站
Message form server: 學習C/C++程式設計的好網站</p>
<p>while(1) 讓程式碼進入死循環，除非使用者關閉程序，否則伺服器端會一直監聽客戶端的請求。客戶端也是一樣，會不斷向伺服器發起連接。</p>
<p>需要注意的是：server.cpp 中呼叫 closesocket() 不僅會關閉伺服器端的 socket，還會通知客戶端連接已斷開，客戶端也會清理 socket 相關資源，所以 client.cpp 中需要將 socket() 放在 while 循環內部，因為每次請求完畢都會清理 socket，下次發起請求時需要重新建立。後續我們會進行詳細講解。</p>
<h1 id="socket緩衝區以及阻塞模式詳解"><a class="header" href="#socket緩衝區以及阻塞模式詳解">socket緩衝區以及阻塞模式詳解</a></h1>
<p>在《socket資料的接收和傳送》一節中講到，可以使用 write()/send() 函數傳送資料，使用 read()/recv() 函數接收資料，本節就來看看資料是如何傳遞的。</p>
<h2 id="socket緩衝區"><a class="header" href="#socket緩衝區">socket緩衝區</a></h2>
<p>每個 socket 被建立後，都會分配兩個緩衝區，輸入緩衝區和輸出緩衝區。</p>
<p>write()/send() 並不立即向網路中傳輸資料，而是先將資料寫入緩衝區中，再由TCP協議將資料從緩衝區傳送到目標機器。一旦將資料寫入到緩衝區，函數就可以成功返回，不管它們有沒有到達目標機器，也不管它們何時被傳送到網路，這些都是TCP協議負責的事情。</p>
<p>TCP協議獨立於 write()/send() 函數，資料有可能剛被寫入緩衝區就傳送到網路，也可能在緩衝區中不斷積壓，多次寫入的資料被一次性傳送到網路，這取決於當時的網路情況、當前執行緒是否空閒等諸多因素，不由程式設計師控制。</p>
<p>read()/recv() 函數也是如此，也從輸入緩衝區中讀取資料，而不是直接從網路中讀取。</p>
<p><img src="linux_system/images/1149355056-0.jpg" alt="TCP套接字的I/O緩衝區示意圖" />
圖：TCP套接字的I/O緩衝區示意圖</p>
<p>這些I/O緩衝區特性可整理如下：</p>
<ul>
<li>I/O緩衝區在每個TCP套接字中單獨存在；</li>
<li>I/O緩衝區在建立套接字時自動生成；</li>
<li>即使關閉套接字也會繼續傳送輸出緩衝區中遺留的資料；</li>
<li>關閉套接字將丟失輸入緩衝區中的資料。</li>
</ul>
<p>輸入輸出緩衝區的默認大小一般都是 8K，可以通過 getsockopt() 函數獲取：</p>
<pre><code class="language-cpp">unsigned optVal;
int optLen = sizeof(int);
getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);
printf(&quot;Buffer length: %d\n&quot;, optVal);
</code></pre>
<p>運行結果：
Buffer length: 8192</p>
<blockquote>
<p>這裡僅給出示例，後面會詳細講解。</p>
</blockquote>
<h2 id="阻塞模式"><a class="header" href="#阻塞模式">阻塞模式</a></h2>
<p>對於TCP套接字（默認情況下），當使用 write()/send() 傳送資料時：</p>
<ul>
<li>
<p>首先會檢查緩衝區，如果緩衝區的可用空間長度小於要傳送的資料，那麼 write()/send() 會被阻塞（暫停執行），直到緩衝區中的資料被傳送到目標機器，騰出足夠的空間，才喚醒 write()/send() 函數繼續寫入資料。</p>
</li>
<li>
<p>如果TCP協議正在向網路傳送資料，那麼輸出緩衝區會被鎖定，不允許寫入，write()/send() 也會被阻塞，直到資料傳送完畢緩衝區解鎖，write()/send() 才會被喚醒。</p>
</li>
<li>
<p>如果要寫入的資料大於緩衝區的最大長度，那麼將分批寫入。</p>
</li>
<li>
<p>直到所有資料被寫入緩衝區 write()/send() 才能返回。</p>
</li>
</ul>
<p>當使用 read()/recv() 讀取資料時：</p>
<ul>
<li>
<p>首先會檢查緩衝區，如果緩衝區中有資料，那麼就讀取，否則函數會被阻塞，直到網路上有資料到來。</p>
</li>
<li>
<p>如果要讀取的資料長度小於緩衝區中的資料長度，那麼就不能一次性將緩衝區中的所有資料讀出，剩餘資料將不斷積壓，直到有 read()/recv() 函數再次讀取。</p>
</li>
<li>
<p>直到讀取到資料後 read()/recv() 函數才會返回，否則就一直被阻塞。</p>
</li>
</ul>
<p>這就是TCP套接字的阻塞模式。所謂阻塞，就是上一步動作沒有完成，下一步動作將暫停，直到上一步動作完成後才能繼續，以保持同步性。</p>
<blockquote>
<p>TCP套接字默認情況下是阻塞模式，也是最常用的。當然你也可以更改為非阻塞模式，後續我們會講解。</p>
</blockquote>
<h1 id="tcp協議的粘包問題資料的無邊界性"><a class="header" href="#tcp協議的粘包問題資料的無邊界性">TCP協議的粘包問題（資料的無邊界性）</a></h1>
<p>上節我們講到了<a href="http://c.biancheng.net/socket/">socket</a>緩衝區和資料的傳遞過程，可以看到資料的接收和傳送是無關的，read()/recv() 函數不管資料傳送了多少次，都會儘可能多的接收資料。也就是說，read()/recv() 和 write()/send() 的執行次數可能不同。</p>
<p>例如，write()/send() 重複執行三次，每次都傳送字串&quot;abc&quot;，那麼目標機器上的 read()/recv() 可能分三次接收，每次都接收&quot;abc&quot;；也可能分兩次接收，第一次接收&quot;abcab&quot;，第二次接收&quot;cabc&quot;；也可能一次就接收到字串&quot;abcabcabc&quot;。</p>
<p>假設我們希望客戶端每次傳送一位學生的學號，讓伺服器端返回該學生的姓名、住址、成績等資訊，這時候可能就會出現問題，伺服器端不能區分學生的學號。例如第一次傳送 1，第二次傳送 3，伺服器可能當成 13 來處理，返回的資訊顯然是錯誤的。</p>
<p>這就是資料的“粘包”問題，客戶端傳送的多個封包被當做一個封包接收。也稱資料的無邊界性，read()/recv() 函數不知道封包的開始或結束標誌（實際上也沒有任何開始或結束標誌），只把它們當做連續的資料流來處理。</p>
<p>下面的程式碼演示了粘包問題，客戶端連續三次向伺服器端傳送資料，伺服器端卻一次性接收到所有資料。</p>
<p>伺服器端程式碼 server.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#pragma comment (lib, &quot;ws2_32.lib&quot;)  //載入 ws2_32.dll
#define BUF_SIZE 100
int main()
{
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
    //建立套接字
    SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);
    //繫結套接字
    struct sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;  //使用IPv4地址
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具體的IP地址
    sockAddr.sin_port = htons(1234);  //連接埠
    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));
    //進入監聽狀態
    listen(servSock, 20);
    //接收客戶端請求
    SOCKADDR clntAddr;
    int nSize = sizeof(SOCKADDR);
    char buffer[BUF_SIZE] = {0};  //緩衝區
    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);
    Sleep(10000);  //注意這裡，讓程序暫停10秒
    //接收客戶端發來的資料，並原樣返回
    int recvLen = recv(clntSock, buffer, BUF_SIZE, 0);
    send(clntSock, buffer, recvLen, 0);
    //關閉套接字並終止DLL的使用
    closesocket(clntSock);
    closesocket(servSock);
    WSACleanup();
    return 0;
}

</code></pre>
<p>客戶端程式碼 client.cpp：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;WinSock2.h&gt;
#include &lt;windows.h&gt;
#pragma comment(lib, &quot;ws2_32.lib&quot;)  //載入 ws2_32.dll

#define BUF_SIZE 100

int main()
{
    //初始化DLL
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    //向伺服器發起請求
    struct sockaddr_in sockAddr;
    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每個位元組都用0填充
    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
    sockAddr.sin_port = htons(1234);

    //建立套接字
    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));

    //獲取使用者輸入的字串並行送給伺服器
    char bufSend[BUF_SIZE] = {0};
    printf(&quot;Input a string: &quot;);
    gets(bufSend);

    for (int i = 0; i &lt; 3; i++) {
        send(sock, bufSend, strlen(bufSend), 0);
    }

    //接收伺服器傳回的資料
    char bufRecv[BUF_SIZE] = {0};
    recv(sock, bufRecv, BUF_SIZE, 0);
    //輸出接收到的資料
    printf(&quot;Message form server: %s\n&quot;, bufRecv);

    closesocket(sock);  //關閉套接字
    WSACleanup();  //終止使用 DLL

    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>先運行 server，再運行 client，並在10秒內輸入字串&quot;abc&quot;，再等數秒，伺服器就會返回資料。運行結果如下：
Input a string: abc
Message form server: abcabcabc</p>
<p>本程序的關鍵是 server.cpp 第31行的程式碼<code>Sleep(10000);</code>，它讓程序暫停執行10秒。在這段時間內，client 連續三次傳送字串&quot;abc&quot;，由於 server 被阻塞，資料只能堆積在緩衝區中，10秒後，server 開始運行，從緩衝區中一次性讀出所有積壓的資料，並返回給客戶端。</p>
<p>另外還需要說明的是 client.cpp 第34行程式碼。client 執行到 recv() 函數，由於輸入緩衝區中沒有資料，所以會被阻塞，直到10秒後 server 傳回資料才開始執行。使用者看到的直觀效果就是，client 暫停一段時間才輸出 server 返回的結果。</p>
<p>client 的 send() 傳送了三個封包，而 server 的 recv() 卻只接收到一個封包，這很好的說明瞭資料的粘包問題。</p>
<h1 id="圖解tcp資料報結構以及三次握手非常詳細"><a class="header" href="#圖解tcp資料報結構以及三次握手非常詳細">圖解TCP資料報結構以及三次握手（非常詳細）</a></h1>
<p>TCP（Transmission Control Protocol，傳輸控制協議）是一種面向連接的、可靠的、基於位元組流的通訊協議，資料在傳輸前要建立連接，傳輸完畢後還要斷開連接。</p>
<p>客戶端在收發資料前要使用 connect() 函數和伺服器建立連接。建立連接的目的是保證IP地址、連接埠、物理鏈路等正確無誤，為資料的傳輸開闢通道。</p>
<p>TCP建立連接時要傳輸三個封包，俗稱三次握手（Three-way Handshaking）。可以形象的比喻為下面的對話：</p>
<ul>
<li>[Shake 1] 套接字A：“你好，套接字B，我這裡有資料要傳送給你，建立連接吧。”</li>
<li>[Shake 2] 套接字B：“好的，我這邊已準備就緒。”</li>
<li>[Shake 3] 套接字A：“謝謝你受理我的請求。”</li>
</ul>
<h2 id="tcp資料報結構"><a class="header" href="#tcp資料報結構">TCP資料報結構</a></h2>
<p>我們先來看一下TCP資料報的結構：
<img src="linux_system/images/1155315343-0.jpg" alt="img" /></p>
<p>帶陰影的幾個欄位需要重點說明一下：</p>
<ul>
<li>
<p>序號：Seq（Sequence Number）序號佔32位，用來標識從電腦A傳送到電腦B的封包的序號，電腦傳送資料時對此進行標記。</p>
</li>
<li>
<p>確認號：Ack（Acknowledge Number）確認號佔32位，客戶端和伺服器端都可以傳送，Ack = Seq + 1。</p>
</li>
<li>
<p>標誌位：每個標誌位佔用1Bit，共有6個，分別為 URG、ACK、PSH、RST、SYN、FIN，具體含義如下：</p>
<ul>
<li>URG：緊急指針（urgent pointer）有效。</li>
<li>ACK：確認序號有效。</li>
<li>PSH：接收方應該盡快將這個報文交給應用層。</li>
<li>RST：重設連接。</li>
<li>SYN：建立一個新連接。</li>
<li>FIN：斷開一個連接。</li>
</ul>
</li>
</ul>
<blockquote>
<p>對英文字母縮寫的總結：Seq 是 Sequence 的縮寫，表示序列；Ack(ACK) 是 Acknowledge 的縮寫，表示確認；SYN 是 Synchronous 的縮寫，願意是“同步的”，這裡表示建立同步連接；FIN 是 Finish 的縮寫，表示完成。</p>
</blockquote>
<h2 id="連接的建立三次握手"><a class="header" href="#連接的建立三次握手">連接的建立（三次握手）</a></h2>
<p>使用 connect() 建立連接時，客戶端和伺服器端會相互傳送三個封包，請看下圖：
<img src="linux_system/images/1155312401-1.jpg" alt="img" /></p>
<p>客戶端呼叫 <a href="http://c.biancheng.net/socket/">socket</a>() 函數建立套接字後，因為沒有建立連接，所以套接字處於<code>CLOSED</code>狀態；伺服器端呼叫 listen() 函數後，套接字進入<code>LISTEN</code>狀態，開始監聽客戶端請求。</p>
<p>這個時候，客戶端開始發起請求：</p>
<ul>
<li>
<p>當客戶端呼叫 connect() 函數後，TCP協議會組建一個封包，並設定 SYN 標誌位，表示該封包是用來建立同步連接的。同時生成一個隨機數字 1000，填充“序號（Seq）”欄位，表示該封包的序號。完成這些工作，開始向伺服器端傳送封包，客戶端就進入了<code>SYN-SEND</code>狀態。</p>
</li>
<li>
<p>伺服器端收到封包，檢測到已經設定了 SYN 標誌位，就知道這是客戶端發來的建立連接的“請求包”。伺服器端也會組建一個封包，並設定 SYN 和 ACK 標誌位，SYN 表示該封包用來建立連接，ACK 用來確認收到了剛才客戶端傳送的封包。伺服器生成一個隨機數 2000，填充“序號（Seq）”欄位。2000 和客戶端封包沒有關係。伺服器將客戶端封包序號（1000）加1，得到1001，並用這個數字填充“確認號（Ack）”欄位。伺服器將封包發出，進入<code>SYN-RECV</code>狀態。</p>
</li>
<li>
<p>客戶端收到封包，檢測到已經設定了 SYN 和 ACK 標誌位，就知道這是伺服器發來的“確認包”。客戶端會檢測“確認號（Ack）”欄位，看它的值是否為 1000+1，如果是就說明連接建立成功。接下來，客戶端會繼續組建封包，並設定 ACK 標誌位，表示客戶端正確接收了伺服器發來的“確認包”。同時，將剛才伺服器發來的封包序號（2000）加1，得到 2001，並用這個數字來填充“確認號（Ack）”欄位。客戶端將封包發出，進入<code>ESTABLISED</code>狀態，表示連接已經成功建立。</p>
</li>
<li>
<p>伺服器端收到封包，檢測到已經設定了 ACK 標誌位，就知道這是客戶端發來的“確認包”。伺服器會檢測“確認號（Ack）”欄位，看它的值是否為 2000+1，如果是就說明連接建立成功，伺服器進入<code>ESTABLISED</code>狀態。</p>
</li>
</ul>
<p>至此，客戶端和伺服器都進入了<code>ESTABLISED</code>狀態，連接建立成功，接下來就可以收發資料了。</p>
<h2 id="最後的說明"><a class="header" href="#最後的說明">最後的說明</a></h2>
<p>三次握手的關鍵是要確認對方收到了自己的封包，這個目標就是通過“確認號（Ack）”欄位實現的。電腦會記錄下自己傳送的封包序號 Seq，待收到對方的封包後，檢測“確認號（Ack）”欄位，看<code>Ack = Seq + 1</code>是否成立，如果成立說明對方正確收到了自己的封包。</p>
<h1 id="詳細分析tcp資料的傳輸過程"><a class="header" href="#詳細分析tcp資料的傳輸過程">詳細分析TCP資料的傳輸過程</a></h1>
<p>建立連接後，兩臺主機就可以相互傳輸資料了。如下圖所示：</p>
<p><img src="linux_system/images/115A462I-0.jpg" alt="TCP 套接字的資料交換過程" />
圖1：TCP 套接字的資料交換過程</p>
<p>上圖給出了主機A分2次（分2個封包）向主機B傳遞200位元組的過程。首先，主機A通過1個封包傳送100個位元組的資料，封包的 Seq 號設定為 1200。主機B為了確認這一點，向主機A傳送 ACK 包，並將 Ack 號設定為 1301。</p>
<blockquote>
<p>為了保證資料精準到達，目標機器在收到封包（包括SYN包、FIN包、普通封包等）包後必須立即回傳ACK包，這樣傳送方才能確認資料傳輸成功。</p>
</blockquote>
<p>此時 Ack 號為 1301 而不是 1201，原因在於 Ack 號的增量為傳輸的資料位元組數。假設每次 Ack 號不加傳輸的位元組數，這樣雖然可以確認封包的傳輸，但無法明確100位元組全部正確傳遞還是丟失了一部分，比如只傳遞了80位元組。因此按如下的公式確認 Ack 號：</p>
<p>Ack號 = Seq號 + 傳遞的位元組數 + 1</p>
<p>與三次握手協議相同，最後加 1 是為了告訴對方要傳遞的 Seq 號。</p>
<p>下面分析傳輸過程中封包丟失的情況，如下圖所示：</p>
<p><img src="linux_system/images/115A453O-1.jpg" alt="img" />
圖2：TCP套接字資料傳輸過程中發生錯誤</p>
<p>上圖表示通過 Seq 1301 封包向主機B傳遞100位元組的資料，但中間發生了錯誤，主機B未收到。經過一段時間後，主機A仍未收到對於 Seq 1301 的ACK確認，因此嘗試重傳資料。</p>
<p>為了完成封包的重傳，TCP套接字每次傳送封包時都會啟動定時器，如果在一定時間內沒有收到目標機器傳回的 ACK 包，那麼定時器超時，封包會重傳。</p>
<blockquote>
<p>上圖演示的是封包丟失的情況，也會有 ACK 包丟失的情況，一樣會重傳。</p>
</blockquote>
<h4 id="重傳超時時間rto-retransmission-time-out"><a class="header" href="#重傳超時時間rto-retransmission-time-out">重傳超時時間（RTO, Retransmission Time Out）</a></h4>
<p>這個值太大了會導致不必要的等待，太小會導致不必要的重傳，理論上最好是網路 RTT 時間，但又受制於網路距離與瞬態時延變化，所以實際上使用自適應的動態演算法（例如 Jacobson 演算法和 Karn 演算法等）來確定超時時間。</p>
<blockquote>
<p>往返時間（RTT，Round-Trip Time）表示從傳送端傳送資料開始，到傳送端收到來自接收端的 ACK 確認包（接收端收到資料後便立即確認），總共經歷的時延。</p>
</blockquote>
<h4 id="重傳次數"><a class="header" href="#重傳次數">重傳次數</a></h4>
<p>TCP封包重傳次數根據系統設定的不同而有所區別。有些系統，一個封包只會被重傳3次，如果重傳3次後還未收到該封包的 ACK 確認，就不再嘗試重傳。但有些要求很高的業務系統，會不斷地重傳丟失的封包，以盡最大可能保證業務資料的正常互動。</p>
<p>最後需要說明的是，傳送端只有在收到對方的 ACK 確認包後，才會清空輸出緩衝區中的資料。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="如何在linux上通過cgroup限制一個處理程序使用cpu和記憶體"><a class="header" href="#如何在linux上通過cgroup限制一個處理程序使用cpu和記憶體">如何在Linux上通過cgroup限制一個處理程序使用CPU和記憶體</a></h2>
<p>https://blog.csdn.net/weixin_37871174/article/details/130390336</p>
<p>Cgroup（Control Group）是 Linux 核心的一個功能，可以通過它來限制處理程序的 CPU 和記憶體佔用。Cgroup 實現了對系統資源的細粒度控制和管理，可以將一組處理程序放入同一個 Cgroup 中，並對該 Control Group 中的所有處理程序共享相應的資源配額。</p>
<p>下面舉個實際的例子，演示如何使用 Cgroup 限制一個處理程序的 CPU 佔用率和記憶體使用量：</p>
<ol>
<li>
<p>首先需要安裝 cgroup 工具包，在 Ubuntu 系統上可以執行以下命令進行安裝： </p>
<pre><code class="language-sh">sudo apt-get install cgroup-tools
</code></pre>
</li>
<li>
<p>建立一個名為 mycg 的控制組，以限制該組中的處理程序的 CPU 佔用率和記憶體使用量。在 shell 終端輸入下列命令：</p>
<pre><code class="language-sh">sudo mkdir /sys/fs/cgroup/cpu_mytainer
sudo mkdir /sys/fs/cgroup/memory_mytainer
</code></pre>
</li>
<li>
<p>設定 cpu 資源限制：</p>
<pre><code class="language-sh">echo &quot;10000&quot; &gt; /sys/fs/cgroup/cpu_mytainer/cpu.cfs_quota_us #設定每10ms分配給cgroup桶的最大時間片值 
echo &quot;200000&quot; &gt; /sys/fs/cgroup/cpu_mytainer/cpu.cfs_period_us #設定每次時間輪轉過多少微秒 
</code></pre>
</li>
</ol>
<p>這兩行程式碼告訴核心同時運行的程序切換超時參數，即當前可佔用 10ms 核心時間，然後必須讓出時間，並等待 200ms 核心時間過後再佔用，以達到限制CPU使用的目地。</p>
<ol start="4">
<li>
<p>設定memory資源限制：</p>
<pre><code class="language-sh">echo &quot;50M&quot; &gt; /sys/fs/cgroup/memory_mytainer/memory.limit_in_bytes #設定cgroup總共最多能夠使用記憶體大小
</code></pre>
<p>這條命令表示限制 mycg 這個 Cgroup 的處理程序總佔用記憶體不得超過 50MB。 </p>
</li>
<li>
<p>建立一個新處理程序並將它加入 mycg 中，然後觀察該處理程序利用率是否受到限制。例如我們建立一個死循環 c</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
    while(1){
        int a=100000000,b;
        b=a/b;
    }
    return 0;
}
</code></pre>
</li>
</ol>
<p>編譯成可執行檔案 test.out 並運行如下程式碼：</p>
<pre><code class="language-sh">sudo cgcreate -a root:root -g cpu_mytainer,memory_mytainer:/mycg  
sudo echo $PID &gt;&gt;/sys/fs/cgroup/cpu_mytainer/tasks 
sudo echo $PID &gt;&gt;/sys/fs/cgroup/memory_mytainer/tasks  
</code></pre>
<p>其中 PID 是指上面循環程序 test.out 的處理程序 ID。</p>
<ol start="6">
<li>
<p>使用 <code>ps</code> 命令檢查處理程序的CPU和記憶體使用情況：</p>
<pre><code class="language-sh">ps aux | grep test.out
</code></pre>
<p>你可以看到產生了類似以下的輸出:</p>
</li>
</ol>
<pre><code class="language-sh">USER      PID    %CPU     %MEM            VSZ         RSS       TTY     STAT      START         TIME        COMMAND
root     3833    10.0     0.1           62820        2580   pts/9    R     11:56         00:00:30     ./test.out
</code></pre>
<p>說明測試程序的CPU使用率已經被成功限制在10%以內，而記憶體佔用不會超過50MB。</p>
<h2 id="limit-chrome"><a class="header" href="#limit-chrome">limit chrome</a></h2>
<pre><code class="language-sh">sudo chmod o+w /sys/fs/cgroup/cgroup.procs


sudo cgcreate -t $USER:$USER -a $USER:$USER  -g memory,cpuset:limitchrome
# Limit RAM to 1.5G roughly
echo 1600000000 | sudo tee /sys/fs/cgroup/limitchrome/memory.limit_in_bytes

echo 0-4 | sudo tee /sys/fs/cgroup/limitchrome/cpuset.cpus
# Run chrome in this cgroup
cgexec -g memory,cpuset:limitchrome /opt/google/chrome/google-chrome --profile-directory=Default
# Delete the cgroup (not required)
sudo cgdelete -g memory,cpuset:limitchrome
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-效能分析工具-perf-1"><a class="header" href="#linux-效能分析工具-perf-1">Linux 效能分析工具: Perf</a></h1>
<h2 id="簡介-2"><a class="header" href="#簡介-2">簡介</a></h2>
<p><a href="https://perf.wiki.kernel.org/index.php/Main_Page">Perf</a> 全名是 Performance Event，是在 Linux 2.6.31 以後內建的系統效能分析工具，它隨著核心一併釋出。藉由 perf，應用程式可以利用 PMU (Performance Monitoring Unit), tracepoint 和核心內部的特殊計數器 (counter) 來進行統計，另外還能同時分析運行中的核心程式碼，從而更全面瞭解應用程式中的效能瓶頸。</p>
<p>相較於 <a href="https://en.wikipedia.org/wiki/OProfile">OProfile</a> 和 <a href="https://sourceware.org/binutils/docs/gprof/">GProf</a> ，perf 的優勢在於與 Linux Kernel 緊密結合，並可受益於最先納入核心的新特徵。perf 基本原理是對目標進行取樣，紀錄特定的條件下所偵測的事件是否發生以及發生的次數。例如根據 tick 中斷進行取樣，即在 tick 中斷內觸發取樣點，在取樣點裡判斷行程 (process) 當時的 context。假如一個行程 90% 的時間都花費在函式 foo() 上，那麼 90% 的取樣點都應該落在函式 foo() 的上下文中。</p>
<p>Perf 可取樣的事件非常多，可以分析 Hardware event，如 cpu-cycles、instructions 、cache-misses、branch-misses …等等。可以分析 Software event，如 page-faults、context-switches …等等，另外一種就是 Tracepoint event。知道了 cpu-cycles、instructions 我們可以瞭解 Instruction per cycle 是多少，進而判斷程式碼有沒有好好利用 CPU，cache-misses 可以曉得是否有善用 Locality of reference ，branch-misses 多了是否導致嚴重的 pipeline hazard？另外 Perf 還可以對函式進行採樣，瞭解效能卡在哪邊。</p>
<h2 id="安裝-4"><a class="header" href="#安裝-4">安裝</a></h2>
<p>首先利用以下指令查看目前的 Kernel config 有沒有啟用 Perf。如果 PC 上是裝一般 Linux distro，預設值應該都有開啟。</p>
<pre><code class="language-sh">＄ cat &quot;/boot/config-`uname -r`&quot; | grep &quot;PERF_EVENT&quot;
</code></pre>
<p>如果自己編譯核心可以參照<a href="http://www.carbondesignsystems.com/virtual-prototype-blog/using-the-arm-performance-monitor-unit-pmu-linux-driver">這篇文章</a>來啟用 perf。</p>
<p>參考的環境是 Ubuntu 14.04，kernel 版本 3.16.0。有兩種方法可以安裝</p>
<ol>
<li>前面講到，perf 是 Linux 內建支持的效能優化工具，在 2.6.31 版本之後，我們可以直接到 <a href="https://www.kernel.org/">Linux Kernel Archives</a> 下載對應版本的程式碼，解壓縮後到 <code>tools/perf</code> 裡面去編譯，通常過程中會有相依的套件需要安裝，依指示完成安裝後，編譯即可成功，最後再把編譯完成的 perf 移至 <code>/usr/bin</code> 中就可以使用了。 這種方法通常適用於更新過 kernel 的使用者，因為更新過 kernel 後會造成 distribution package 與 kernel version 不相符。一般使用者採用第二種方法即可。</li>
<li>使用 apt-get 進行安裝。</li>
</ol>
<pre><code class="language-sh">$ sudo apt-get install linux-tools-common
</code></pre>
<p>接著輸入 perf list 或 perf top 檢查一下 perf 可不可以使用。</p>
<p>如果出現以下的訊息，表示還漏了些東西。</p>
<pre><code>WARNING: perf not found for kernel 3.16.0-50
You may need to install the following packages for this specific kernel:
    linux-tools-3.16.0-50-generic
    linux-cloud-tools-3.16.0-50-generic
</code></pre>
<p>上面的 Kernel 版本可能和你不一樣，根據指示安裝起來即可。不放心的話可以使用<code>＄ uname -r</code>確認。</p>
<pre><code class="language-sh">$ sudo apt-get install linux-tools-3.16.0-50-generic linux-cloud-tools-3.16.0-50-generic
</code></pre>
<ol>
<li>到這裡 perf 的安裝就完成了。不過這裡我再稍微補充一下，如果你不是切換到 root 的情況下輸入</li>
</ol>
<pre><code class="language-sh">$ perf top
</code></pre>
<p>其實會出現以下錯誤畫面。</p>
<p><img src="linux_system/images/perf_top_error.png" alt="img" /></p>
<p>kernel.perf_event_paranoid 是用來決定你在沒有 root 權限下 (Normal User) 使用 perf 時，你可以取得哪些 event data。預設值是 1 ，你可以輸入</p>
<pre><code class="language-sh">$ cat /proc/sys/kernel/perf_event_paranoid
</code></pre>
<p>來查看權限值。一共有四種權限值:</p>
<p><code>2</code> : 不允許任何量測。但部份用來查看或分析已存在的紀錄的指令仍可使用，如 perf ls、perf report、perf timechart、 perf trace。</p>
<p><code>1</code> : 不允許 CPU events data。但可以使用 perf stat、perf record 並取得 Kernel profiling data。</p>
<p><code>0</code> : 不允許 raw tracepoint access。但可以使用 perf stat、perf record 並取得 CPU events data。</p>
<p><code>-1</code>: 權限全開。</p>
<p>最後如果要檢測 cache miss event ，需要先取消 kernel pointer 的禁用。</p>
<pre><code class="language-sh">$ sudo sh -c &quot; echo 0 &gt; /proc/sys/kernel/kptr_restrict&quot;
</code></pre>
<h2 id="先來個範例暖身吧-1"><a class="header" href="#先來個範例暖身吧-1">先來個範例暖身吧！</a></h2>
<p>一開始，我們先使用第一次作業 「計算圓周率」 的程式來體會一下 perf 使用。 [perf_top_example.c]</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

double compute_pi_baseline(size_t N) {
    double pi = 0.0;
    double dt = 1.0 / N;
    for (size_t i = 0; i &lt; N; i++) {
        double x = (double) i / N;
        pi += dt / (1.0 + x * x);
    }
    return pi * 4.0;
}
int main() {
    printf(&quot;pid: %d\n&quot;, getpid());
    sleep(10);
    compute_pi_baseline(50000000);
    return 0;
}
</code></pre>
<p>將上述程式存檔為 perf_top_example.c，並執行：</p>
<pre><code class="language-sh">g++ -c perf_top_example.c
g++ perf_top_example.o -o example
./example
</code></pre>
<p>執行上述程式後，可以取得一個 pid 值，再根據 pid 輸入</p>
<pre><code class="language-sh">perf top -p $pid
</code></pre>
<p>應該會得到類似下面的結果：</p>
<p><img src="linux_system/images/perf_computepi_example.png" alt="img" /></p>
<p>預設的 performance event 是 「cycles」，所以這條指令可以分析出消耗 CPU 週期最多的部份，結果顯示函式 compute_pi_baseline() 佔了近 99.9％，跟預期一樣，此函式是程式中的「熱點」！有了一些感覺後，後面會詳細一點介紹 perf 用法。</p>
<h2 id="背景知識-1"><a class="header" href="#背景知識-1">背景知識</a></h2>
<p>以下節錄上海交大通信與電子工程系的劉明寫的文章：</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">Perf – Linux下的系統性能調優工具</a></p>
<p><a href="https://zh.wikipedia.org/zh-tw/Wikipedia:%E7%B9%81%E7%B0%A1%E5%88%86%E6%AD%A7%E8%A9%9E%E8%A1%A8#.E7.A7.91.E6.8A.80">簡繁體中文詞彙對照：科技纇</a> (本課程斟酌修改詞彙，<code>==&gt;</code> 開頭表示補充)</p>
<ul>
<li><strong>背景知識</strong></li>
</ul>
<p>有些背景知識是分析性能問題時需要瞭解的。比如硬件 cache；再比如作業系統核心。應用程式的行為細節往往是和這些東西互相牽扯的，這些底層的東西會以意想不到的方式影響應用程式的性能，比如某些程式無法充分利用 cache，從而導致性能下降。比如不必要地呼叫過多的系統呼叫，造成頻繁的核心 / 使用者層級的切換 …等等。這裡只是為本文的後續內容做些概述，關於效能調校還有很多東西。</p>
<ul>
<li><strong>效能相關的處理器硬體特性，PMU 簡介</strong></li>
</ul>
<p>當演算法已趨於最佳化，程式碼不斷精簡，人們調到最後，便需要斤斤計較了。cache、pipeline 等平時不大注意的東西也必須精打細算了。</p>
<ul>
<li><strong>硬體特性之 cache</strong></li>
</ul>
<p>記憶體存取很快，但仍無法和處理器的指令執行速度相提並論。為了從記憶體中讀取指令 (instruction) 和資料 (data)，處理器需要等待，用處理器的時間來衡量，這種等待非常漫長。cache 是一種 SRAM，它的存取速率非常快，與處理器處理速度較為接近。因此將常用的資料保存在 cache 中，處理器便無須等待，從而提高效能。cache 的尺寸一般都很小，充分利用 cache 是軟體效能改善過程中，非常重要的部分。</p>
<ul>
<li><strong>硬體特性之 pipeline, superscalar, out-ot-order execution</strong></li>
</ul>
<p>提昇效能最有效的方式之一就是平行 (parallelism)。處理器在設計時也儘可能地平行，比如 pipeline, superscalar, out-of-execution。</p>
<p>處理器處理一條指令需要分多個步驟完成，比如 fetch 指令，然後完成運算，最後將計算結果輸出到匯流排 (bus) 上。在處理器內部，這可以看作一個三級 pipeline，如下圖處理器 pipeline 所示：</p>
<p><img src="linux_system/images/3stage_pipeline.gif" alt="img" /></p>
<p>指令從左邊進入處理器，上圖中的 pipeline 有三級，一個時鐘週期內可以同時處理三條指令，分別被 pipeline 的不同部分處理。</p>
<p>Superscalar 指一個時鐘週期觸發 (issue) 多條指令的 pipeline機器架構，比如 Intel 的 Pentium 處理器，內部有兩個執行單元，在一個時鐘週期內允許執行兩條指令。</p>
<p>==&gt; 這樣稱為 dual-issue，可想像為一個 packet 裡同時有兩組 pipelined 的 instruction</p>
<p>==&gt; 比方說，<a href="http://www.arm.com/products/processors/cortex-a/cortex-a5.php">Cortex-A5</a> 和 Cortex-A8 一樣採用 ARMv7-A 指令集，但是 Cortex-A5 是 Cortext-A8/A9 的精簡版，有以下差異：</p>
<p>1.pipeline 自 13 stages 減為 8 stages 2.instruction 自 dual-issue 減為 single-issue 3.NEON/FPU 為選配 4.不具有 L2 Cache</p>
<p>此外，在處理器內部，不同指令所需要的執行時間和時鐘週期是不同的，如果嚴格按照程序的執行順序執行，那麼就無法充分利用處理器的 pipeline。因此指令有可能被亂序執行 (out-of-order execution)。</p>
<p>上述三種平行技術對所執行的指令有一個基本要求，即相鄰的指令相互沒有依賴關係。假如某條指令需要依賴前面一條指令的執行結果數據，那麼 pipeline 便失去作用，因為第二條指令必須等待第一條指令完成。因此好的軟體必須儘量避免產生這種程式碼。</p>
<ul>
<li><strong>硬體特性之 branch prediction</strong></li>
</ul>
<p>branch prediction 指令對軟體效能影響較大。尤其是當處理器採用流水線設計之後，假設 pipeline 有三級，且目前進入 pipeline 的第一道指令為分支 (branch) 指令。假設處理器順序讀取指令，那麼如果分支的結果是跳躍到其他指令，那麼被處理器 pipeline 所 fetch 的後續兩條指令勢必被棄置 (來不及執行)，從而影響性能。為此，很多處理器都提供了 branch prediction，根據同一條指令的歷史執行記錄進行預測，讀取最可能的下一條指令，而並非順序讀取指令。</p>
<p>==&gt; 搭配簡報: <a href="http://www.cs.ucr.edu/%7Egupta/teaching/203A-09/My6.pdf">Branch Prediction</a></p>
<p>branch prediction 對軟體架構有些要求，對於重複性的分支指令序列，branch prediction 硬體才能得到較好的預測結果，而對於類似 switch-case 一類的程式結構，則往往不易得到理想的預測結果。</p>
<p>==&gt; 對照閱讀: <a href="http://igoro.com/archive/fast-and-slow-if-statements-branch-prediction-in-modern-processors/">Fast and slow if-statements: branch prediction in modern processors</a></p>
<p>==&gt; 編譯器提供的輔助機制: <a href="http://cellperformance.beyond3d.com/articles/2006/04/branch-patterns-using-gcc.html">Branch Patterns, Using GCC</a></p>
<p>上面介紹的幾種處理器特性對軟體效能影響很大，然而依賴時鐘進行定期採樣的 profiler 模式無法闡述程式對這些處理器硬體特性的使用情況。處理器廠商針對這種情況，在硬體中加入了 PMU (performance monitor unit)。PMU 允許硬體針對某種事件設置 counter，此後處理器便開始統計該事件的發生次數，當發生的次數超過 counter 內設定的數值後，便產生中斷。比如 cache miss 達到某個值後，PMU 便能產生相應的中斷。一旦捕獲這些中斷，便可分析程式對這些硬體特性的使用率了。</p>
<ul>
<li><strong>Tracepoints</strong></li>
</ul>
<p>Tracepoint 是散落在核心原始程式碼的一些 hook，一旦使能，在指定的程式碼被運行時，tracepoint 就會被觸發，這樣的特性可被各種 trace/debug 工具所使用，perf 就是這樣的案例。若你想知道在應用程式執行時期，核心記憶體管理模組的行為，即可透過潛伏在 slab 分配器中的 tracepoint。當核心運行到這些 tracepoint 時，便會通知 perf。</p>
<p>Perf 將 tracepoint 產生的事件記錄下來，生成報告，通過分析這些報告，效能分析調校的工程人員便可瞭解程式執行時期的核心種種細節，也能做出針對效能更準確的診斷。</p>
<h2 id="perf-基本使用-1"><a class="header" href="#perf-基本使用-1">Perf 基本使用</a></h2>
<p>前面有提到，Perf 能觸發的事件分為三類：</p>
<ul>
<li><strong>hardware</strong> : 由 PMU 產生的事件，比如 cache-misses、cpu-cycles、instructions、branch-misses …等等，通常是當需要瞭解程序對硬體特性的使用情況時會使用。</li>
<li><strong>software</strong> : 是核心程式產生的事件，比如 context-switches、page-faults、cpu-clock、cpu-migrations …等等。</li>
<li><strong>tracepoint</strong> : 是核心中的靜態 tracepoint 所觸發的事件，這些 tracepoint 用來判斷在程式執行時期，核心的行為細節，比如 slab 記憶體配置器的配置次數等。</li>
</ul>
<p>Perf 包含 20 幾種子工具集，不過我還沒碰過很多，我根據目前理解先介紹以下。 如果想看第一手資料</p>
<pre><code class="language-sh">$ perf help &lt;command&gt;
</code></pre>
<p>###perf list 這應該是大部分的人第一次安裝 perf 後所下的第一個指令，它能印出 perf 可以觸發哪些 event，不同 CPU 可能支援不同 hardware event，不同 kernel 版本支援的 software、tracepoint event 也不同。我的 perf 版本是<code>3.19.8</code>，所支援的 event 已經超過 1400 項（另外要列出 Tracepoint event 必須開啟 root 權限）。</p>
<pre><code class="language-sh">$ perf list
</code></pre>
<p><img src="linux_system/images/perf_list.png" alt="img" /></p>
<h3 id="perf-top-1"><a class="header" href="#perf-top-1">perf top</a></h3>
<p>perf top 其實跟平常 Linux 內建的 top 指令很相似。它能夠「即時」的分析各個函式在某個 event 上的熱點，找出拖慢系統的兇手，就如同上面那個範例一樣。甚至，即使沒有特定的程序要觀察，你也可以直接下達 <code>$ perf top</code> 指令來觀察是什麼程序吃掉系統效能，導致系統異常變慢。譬如我執行一個無窮迴圈：</p>
<pre><code class="language-c">int main() {
    long int i = 0;
    while(1) {
        i++;
        add(i);
        div(i);
    }
    return 0;
}
</code></pre>
<p>可以發現紅色熱點就出現了。右邊第一列為各函式的符號，左邊第一行是該符號引發的 event 在整個「監視域」中佔的比例，我們稱作該符號的熱度，監視域指的是 perf 監控的所有符號，預設值包括系統所有程序、核心以及核心 module 的函式，左邊第二行則為該符號所在的 Shared Object 。若符號旁顯示<code>[.]</code>表示其位於 User mode，<code>[k]</code>則為 kernel mode。</p>
<p><img src="linux_system/images/perf_top_while.png" alt="img" /></p>
<p>（當你關掉該程序之後，這個監視畫面 (tui 界面) 裡的該程序不會「馬上」消失，而是其 overhead 的比例一直減少然後慢慢離開列表）。</p>
<p>按下 <code>h</code>可以呼叫 help ，它會列出 perf top 的所有功能和對應按鍵。 我們來試看看 Annotate（註解），這功能可以進一步深入分析某個符號。使用方向鍵移到你有興趣的符號按下<code>a</code>。 它會顯示各條指令的 event 取樣率（耗時較多的部份就容易被 perf 取樣到）。</p>
<p><img src="linux_system/images/perf_top_annotate.png" alt="img" /></p>
<p>最後若你想要觀察其他 event ( 預設 cycles ) 和指定取樣頻率 ( 預設每秒4000次 ) :</p>
<pre><code>$ perf top -e cache-misses -c 5000
</code></pre>
<h3 id="perf-stat-1"><a class="header" href="#perf-stat-1">perf stat</a></h3>
<p>相較於 top，使用 perf stat 往往是你已經有個要優化的目標，對這個目標進行特定或一系列的 event 檢查，進而瞭解該程序的效能概況。（event 沒有指定的話，預設會有十種常用 event。） 我們來對以下程式使用 perf stat 工具 分析 cache miss 情形</p>
<pre><code class="language-c">static char array[10000][10000];
int main (void){
  int i, j;
  for (i = 0; i &lt; 10000; i++)
    for (j = 0; j &lt; 10000; j++)
       array[j][i]++;
  return 0;
}
</code></pre>
<pre><code class="language-sh">$ perf stat --repeat 5 -e cache-misses,cache-references,instructions,cycles ./perf_stat_cache_miss
    Performance counter stats for './perf_stat_cache_miss' (5 runs):
    4,416,226        cache-misses        #    3.437 % of all cache refs    ( +-  0.27% )
    128,483,262      cache-references                                      ( +-  0.02% )
    2,123,281,496    instructions        #    0.65  insns per cycle        ( +-  0.02% )
    3,281,498,034    cycles                                                ( +-  0.21% )
        1.299352302 seconds time elapsed                                   ( +-  0.19% )
</code></pre>
<p><code>--repeat &lt;n&gt;</code>或是<code>-r &lt;n&gt;</code> 可以重複執行 n 次該程序，並顯示每個 event 的變化區間。 <code>cache-misses,cache-references</code>和 <code>instructions,cycles</code>類似這種成對的 event，若同時出現 perf 會很貼心幫你計算比例。</p>
<p>根據這次 perf stat 結果可以明顯發現程序有很高的 cache miss，連帶影響 IPC 只有<code>0.65</code>。</p>
<p>如果我們善用一下存取的局部性，將 <code>i，j</code>對調改成<code>array[i][j]++</code>。</p>
<pre><code>    Performance counter stats for './perf_stat_cache_miss' (5 runs):
    2,263,131        cache-misses        #   93.742 % of all cache refs    ( +-  0.53% )
    2,414,202        cache-references                                      ( +-  1.82% )
    2,123,275,176    instructions        #    1.98  insns per cycle        ( +-  0.03% )
    1,074,868,730    cycles                                                ( +-  1.96% )
        0.432727146 seconds time elapsed                                   ( +-  1.99% )
</code></pre>
<p>cache-references 從 <code>128,483,262</code>下降到 <code>2,414,202</code>，差了五十幾倍，執行時間也縮短為原來的三分之一！</p>
<p>###perf record &amp; perf report 有別於 stat，record 可以針對函式級別進行 event 統計，方便我們對程序「熱點」作更精細的分析和優化。 我們來對以下程式，使用 perf record 進行 branch 情況分析</p>
<pre><code class="language-c">#define N 5000000
static int array[N] = { 0 };
void normal_loop(int a) {
    int i;
    for (i = 0; i &lt; N; i++)
        array[i] = array[i]+a;
}
void unroll_loop(int a) {
    int i;
    for (i = 0; i &lt; N; i+=5){
        array[i] = array[i]+1;
        array[i+1] = array[i+1]+a;
        array[i+2] = array[i+2]+a;
        array[i+3] = array[i+3]+a;
        array[i+4] = array[i+4]+a;
    }
}
int main() {
    normal_loop(1);
    unroll_loop(1);
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ perf record -e branch-misses:u,branch-instructions:u ./perf_record_example
$ perf report
</code></pre>
<p><code>:u</code>是讓 perf 只統計發生在 user space 的 event。最後可以觀察到迴圈展開前後 branch-instructions 的差距。</p>
<p>另外，使用 record 有可能會碰到的問題是取樣頻率太低，有些函式的訊息沒有沒顯示出來（沒取樣到），這時可以使用 <code>-F &lt;frequcncy&gt;</code>來調高取樣頻率，可以輸入以下查看最大值，要更改也沒問題，但能調到多大可能還要查一下。</p>
<pre><code class="language-sh">$ cat /proc/sys/kernel/perf_event_max_sample_rate
</code></pre>
<h2 id="參考資料-6"><a class="header" href="#參考資料-6">參考資料</a></h2>
<ul>
<li><a href="http://www.brendangregg.com/linuxperf.html">Linux Performance</a></li>
<li><a href="https://perf.wiki.kernel.org/index.php/Tutorial#Sample_analysis_with_perf_report">Tutorial - Linux kernel profiling with perf</a> [Perf wiki]</li>
<li>Perf - Linux下的系統性能調優工具 / 劉明 [IBM developerWorks]
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">第一部分 - 簡介、背景知識、基本使用</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/index.html">第二部分 - tracepoint、probe、sched、bench、lock、Kmem、timechart、使用 Script 增強 perf 的功能</a></li>
</ul>
</li>
<li><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Performance_Monitoring_Unit.pdf">A Study of Performance Monitoring Unit, perf and perf_events subsystem</a> [PDF]</li>
<li><a href="http://kernel.taobao.org/index.php?title=Documents/Perf_FAQ">Perf FAQ</a> [kernel.taobao.org]</li>
<li><a href="http://unix.stackexchange.com/questions/14227/do-i-need-root-admin-permissions-to-run-userspace-perf-tool-perf-events-ar">Do I need root (admin) permissions to run userspace ‘perf’ tool?</a></li>
<li><a href="http://www.carbondesignsystems.com/virtual-prototype-blog/using-the-arm-performance-monitor-unit-pmu-linux-driver">Using the ARM Performance Monitor Unit (PMU) Linux Driver</a></li>
<li><a href="http://blog.csdn.net/trochiluses/article/details/17346803">perf 性能分析實例——使用perf優化cache利用率</a> [CSDN]</li>
</ul>
<h2 id="context-switches-1"><a class="header" href="#context-switches-1">Context Switches</a></h2>
<p>Context Switches  上下文切換，有時也被稱為處理程序切換(process switch)或任務切換。是一個重要的性能指標。</p>
<p>CPU從一個執行緒切換到另外一個執行緒，需要保存當前任務的運行環境，恢復將要運行任務的運行環境，必然帶來性能消耗。</p>
<p>Context Switches 上下文切換簡介</p>
<p>作業系統可以同時運行多個處理程序， 然而一顆CPU同時只能執行一項任務，作業系統利用時間片輪轉的方式，讓使用者感覺這些任務正在同時進行。 CPU給每個任務都服務一定的時間, 然後把當前任務的狀態保存下來, 在載入下一任務的狀態後, 繼續服務下一任務。任務的狀態保存及再載入, 這段過程就叫做上下文切換。</p>
<p>時間片輪轉的方式使多個任務在同一顆CPU上執行變成了可能, 但同時也帶來了保存現場和載入現場的直接消耗。</p>
<p>上下文切換的性能消耗</p>
<p>Context Switchs過高，導致CPU就像個搬運工一樣，頻繁在暫存器(CPU Register)和運行佇列(run queue)之間奔波，系統更多的時間都花費線上程切換上，而不是花在真正做有用工作的執行緒上。</p>
<p>直接消耗包括: CPU暫存器需要保存和載入, 系統調度器的程式碼需要執行, TLB實例需要重新載入, CPU 的pipeline需要刷掉。</p>
<p>間接消耗：多核的cache之間得共享資料。間接消耗對於程序的影響要看執行緒工作區運算元據的大小。</p>
<p>性能分析查看Context Switches的方法</p>
<p>Linux中可以通過工具vmstat, dstat, pidstat來觀察CS的切換情況。vmstat, dstat只能觀察整個系統的切換情況，而pidstat可以更精確地觀察某個處理程序的上下文切換情況。</p>
<p>最常見的，在一些<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E7%A8%8B">排程</a>（scheduling）<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">演算法</a>內，其中行程有時候需要暫時離開CPU，讓另一個行程進來CPU運作。在先佔式多工系統中，每一個行程都將輪流執行不定長度的時間，這些時間段落稱為<a href="https://zh.wikipedia.org/wiki/%E6%99%82%E9%96%93%E7%89%87">時間片</a>。如果行程並非自願讓出CPU(例如執行<a href="https://zh.wikipedia.org/wiki/I/O">I/O</a>操作時，行程就需放棄CPU使用權)，當時限到時，系統將產生一個定時中斷，<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%B5%B1">作業系統</a>將排定由其它的行程來執行。此機制用以確保CPU不致被較依賴處理器<a href="https://zh.wikipedia.org/wiki/%E9%81%8B%E7%AE%97">運算</a>的行程壟斷。若無定時中斷，除非行程自願讓出CPU，否則該行程將持續執行。對於擁有較多I/O<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>的行程，往往執行不了多久，便需要讓出CPU；而較依賴處理器的行程相對而言I/O操作較少，反而能一直持續使用CPU，便形成了<a href="https://zh.wikipedia.org/wiki/%E7%8D%A8%E4%BD%94">壟斷</a>現象。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="你還在用老派網格交易嗎-試試新一代的-bollmaker-策略吧"><a class="header" href="#你還在用老派網格交易嗎-試試新一代的-bollmaker-策略吧">你還在用老派網格交易嗎? 試試新一代的 bollmaker 策略吧</a></h2>
<h2 id="網格交易"><a class="header" href="#網格交易">網格交易</a></h2>
<p>其實經歷 2020 年到 2022 年這整整兩年的加密貨幣牛市，很多人應該都已經知道網格交易策略是什麼。</p>
<p>熟悉網格交易的朋友應該都知道，網格需要設定區間，所以，要不是你的區間設定得非常好，每次抓震盪區間都能夠抓到非常準確，就是你必須砸重金開張天地網格，設下非常大的區間和非常多的格數。 但是天地網格單其實資金利用率很低，因為震盪幅度每天可能 2%~5% 左右遊走，你的區間如果設定是 500% 的上下區間，那可能每天吃到的單就很有限，掛單只能吃到很小的範圍。</p>
<p>但是在牛市中，震盪區間常常接下來就是幅度不小的拉盤，如果你設定震盪區間網格，那麼每次價格突破你的震盪區間，網格就是一定會幾乎賣飛所有現貨。</p>
<h2 id="研發全新穿越牛熊交易策略--bollmaker"><a class="header" href="#研發全新穿越牛熊交易策略--bollmaker">研發全新穿越牛熊交易策略 — bollmaker</a></h2>
<p>筆者這段時間一直在研究交易，在去年第二波新高回落時，思考什麼樣的策略有辦法穿越牛熊，也因此有了一些交易策略的靈感。</p>
<p><img src="strategy/images/1*VvyKItidPzWtA9VXhm_5BQ.png" alt="img" /></p>
<p>2021 年末 ETHUSDT 走勢</p>
<p>如上圖，ETHUSDT 的 4h 小時線做肉眼回測，當時是在接近 ATH 4800 左右的位置，價格不斷在布林通道上下方震盪來回作出緩跌，每一次都會重新回到布林通道上方，才繼續開始下跌。</p>
<p>所以筆者利用布林通道加上部位控制的算法，研發出 bollmaker 這套使用雙重布林通道的造市策略，但沒想到效果意外地好，只要設定完，放著給他跑就可以應付各種價格區間，幾乎不用一直調整參數。</p>
<p>雖然是自己研發，又是開放原始碼，肯定會有人抄襲模仿，但是筆者不怕，原因是我們每週都持續在研發改進。</p>
<p>我們先來看 bollmaker 的回測績效:</p>
<p><img src="strategy/images/1*ZJ2XZtE4u4Of8_yotjSD3g.jpeg" alt="img" /></p>
<p>使用八月的資料來做回測，測試到九月初的超大暴跌，初始資本: 20,000 USDT+ 1 ETH，單月已實損益 +$7,326.69。</p>
<p>最關鍵的是，跑完策略後，維持未實現損益 UNREALIZED PROFIT: +$ 17.55</p>
<p>沒有過度 hold ETH 部位，也沒有提早賣飛 ETH 部位，如果用這個獲利來試算 APY 的話，約是 APY +3097%。</p>
<h2 id="bollmaker-實戰的下單位置"><a class="header" href="#bollmaker-實戰的下單位置">bollmaker 實戰的下單位置</a></h2>
<p>先來看筆者跑 bollmaker 實戰的下單位置，這是幣安 App 的下單歷史顯示，S 是 Sell 賣單成交，B 是 Buy 買單成交:</p>
<p><img src="strategy/images/0*VpTetjoaz0s7mUYm" alt="img" /></p>
<p><img src="strategy/images/0*udA5Yb1VXn2C80mW" alt="img" /></p>
<p><img src="https://miro.medium.com/max/1182/0*xKiMPqViQAP4WAoV" alt="img" /></p>
<h2 id="bollmaker-的基本原理"><a class="header" href="#bollmaker-的基本原理">bollmaker 的基本原理</a></h2>
<p>其實 bollmaker 顧名思義就是他算是一種造市策略，透過利用在市場上創造流動性，同時在 mid price 上下方掛買單賣單，被動等其他人下單跟你成交來取得獲利。</p>
<p>但造市策略的天敵就是一路跌和一路漲，所以 bollmaker 透過兩個不同時間區間的布林通道來管控造市的下單。</p>
<p>長時間通道: 用來控制部位大小</p>
<p>短時間通道: 用來避免在強趨勢出現的時候下單</p>
<p><img src="strategy/images/1*WmAj4zAh7Wn-ZMFrdHclqw.png" alt="img" /></p>
<p>用上圖來解釋，如果我們長時間通道採用 30m，畫出來的布林通道大概是長這樣，價格根據常態分佈的機率 95.4 會在通道內遊走，因此我們抓下方通道用來囤貨，上方通道用來出貨來掛單，並依照通道的寬度去算出一個最大部位的分佈。</p>
<p>舉例來說，當價格靠近布林通道上方的時候，我們可以設定最多買 ETH 就是買到 0.1 顆，當價格靠近布林通道下方的時候，我們可以設定最多買 ETH 可到 10 顆。</p>
<p>所以透過這樣價格的遊走和動態的調控部位，我們就可以利用市場上的 Spread 價差來買低賣高獲利。</p>
<p><strong>bollmaker 是利用向下攤平的概念，在下跌趨勢中降低持有成本，並在反彈拉回的時候有機會能夠賣出並減碼，因此只要你本金足夠，就有辦法在市場週期中賺到錢。</strong></p>
<h2 id="bollmaker-適合的市場和情境"><a class="header" href="#bollmaker-適合的市場和情境">BollMaker 適合的市場和情境</a></h2>
<p>基本上要跑 bollmaker 主要還是以囤貨為目的，<strong>囤貨和逃頂是兩個極端的面相，兩者很難用同一組設定兼得。 也因此，你需要去選擇一個你願意長期投資的資產來做操作，不要去選投機幣來跑。</strong></p>
<p>所以當你覺得現在市場行情可以準備開始囤貨，就很適合跑 bollmaker 策略。</p>
<p><strong>建議跑在市值相對高的幣種，成交量高，震盪也多</strong>，且因為市值高的幣種在空頭市場來的時候，跌幅也不會像很多小幣一樣這麼深。大幣跌 8% 的時候，有些小幣一天可以跌到 20%。</p>
<h2 id="bollmaker-策略的缺點"><a class="header" href="#bollmaker-策略的缺點">BollMaker 策略的缺點</a></h2>
<p>醜話也是要先講在先，畢竟沒有策略能夠應付所有市場的極端情況。</p>
<p><strong>bollmaker 不怕急跌，因為這樣反而有機會在短時間內拉低持倉成本，但 bollmaker 的天敵是一路緩跌完全沒有回彈</strong> — 為什麼？因為價格要靠近布林通道上方的時候，我們才有機會開始減倉。</p>
<p>bollmaker 在掛單的時候，可採取每分鐘掛單一次，或是每五分鐘掛單一次，這可以自由設定，時間越短，成交頻率越高，獲利也會相對可觀，但在面對下跌的狀況，自然就會犧牲逃頂的特性。</p>
<p>剛剛上面有講到，bollmaker 是利用向下攤平的概念，在下跌趨勢中降低持有成本，並在反彈拉回的時候有機會能夠賣出並減碼，所以如果你的本金只有幾百美金是沒辦法跑的 — 為什麼? 因為交易所都有最小下單金額限制，通常是十美金，你每次掛單至少需要 10 美金，但你只準備 100 美金的話，就只有 10 次機會可以向下攤平，所以這樣會導致套牢的機率非常大。</p>
<p>根據筆者的實測，本金最少最少要能夠做 100~200 次以上的掛單，每單金額至少要 20U，也就是本金差不多需要 200 x 20 = 4000 是最小需求。</p>
<h2 id="市場價差-spread"><a class="header" href="#市場價差-spread">市場價差 Spread</a></h2>
<p>由於 bollmaker 的獲利靠的是市場的<strong>波動性</strong>，所以交易所的主動成交波動性很重要，看的是市場上的 taker buy 和 taker sell。</p>
<p>價格波動性來講，Binance 還是比 FTX 高，如果希望成交頻率高的話，會比較推薦在幣安上面跑 bollmaker。 FTX 也不是不行，但頻率自然會低一點。</p>
<p>在 MAX 交易所的話，由於 <strong>MAX 交易所的手續費非常低，幾乎是幣安的一半以上</strong>，而且又特別容易升等 VIP，所以如果你要在 MAX 上跑可以掛更近，舉例來說幣安上如果掛 0.1% 的價差 (幣安手續費是 0.075%)，那在 MAX 上可以掛到 0.05% 的價差達到類似的效果。</p>
<p>如果你喜歡筆者開發的自動交易策略，歡迎給筆者一點支持和鼓勵，可使用筆者的推薦碼註冊幣安, MAX 或 FTX 🙏</p>
<ul>
<li>幣安 https://accounts.binance.com/en/register?ref=38192708</li>
<li>MAX https://max.maicoin.com/signup?r=c7982718</li>
<li>FTX https://ftx.com/referrals#a=bbgo</li>
</ul>
<h2 id="如何設定-bollmaker"><a class="header" href="#如何設定-bollmaker">如何設定 bollmaker?</a></h2>
<p>如果你是工程師，對怎麼 build &amp; install 已經非常熟悉了，可以直接參考 bbgo 官方 repository 的文件做設置:</p>
<p>https://github.com/c9s/bbgo</p>
<p>如果你都還不懂，也還沒有跑過 bbgo ，可以先看看下面這篇:</p>
<p><a href="https://c9s.medium.com/bbgo-%E5%9C%A8%E5%AE%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%B7%91%E7%B6%B2%E6%A0%BC%E7%AD%96%E7%95%A5%E7%A8%8B%E5%BC%8F-cdb59e171cf9">BBGO — 在家也可以跑網格策略程式各位從 Google 進來看到這篇文章，應該已經很暸解網格策略的運作方式還有獲利模型，網格策略也有很多種變化，在這邊就不再闡述。c9s.medium.com</a></p>
<p>如果各位已經 ready 了，那就可以開始來設定 bollmaker 了。 先來看筆者建議的設定:</p>
<pre><code class="language-yaml">---
persistence:
  redis:
    host: 127.0.0.1
    port: 6379
    db: 0

exchangeStrategies:
- on: binance
  bollmaker:
    symbol: BNBUSDT
    interval: 1m
    amount: 30
    askSpread: 0.1%
    bidSpread: 0.1%
    minProfitSpread: 0.2%
    useTickerPrice: true
    
    dynamicExposurePositionScale:
      byPercentage:
        # exp means we want to use exponential scale, you can replace &quot;exp&quot; with &quot;linear&quot; for linear scale
        exp:
          # from down to up
          domain: [ -1, 1 ]
          # when in down band, holds 10.0 by maximum
          # when in up band, holds 1.0 by maximum
          range: [ 10.0, 1.0 ]

    uptrendSkew: 0.2
    downtrendSkew: 1.5

    long: true
    buyBelowNeutralSMA: true
    tradeInBand: true

    defaultBollinger:
      interval: &quot;4h&quot;
      window: 21
      bandWidth: 2.0

    neutralBollinger:
      interval: &quot;5m&quot;
      window: 21
      bandWidth: 2.0

    persistence:
      type: redis
</code></pre>
<p>以上，我們先看到 persistence 有設定 redis。 bbgo 基本上要執行是可以不用 redis 的，但是因為我們需要紀錄部位資訊，重開 bbgo 之後也要能夠載入回來，所以這邊要設定一下 redis，沒有的話，可以裝一下:</p>
<pre><code>apt install redis
</code></pre>
<p>繼續往下看到 <code>exchangeStrategies</code> 的部分，我們設定了 <code>bollmaker</code> ，設定細節如下:</p>
<p><code>interval</code> 是你多久要下單一次， <code>1m</code> 就是一分鐘，可使用的參數有 <code>1m</code> , <code>5m</code> , <code>15m</code> , <code>30m</code> , <code>1h</code> 等等，當然如果你使用越慢的掛單頻率，可以透過增加每次掛單金額來提高獲利率。</p>
<p><code>amount</code> 是你每次的下單金額 (BNBUSDT 的話，是以 USDT) 計算，這邊寫 30，意味著我們下單的顆量是 $30 等值的 BNB 顆量 (Quantity)。 剛剛有講到，這邊的 amount 最少是你的本金 1/100 或甚至 1/200, 最好可以到 1/500。</p>
<p><code>spread</code> 是掛單距離 mid price 的價差，所謂的 mid price 是 (第一檔賣單價格 + 第一檔買單加格) / 2。 通常設定 0.1% 左右，依照你的手續費比率來設定。 幣安是 0.075% ，因此我們這邊設定 0.1%。 如果是使用 MAX 交易所的話，可以設定 0.06% 左右。 <code>spread</code> 的設定跟 <code>interval</code> 參數有關，你可以打開線圖看每個分線的震幅 (Amplification)，只要小於這個震幅，成交頻率就會夠高。</p>
<p><code>long</code> 是指我們的 bollmaker 只做多頭部位 (只增加持倉，不會一開始就減倉)，不會賣掉你原本帳號裡手動買的部位。</p>
<p><code>minProfitSpread</code> 是指，當目前價格比持有成本高出 <code>minProfitSpread</code> 後，我們才開始掛賣單，這個數值越小越可以避險，但是在牛市也就越容易賣飛。</p>
<p><code>buyBelowNeutralSMA</code> 是指，當價格在布林通道的 SMA 以下我們才開始掛買單，這個設定是用來應付空頭市場，如果在牛市，會建議不要啟用 (可改為 false)。</p>
<p><code>dynamicExposurePositionScale</code> 就是我們用來調控部位的設定了，其中你看到 <code>[-1, 1]</code> 請不要去改他，你要修改的是 <code>range</code> ，-1 對應的就是布林通道下方， 1 對應的是布林通道上方。 也就是，如果設定 [100, 1] ，那麼你在布林通道下方最多就是買到 100 顆，上方最多買到 1 顆。 (這個部分的設定你可以一邊運行 bbgo 一邊依照需求修改，改完只要重啟 bbgo 即可)</p>
<p><code>defaultBollinger</code> 這個就是用來控制部位的布林通道，詳細設定你可以用 TradingView 或是幣安的走勢圖選一個合適布林通道出來用，這邊建議不要抓太近抓到 5m 或甚至 15m 都太短。</p>
<p><code>neutralBollinger</code> 這個是用來偵測短期趨勢用的布林通道，加上 <code>tradeInBand</code> 這個選項，如果超過這個布林通道的區間，bollmaker 就會暫停掛單。</p>
<p>最後，存檔好你的 bbgo 設定，就可以起飛:</p>
<pre><code>bbgo run
</code></pre>
<p>如果懶得自己設定，有在用 Linode 的朋友也可以用筆者準備的 StackScript 做一鍵部署:</p>
<p><a href="https://cloud.linode.com/stackscripts/1002384">Linode StackScript — BollMakerbbgo bollmaker deploymentcloud.linode.com</a></p>
<p>☝☝☝ ️️️️Linode StackScript for BollMaker</p>
<p>最後~</p>
<p>如果你喜歡筆者開發的自動交易策略，歡迎給筆者一點支持和鼓勵，可使用筆者的推薦碼註冊幣安, MAX 或 FTX 🙏</p>
<ul>
<li>幣安 https://accounts.binance.com/en/register?ref=38192708</li>
<li>MAX https://max.maicoin.com/signup?r=c7982718</li>
<li>FTX https://ftx.com/referrals#a=bbgo</li>
</ul>
<p>出處
https://c9s.medium.com/bbgo-bollmaker-%E7%A9%BF%E8%B6%8A%E7%89%9B%E7%86%8A%E7%9A%84%E8%87%AA%E5%8B%95%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5-b573ba6625b3</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="淺析經典高頻做市策略"><a class="header" href="#淺析經典高頻做市策略">淺析經典高頻做市策略</a></h1>
<p>引言：做市策略指的是一種分別建立限價買賣單，利用標的價格的上下波動觸發限價單，通過買賣單的差價獲取交易收益的策略。做市策略中重點關注的是限價單的數量和以及買賣單報價與中間價距離的設定，因而在各類經典的做市策略中，主要研究的是中間價的估算，進而在中間價兩邊合適的位置設定買單和賣單。本文將介紹做市的基本概念以及兩大經典高頻做市策略。</p>
<h2 id="第一章做市的基本概念"><a class="header" href="#第一章做市的基本概念"><strong>第一章：做市的基本概念</strong></a></h2>
<p>在一些流動性較好的標的資產的交易活動中，普通投資者可以通過提交市價單或者直接買賣標的資產或者相關衍生標的直接參與市場交易。這樣的市場中存在較多的投資者，資產流動性好。只要投資者在合理的價位出價，很快就可以找到交易對手。通過連續不斷的交易活動，資產的價值也可以逐漸反映在價格中，從而使得標的資產的價值得到充分的體現。這一方面促進了標的資產的價值實現，另一方面推動了市場整體資金的流動，一定程度上提高了市場投資活動的積極性，為市場經濟注入活力。</p>
<p>但在一些流動性較差的資產上，由於種種原因，參與這些資產投資活動的交易者較少，想要對這些資產展開買賣活動的投資者很難正確認識到資產的真實價值，也很難找到合適的對手進行成交，這時候就需要藉助做市商來為市場提供流動性了。</p>
<h2 id="1做市的定義"><a class="header" href="#1做市的定義"><strong>1.做市的定義</strong></a></h2>
<p>什麼是做市？簡而言之，做市就是製造市場流動性。股票市場的驅動方式分為報價驅動和訂單驅動。在訂單驅動的市場上，做市商有幾種不同的形式：交易所可以與指定做市商達成協議，在保證市場公平有序的前提下提供更多買賣報價，指定做市商必須在開盤和收盤時參與競價並在規定時間內保證一定比例的報價。非交易所指定的做市商則不必承擔上述義務，只是作為流動性提供者。採用做市策略的高頻交易者便是如此，在高頻交易資料的基礎上圍繞標的資產的價格在不同價位掛出限價單，當標的資產價格在不斷波動時會觸發做市商掛出的低價買單和高價賣單，做市商借此實現低買高賣，並賺取差價。而在報價驅動的市場上，做市商就是交易商，他們提供通過報價向其他市場參與者提供流動性。做市商通過賺取買賣價差獲利，每個做市商就像一個小的交易所。</p>
<h2 id="2做市策略的收益來源"><a class="header" href="#2做市策略的收益來源"><strong>2.做市策略的收益來源</strong></a></h2>
<p>由此可見，做市商在依賴於資產價格波動中高低價之間的差價獲得收益。那麼，這種買賣價差是如何形成的？Harold Demsetz, 1968研究了紐約股市的交易成本，研究中首次闡述了做市商買賣報價差的形成過程：供求的不平衡會導致價差產生，“買賣報價價差是有組織的市場為交易的即時性（immediacy）支付的加成”。做市策略通常在雙邊報價，通過成交價格在價差間的窄幅波動獲利，而這裡的窄幅一般只有1-2個價位，而非大方向性變化。根據市場有效理論，股票價格在市場有效的狀態下為“隨機遊走”，價格的走向不可預測。然而長期跟蹤研究發現，價格的長期走勢具有“均值回歸（Mean Reversion）”的特點。均值回歸在理論上具有必然性，價格走勢不可能只升不降或者只降不升，價格保持正收益率或負收益率稱之為均值迴避（Mean-aversion）。在均值回歸理論中，均值迴避的現像是暫時的，均值回歸是必然的。資產價格偏離其內在價值的程度影響均值回歸週期的長短。</p>
<p>Tanmoy Chakraborty and Michael Kearn, 2011通過理論和公式推導，進一步明確了做市策略的絕對收益。假設所有的市場事件出現在離散的時間點位 0，1，2 直到時刻T，在收盤時刻 T ，做市策略必須平掉所有的單方向淨頭寸。文章中證明瞭做市策略的理論收益為12(K−z2)，其中K=∑t=1T|Pt+1−Pt|表示價格波動的絕對幅度， z=PT−P0 表示收盤後平掉淨頭寸產生的淨盈虧。研究也進一步證明瞭在均值回歸的條件下，該理論收益的期望為正，也就是說在均值回歸的假設下，做市策略確實可以產生絕對收益。通過這個理論收益公式，我們也可以發現做市商需要儘可能捕捉價格的窄幅波動，而清除庫存以減低庫存風險的操作則會對做市商的絕對收益產生一定削減效應。</p>
<h2 id="3做市vs統計套利"><a class="header" href="#3做市vs統計套利"><strong>3.做市v.s.統計套利</strong></a></h2>
<p>在做市中，做市商不總是提交最優價格的買單或賣單，並且會儘量保持買賣單的平衡，減少庫存風險。由於庫存風險的存在，即做市商的庫存端可能會面臨反向的上漲趨勢，從而使其擔憂在標的資產上的淨空頭或淨多頭暴露，此時做市商會盡快做出反方向的買賣單從而降低庫存風險。另外有時為了防止買賣單被打穿，做市商也會在更深的價位做單。而統計套利策略的投資者則會故意做出方向性的交易，直到標的價格回歸到合理價格區間，因此在套利操作中存在在某個標的上的淨多頭或空頭是十分常見的。當然，做市商和套利交易者都持有中長期趨勢回歸的觀點——做市商在中間價基礎上在兩端建立買賣單，認為標的資產的價格會在中間價兩側上下波動，從而觸發買單和賣單，而做市商從中賺取差價；而套利投資者則是從標的資產的相對價值或者絕對價值出發，認為一定時間內，價格會回歸到相對價值或者絕對價值區間，因此當套利投資者發現某標的資產價格或者某組標的的相對價值脫離合理區間時，他們就會通過淨持倉，等待價格回歸到合理的價值區間，從而獲得策略收益。</p>
<h2 id="4做市策略的風險管理"><a class="header" href="#4做市策略的風險管理"><strong>4.做市策略的風險管理</strong></a></h2>
<p>在做市中，主要包括三類成本——指令處理成本、存貨成本、資訊成本，一般交易所指定的做市商會得到一定比例的手續費返還，因此做市商在建構做市策略中常常關注後兩種交易成本，在此基礎上，形成了兩類做市模型——存貨模型和資訊模型。</p>
<p><strong>（1）指令處理成本</strong></p>
<p>指在交易指令發生時做市商所承擔的如印花稅、過戶費等成本（早期還包含人工下單的人力成本）。</p>
<p><strong>（2）存貨成本</strong></p>
<p>指做市商在向市場提供買賣報價時而保有一定數目的證券等頭寸而產生的成本。因為標的物的價值會不斷變動及價格和交易數量的不確定性，有可能帶來的成本損失。通常來說，交易量的不確定性越高則做市商保持的存貨越多；標的物的價格不確定性越高，存貨成本則越高。做市商期望通過買賣價差來獲取利潤。做市商如果不同時買賣，就會產生庫存成本。做市商面臨的最核心問題就是如何在有多空庫存暴露的風險下更加精準地報價，避免積累大量的多空頭寸（圖1）。Smidt, 1971指出被動報價的做市商假設不能夠解釋價差隨著股票價格的波動而變化，做市商作為市場的理性參與者，也不會被動地進行報價，而是根據自己的庫存情況主動地調整報價，控制庫存風險和提高庫存的周轉率。</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-b39435554096d64625279c8a244ad668_720w.webp" alt="img" /></p>
<p>圖1：存貨模型對於買賣報價的調整（來源：加密資產衍生品新藍海，期權交易詳解,2020.）</p>
<p>做市商往往根據收益最大化和風險最小的原則來決定買賣報價，做市商控制自身的初始財富以及任一給定時間點手中所持有的資金和存貨。Garman , 1976首次提出了基於庫存的做市商報價決策模型。此後，庫存模型從單個做市商的情況發展至多個做市商的情形（Ho and Stoll, 1983），由單期模型擴展至多期決策，並引入了風險係數來研究不同風險偏好程度的做市商的決策（Stoll, 1978, Ho and Stoll, 1981）。但Madhavan and Smidt, 1991也通過實證表明庫存風險並不能完全解釋對做市商的收益。</p>
<p><strong>（3）資訊成本</strong></p>
<p>資訊成本是未知情交易者對知情交易者付出的成本。如果在市場上存在資訊知情者，那麼在這種資訊不對稱的場景下，做市商如果選擇和資訊知情者交易，將會承擔一定的損失。Treynor, 1971指出在交易中，做市商根據委託訂單的情況來區分具備和不具備資訊優勢的交易者的交易動機對交易決策有重要的作用。因此，如何通過對訂單流的分析來獲取隱藏的交易資訊，成為做市商報價模型的新的發展發向。Stoll, 1989利用NASDAQ資料將市場實際的交易價差分解為訂單處理成本（45%）、庫存成本（10%）和資訊不對稱成本（45%），發現資訊不對稱成本和訂單處理成本是影響做市商行為的最重要的兩個因素。</p>
<p>Bagehot, 1971提出資訊模型，當下隨著交易資訊公開化和電子交易的推動，投資者大量使用限價單。做市商也會分析市場微結構，研究訂單簿波動性來預測價格的短期變化。</p>
<hr />
<p><strong>第二部分：經典高頻做市策略</strong></p>
<p>接下來，我們將簡單介紹兩大經典的高頻做市模型——AS模型（Avellaneda, M., and S. Stoikov, 2008）和GP模型（Fabien Guilbaud and Huyen Pham, 2011）。</p>
<h2 id="經典高頻做市策略之一as模型"><a class="header" href="#經典高頻做市策略之一as模型"><strong>經典高頻做市策略之一：AS模型</strong></a></h2>
<p>Avellaneda, M., and S. Stoikov, 2008在庫存風險管理的基礎上建立了高頻做市的AS模型。AS模型的理論基礎源於Ho and Stoll, 1980和Ho and Stoll, 1981這兩篇文章的研究結論，前者分析了在競爭環境中，做市商的報價與所有代理商的無差別報價相關；而後者則研究了一個做市商在考慮了存貨風險的前提下，單項標的資產報價中的最優決策——即在資產的“真實價格”兩側建立最優買賣單。AS模型在此基礎上，研究了市場中單個做市商的最優決策行為，並用市場中間價代表所謂的“真實價格”。模型建立主要分為兩個步驟：首先，做市商在給定庫存下，計算出自身對資產的無差異估值，即中間價格；其次，根據報價單與中間價之間的距離推算報價單被執行的機率，在此基礎上結合市場環境和做市商的風險承受能力建立效用函數，推匯出做市商的最優報價。</p>
<h3 id="第一部分模型推導"><a class="header" href="#第一部分模型推導"><strong>第一部分：模型推導</strong></a></h3>
<p>（1）中間價格</p>
<p>做市商對於標的資產的無差異估值由下式給出：</p>
<p>dSu=σ∗dWu</p>
<p>中間價格的初始值St=s，上式中Wu表示一維標準布朗運動。</p>
<p>（2）效用函數</p>
<p>做市商的目標是為了在時間T實現損益最大化，為了研究做市商的效用函數，Avellaneda, M., and S. Stoikov首先以不活躍的交易者為例考察了做市商的效用函數。</p>
<p>不活躍的交易者指的是尚未提交報價任何報價單，在投資期間標的資產上有固定持有庫存q的投資者。假設該交易者原來持有現金x，當其庫存為q時，該投資者的效用函數為v，使用凸函數度量風險，此時交易者的效用函數如下式所示：</p>
<p>v(x,s,q,t)=E[−exp⁡(−γ(x+q∗ST)]⇒v(x,s,q,t)=−exp⁡(−γ(x+q∗s))∗exp⁡(γ2q2σ2(T−t)2)</p>
<p>對於不活躍的交易者，當他們願意以一單的價格買入一單位標的資產，成交後該交易者持有現金x−rb，庫存增加一單位，若此交易行為對該交易者的效用不產生影響，則rb表示該交易者的無差異買價（reservation bid price），即rb應當滿足：</p>
<p>v(x−rb,s,q+1,t)=v(x,s,q,t)</p>
<p>通過同樣的方式我們也可以建立無差異賣價（reservation ask price）ra的等量關係式，解得：</p>
<p>ra(s,q,t)=s+(1−2q)γσ2(T−t)2rb(s,q,t)=s+(−1−2q)γσ2(T−t)2r(s,q,t)=s−qγσ2(T−t)</p>
<p>其中r(s,q,t)表示買賣價的均價。</p>
<p>上述討論是針對有限的投資期間T−t展開的，若從無限的時間長度來討論，該投資者的效用函數為</p>
<p>v¯(x,s,q)=E[∫0∞v(x,s,q,t)dt]ω=γ2q2σ22⇒v¯(x,s,q)=E[∫0∞−exp⁡(−ωt)∗exp⁡(−γ(x+qSt))dt]</p>
<p>其中ω將決定投資者允許持有庫存量的上界，一般設定為</p>
<p>ω=12γ2σ2(qmax+1)2</p>
<p>（3）建構限價單</p>
<p>為瞭解決最優報價決策的問題，模型進一步研究了可以通過限價單交易參與市場投資的做市商的行為。</p>
<p>A.限價單報價及執行數量</p>
<p>做市商在中間價兩端分別以pa和pb的價格分別報單，假設做市商可以連續無成本報價，報價單與中間價之間的距離δa=pa−s、δb=pb−s，以及當前限價單的結構決定了該做市商限價單被執行的優先順序。具體來說，以限價買單為例，若市價賣單數量為Q，當這批賣單最深的價位pQ低於做市商限價買單報價pb時， 限價單被擊穿成交。而實證研究表明市價賣單最深價位與中間價的差價Δp與市價賣單數量的對數值成正比，即</p>
<p>Δp=pQ−s∝ln⁡(Q)</p>
<p>經過時間t後，做市商分別持有Nta手空單，Ntb手多單。根據研究，假設Nta、Ntb分別服從速率為λa和λb的泊松過程，λa和λb表示限價單分別被市價點選穿的機率，當δ超出Δp時，限價單將不會被擊穿，得到λ(δ)=Aexp(−kδ) 。</p>
<p>B.最佳化問題</p>
<p>經過時間t後，做市商持有現金Xt，滿足</p>
<p>dXt=padNta−pbdNtb</p>
<p>淨庫存為qt=Ntb−Nta。此時做市商面臨的最佳化問題是：</p>
<p>u(s,x,q,t)=maxδa,δbE[−exp⁡(−γ(XT+qTST))]</p>
<p>上述等式也需要同時滿足</p>
<p>u(x,s,q,t)=u(x−rb,s,q+1,t)=u(x+ra,s,q−1,t)</p>
<p>我們可以通過求解上述價值函數的Hamilton-Jacobi-Bellman偏微分方程解得 ra 和 rb 的均值即中間價以及 δa 和 δb 的和：</p>
<p>r(s,q,t)=ra+rb2=s−qγσ2(T−t)δa+δb=2γln⁡(1+γk)</p>
<h3 id="第二部分實證研究"><a class="header" href="#第二部分實證研究"><strong>第二部分：實證研究</strong></a></h3>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-ad7e27ed06c0c3fabee7b993a0e76b54_720w.webp" alt="img" /></p>
<p>圖2.1：圍繞中間價格進行報價的做市收益（來源：華泰期貨研究院）</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-9d78b80bb0fb9cda45b17686949c99fd_720w.webp" alt="img" /></p>
<p>圖2.2：使用AS模型的做市收益（來源：華泰期貨研究院）</p>
<p>華泰期貨，190425對比了圍繞中間價進行報價（圖2.1）和參照AS模型圍繞無差別價格進行報價（圖2.2）這兩種方式進行做市的策略收益，可以發現兩種方法在賬面上都能產生盈利，但AS模型的策略收益要顯著高於直接圍繞中間價進行報價的策略收益，並且前一種方法在限倉後明顯產生了收益的下滑，而AS模型的收益則在限倉前後持續上漲。從返傭比例的臨界點來看（圖3），使用AS模型僅需要57.22%的手續費返還就可以實現盈虧平衡，而直接在中間價兩端進行報價則需要返還84.51%的手續費才能扭虧為盈。</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-c14ec8714548d31bcf3ad029c753e39f_720w.webp" alt="img" /></p>
<p>圖3：策略收益對比（來源：華泰期貨研究院）</p>
<h3 id="第三部分拓展與推廣asq模型"><a class="header" href="#第三部分拓展與推廣asq模型"><strong>第三部分：拓展與推廣——ASQ模型</strong></a></h3>
<p>華泰期貨，190520指出AS模型能有效模擬市價單的成交情況，但是沒有對庫存風險進行有效管理，因此該研究在AS模型模型的基礎上加上了對庫存最值的限制，當庫存達到最值時，立即停止相應端的報價，只做反方向報價，以期減少庫存，降低庫存風險。通過實證結果的對比（圖4.1、圖4.2），我們可以發現，AS模型和加上庫存限制的ASQ模型策略收益幾乎相當，但ASQ模型下手續費用更低，也因此使得ASQ模型對返傭比例的要求更低，最大持倉也更小。</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-7675f486adb0b1cf04fc3a2ca3a3e44b_720w.webp" alt="img" /></p>
<p>圖4.1：AS模型v.s.ASQ模型做市策略收益（來源：華泰期貨研究院）</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-728ee94946c13740bf665dc7dfee2efc_720w.webp" alt="img" /></p>
<p>圖4.2：策略收益對比（來源：華泰期貨研究院）</p>
<hr />
<h2 id="經典高頻做市策略之二gp模型"><a class="header" href="#經典高頻做市策略之二gp模型"><strong>經典高頻做市策略之二：GP模型</strong></a></h2>
<p>Fabien Guilbaud and Huyen Pham, 2011根據動態規劃原理在不同的庫存條件以及成交機率下，在一檔掛限價單，對比以最優買價、最優買價+一個跳價，最優賣價、最優賣價+一個跳價這四種掛單方式中的最優選擇。</p>
<p>GP模型假設做市商的目標是通過市價單和限價單，控制庫存數量，實現在某個短期區間的收益最大化。通過Markov過程模擬中間價的變動，使用Cox過程模擬給定價差和限價時做市商的限價單成交情況，並結合Calibration程序估計轉移矩陣和價差的密度參數等，最終形成一個以庫存和價差變數為基礎執行的動態作業系統。</p>
<h3 id="第一部分模型推導-1"><a class="header" href="#第一部分模型推導-1"><strong>第一部分：模型推導</strong></a></h3>
<p>（1）中間價格和價差</p>
<p>GP模型使用外生的Markov過程來模擬標的資產中間價的變化。</p>
<p>對於使用限價單參與交易的投資者而言，隨機買賣價差是市場參與者的投資結果，會在隨機的時間點發生跳動，並且這些價差只能是單個跳價的整倍數，因此研究中使用Cox過程模擬價差的變動，即分別使用獨立的泊松過程模擬市場上的買價和賣價，並通過實際資料估計價差的轉移矩陣：</p>
<p>ρij:=P[Sn+1=jσ∣Sn=iσ]ρij:=∑n=1K1{(S^n+1,S^n)=(jσ,iσ)}∑n=1K1{S^n=iσ}</p>
<p>（2）建構限價單</p>
<p>在價格選取的過程中，做市商需要在當前的最優報價或者相對最優報價差一個跳價的報價之間做出抉擇，後者在實際應用中主要是為了提高將當前限價單在限價單序列中的位置提前，從而提高該限價單被執行的機率。在限價單建構這一步中，做市商的限價單策略可以被描述為</p>
<p>αtmake=(Qtb,Qta,Ltb,Lta)</p>
<p>其中L=(La,Lb)表示的限價單量，Q=(Qa,Qb)表示限價單報價決策。對於限價買單，做市商可以選擇最優買價，或者最優買價+一個跳價，即</p>
<p>Qb=(Bb,Bb+),Bb+=Bb+tick</p>
<p>同樣的，做市商也可以選擇在最優賣價或者最優賣價-一個跳價上報出限價單，即</p>
<p>Qa=(Ba,Ba−),Ba−=Ba−tick</p>
<p>在以下幾種特殊情況下，做市商的限價單報價是確定的：</p>
<p>A.初始報價時：直接選擇最優報價，即</p>
<p>Qb=Bb,Qa=Ba</p>
<p>B.當差價為一個跳價時：直接選取最優報價，即</p>
<p>Qb=Bb,Qa=Ba</p>
<p>由於此時差價為一個跳價，Bb+=Ba ，Ba−=Bb。</p>
<p>根據之前的研究，我們已經得到了中間價和價差，當進一步確定了選取最優報價還是次優報價（即比最優報價差一個跳價的報價）時，做市商就可以報出限價單的價格π(q,p,s)，當價差 s=i∗δ 時，定義</p>
<p>πi(p,q)=π(q,p,i∗δ)</p>
<p>接下來，使用Cox過程模擬限價單被執行的過程，即分別用獨立的泊松過程Na和Nb表示市價買單和市價賣點選中限價單，這兩個過程的密度參數分別為λa(Qta,St)和λb(Qtb,St)。相應地，我們可以建構出庫存Y和現金X的微分方程：</p>
<p>dYt=Ltb∗dNtb−Lta∗dNtadXt=−πb(Qtb,Pt−,St−)Ltb∗dNtb+πa(Qta,Pt−,St−)Lta∗dNta</p>
<p>（3）利用市價單減少庫存</p>
<p>為了降低庫存風險，GP模型也通過引入市價單來減少庫存，市價單部分的決策包括市價單下單量和執行時間，</p>
<p>αtake=(τn,ζn)</p>
<p>其中，τn表示市價單的執行時間序列，ζn則表示每次市價單執行時觸發的單量，ζn&gt;0 表示在最優賣價買入，ζn&lt;0表示在最優買價賣出，那麼隨之產生的庫存Y和現金序列X分別滿足：</p>
<p>Yτn=Yτn−+ζnXτn=Xτn−−c(ζn,Pτn,Sτn)c(e,p,s)=ep+|e|∗s2+ε</p>
<p>其中c表示做市商執行市價單的成本，ε表示固定費用。</p>
<p>（4）最佳化</p>
<p>綜合上述步驟，做市商的目標是通過限價單和市價單為基礎的綜合做市策略α=(αmake,αtake)，實現效用函數最大化：</p>
<p>maxE[U(L(XT,YT,PT,ST))−γ∫0Tg(YT)dt]L(x,y,p,s)=x−c(−y,p,s)=x+yp−|y|s2−ε</p>
<p>其中 L 表示做市商持有的流動性函數，U表示做市商持有的流動性為其帶來的效用，庫存則在效用函數中則表現為懲罰，從而使得效用函數在達到最優時，把庫存風險降低到可容忍範圍內。</p>
<p>在Fabien Guilbaud and Huyen Pham的研究中，他們考察了兩種方式來度量流動性為做市商帶來的效用：U(x)=x;U(x)=−exp(−ηx)，並通過分離變數的方法將整體效用函數的最佳化問題簡化為</p>
<p>U(x)=x,g(y)=y2vi(t,x,y,p):=v(t,x,y,p,s=iδ)vi(t,x,y,p)=x+yp+ϕi(t,y)</p>
<p>同樣通過求解上述效用函數的Hamilton-Jacobi-Bellman偏微分方程，可以得出做市商的最優策略。研究發現在兩種效用函數下，最優決策均與市場價格無關，與庫存水平和價差相關。</p>
<h3 id="第二部分實證研究-1"><a class="header" href="#第二部分實證研究-1"><strong>第二部分：實證研究</strong></a></h3>
<p>華泰期貨，190730通過實證探究了最優掛單策略的分佈規律。圖5表示的是買賣價差狀態為1時最優買單掛單的位置分佈，可以發現當空頭庫存較高時，最優策略傾向於在次優買價掛單，以減少庫存風險；隨著空頭庫存單的減少或者多頭庫存的上升，由於庫存偏向性不高，最優策略偏向於在買一價掛單；當多頭庫存上升到一定程度時，庫存風險較高，做市商停止掛單。</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-3aa472138fae30570aa09b0fef7c6400_720w.webp" alt="img" /></p>
<p>圖5：2017 年 8 月 14 日買賣價差狀態為 1 時，最優買單位置（來源：華泰期貨研究院）</p>
<p><em>註：圖中紅色表示在次優價掛單，黃色表示在最優價掛單，白色表示停止掛單。</em></p>
<p>通過在滬銅期貨日盤上的回測研究發現，GP模型的做市收益十分穩定，但是做市策略的盈利大概是手續費的10%，並且與手續費高度相關（圖6）。因此手續費的返還水平需要達到90%以上才能實現盈利，也就是說GP模型的整體收益十分依賴於手續費的返還水平。同時，高成交量導致的高手續費與高撤單量也是GP模型的一大缺陷，由於GP模型採取在買一賣一或者更差的價位上報價的方式，多數情況限價單成交都只有跳價的一半，導致每次成交產生的利潤都十分有限。</p>
<p>從整體來看，GP模型的優勢在於充分考慮了庫存風險的管理，並且考慮了市場上報價的跳價現象，在離散報價的基礎上進行最優策略的研究，但從實證結果來看，GP模型的策略收益很大程度上依賴於手續費返還的比例，並且對手續費返還的要求較高。</p>
<p><img src="strategy/%E9%80%A0%E5%B8%82/../images/v2-a78c17741905caf01251011f1b3f0601_720w.webp" alt="img" /></p>
<p>圖6：GP 模型做市策略收益（來源：華泰期貨研究院）</p>
<hr />
<h2 id="參考文獻"><a class="header" href="#參考文獻"><strong>參考文獻</strong></a></h2>
<p>[1] Demsetz H. The cost of transacting[J]. The quarterly journal of economics, 1968, 82(1): 33-53.</p>
<p>[2] Chakraborty T, Kearns M. Market making and mean reversion[C]//Proceedings of the 12th ACM conference on Electronic commerce. 2011: 307-314.</p>
<p>[3] Smidt S. Which road to an efficient stock market: free competition or regulated monopoly?[J]. Financial Analysts Journal, 1971, 27(5): 18-20.</p>
<p>[4] Garman M B. Market microstructure[J]. Journal of financial Economics, 1976, 3(3): 257-275.</p>
<p>[5] Ho T S Y, Stoll H R. The dynamics of dealer markets under competition[J]. The Journal of finance, 1983, 38(4): 1053-1074.</p>
<p>[6] Stoll H R. The pricing of security dealer services: An empirical study of NASDAQ stocks[J]. The journal of finance, 1978, 33(4): 1153-1172.</p>
<p>[7] Ho T, Stoll H R. Optimal dealer pricing under transactions and return uncertainty[J]. Journal of Financial economics, 1981, 9(1): 47-73.</p>
<p>[8] Madhavan A, Smidt S. A Bayesian model of intraday specialist pricing[J]. Journal of Financial Economics, 1991, 30(1): 99-134.</p>
<p>[9] Bagehot W. The only game in town[J]. Financial Analysts Journal, 1971, 27(2): 12-14.</p>
<p>[10] 加密資產衍生品新藍海，期權交易詳解,2020.<a href="https://link.zhihu.com/?target=https%3A//www.odaily.com/post/5146681">https://www.odaily.com/post/5146681</a></p>
<p>[11] Avellaneda M, Stoikov S. High-frequency trading in a limit order book[J]. Quantitative Finance, 2008, 8(3): 217-224.</p>
<p>[12] Guilbaud F, Pham H. Optimal high-frequency trading with limit and market orders[J]. Quantitative Finance, 2013, 13(1): 79-94.</p>
<p>[13] 華泰期貨-股指期貨高頻做市策略的政策性影響-190425</p>
<p>[14] 華泰期貨-股指期貨高頻做市策略的庫存風險管理-190520</p>
<p>[15] 華泰期貨-量化專題報告：基於離散報價的高頻做市策略-190730</p>
<p><em>市場有風險，投資需謹慎。以上陳述僅作為對於歷史事件的回顧，不代表對未來的觀點，同時不作為任何投資建議。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="期貨報價訂閱"><a class="header" href="#期貨報價訂閱">期貨報價訂閱</a></h3>
<pre><code class="language-py">import shioaji as sj
import datetime as dt
import pandas as pd
import signal
import os
import sys
import json
import time

# from datetime import timedelta
from dateutil import relativedelta
from line_notify import LineNotify
from datetime import timezone, timedelta


tz = timezone(timedelta(hours=+8))


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


def get_week_of_month(day_of_month=dt.datetime.now(tz).day):
    return (day_of_month - 1) // 7 + 1


def getFutureDate(today=dt.datetime.now(tz)):
    week_of_month = get_week_of_month()
    weekday = today.weekday()
    print(today, week_of_month, weekday)
    # 第三週 星期三 小於 15:00 周選就是月選
    if (
        week_of_month == 3
        and weekday == 2
        and today &lt; dt.datetime(today.year, today.month, today.day, 15, 0)
    ):
        return str(today.year) + str(today.month + 1).zfill(2)
    else:
        return str(today.year) + str(today.month).zfill(2)


def getOpenPrice(api, year, month, day, open_time):
    FutureDate = getFutureDate()
    TXF = &quot;TXF&quot; + FutureDate
    date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
    kbars = api.kbars(api.Contracts.Futures.TXF[TXF], date)
    df = pd.DataFrame({**kbars})
    df.ts = pd.to_datetime(df.ts)
    df.set_index(&quot;ts&quot;, inplace=True)
    open_price = df.iloc[df.index.get_loc(open_time, method=&quot;nearest&quot;)][&quot;Open&quot;]
    return open_price


def getOptionsDealts(api, OP, year, month, day):
    date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
    try:
        # print(OP[:3], OP, date)
        ticks = api.ticks(api.Contracts.Options[OP[:3]][OP], date)
        df = pd.DataFrame({**ticks})
        if df.empty:
            return pd.DataFrame()
        df.ts = pd.to_datetime(df.ts)
        df[&quot;OP&quot;] = OP
    except:
        # print(OP)
        return pd.DataFrame()
    return df


# {1: buy deal, 2: sell deal, 0: can't judge}
def set_tick_type(df):
    if df[&quot;close&quot;] == df[&quot;bid_price&quot;]:
        return 1
    elif df[&quot;close&quot;] == df[&quot;ask_price&quot;]:
        return 2
    else:
        return 0


@sj.on_quote
def quote_callback(topic: str, quote: dict):
    TAG = str(topic.split(&quot;/&quot;)[0])
    # print(topic, TAG, json.dumps(quote, indent=4, ensure_ascii=False))
    print(TAG, quote)
    # if TAG == 'L':
    #    #print(f'逐筆報價:{quote}')
    #    print(topic)
    #    print(f&quot;Time:{quote['Date']} {quote['Time']}, Close:{quote['Close']}&quot;, len(TICKS))
    #    TICKS = TICKS.append({'time':f&quot;{quote['Date']} {quote['Time']}&quot;,
    #                                  'price':quote['Close'][0]}, ignore_index=True)
    # elif TAG == 'Q':
    #    pass
    #    #print(f&quot;AskPrice:{quote['AskPrice']}, BidPrice:{quote['BidPrice']}&quot;)
    #    #print(f'五檔報價:{quote}')
    # elif TAG == 'I':
    #    print(topic)
    #    print(f&quot;代碼:{quote['Code']}&quot;, \
    #          f&quot;日期:{quote['Date']} {quote['Time']}\n&quot;, \
    #          f&quot;開盤價:{quote['Open']}&quot;, \
    #          f&quot;最低價:{quote['Low']}&quot;, \
    #          f&quot;最高價:{quote['High']}&quot;, \
    #          f&quot;成交價:{quote['Close']}&quot;, \
    #          f&quot;總金額:{quote['AmountSum']}&quot;, \
    #          f&quot;總成交張數:{quote['VolSum']}&quot;, \
    #          f&quot;總成交筆數:{quote['Cnt']}&quot;,
    #          f&quot;漲跌價:{quote['DiffPrice']}&quot;, \
    #          f&quot;漲跌幅:{quote['DiffRate']}&quot;)
    # elif TAG == 'MKT':
    #    Code = str(topic.split('/')[-1])
    #    # TickType：1代表外盤、2代表內盤
    #    #print(quote['TickType'][0], type(quote['TickType'][0]))
    #    print(f&quot;代碼:{Code}&quot;, \
    #          f&quot;日期:{quote['Date']} {quote['Time']}\n&quot;, \
    #          f&quot;成交價:{quote['Close'][0]}&quot;, \
    #          f&quot;總金額:{quote['AmountSum'][0]}&quot;, \
    #          f&quot;成交盤:{'外盤成交' if quote['TickType'][0] == 1 else '內盤成交'}&quot;, \
    #          f&quot;總成交張數:{quote['VolSum'][0]}&quot;)


def main():
    api = sj.Shioaji(simulation=False)
    with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/login.txt&quot;, &quot;r&quot;) as f:
        kw_login = json.loads(f.read())
        accounts = api.login(**kw_login, contracts_timeout=300000)

    FutureDate = getFutureDate()
    MXF = &quot;MXF&quot; + FutureDate
    TXF = &quot;TXF&quot; + FutureDate
    # print(api.Contracts.Futures.MXF)
    api.quote.subscribe(
        api.Contracts.Futures.TXF[TXF],  # 期貨Contract
        quote_type=sj.constant.QuoteType.Tick,  # 報價類型為Tick
        # version=sj.constant.QuoteVersion.v1,  # 回傳資訊版本為v1
    )
    api.quote.set_callback(quote_callback)
    print(MXF, TXF)
    while True:
        time.sleep(1)


if __name__ == &quot;__main__&quot;:
    Watcher()
    main()


</code></pre>
<h3 id="選擇權訂閱"><a class="header" href="#選擇權訂閱">選擇權訂閱</a></h3>
<pre><code class="language-py">import shioaji as sj
import datetime as dt
import pandas as pd
import signal
import os
import sys
import json
import time

# from datetime import timedelta
from dateutil import relativedelta
from line_notify import LineNotify
from datetime import timezone, timedelta


tz = timezone(timedelta(hours=+8))


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


def get_week_of_month(year, month, day):
    &quot;&quot;&quot;
    獲取指定的某天是某個月的第幾周
    週一為一週的開始
    實現思路：就是計算當天在本年的第y周，本月一1號在本年的第x周，然後求差即可。
    因為查閱python的系統庫可以得知：
    &quot;&quot;&quot;
    begin = int(dt.date(year, month, 1).strftime(&quot;%W&quot;))
    end = int(dt.date(year, month, day).strftime(&quot;%W&quot;))
    return end - begin + 1


def getFutureDate(today=dt.datetime.now(tz)):
    week_of_month = get_week_of_month(today.year, today.month, today.day)
    weekday = today.weekday()
    # 第三週 星期三 小於 15:00 周選就是月選
    if (
        week_of_month == 3
        and weekday == 2
        and today &lt; dt.datetime(today.year, today.month, today.day, 15, 0)
    ):
        print(today.year, today.month)
        return str(today.year) + str(today.month).zfill(2)
    else:
        return str(today.year) + str(today.month + 1).zfill(2)


def getOpenPrice(api, year, month, day, open_time):
    FutureDate = getFutureDate()
    TXF = &quot;TXF&quot; + FutureDate
    date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
    kbars = api.kbars(api.Contracts.Futures.TXF[TXF], date)
    df = pd.DataFrame({**kbars})
    df.ts = pd.to_datetime(df.ts)
    df.set_index(&quot;ts&quot;, inplace=True)
    open_price = df.iloc[df.index.get_loc(open_time, method=&quot;nearest&quot;)][&quot;Open&quot;]
    return open_price


def get_week_of_month(year, month, day):
    &quot;&quot;&quot;
    獲取指定的某天是某個月的第幾周
    週一為一週的開始
    實現思路：就是計算當天在本年的第y周，本月一1號在本年的第x周，然後求差即可。
    因為查閱python的系統庫可以得知：

    &quot;&quot;&quot;

    begin = int(dt.date(year, month, 1).strftime(&quot;%W&quot;))
    end = int(dt.date(year, month, day).strftime(&quot;%W&quot;))

    return end - begin + 1


def getOptionsDealts(api, OP, year, month, day):
    date = dt.datetime(year, month, day).strftime(&quot;%Y-%m-%d&quot;)
    try:
        # print(OP[:3], OP, date)
        ticks = api.ticks(api.Contracts.Options[OP[:3]][OP], date)
        df = pd.DataFrame({**ticks})
        if df.empty:
            return pd.DataFrame()
        df.ts = pd.to_datetime(df.ts)
        df[&quot;OP&quot;] = OP
    except:
        # print(OP)
        return pd.DataFrame()
    return df


# {1: buy deal, 2: sell deal, 0: can't judge}
def set_tick_type(df):
    if df[&quot;close&quot;] == df[&quot;bid_price&quot;]:
        return 1
    elif df[&quot;close&quot;] == df[&quot;ask_price&quot;]:
        return 2
    else:
        return 0


def main():
    api = sj.Shioaji(simulation=False)
    with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/login.txt&quot;, &quot;r&quot;) as f:
        kw_login = json.loads(f.read())
        accounts = api.login(**kw_login, contracts_timeout=300000)

    now = dt.datetime.now(tz)
    wm = get_week_of_month(now.year, now.month, now.day)
    n_w = dt.datetime.today().weekday()
    # print(wm, n_w)
    # print(api.Contracts.Options)
    # print(now.strftime(&quot;%Y%m&quot;))
    week_delivery_month = now.strftime(&quot;%Y%m&quot;)
    month_delivery_month = (
        (now + relativedelta.relativedelta(months=1)).strftime(&quot;%Y%m&quot;)
        if wm &gt;= 3 and n_w &gt;= 2
        else now.strftime(&quot;%Y%m&quot;)
    )
    print(week_delivery_month, month_delivery_month)
    month_options = []
    week_options = []
    strike_price_list = []
    for option in api.Contracts.Options:
        for o in option:
            if &quot;TX&quot; in o[&quot;category&quot;] and (
                o[&quot;delivery_month&quot;] == week_delivery_month
                or o[&quot;delivery_month&quot;] == month_delivery_month
            ):
                strike_price_list.append(int(o[&quot;strike_price&quot;]))
                if o[&quot;category&quot;] == &quot;TXO&quot;:
                    month_options.append(o[&quot;symbol&quot;])
                else:
                    week_options.append(o[&quot;symbol&quot;])
    now = dt.datetime.now(tz)
    week_of_month = get_week_of_month(now.year, now.month, now.day)
    weekday = now.weekday()

    # 第三週 星期三 小於 15:00 周選就是月選
    if (
        week_of_month == 3
        and weekday == 2
        and now &lt; dt.datetime(now.year, now.month, now.day, 15, 0)
    ):
        week_options = month_options

    EndDate = dt.datetime.now(tz) + dt.timedelta(days=1)
    StartDate = EndDate - dt.timedelta(days=7)
    DataFrameList = []
    OptionsDict = {}

    if now.hour &lt; 15:
        open_time = dt.datetime(now.year, now.month, now.day, 8, 45, 0)
    else:
        # open_time = dt.datetime(now.year, now.month, now.day, 8, 45, 0)
        open_time = dt.datetime(now.year, now.month, now.day, 15, 0, 0)

    open_price = getOpenPrice(api, now.year, now.month, now.day, open_time)
    strike_price_list = sorted(list(set(strike_price_list)))
    strike_price = min(strike_price_list, key=lambda x: abs(x - open_price))
    # print(strike_price_list, strike_price)
    # print(week_options)
    week_options = [s for s in week_options if str(strike_price) in s]
    print(week_options)

    while StartDate &lt;= EndDate:
        for OP in week_options:
            df = getOptionsDealts(
                api, OP, StartDate.year, StartDate.month, StartDate.day
            )
            if not df.empty:
                columns = [
                    &quot;OP&quot;,
                    &quot;ts&quot;,
                    &quot;close&quot;,
                    &quot;volume&quot;,
                    &quot;ask_price&quot;,
                    &quot;ask_volume&quot;,
                    &quot;bid_price&quot;,
                    &quot;bid_volume&quot;,
                ]
                df = df[columns]
                df = df.assign(tick_type=df.apply(set_tick_type, axis=1))
                DataFrameList.append(df)
        StartDate = StartDate + dt.timedelta(days=1)

    if DataFrameList != []:
        df_final = pd.concat(DataFrameList, axis=0, ignore_index=True)
        # print(df_final.to_markdown())
        options = list(set(df_final[&quot;OP&quot;].tolist()))
        # print(options)
        for option in options:
            indexs = df_final[df_final.OP == option].index.tolist()
            # print(indexs)
            # print(df_final.iloc[indexs])
            OptionsDict[option] = (
                df_final.iloc[indexs].sort_index(ascending=True).reset_index(drop=True)
            )

    Resistance_Support = {}
    for key, value in OptionsDict.items():
        # print(value, type(value))
        value.ts = pd.to_datetime(value.ts)
        value.set_index(&quot;ts&quot;, inplace=True)
        for t, row in value.iterrows():
            if t &gt;= open_time:
                if key[-1] == &quot;P&quot;:
                    print(open_price + row.close)
                    Resistance_Support[&quot;Resistance&quot;] = open_price + row.close
                else:
                    print(open_price - row.close)
                    Resistance_Support[&quot;Support&quot;] = open_price - row.close
                break

    LineNotify(&quot;KXwzqEGtIp1JEkS5GjqXqRAT0D4BdQQvCNcqOa7ySfz&quot;).send(
        f&quot;\nOpen Price: {open_price} \nResistance: {Resistance_Support['Resistance']} \nSupport: {Resistance_Support['Support']}&quot;
    )
    LineNotify(&quot;eTd1BOTLRXu4VtFWNwwFr3DjOcQnm7ZdLIyEuR4ZgII&quot;).send(
        f&quot;\nOpen Price: {open_price} \nResistance: {Resistance_Support['Resistance']} \nSupport: {Resistance_Support['Support']}&quot;
    )
    print(&quot;OPEN PRICE:&quot;, open_price, open_time)
    # open_price = df.iloc[df.index.get_loc(open_time, method=&quot;nearest&quot;)][&quot;Open&quot;]


if __name__ == &quot;__main__&quot;:
    Watcher()
    print(getFutureDate())
    input()
    main()

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三角套利策略"><a class="header" href="#三角套利策略">三角套利策略</a></h1>
<h2 id="策略說明"><a class="header" href="#策略說明">策略說明</a></h2>
<p>三角套利又叫間接套利或多邊套利，起源於外匯市場中利用交叉匯率定價錯誤進行的套利。</p>
<p><strong>所謂三角套利，是一種引入三種貨幣的套利手段。它利用三種外匯對合理交叉匯率的暫時性偏離來實現套利。理論上，如果我們擁有很低延遲的下單平臺，並且可以獲得較低的買賣價差，那麼我們有機會實現無風險套利</strong>。</p>
<p>三角套利在數字貨幣市場同樣適用，通常情況下，數字貨幣之間的匯率與其相對應的美元價格相關。但由於數字貨幣市場波動性較強，部分交易所由於流動性不足等各種原因，會造成某些時刻，<strong>合成交叉價格和市場價格的暫時偏離</strong>，當這種偏離足夠抵消我們的交易成本時，我們便可使用三角套利方法實現無風險利潤。</p>
<p><strong>適用情況</strong>：行情有較大波動時，不同交易標的漲跌幅不同導致的不同交易對之間的價格變動之後。</p>
<p><strong>舉個例子</strong>，現貨市場現有這樣三個交易對：BTC/USDT，ETH/USDT，ETH/BTC。</p>
<p>假設前提是：市場中的手續費為零:</p>
<p>BTC/USDT買1 = 9999 USDT，賣1=10000 USDT；</p>
<p>ETH/USDT買1 = 299 USDT，賣1 = 300 USDT；</p>
<p>ETH/BTC買1 = 0.029901 BTC，賣1 = BTC 0.03001 BTC。</p>
<p>我們根據BTC/USDT以及ETH/USDT的現價計算出ETH/BTC的現價，計算後得知ETH/BTC的理論買1 = 0.029902 BTC，賣1 = 0.03000 BTC，與市場現價基本吻合。</p>
<p>若某時刻價格出現波動，<strong>ETH/BTC買1變為0.038 BTC，賣1變為0.039 BTC，另外兩個交易對價格不變</strong>。</p>
<p><img src="strategy/images/circle_cn.jpg" alt="" /></p>
<p>最終，所有盈虧均反映在USDT上，我們在市場行情的波動下，利用價差實現了三角套利。</p>
<p><strong>優勢</strong>：受交易標的價格漲跌影響較小，無行情劇烈變動導致的大額虧損，總體風險較小。</p>
<p><strong>劣勢</strong>：掛單變動導致價格滑點；交易存在手續費成本；可能存在套利後未及時兌換成穩定幣，持有幣種價格下跌導致虧損的風險；受交易資料延遲以及交易所訂單撮合性能影響較大。</p>
<p><strong>此外，KuCoin擁有level3等級的交易資料、極優的撮合引擎，以及對api使用者提供特別的手續費折扣，極大程度的減少了你在策略實施時的劣勢，同時提供sandbox環境作為資料測試支撐，幫助你規避風險。</strong></p>
<p><strong>請注意，任何策略在使用時需要做好風險管理，如果你想在實際環境中利用策略獲得穩定的盈利，我們希望你能夠在sandbox環境配合其他參數或是策略進行測試調整，以使你能夠達到目的，我們也非常期待你能分享你的測試資料以及獨到的見解。</strong></p>
<p><strong>當然，如果這個過程中，你遇到任何問題需要幫助亦或是有賺錢的策略想要分享，請在ISSUE中反映，我們會努力及時響應。</strong></p>
<p><strong>如果你對該策略有興趣，請點選右上角star，我們會根據star個數來衡量策略的受歡迎程度和後續最佳化優先順序，你也可以點選右上角watching通過接收更新通知來持續關注該項目</strong>。</p>
<h2 id="比特幣怎麼低風險套利不知道這6點不要買比特幣建議收藏"><a class="header" href="#比特幣怎麼低風險套利不知道這6點不要買比特幣建議收藏">比特幣怎麼低風險套利？不知道這6點不要買比特幣（建議收藏）</a></h2>
<p>先說結論：</p>
<p><strong>1.比特幣套利不是騙局，但是，比特幣套利機會很少。</strong></p>
<p><strong>2.收費教你比特幣搬磚套利的100%是騙子，別問我為什麼知道。</strong></p>
<p><strong>3.拿不準時，記得翻翻我這篇文章（文章略長，可以先收藏）。</strong></p>
<p>OK，下面我們進入正題，比特幣套利方法有很多種，一般人我不告訴他。常見的有現貨搬磚、期現對沖、期期對沖、跨平臺合約對沖、跨品種套利、大週期套利（適合小白）。</p>
<hr />
<p>（1）現貨搬磚</p>
<p>什麼是現貨交易？一手交錢，一手交貨。比如你去菜市場買菜，這就是一種現貨交易。</p>
<p>由於比特幣在不同交易所存在價差，這就產生了搬磚套利的概念。就好像同樣的土豆超市1斤賣5塊，而菜市場1斤才2塊，於是你可以從菜市場買土豆，賣給超市，這便是套利原理。具體到比特幣來說，現貨搬磚的方法有兩個：</p>
<ul>
<li>在A平臺買入<a href="https://www.bixiaobao.com/cn/coinlist/bitcoin">比特幣</a>，在B平臺賣出。好處是風險低，缺點是手續費高，搬磚一次十分麻煩，利潤低。</li>
<li>在A和B兩個平臺同時存入比特幣和USDT，在價格低的平臺買入比特幣，價格高的平臺賣出比特幣。這種方法的缺點是資金佔用大，有時需要承擔一定的波動風險。</li>
</ul>
<p>（2）期現對沖</p>
<p>期現對沖也是一種常見的比特幣套利方法，這種方法的好處是風險低，效率高，我見過牛逼的策略年化超過100%，回撤才百分之幾，缺點是門檻略高，一般人玩不了。</p>
<p>由於比特幣期貨和現貨之間常常存在價差，因此產生了套利機會。什麼是比特幣期貨？大家可以把期貨理解成一種可以賣出的品種，舉例，假如幣小寶判斷未來比特幣價格下跌，即使我手裡沒有比特幣，也可以賣出，這便是期貨交易。（要是不理解期貨相關概念，建議先收藏文章）</p>
<ul>
<li>期現對沖的基本方法是：在某一價位買入比特幣，同時在比特幣期貨賣出比特幣。當比特幣期貨價格低於現貨價格時，平倉期貨，同時賣出比特幣；當比特幣現貨價格高於期貨時，賣出現貨，平掉期貨。</li>
<li>舉例，幣小寶在6萬塊的位置買入了1枚比特幣現貨，同時在該價位賣出1枚比特幣期貨。10天以後，比特幣現貨跌至5.2萬，而比特幣期貨卻跌至5萬。賣出現貨，幣小寶虧損0.8萬；平倉期貨，幣小寶賺了1萬。一來一去，賺了0.2萬。</li>
</ul>
<p>（3）期期對沖（交割合約）</p>
<p>期期對沖是利用不同期貨品種進行套利。比特幣期貨分為永續合約和交割合約。交割合約又分本週，次周，季度，次季度。由於不同合約間差價不同，而短期合約都會涉及到交割從而產生了套利機會。</p>
<ul>
<li>比如比特幣本週合約5萬塊，指數5.2萬，季度5.5萬。即可做多本週，等比例做空季度。等交割時平倉獲利即可。</li>
</ul>
<p>期期對沖需要非常專業的水平，建議慎重參與。</p>
<p>（4）跨平臺合約對沖</p>
<p>這種方法是針對永續合約的。幣小寶參與過一段時間，個人覺得風險收益比較低。</p>
<p>與現貨類似，不同平臺之間的永續合約也存在一定價差。</p>
<ul>
<li>可以在價格低的平臺做多比特幣永續，價格高的平臺做空比特幣永續，待價格回歸後平倉即可。</li>
</ul>
<p>（5）跨品種套利</p>
<p>跨品種套利主要是指比特幣不同交易對之間的套利，有時也稱三角套利。比如BTC/USDT、BTC/ETH、ETH/USDT這三個交易對之間由於行情波動存在套利機會。</p>
<ul>
<li>舉例，BTC/USDT=10000；BTC/ETH=50；ETH/USDT=220</li>
<li>此時，買入BTC,花費10000美金，之後將BTC全部換成50ETH，最後再將ETH賣出50*220=11000。這筆交易獲利1000美金。</li>
</ul>
<p>不過，實際交易中這種機會比較少，需要碰運氣，這種方法的優勢是風險非常低。</p>
<p>（6）大週期套利（適合小白）</p>
<p>很多人看了上面的幾點，還是不明白怎麼進行比特幣套利。下面講一種非常簡單的套利方法，也就是大週期套利。</p>
<p>這個方法是幣小寶獨家首創哈。先說這個方法的缺點：持有週期長（3~6個月或更長），交易機會少（1年1次），好處是操作簡單，風險可控，適合小白。</p>
<ul>
<li>大週期套利原理是：比特幣價格一般會圍繞長期開採成本大幅波動。當比特幣價格大幅低於開採成本時，果斷買進，高於開採成本時，賣出。</li>
<li>舉例：比特幣在2018年12月至2019年3月之間價格小於3萬，而當時最好的礦機挖一枚比特幣都得4萬多，因此，可以果斷買入。而比特幣歷史價格也顯示，在這一區域買入獲利的概率非常高。</li>
</ul>
<p><img src="strategy/images/unnamed.png" alt="" /></p>
<p>unnamed.png</p>
<p>而今年的3月份市場大跌，比特幣一度跌到3.8萬，再次出現了一次非常強烈了買入機會。如果你不知道怎麼看挖礦成本，還有一個辦法是，根據比特幣歷史K線判斷。</p>
<ul>
<li>當比特幣價格低於周線MA256時，選擇買入，高於MA256時，賣出。</li>
</ul>
<p><img src="strategy/images/unnamed1.png" alt="" /></p>
<hr />
<p>總結，目前市場確實存在很多比特幣套利策略，但是萬變不離其宗，套利的本質是價差。與一般的炒幣相比，套利風險低，吸引了大量的專業玩家介入。目前市場一般都是程序化套利，類似於股票行業的高頻交易。因此，對於一般人門檻較高。比特幣套利確實也不乏大牛，一年幾倍時有發生，但那都是常人難以企及的高度。幣小寶認為，大週期套利雖然交易機會少，但是好在門檻低。</p>
<p>總之，要想對比特幣套利深入瞭解，還需要在實踐中進行提升，切勿一知半解盲目投資，<strong>否則可能遇到各種名義的搬磚套利騙子</strong>（比如至今仍然存在的火幣搬磚套利騙局）。本文主要拋磚引玉，期待大家在比特幣投資方面取得更大的成就。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="史上最詳盡的海龜交易法則筆記"><a class="header" href="#史上最詳盡的海龜交易法則筆記">史上最詳盡的海龜交易法則筆記</a></h1>
<p>出處 ： https://zhuanlan.zhihu.com/p/158083885</p>
<p>海龜交易的一切都源於全世界最著名的期貨投機家理查德 丹尼斯和他的好朋友比爾 埃克哈特的一場爭論，就是傑出的交易者究竟是天生的還是培養出來的。丹尼斯相信他幾乎可以把任何一個人變為優秀的交易者，埃克哈特則認為這是一種天賦問題，不是培養問題。丹尼斯願意用自己的錢來證明自己的話，於是兩人打了一個賭。</p>
<p>為此，他們在《華爾街日報》、《巴倫週刊》和《紐約時報》上刊登了大幅廣告，宣佈丹尼斯正在招募培訓生，他會把自己的交易方法傳授給這些人，然後給每個人一個100萬美元的交易帳戶。這些培訓生就被叫做海龜。</p>
<p>我認為海龜交易法則是一套投機理念，它的技術規則、操作規則與心理解析共同支撐了這套交易系統，而不是單單根據一些技術資料進行交易，它的技術資料可能在我們自己的市場得不到驗證，但是整個理念適合於所有的投機市場。</p>
<p>《海龜交易法則》這本書的作者就是丹尼斯的門徒之一，他負責丹尼斯最大的一個帳戶，為丹尼斯賺了3100多萬美元。</p>
<p>海龜的思維</p>
<p>三種類型的交易者</p>
<p>對沖者：一般為企業，通過買賣期貨合約抵消期貨價格波動風險。</p>
<p>帽客：經營市場的流動性風險，希望通過快速與對沖者交易賺取價差。他們為市場創造了流動性，因為他們在不停的出價、要價，寄希望於買單和賣單之間的平衡。</p>
<p>投機者：寄希望短期價格的預判。</p>
<p><img src="strategy/images/v2-acd9da93ddb16c9e45ea44f6ed726842_720w.webp" alt="img" /></p>
<p>價格變動取決於市場中所有的買者和賣者的共同態度，這些買賣者就是我們所說的那些帽客、投機者和對沖者：想在一天內反覆賺取微小買賣價差的人（帽客），想投機於一天或幾個星期、幾個月內價格大幅變化的人（投機者），以及想規避經營風險的人。（對沖者）</p>
<p>共同態度變了，價格就會變化。不管什麼原因，一旦賣者不再願意以目前的價格賣出，而是想提高價格，買者又願意接受這個更高的價格時，市場價格就會上漲。反之亦然。</p>
<p>交易過程中出現的情緒：</p>
<ol>
<li>希望：我當然希望我買了之後，它馬上就漲</li>
<li>恐懼：我再也賠不起了，這一次我得躲得遠遠的。</li>
<li>貪心：我賺翻了，我要把我的頭寸擴大一倍。</li>
<li>絕望：這個交易系統不管用，我一直在賠錢。</li>
</ol>
<p>在那些較為簡單原始的環境中，人類已經形成的某些特定的世界觀對他們大有幫助，但在交易世界中，這些認識反而成了障礙。人類認識現實的方式可能出現扭曲，科學家們稱之為認知偏差。以下是幾種對交易行為有影響的認知偏差：</p>
<p><strong>1、損失厭惡：對避免損失有一種強烈的偏好。也就是說，不賠錢遠比賺錢更重要。</strong></p>
<p>患上損失厭惡症的人對避免損失有一種絕對的偏好，盈利只是第二位的。對大多數人來說，沒有賺到100美元與損失了100美元並不是一回事。但是從理性角度來看，這兩者是一回事：它們都代表著這100美元沒有盈利。</p>
<p><strong>2、沉沒成本效應：更重視已經花掉的錢，而不是而來可能要花的錢。</strong></p>
<p>假設ACME公司投入了1億美元開發一種用於生產筆記型電腦螢幕的特殊技術，但在這筆錢已經花掉之後，該公司卻發現另外一種技術明顯更好，而且更有可能及時帶來它所期望的成果。如果從純理性的角度出發，ACME公司應該權衡一下採用這種新技術的未來成本和繼續使用當前技術的未來成本，然後根據未來的收益和支出狀況作出決策，完全不必考慮已經花掉的那些研發投資。</p>
<p><strong>3、處置效應：早早兌現利潤，卻讓損失持續下去。</strong></p>
<p>指投資者傾向於賣掉價格正在上漲的股票，卻保留價值正在下跌的股票。有人認為這種效應與沉沒成本效應有關。</p>
<p><strong>4、結果偏好：只會根據一個決策的結果來判斷它的好壞，而不去考慮決策本身的質量。</strong></p>
<p><strong>5、近期偏好：更重視近期的資料或經驗，忽視早期的資料或經驗。</strong></p>
<p>指一個人更重視近期的資料和經驗。昨天的一筆交易比上個星期或上一年的交易重要。近兩個月的賠錢經歷可能跟過去6個月的賺錢經歷同樣重要，甚至更加重要。於是，近期的一連串不成功的交易會導致交易者懷疑他們的方法和決策程序。</p>
<p><strong>6、錨定效應：過於依賴容易獲得的資訊。他們可能會盯著近期的一個價位，根據當前價格與這個參考價格的關係來作出決策。</strong></p>
<p><strong>7、潮流效應：盲目相信一件事，只因為其它許多人都相信它。</strong></p>
<p><strong>8、小數定律：從太少的資訊中得出沒有依據的結論。</strong></p>
<p>小樣本對總體並沒有太大的代表性。比如，如果一個交易系統在6次測試中有4次成功，大多數人都會說這是一個好系統，但從統計學上說，並沒有足夠多的資訊可以支援這種結論。</p>
<h2 id="一些交易風格"><a class="header" href="#一些交易風格">一些交易風格</a></h2>
<p><strong>1、趨勢跟蹤</strong></p>
<p>使用這種方法的交易者檢視利用幾個月內的大趨勢。趨勢跟蹤者在市場處於歷史高位或低位的時候入市，如果市場逆轉並維持了幾個星期，他們就會退出。</p>
<p><strong>2、反趨勢交易</strong></p>
<p>與趨勢交易相反，在價格接近新高的時候賣空。他們的理論依據是，新高的突破大多都不會引發市場趨勢。</p>
<p><strong>3、波段交易</strong></p>
<p>本質上與趨勢跟蹤交易相同，只不過它瞄準的是短期市場動向。比如，一次成功的波段交易可能只會持續三四天，而不是幾個月。</p>
<p><strong>4、當日交易</strong></p>
<p>一個真正的當日交易者總是試圖在每天的交易結束之前退出市場。這樣一來，即使夜間爆發的負面新聞引發了開盤之後的劇烈變化，他們的頭寸也不會受到什麼影響。</p>
<h2 id="市場狀態"><a class="header" href="#市場狀態">市場狀態</a></h2>
<p>講技術的書，以下面的描述最為模稜兩可，因為很多參數沒有量化。比如第一個穩定平靜的狀態，較小的範圍是多少就很難界定，而且各人有各人的理解。但是這個問題直接影響到進場的時機，所以又必須進行量化。我不認為所有講述技術的書都是扯淡，也不認為所有講述技術的書都是真實的，最重要的還是得到一種思路，然後通過思路進行實驗，得出一個適合於自己的套路。這個適合於自己包括自己的風險承受能力，自己的資金量和操作手法。為了將下面描述的市場狀態做一個量化，首先假定觀察週期是3個月。</p>
<p><strong>1、穩定平靜</strong></p>
<p>價格在一個相對較小的範圍內上下波動，很少超出這個範圍。</p>
<p>量化指標：如果觀察週期內最高價與最低價的波幅不超過20%，以觀察週期的第一天價格為基準價，週期最後一天價格與基準價格波幅不超過10%，則為穩定平靜狀態。</p>
<p><img src="strategy/images/v2-e93ff006706788ccae10ea02d91171ab_720w.webp" alt="img" /></p>
<p>例子：魯抗醫藥2019年9月24日-12月31日</p>
<p><strong>2、穩定波動</strong></p>
<p>有大的日間或周間變化，但沒有重大的月際變化。</p>
<p>量化指標：如果觀察週期內最高價與最低價的波幅在20%-50%之間，週期最後一天價格與基準價格波幅不超過20%，則為穩定波動狀態。</p>
<p><img src="strategy/images/v2-7c541868e12f5fb1b88a4f0702d7b3dd_720w.webp" alt="img" /></p>
<p>例子：堅瑞沃能2020年4月17日-7月24日</p>
<p><strong>3、平靜的趨勢</strong></p>
<p>價格在幾個月中呈現出緩慢的運動或趨向，但始終沒有劇烈的回呼或反方向運動。</p>
<p>量化指標：向上趨勢為將週期分為均等的10段，每一段的波幅都不超過-20%，基準價向下波幅不超過-20%，週期最後一天價格幅度超過基準價60%，向下趨勢正好相反</p>
<p><img src="strategy/images/v2-f97ed5fbb583a9dce6230f95300e7077_720w.webp" alt="img" /></p>
<p>例子：神馳機電2020年1月23日-5月8日</p>
<p><strong>4、波動的趨勢</strong></p>
<p>價格有大的變化，偶爾伴有劇烈的短期逆轉。</p>
<p>量化指標：向上趨勢為基準價向下幅度在-20%以下，週期最後一天價格幅度超過60%，向下趨勢正好相反</p>
<p><img src="strategy/images/v2-a998a6413273723e2ce0f233d3a6ae5f_720w.webp" alt="img" /></p>
<p>例子：神馳機電2020年1月20日至4月30日</p>
<h2 id="海龜的課程"><a class="header" href="#海龜的課程">海龜的課程</a></h2>
<p><strong>1、破產風險</strong></p>
<p>裡面舉了一個擲骰子的例子，一個骰子6個面，假如你擲出4點、5點或6點，你每押1美元就賠給你2美元，那麼如果你口袋裡有1000美元，你每次會押多少錢？是押1000美元、500美元還是100美元？從機率上來說，如果你一次就all in，那麼你有50%的機率破產，如果你每次押500美元，那麼也有25%的機率破產，如果你每次押100美元，那麼你的破產機率是 0.510 =0.097%</p>
<p>破產風險會隨著賭注的增加而不成比例地迅速增大，這是它最重要的特徵之一。如果你把每次的賭金翻一番，破產風險一般不止翻一番，視系統特性的不同，風險有可能翻上兩番、三番甚至四番。</p>
<p><strong>2、資金管理</strong></p>
<p>所謂資金管理，就是指控制市場風險的程度，確保交易者能安然度過每一個交易者都必然要碰到的不利時期。交易者既要讓盈利潛力最大化，又要把破產風險控制在可以接受的水平，資金管理就是這樣一門藝術。</p>
<p>這裡書中的第三章看的不是太明白，所以查閱了知乎上的文章</p>
<p>2.1、首先要計算一個叫做ATR的技術指標，這個技術指標的演算法如下：</p>
<p>2.1.1、當前交易日的最高價與最低價間的波幅</p>
<p>2.1.2、前一交易日收盤價與當前交易日最高價間的波幅</p>
<p>2.1.3、前一交易日收盤價與當前交易日最低價間的波幅</p>
<p>以上三個數取最大值就叫真實波幅，根據迭代演算法，每天都可以取這麼一個真實波幅，比如取14天真實波幅的平均值作為當天的ATR（平均真實波幅），其實就跟移動平均線的演算法是一致的，只不過具體的規則有點區別。</p>
<p>舉個例子：</p>
<p>假設初始資金為init元，讓1個ATR波動表式帳戶的1%，再假設某股票價格為p，當前ATR值為atr，那麼應該買多少股呢？</p>
<p>應該買的股數 = init * 1% / atr</p>
<p>那麼交易的資金 = p * init * 1% / atr= init * 1% * p / atr</p>
<p>如果我們的止損定在1atr，那麼當虧損 = -atr * init * 1% * p / atr = - init * 1% 的時候，就止損</p>
<p>如果我們的止損定在2atr，那麼當虧損 = -2 * atr * init * 1% * p / atr = -2 * init * 1%的時候，就止損。</p>
<p>下面是原版海龜的ATR計算方法</p>
<blockquote>
<p>原版海龜ATR的計算方法
真實波幅 = max(H-L, H-PDC, PDC-L)
H=當日最高價
L=當日最低價
PDC=前一日收盤價
N = (19 * PDN +TR)/20
PDN = 前一日的N值
TR= 當日的真實波動幅度
由於公式中需要前一日的N值，你在首次計算N的時候不能用這個公式，只能計算真實波動幅度的20日簡單平均值。</p>
</blockquote>
<p>資金管理是海龜交易的精髓所在。</p>
<p><strong>3、期望值</strong></p>
<p>運用機率學公式，E= ∑iNp(xi)∗xi ，如果在有限次交易中，最後E的結果為正，那麼表示策略是可行的。所以短期的失利不重要，海龜以這樣的方式看待損失：損失只是做生意的成本，並不代表著一次錯誤交易或一個壞決策。</p>
<h2 id="像海龜一樣思考"><a class="header" href="#像海龜一樣思考"><strong>像海龜一樣思考</strong></a></h2>
<p><strong>1、避免結果偏好</strong></p>
<p>好的交易者考慮的是現在，而避免對未來考慮過多。新手則想預見到未來：如果他們贏了，他們會認為自己預測對了，感覺自己像個英雄；如果他們輸了，他們會把自己當成傻瓜。這是錯誤的。</p>
<p><strong>2、避免近期偏好</strong></p>
<p>大多數交易者不僅對未來考慮過多，對過去同樣考慮過多。他們會唸唸不忘過去所做的事，過去所犯的錯誤，還有過去那些失敗的交易。</p>
<p>海龜們會從過去的經歷中吸取教訓，但不會為過去而煩惱。他們不會為過去所犯的錯誤而責備自己，也不會對過去的失敗耿耿於懷。他們知道這只是遊戲的一部分。</p>
<p><strong>3、避免預測未來</strong></p>
<p>你必須從機率的角度來考慮未來，而不是擺出一副預測的架勢。文中舉的例子為對唐奇安趨勢系統的一次20年間月度回報率的測試結果，並作出了機率密度圖與累積機率圖，類似於常態分配圖。此例子提到了一個參數叫<strong>R乘數</strong>，R乘數等於一筆交易的利潤除以這筆交易的風險投入。風險投入的概念以一個例子說明。如果你在每盎司450美元的價位買了一份8月份黃金合約，止損退出價位是440美元，那麼你的風險投入是1000美元，因為450美元與440美元之差（10美元）乘以一份合約所代表的黃金數量（100盎司），等於1000美元。如果這筆交易賺了5000美元，那麼它就是一筆5R交易。以下是測試結果的機率圖（自己重設的，在資料上與文章的不一樣，意思是一個意思）</p>
<h2 id="發現系統優勢"><a class="header" href="#發現系統優勢"><strong>發現系統優勢</strong></a></h2>
<p>優勢這個詞借鑑自賭博理論，原本是指賭場所掌握的統計學優勢，它也指21點玩家可能通過記牌而獲得的優勢。在賭局中，如果你沒有優勢，從長期來看你肯定會輸。</p>
<p>交易世界中也是如此。如果你沒有優勢，交易的成本會讓你賠錢。交易中的優勢是指一種可以利用的統計學優勢，它以市場行為為基礎，而這些市場行為是會重複發生的。在交易世界中，最好的優勢來自於人類認知偏差所釀成的市場行為。</p>
<p><strong>系統優勢三要素</strong></p>
<p>1、資產組合的選擇：決定應該進入哪些市場的運算系統</p>
<p>2、入市訊號：決定什麼時候開始一筆交易的運算系統。</p>
<p>3、退出訊號：決定什麼時候退出一筆交易的運算系統。</p>
<p><strong>如何發現優勢</strong></p>
<p>當某種特定的市場行為發生時，系統會發出入市訊號。當你檢驗入市訊號時，你需要關注的是伴隨這種市場行為而來的價格變動。我們可以把這種價格變動分為兩個部分：好的變動和壞的變動。好的變動就是對你有利的變動。換句話說，如果你買入，那麼市場上漲就是好的變動。壞的變動與之相反。</p>
<p>交易者們把往壞方向的最大變動幅度稱為MAE（maximum adverse excursion），把往好方向的最大變動幅度稱為MFE（maximum favorable excursion）你可以用這些概念來直接衡量一個入市訊號的優勢。觀察一個入市訊號之後的價格變動，如果好的方向的平均最大變動幅度大於壞方向的平均最大變動幅度，說明存在正的優勢。一個真正隨機性的入市策略會帶來大致上相等的好變動和壞變動。比如，如果你用擲硬幣的方式來做出買賣決策，正面朝上就做多，背面朝上就做空，那麼在你入市之後的價格變動中，MFE與MAE應該相等。</p>
<p>MAE=abs(買入價-計算週期內的最低價)</p>
<p>MFE=abs(買入價-計算週期內的最高價)</p>
<p>文中介紹了作者自己開發的一種優勢比較工具，稱之為E-比率，E-比率的計算方式如下：</p>
<p>1、為每一個入市訊號計算指定時間段內的MFE和MAE。</p>
<p>2、將上述各MFE和MAE值分別除以入市時的ATR，這是為了根據波動性做出調整，將不同市場標準化。</p>
<p>3、將上述調整後的MFE和MAE分別求和然後除以入市訊號的總次數，得到調整後的平均MFE和MAE。</p>
<p>4、調整後的平均MFE除以調整後的平均MAE就是E-比率。</p>
<p>MFE= (∑1nMFEi/ATR)/n</p>
<p>MAE= (∑1nMAEi/ATR)/n</p>
<p>n = 入市訊號的總次數</p>
<p>E-比率 = MFE/MAE</p>
<p>擲硬幣的E-比率在n趨近於無窮大的時候應該等於1，所以E-比率等於1時，表明沒有優勢，也沒有劣勢。當E-比率大於1時（樣本量要足夠），說明當前的入市訊號存在優勢。E-比率要結合指定的時間段計算，如果以10個交易日為週期，那麼就稱之為E10-比率。文中將兩個入市訊號結合起來使用獲得了1.33的E-比率，證明通過一些策略是可以在買入時獲得很大優勢的。</p>
<p><strong>E比率實驗：</strong></p>
<p>由於A股市場無法做空，所以也無需擲硬幣，我的實驗步驟是這樣的：</p>
<p>1、找出A股的所有股票</p>
<p>2、隨機抽樣100隻股票</p>
<p>3、計算每隻股票從上市到當前時間的ATR值，採用海龜原版的方法計算ATR</p>
<p>4、針對每隻股票隨機選取起始時間（但是要保證往後有50個交易日）</p>
<p>5、計算每隻股票的E-50比率</p>
<p>6、計算這100隻股票的平均E-50比率</p>
<p>7、從第2步開始到第6步，重複100次</p>
<p>8、計算總體平均E-50比率</p>
<p>最後計算出來的E-50比率為1.49</p>
<p>同樣的邏輯計算出：</p>
<p>E-30比率為1.35</p>
<p>E-10比率為1.22</p>
<p>以下是程式碼片段</p>
<pre><code class="language-python3">&quot;&quot;&quot;
根據隨機入市訊號計算E-50比率
&quot;&quot;&quot;
def randomERate(self, n=50):
    e_list = []
    st = storage()
    sql = &quot;select symbol from stock_summary where type = 0&quot;
    stockList = self.connect.getAll(sql)
    for _ in range(100):
        mae_list = []
        mfe_list = []
        sample = getSamplePointWithRandom(100, stockList)
        for ss in sample:
            symbol = stockList[ss][0]
            tableName = &quot;stock_history_&quot;+symbol
            if st.isTableExist(tableName):
                sql = &quot;select `close`,`open`,`high`,`low` from &quot;+tableName+&quot; order by timestamp asc&quot;
                dataList = self.connect.getAll(sql)
                if len(dataList) &lt; n: #計算50日E比率，記錄小於50條的過濾掉
                    continue
                atr_list = []
                dList = []
                for idx in range(len(dataList)):
                    close_price = dataList[idx][0]
                    open_price = dataList[idx][1]
                    high_price = dataList[idx][2]
                    low_price = dataList[idx][3]
                    if idx == 0:
                        atr = high_price - low_price
                    else:
                        prev_close_price = dataList[idx-1][0]
                        tr = np.max([high_price - low_price, high_price - prev_close_price, prev_close_price - low_price])
                        atr = (19 * atr_list[idx - 1] + tr) / 20
                    atr_list.append(atr)
                    dList.append({'high': high_price, 'low': low_price, 'close': close_price, 'open': open_price, 'atr': atr})
                stop_num = len(dList) - n
                random_start = random.randint(0, stop_num)
                vList = dList[random_start:random_start+n]
                atr_buy = vList[0]['atr'] #入市時的atr
                v_low_list = []
                v_high_list = []
                for v in vList:
                    v_low_list.append(v['low'])
                    v_high_list.append(v['high'])
                mae = vList[0]['close'] - np.min(v_low_list) #買入價-最低價
                mfe = np.max(v_high_list) - vList[0]['close'] #最高價-買入價
                if atr_buy == 0:
                    continue
                mae_standard = mae/atr_buy
                mfe_standard = mfe/atr_buy
                mae_list.append(mae_standard)
                mfe_list.append(mfe_standard)
        mfe = np.sum(mfe_list)/len(mfe_list)
        mae = np.sum(mae_list)/len(mae_list)
        e = mfe/mae
        e_list.append(e)
    print(np.mean(e_list))
</code></pre>
<p><em>從實驗上可以看到，A股市場上的E比率通常是大於1的，由此可以看出，市場的不同會導致指標值出現較大的差異。至於這個指標對於A股市場，我認為需要辯證的看待。因為指標的演算法是MFE/MAE，而MFE是買入價減週期內最高價的絕對值，MAE是買入價減週期內最低價的絕對值。而我們的市場可能會出現這麼一種情況：在一個週期內出現了一段時間的暴漲和持續的低迷。如果我們的市場普遍存在這種情況，就會出現一個1.4以上的E比率。在《海龜交易法則》這本書中，這個值是一個非常有優勢的入市訊號，因為結合作者的交易策略（一次很大的盈利和N次較小的虧損，但是保證盈利蓋過所有虧損）是非常有效的，而對於A股市場來說，在沒有策略的指引下，這個指標還有意義麼？這是個值得思考的問題。所以對於所謂的技術導向來投機交易，學習指標沒有錯，但是我的意思是不能照本宣科，一是要理解指標的深層次含義，二是要結合具體的市場，三是要結合具體的策略，否則指標對我們來說不僅沒用，而且對我們有害。書中所說的也不能全信，重在理解，學習的只是思路，精髓在於利用思路去創造。</em></p>
<p><strong>退出策略的優勢</strong></p>
<p>如果有可能的話，即使是系統的退出策略也應該有優勢。遺憾的是，衡量退出策略的優勢更不容易。這是因為退出策略與入市策略和退出訊號都有關係。換句話說，你不能拋開最初建立一個頭寸的緣由而去單獨考察退出策略。這裡面不止有一個系統要素，而是有多個不同要素，而且它們之間有著錯綜複雜的互動作用。</p>
<h2 id="尋找交易時機"><a class="header" href="#尋找交易時機"><strong>尋找交易時機</strong></a></h2>
<p>優勢是在買者和賣者之間的戰場上發現的。作為一個交易者，你的任務就是找到這些戰場，靜觀誰勝誰敗。</p>
<p>對幾乎所有的交易策略來說，支撐和阻力都是一個基礎概念。所謂支撐和阻力，就是指價格有一種不突破前期水平的傾向。要理解這個概念，最簡單的辦法就是看看價格走勢圖。</p>
<p>支撐和阻力來源於市場行為，而這些市場行為則來源於三種認知偏差：錨定效應、近期偏好和處置效應。</p>
<p>錨定效應是指依賴輕鬆可得的資訊來判斷價格水平的傾向。一個近期的新高或新低變成了一個新的錨，之後的每一個價位都要根據這個錨來衡量和比較。新價格是高還是低，完全取決於它是高於還是低於這個錨定價。近期的高點或低點之所以會成為錨定價，是因為它們在圖表上一眼可見，在心理上對市場參與者有重大的影響。所謂的支撐位與阻力位即是錨定效應的一種表現。</p>
<p>大多數交易者都相信支撐和阻力現象的存在，這又進一步加強了支撐力和阻力，因為對這種現象深信不疑的交易者反過來也會促進這種現象。如果有很多交易者相信價格一旦下跌到某個水平就會有大批買入者接盤，那麼他們就更容易相信價格跌到這個水平時必然會反彈。這種信念將削弱他們在這個價位賣出的意願，因為他們更願意晚些再賣，等價格在這個支撐位反彈後再賣。於是，對支撐和阻力現象的篤定使它成了一種自我實現的機制。</p>
<p><strong>支撐位和阻力位的突破</strong></p>
<p>這裡就有趣了，支撐位和阻力位的突破對於兩種不同策略的交易者來說，他們的交易方向是相反的。既然叫阻力位和支撐位，那麼可以說價格在支撐位被支撐的機率比價格在支撐位被突破的機率要大，阻力位同理。那麼如果你是一個趨勢交易者，必然你在阻力位買入後的勝率就比較低，但是如果價格被突破，那麼錨定效應就會失效，此時價格可能會有一個大幅度的上漲。這樣在制定策略時，如果能設定一個低止損和高止盈，那麼你一次的大收益往往能彌補許多次的小虧損並有剩餘，從整體上來說就是盈利的。反趨勢交易者就是完全相反的操作，當你在支撐位買入後，價格反彈的機率會比較高，那麼你的勝率就會比較高，但是價格反彈後通常會馬上到達阻力位，到達阻力位之前你就必須賣掉頭寸，如果在支撐位買入後加個被突破，那麼就會虧損。與趨勢交易者一樣，你的策略也必須設定一個低止損和高止盈，但是這個高止盈不可超過阻力價位，這樣，如果你的止損和止盈是相同的百分比，那麼如果在勝率上有優勢，則總體上仍然是盈利的。</p>
<p><img src="strategy/images/v2-6b0269729442f914466068c10a78789b_720w.webp" alt="img" /></p>
<p>紅色是支撐位向下突破累積機率，藍色是壓力位向上突破累積機率</p>
<p>我在A股市場做了一個關於支撐位與壓力位的累計機率實驗。實驗隨機選取了500個股票樣本，每個股票隨機選取222個連續交易日，前22個交易日當做觀察週期，後200個交易日當做測試週期。先取觀察週期內的最高價和最低價，當做壓力位與支撐位。然後從測試週期的第一天開始測試，檢查當天的收盤價是否突破壓力位或支撐位，如果到測試週期的第三天，那就判斷第一天、第二天、第三天是否突破了壓力位或支撐位，以此類推。從圖中可以看出，12天內突破的機率大概是30%左右，25天內突破的機率大概是40%左右。說明錨定價位是真實存在的，並且支撐位的錨定價要比壓力位的錨定價效果更加顯著。支撐位與壓力位對於短線投機是非常重要的參考。</p>
<p>以下是程式碼片段：</p>
<pre><code class="language-python">def testSupportAndPress(self, n=1, limit=100):
    st = storage()
    period = self.getPeriod(n)
    sql = &quot;select symbol from stock_summary where `type`=0&quot;
    stockList = self.connect.getAll(sql)
    sample = getSamplePointWithRandom(500, stockList) #隨機抽取500個樣本
    support_result = {}
    press_result = {}
    for ss in sample:
        stock = stockList[ss]
        symbol = stock[0]
        tableName = &quot;stock_history_&quot;+symbol
        if st.isTableExist(tableName) is False: #沒有股票資料跳過
            continue
        sql = &quot;select `low`,`high`,`close` from &quot;+tableName+&quot; order by timestamp asc&quot;
        stockData = self.connect.getAll(sql)
        if len(stockData) &lt; period+limit: #股票資料不符合測試條件跳過
            continue
        support_result[symbol] = {}
        press_result[symbol] = {}
        for day in range(limit):
            support_result[symbol][day + 1] = 0
            press_result[symbol][day + 1] = 0
        start_idx = random.randint(0, len(stockData)-period-limit)
        stockInfo = stockData[start_idx:start_idx+period+limit]
        periodData = stockInfo[0:period]
        obData = stockInfo[period:]
        period_low_list = []
        period_high_list = []
        for pd in periodData:
            low_price = pd[0]
            high_price = pd[1]
            period_low_list.append(low_price)
            period_high_list.append(high_price)
        support_price = np.min(period_low_list)
        press_price = np.max(period_high_list)
        ob_close_price_list = []
        for day in range(len(obData)):
            close_price = obData[day][2]
            ob_close_price_list.append(close_price)
            for ocp in ob_close_price_list:
                if ocp &lt; support_price:
                    support_result[symbol][day+1] = 1
                    break
            for ocp in ob_close_price_list:
                if ocp &gt; press_price:
                    press_result[symbol][day+1] = 1
                    break
    support_fresult = {}
    press_fresult = {}
    x = []
    support_y = []
    press_y = []
    for day in range(limit):
        support_fresult[day+1] = {'sum': 0, 'hit': 0}
        press_fresult[day+1] = {'sum': 0, 'hit': 0}
    for day in range(limit):
        x.append(day+1)
        for symbol in support_result.keys():
            support_fresult[day+1]['sum'] += 1
            support_fresult[day+1]['hit'] += support_result[symbol][day+1]
        for symbol in press_result.keys():
            press_fresult[day + 1]['sum'] += 1
            press_fresult[day + 1]['hit'] += press_result[symbol][day + 1]
        support_y.append(round(support_fresult[day+1]['hit']*100/support_fresult[day+1]['sum'], 2))
        press_y.append(round(press_fresult[day + 1]['hit']*100/press_fresult[day + 1]['sum'], 2))
    import matplotlib.pyplot as plt
    from matplotlib.font_manager import FontProperties
    font_set = FontProperties(fname=r&quot;c:\windows\fonts\simsun.ttc&quot;, size=12)
    from pylab import mpl
    mpl.rcParams['font.sans-serif'] = ['FangSong']
    mpl.rcParams['axes.unicode_minus'] = False
    from matplotlib.font_manager import _rebuild
    _rebuild()
    plt.title(u'A股市場支撐位與壓力位突破累積機率圖', fontproperties=font_set)
    ln1, = plt.plot(x, support_y, color='red', linewidth=2.0, linestyle='--')
    ln2, = plt.plot(x, press_y, color='blue', linewidth=3.0, linestyle='-.')
    plt.legend(handles=[ln1, ln2], labels=['n days support break', 'n days pressure break'])
    ax = plt.gca()
    ax.spines['right'].set_color('none')
    ax.spines['top'].set_color('none')
    plt.show()
</code></pre>
<h2 id="衡量風險"><a class="header" href="#衡量風險"><strong>衡量風險</strong></a></h2>
<p>風險有很多種，因此衡量風險的方法也有很多種。有些大風險產生於相對罕見的事件，10年內也碰不到幾次。有的風險較為常見，一年內總會出現幾次。大多數交易者都擔心4種主要的交易風險：</p>
<p>衰落：一連串損失使你的帳戶縮水。</p>
<p>低迴報：回報太低，你賺到的錢微不足道。</p>
<p>價格動盪：一個或多個市場中出現價格的驟然變動，導致無可挽回的重大損失。</p>
<p>系統死亡：市場狀態改變，致使曾經有效的系統突然失效。</p>
<p>當碰到衰落時，往往我們的大腦會產生類似下面的想法：</p>
<p>“萬一這個系統不再管用了，怎麼辦？”</p>
<p>“萬一這只是一個大滑坡的開端，怎麼辦？”</p>
<p>“萬一我之前的測試方法有問題，怎麼辦？”</p>
<p>等等，這些疑慮往往會促使一個新手放棄這個系統，或者開始有選擇的交易，以期“降低風險”。這經常導致交易者錯失本來可以賺錢的機會。在沮喪的情緒下，在看到初始帳戶遭受了1/2甚至更多的損失之後，交易者終於忍無可忍的退出了。這就是新手們即使使用有效的策略也無法賺錢的原因：他們高估了自己在高風險水平下承受巨大波動的能力。</p>
<p><strong>風險的量化</strong></p>
<p><strong>1、最大衰落</strong></p>
<p>測試期從最高點到最低點的下跌百分比。</p>
<p><strong>2、最長衰落期</strong></p>
<p>測試期從一個頂峰到下一個頂峰的時間，衡量一段損失期後需要多長時間才能重新站上新的高點。</p>
<p><strong>3、回報標準差</strong></p>
<p>回報標準差可以以不同週期為單位計算期間內平均回報的標準差。衡量回報率的起伏狀態。</p>
<p><strong>4、R平方值</strong></p>
<p>這個指標衡量的是實際投資回報率與平均複合增長率的吻合程度。對帶息帳戶這一類的固定收益投資來說，R平方值為1。（其實就是實際投資回報率與平均複合增長率做線性回歸後的R平方值）</p>
<p><strong>回報的量化</strong></p>
<p>平均複合增長率</p>
<p>公式： (1+r1)×(1+r2)×...×(1+rn)n−1</p>
<p>n代表有n期</p>
<p>r代表每期的收益率</p>
<p>例如初始投資資金為100元，第一個月收益100元，總資金變為200元，第二個月虧損100元，總資金又變為100元。</p>
<p>那麼如果按月算n = 2</p>
<p>r1 = (200-100)/100 = 100% = 1</p>
<p>r2 = (100-200)/200 = -50% = -0.5</p>
<p>平均複合增長率 = [(1+1)*(1-0.5)]^0.5 - 1 = 0</p>
<p><strong>衡量風險與回報的綜合指標</strong></p>
<p>夏普比率</p>
<p>這裡引入聚寬的夏普比率公式： (Rp−Rf)/σp</p>
<p>Rp 為年收益 = (1+P)250/n−1 ，P為週期總收益，n為週期天數</p>
<p>Rf 為無風險收益，如銀行利率，默認設定為0.04</p>
<p>σp 為策略收益波動率（標準差） = 250∗∑1n(rpi−rp)¯2/(n−1)</p>
<p>rp¯=∑1nrpi/n 每日收益率的平均值</p>
<p>rp為每日收益率</p>
<p>例如測算一個週期5天的夏普比率，假設初始資金為100元，第一天後，總資金為120，</p>
<p>第二天後，總資金為110元，第三天後，總資金為130元，第四天後，總資金為140元，第五天後，總資金為135元。</p>
<p>利用Python算算：</p>
<pre><code class="language-python">def getSharp(self):
    r_f = 0.04
    money = [100, 110, 130, 140, 135]
    r_p = (money[-1] - money[0])/money[0]
    numerator = r_p - r_f
    r_pi = []
    for idx in range(len(money)):
        if idx &gt; 0:
            rp = (money[idx] - money[idx-1])/money[idx-1]
            r_pi.append(rp)
    r_p_mean = np.mean(r_pi)
    r_pi_diff_square = []
    for rp_item in r_pi:
        diff_square = np.square(rp_item - r_p_mean)
        r_pi_diff_square.append(diff_square)
    r_pi_diff_square_sum = np.sum(r_pi_diff_square)
    baidenominator = 250 * r_pi_diff_square_sum / len(r_pi_diff_square)
    sharp = round(numerator/baidenominator, 3)
    print(sharp)
</code></pre>
<p>最後計算的結果為：0.205</p>
<p>它代表每承受一單位總風險，會產生多少的超額報酬，by the way，上面的結果非常不錯。</p>
<p>MAR比率</p>
<p>MAR比率是Managed Accounts Reports有限公司發明的一個指標，這個公司專門提供對沖基金的業績報告。<em><strong>MAR比率等於年均回報率除以最大的衰落幅度，衰落是根據月末資料計算的*</strong></em>（<em><em><strong>文中作者是通過整個週期的最高點到最低點的跌幅計算的*</strong></em>）</em>。這個比率是風險回報比率的一個相當快捷而又直接的衡量指標。文中作者提到，用它來剔除表現不佳的策略是非常有效的。對粗略的分析來說，它是一個絕好的工具。這句話我是這麼理解的，如果制定的策略MAR比率過低，那麼肯定可以淘汰。如果MAR不低，就可以進一步看別的指標了。</p>
<p>下面的程式碼是我隨機抽取一個三個月的時間段，然後隨機抽取的一些股票在這三個月的MAR比率，結果如下：</p>
<blockquote>
<p>黑貓股份在時間段2013-12-17到2014-03-17的MAR比率是-0.0553287494628
大唐電信在時間段2013-12-17到2014-03-17的MAR比率是0.394967351489
永輝超市在時間段2013-12-17到2014-03-17的MAR比率是-0.0531024531025
麥捷科技在時間段2013-12-17到2014-03-17的MAR比率是0.00971195898055
泰山石油在時間段2013-12-17到2014-03-17的MAR比率是0.440798444327
光線傳媒在時間段2013-12-17到2014-03-17的MAR比率是0.0686396712033</p>
</blockquote>
<p>MAR比率程式碼</p>
<pre><code class="language-python">def MAR(self):
    st = storage()
    timeRange = getRandomMonthTimestampRangeForLoopback(3)
    start_timestamp = timeRange[0][0]
    end_timestamp = timeRange[-1][-1]
    start_date = time.strftime('%Y-%m-%d', time.localtime(int(start_timestamp / 1000)))
    end_date = time.strftime('%Y-%m-%d', time.localtime(int(end_timestamp / 1000)))
    sql = &quot;select symbol, name from stock_summary where type = 0&quot;
    rList = self.connect.getAll(sql)
    id_list = getSamplePointWithRandom(10, rList)
    for idx in id_list:
        symbol = rList[idx][0]
        name = rList[idx][1]
        tableName = &quot;stock_history_&quot;+symbol
        if st.isTableExist(tableName) is True:
            sql = &quot;select close, high, low from &quot;+tableName+&quot; where timestamp &gt;= {st} &quot; \
                                                                &quot;and timestamp &lt;= {et}&quot;.format(st=start_timestamp, et=end_timestamp)
            stockList = self.connect.getAll(sql)
            if len(stockList) &lt;= 0:
                continue
            high_list = []
            low_list = []
            percent = (stockList[-1][0] - stockList[0][0]) / stockList[0][0]
            for item in stockList:
                high_price = item[1]
                low_price = item[2]
                high_list.append(high_price)
                low_list.append(low_price)
            high = np.max(high_list)
            low = np.min(low_list)
            wave = (high - low) / low
            MAR = percent/wave
            print(&quot;{name}在時間段{st}到{et}的MAR比率是{mar}&quot;.format(name=name, st=start_date, et=end_date, mar=MAR))
</code></pre>
<p><strong>模倣傚應與系統死亡風險</strong></p>
<p>在風險回報比率上擁有傲人記錄的那些策略往往都是最容易被整個行業群起模仿的策略。她們剛剛嶄露頭角，立即就被數十億美元竟相追隨，結果反而自毀長城，因為它們的規模已經超出了市場的承受能力。到頭來，它們早早就成了系統死亡的犧牲品。</p>
<p>在這一點上，套利策略可能是最好的例子。最純粹的套利實際上是一種沒有風險的交易。你在一個地方買入某個東西，在另一個地方把它高價賣掉，扣掉運輸或倉儲成本，剩下的都是你的李瑞。大多數套利策略都不會完全沒有風險，但有很多接近於沒有風險。問題是，靠這樣的策略賺錢是有前提條件的，那就是不同地方的同一種工具存在價格差，或者一種工具和另一種類似工具之間存在價格差。</p>
<p>使用某一種特定策略的人越多，價格差就消失的越快，因為這些交易者本質上都在爭奪同樣的機會。長此以往，這種效應會毀掉這種策略，因為它會變得越來越無利可圖。</p>
<h2 id="風險與資金管理"><a class="header" href="#風險與資金管理"><strong>風險與資金管理</strong></a></h2>
<p>文中作者的自己管理方式為</p>
<blockquote>
<p>我們把頭寸分成一個個小塊，也就是我們所說的頭寸單位。每一個頭寸單位的合約數量是根據這樣的標準確定的：要讓1ATR的價格變動正好等於我們帳戶規模的1%。對一個100萬美元的帳戶來說，1%是10000美元。因此，我們會算出一個市場中代表著每份合約有1ATR變動幅度的美元金額，然後10000美元除以這個金額，得出每100萬美元的交易資本所對應的合約數量。我們把這些數字稱作頭寸單位。</p>
</blockquote>
<p>我認為把這段話引用到A股市場應該這麼理解，假設我們的初始資金為20000元，有一隻股票A，當前的價格為P，當前的ATR為N，根據策略，此時股票A發出了買入訊號，那麼我們應該買入多少A呢？</p>
<p>要讓1ATR的價格變動正好等於帳戶規模的1%，我們的帳戶規模是20000，1%就是200。那麼200/N就是我們應該買入的股票數，由於股票買入是以手為單位的，所以如果200/N小於100，那麼我們不應該買入。設R=200/N，那麼R就為1個頭寸單位，不同股票因為價位和買入點的ATR均不同，所以1個頭寸單位所代表的股數也不同。頭寸單位同時受到買入價位和買入點的ATR影響。</p>
<p>通過這種方式，買入和賣出的資金管理可以做到一目瞭然。</p>
<h2 id="海龜式交易系統"><a class="header" href="#海龜式交易系統">海龜式交易系統</a></h2>
<p><strong>ATR通道突破系統</strong></p>
<p>ATR通道突破系統是一個波幅通道系統，它把真實波動幅度均值（即ATR）用作波動性指標。350日移動平均收盤價加上7個ATR就是通道的頂部，減去3個ATR就是通道的底部。如果前一日的收盤價穿越了通道頂部，則在今日開盤時做多；如果前一日的收盤價跌破通道底部，則在開盤時做空（A股不存在做空）。當收盤價反向穿越了移動平均線，交易者們就會退出。</p>
<p>移動平均收盤價=N日收盤價之和/N</p>
<p>ATR的計算公式上面已經介紹過了，這裡不介紹了。</p>
<p><strong>布林格（布林線）突破系統</strong></p>
<p>這個系統的布林線是通過350日移動平均收盤價加減2.5倍標準差而得出的。如果前一日的收盤價穿越了通道的頂部，則在開盤時做多；如果前一日的收盤價跌破通道的底部，則在開盤時做空。</p>
<p>布林線的公式：</p>
<p>首先中間一條線是350日移動平均線MB = \sum_{1}^{n}{close}/n</p>
<p>然後計算校準差std= \sqrt{\sum_{1}^{n}{(close_{i}-mb)^{2}}/n}</p>
<p>頂部 = MB+2.5*std</p>
<p>底部 = MB-2.5*std</p>
<p><strong>唐奇安趨勢系統</strong></p>
<p>採用20日突破入市策略，10日突破退出策略。也就是價格向上突破20日均線，則買入。價格向下突破10日均線，則賣出。另外，這個系統規定了2ATR的止損退出點。2ATR的資金管理上面有介紹過，這裡不再贅述。</p>
<p><strong>定時退出唐奇安趨勢系統</strong></p>
<p>定時退出唐奇安趨勢系統是唐奇安趨勢系統的一個辯題，它採用的是定時退出策略，而不是突破退出策略。它在80天之後退出，沒有任何形式的止損點。</p>
<p><strong>三重移動均線系統</strong></p>
<p>這個系統使用三種移動均線：150日、250日和350日均線。交易者在150日均線穿越250日均線時買入（向上穿）或賣出（向下穿）。最長期的350日均線扮演的是趨勢過濾器的角色。只有150日和25日均線位於350日均線的同一側時才能交易。</p>
<h2 id="歷史測試的謊言"><a class="header" href="#歷史測試的謊言"><strong>歷史測試的謊言</strong></a></h2>
<p>歷史測試結果和實際交易結果的差異主要是由四大因素造成的：</p>
<p>交易者效應：如果一種方法在近期賺了很多錢，那麼其他交易者很可能會注意到它，開始用類似的方法模仿它，這很容易導致這種方法的效果不再想一開始那樣好。</p>
<p>文中有一例子說明：</p>
<blockquote>
<p>幾年前曾有一個系統因為多年來的優異表現而變得大受歡迎，有很多經紀人開始向他們的客戶提供這個系統。我曾一度聽說已經有數億美元開始追隨這個系統。但就在它的影響力達到巔峰之後沒多久，它的追隨者們遭遇了一次曠日持久的衰落，而這樣長和這樣嚴重的衰落期在它20年的歷史測試中從未出現過。這個系統有一個容易被利用的軟肋。按照它的法則，如果當日的收盤價超過了某個特定水平，那麼就在次日早晨一開盤時買入或賣出。由於其他交易者知道什麼樣的價位會引發這些買單或賣單，那麼狠簡單，他們完全可以趕在當日收盤之前買入，然後在次日開盤之後馬上賣出。賣出價通常比買入價高得多，因為所有在一夜之間生成的買單都是在這個時候入市的，這是由系統的法則決定的。</p>
</blockquote>
<p>交易者效應在任何情況下都有可能發生，不一定是某些交易者故意搶先行動的結果。只要有太多的交易者不約而同地試圖利用某種市場現象，這種現象的優勢就會被毀掉，至少在一段時間內不再有效，因為眾多交易者的定單會削弱它的優勢。</p>
<p>隨機效應：歷史測試的結果誇大了系統的內在優勢也可能是純隨機性的現象。</p>
<p>摘抄書中原文可以瞭解到任何系統的短期回測結果與任何基金的近幾年的成績都不足以讓我們做出正確的決策：</p>
<blockquote>
<p>我曾對一個隨機性入市策略進行了模擬檢驗，這種策略僅根據電腦模擬的擲硬幣結果來決定在開盤時做多還是做空。當時我設計了一個完整的系統，採用以擲硬幣結果為基礎的進入策略和定時退出策略，在入市之後的若干天后退出，天數從20天到120天不等。然後我對這個系統作了100次測試。在這100次測試中，最好的一次獲得了16.9%的年均回報，在10.5年的測試期內把100萬美元變成了550萬美元，但最差的一次測試卻年均虧損20%。這說明，純隨機性事件可以導致巨大的差異。
如果加入一點優勢因素，結果會怎麼樣呢？如果我們在這個完全隨機性的系統中加入一個有正優勢的趨勢過濾器，那麼100次測試的平均表現會顯著改善。根據我的測試，平均回報率上升至32.46%，平均衰落幅度下降至43.74%。但即使加入了過濾器，各次測試結果之間仍有相當大的差異。在100次隨機測試中，最好的一次達到了53.3%的年回報率和1.58的MAR比率，最大的衰落只有33.6%；但最差的一次只有17.5%的回報率，最大衰落卻有62.7%之大。
當你用業績衡量指標去區分好基金和壞基金的時候，你很容易遭遇隨機效應問題。因為運氣好的平庸交易者要多於運氣不佳的優秀交易者。假設有1000個交易者，其中有80%接近於平均水平，只有五六個真正的高手。那麼，只有五六個人有可能成為運氣不佳的優秀交易者，卻有800個平庸的人有機會擁有好運。如果這800個人裡有2%能幸運的擁有10年的良好記錄，這意味著，擁有良好記錄的固然有21個人，但其中只有1/4的人是真正的優秀交易者。</p>
</blockquote>
<p>最佳化矛盾：選擇特定參數的過程（比如選擇25日移動均線而不是30日移動均線），可能降低事後測試的預測價值。</p>
<p>有些交易系統需要用特定的數值進行計算，選擇這些數值的過程就是最佳化。這些數值被稱為參數。比如，長期移動均線的計算天數就是一個參數，短期均線的計算天數也是一個參數。最佳化就是為這些參數選擇最佳或最佳化數值的過程。</p>
<p>所謂的最佳化矛盾是有這麼一個觀點，在做回測時把參數調到最佳（也就是參數調到某個值的時候，回測期間受益最大，衰落較小）並不是最好的選擇，因為這樣可能導致過擬合，導致未來的回報與過去的回報產生相當大的差異。用文中作者的話來說，這個觀點純屬放屁。作者的觀點是應該將最佳參數應用到策略系統中去。作者寫了比較長的篇幅來論證他的觀點，我用幾句話來說明他的觀點：在統計學的角度來看，我們的一次回測結果其實是無數次回測結果中的一個隨機值，這個隨機值是無偏的。因此，我們的回測次數越多，回測結果就越接近真實的平均值。如果我們正在測試一個策略系統的某一個參數，這個參數取了不同的兩個值，每個值分別測試了十次，那麼肯定會有一個值的平均值產生的回報要高於另一個值產生的回報。由於每次回測結果可以看成獨立同分佈的，那麼實際上這個回測結果是一個常態分配，那麼未來利用此參數產生的回報就會落在我們回測結果平均值的某幾個標準差內。為什麼要選擇最佳的參數，因為無論未來回報是怎麼樣的，高回報均值的鄰域永遠比低迴報均值的鄰域要高，所以應該選最佳參數。</p>
<p>過擬合：系統可能太過複雜，以至於失去了預測價值。由於它與歷史資料的吻合度太高，市場行為的一個輕微變化就會造成效果的明顯惡化。</p>
<p>過擬合比較好理解，直接摘抄原文中的一段話即可理解：</p>
<blockquote>
<p>過度擬合通常發生在系統變得過於複雜的時候。有時候，你可以通過新增法則來提高一個系統的歷史表現，但這僅僅是因為這些法則影響了屈指可數的幾筆重要交易。新增法則會導致過度擬合，這對發生在關鍵時期的交易來說尤其明顯。比如，假如一條法則要求你在接近最高峰的時候退出一個特別大的盈利頭寸，這當然會提高你的系統表現，但如果這條法則對其它情況沒有充分的適用性，這就成了過度擬合。</p>
</blockquote>
<p>說簡單點，過擬合就是在回測時為了得到一個好的結果而特意針對某種場景設定一個條件。而通常的策略交易，應該具有普遍適用性。</p>
<h2 id="歷史測試的統計學基礎"><a class="header" href="#歷史測試的統計學基礎">歷史測試的統計學基礎</a></h2>
<p><strong>測試樣本的有效性</strong></p>
<p>通過樣本特徵推斷總體特徵是統計學中的一個領域，也是歷史檢驗結果的未來預測價值的理論基礎。其中的核心觀點是，如果你有足夠大的樣本，你就可以用這個樣本的情況去近似推斷總體情況。因此，如果你對某一種特定交易策略的歷史交易記錄有充分的研究，你就可以對這種系統的未來潛力得出結論。</p>
<p>樣本分析在統計學上的有效性受兩大因素的影響：一個是樣本規模，一個是樣本對總體的代表性。</p>
<p>從概念上說，許多交易者和系統測試新手指導樣本規模的意思，但他們以為樣本規模僅指他們所測試的交易次數。他們並不明白，假如某個法則或概念僅適用於少數幾次交易，即使他們測試了上千次交易也不足以確保統計學上的有效性。</p>
<p>系統測試者假設過去的情況對未來的情況有代表性，如果這是事實，而且我們有足夠大的樣本，我們就可以從過去的情況中得出結論，並且把這些結論應用於未來的交易。但如果我們的樣本對未來不具代表性，那我們的測試就毫無用處。比如我們的市場通常有4種狀態，但我們的測試樣本只包含其中的某一種或兩種，那麼我們的樣本就不具有代表性。所以，你的測試方法必須儘可能的提高你所測試的樣本對未來的代表性。</p>
<p><strong>找出穩健的衡量指標</strong></p>
<p>在系統測試中，你要做的是觀測相對表現，分析未來潛力，判定一個特定理念是否有價值。但這裡面有個問題，那就是公認的那些業績衡量指標並不是非常穩定，也就是說，它們不夠穩健。這就使評判一個理念的相對優勢變得非常困難，因為寥寥幾次交易中的微小變化就能對這些不穩健指標的值產生巨大的影響。</p>
<p>如果對資料稍作改變並不會顯著影響一個統計指標，我們就說這個指標是穩健的。MAR比率、平均複合增長率（CAGR）和夏普比率用作相對表現的衡量指標。但這些指標並不穩健，因為它們對測試期的起始日和終止日非常敏感。以平均複合增長率為例，可以以時間為橫坐標，平均複合增長率的對數為縱坐標（這樣可以讓平均複合增長率關於時間的函數看起來像一個線性模型）做散點圖，你會發現當擷取不同時間段的時候，時間起止日的不同會使它們的連接線的斜率產生很大的變化，這說明一點點時間上的改變就對複合增長率有顯著的影響。如果我們將這些散點擬合成一條直線（使用一元線性回歸模型），取複合增長率時，我們取不同時間點上的擬合值，那麼這個擬合的複合增長率會穩定很多。文中作者對這個擬合的複合增長率取了一個新名字，叫回歸年度回報率，簡稱RAR。（regressed annual return）</p>
<p><img src="strategy/images/v2-66d82a530ec72022276f61f580bd5037_720w.webp" alt="img" /></p>
<p>平均複合增長率</p>
<blockquote>
<p><em>上圖紅線代表實際的平均複合增長率，藍線是通過最小二乘法擬合的平均複合增長率，也就是RAR，可以看到，對於實際的平均複合增長率，如果拉長或縮短橫坐標的範圍，Y值兩點連線的斜率會有較大的變化，這代表指標是不穩健的，如果將它擬合成一條直線，斜率不變，所以更加穩定。指標值對於實際值的殘差較小，表明擬合值不會有太大的誤差。</em></p>
</blockquote>
<p>RAR程式碼如下：</p>
<pre><code class="language-python">def CAGRlog(rate):
    r = []
    for ra in rate:
        r.append(np.log(1+ra))
    return np.sum(r)

def testCAGRLog(self):
    p_list = np.random.rand(10)
    X = []
    Y = []
    for idx in range(1, len(p_list)+1):
        X.append(idx)
        pl = p_list[:idx]
        result = CAGRlog(pl)
        Y.append(result)
    import statsmodels.api as sm
    X_fit = sm.add_constant(X)
    model = sm.OLS(Y, X_fit)
    results = model.fit()
    Y_fit = results.predict()
    import matplotlib.pyplot as plt
    from matplotlib.font_manager import FontProperties
    font_set = FontProperties(fname=r&quot;c:\windows\fonts\simsun.ttc&quot;, size=12)
    from pylab import mpl
    mpl.rcParams['font.sans-serif'] = ['FangSong']
    mpl.rcParams['axes.unicode_minus'] = False
    from matplotlib.font_manager import _rebuild
    _rebuild()
    plt.title(u'平均複合增長率', fontproperties=font_set)
    ln1, = plt.plot(X, Y, color='red', linewidth=2.0, linestyle='--')
    ln2, = plt.plot(X, Y_fit, color='blue', linewidth=2.0, linestyle='--')
    plt.legend(handles=[ln1, ln2], labels=['actual value', 'fit value'])
    ax = plt.gca()
    ax.spines['right'].set_color('none')
    ax.spines['top'].set_color('none')
    plt.show()
</code></pre>
<p>如果將夏普比率的分子替換成RAR，那麼夏普比率同樣變成了穩定性指標。</p>
<p>替換MAR比率的穩健風險回報比率，作者給它起名叫R立方（<strong>r</strong>obust <strong>r</strong>ist/reward <strong>r</strong>atiio）。R立方的分子就是RAR，分母是個新指標，作者稱之為長度調整平均最大衰落。這個分母指標有兩個要素：平均最大衰落和長度調整。</p>
<p><strong>平均最大衰落</strong>就是5次最大衰落幅度的平均值。<strong>長度調整</strong>就是將這5次衰落期的平均天數除以365天，然後用這個結果乘以平均最大衰落。平均衰落天數的計算原理與平均衰落幅度相同，也就是將5次衰落期的天數相加再除以5。</p>
<p>設5次最大的衰落幅度分別為a, b, c, d, e，那麼平均最大衰落 = (a+b+c+d+e)/5</p>
<p>設5次最大的衰落幅度的天數分別為u, v, w, x, y，那麼長度調整 = (u+v+w+x+y)/(5*365)</p>
<p>穩健風險回報比率的分母 =[ (a+b+c+d+e)/5] * [(u+v+w+x+y)/(5*365)]</p>
<p><strong>從虛擬測試到實戰交易</strong></p>
<p>怎麼判斷你在實際交易中可能獲得什麼樣的成果？對歷史測試來說，這或許是最有趣的問題之一。</p>
<p>要想得到有意義的答案，你必須理解影響系統表現的因素，使用穩健指標的必要性，以及採集足夠大的代表性樣本的重要性。一旦你做到了這一點，你就可以開始思考市場變換的潛在影響，思考為什麼連老練的交易者設計的優秀系統也會經歷業績的盛衰起伏。你不可能知道，也不可能預見到一個系統的表現會怎麼樣，這是現實。充其量，你只能借用有效的工具來判斷系統的潛在效果，以及影響這種效果的因素。</p>
<p>如果一個系統在最近一段時間表現得特別出眾，這有可能是個運氣問題，或許市場對這種系統來說正處於理想的狀態中。一般來說，這種冒尖的系統在好時期過後很容易轉入困難時期，不能指望它在未來會重現這種好運的表現。這也許會發生，但你不能寄希望於運氣。你更有可能經歷業績的下滑。</p>
<p>參數檢驗調整</p>
<p>1、在決定採用一個系統之前先體驗一下參數的作用是個好習慣。挑出幾個系統參數，大幅調整參數值，然後看看效果怎麼樣？如果效果顯著，說明系統參數對於系統的影響是顯著的。</p>
<p>2、隨便選擇8-10年前的一天，用這一天之前的所有的資料進行最佳化，當你得出了最佳化參數值後，再用這一天之後兩年內的資料檢驗一下這些參數值。這就跟機器學習中要建立訓練集和測試集一樣的道理。</p>
<p>蒙特卡洛檢驗</p>
<p>摘抄自wiki的對蒙特卡洛檢驗的一個簡單說明：</p>
<blockquote>
<p>假設我們要計算一個不規則圖形的面積，那麼圖形的不規則程度和分析性計算（比如，積分）的複雜程度是成正比的。蒙特卡羅方法基於這樣的想法：假設你有一袋豆子，把豆子均勻地朝這個圖形上撒，然後數這個圖形之中有多少顆豆子，這個豆子的數目就是圖形的面積。當你的豆子越小，撒的越多的時候，結果就越精確。藉助電腦程序可以生成大量均勻分佈坐標點，然後統計出圖形內的點數，通過它們佔總點數的比例和坐標點生成範圍的面積就可以求出圖形面積。</p>
</blockquote>
<p>文中所用的利用蒙特卡洛檢驗思想的一種方法是拼接淨值曲線：在初始淨值曲線中隨機選擇一些小段，然後將它們打亂次序組成一個新的淨值曲線。按如此方式生成幾千個新的曲線，然後計算曲線對應的RAR，通過RAR的直方圖和累積機率圖來找出90%置信區間下的RAR的水平。</p>
<p>以上詳細闡述了《海龜交易法則》這本書的所有觀點、思路及具體操作，下面給出原版海龜交易系統。以下均摘抄原文：</p>
<blockquote>
<p>入市策略
交易者大多從入市訊號的角度來評判一個特定的交易系統。他們相信，入市策略是一個交易系統最重要的一個環節。
所以他們可能想不到，海龜們使用的是一個以理查德-唐奇安的通道突破系統為基礎的非常簡單的入市系統。
海龜們使用兩個有所差異但也彼此相關的入市系統，我們稱為系統1和系統2。我們可以自由決定如何在這兩個系統之間分配資金。有的海龜只用系統2，有的在兩個系統上各投入50%的資金，還有的採用其他組合。這兩個系統分別是：
系統1：以20日突破為基礎的短期系統
系統2：以55日突破為基礎的長期系統
突破
突破是指價格超越了過去一定時期內的最高點或最低點。所以，20日突破就是指價格超越了過去20天的最高或最低點。
海龜們總是在突破發生時立即入市交易，不會等到當日收盤或次日開盤時。在跳空開盤的情況下，假如開盤價已經跳過了突破價，海龜們就在開盤時入市。
<strong>系統1入市法則</strong>
只要價格超越20日最高或最低點一個最小單位，海龜們就馬上行動。如果價格超越了20日高點，海龜們就買入1個頭寸單位，開始做多。如果價格跌破了20日低點，海龜們就賣出1個頭寸單位，開始做空。
但是，假如上一次突破是一次盈利性突破（也就是可以帶來一次盈利的交易），那麼系統1的當前入市訊號將被忽略。注意：對這一法則來說，上一次突破就是指市場的上一次實際突破，不管交易者當時採取了突破交易還是根據這一法則而忽略了那次突破。那麼什麼是虧損型的突破呢？如果突破日之後的價格在頭寸有機會退出獲利（根據10日突破退出法則）之前發生了2N幅度的不利變動，這就被視為一次虧損性的突破。
對這一法則來說，上一次突破的方向並不重要。因此，無論上一次突破是向上突破還是向下突破，只要是虧損型突破，那麼目前的新突破（無論是向上還是向下突破）就會被視為有效的入市訊號。
不過，如果一次突破因為這條法則而被忽略，那麼交易者將在55日突破點入市，這是為了避免錯過重大趨勢。這個55日突破點被視為一個保障性突破點。
在任何時候，如果一個交易者處於離場等待的狀態，那麼總有某個價位能引發空頭入市訊號，也總有某個更高的價位能引發多頭入市訊號。如果上一次突破是虧損的，那麼新突破（也就是20日突破點）將更接近於當前價格；如果上一次突破是盈利性的，那麼新突破點可能離當前價遠的多，因為那有可能是個55日突破點。
<strong>系統2入市法則</strong>
只要價格超越55日最高點或最低點一個最小單位，我們就入市。如果價格超越了55日高點，海龜們就買入1個頭寸單位，開始做多。如果價格跌破了55日低點，海龜們就賣出1個頭寸單位，開始做空。
對系統2來說，所有突破都被視為有效訊號，無論上一次突破是虧損性還是盈利性的。
逐步建倉
海龜們首先在突破點建立1個單位的頭寸，然後按1/2N的價格間隔一步一步擴大頭寸。這個1/2N的間隔以上一份定單的實際成交價格為基礎。所以，如果最初的突破交易發生了1/2N的成交價偏差，那麼新定單的價格將與突破點相差1N，也就是最初1/2N的偏差加上1/2N的標準間隔。
這個過程將繼續下去，一直到頭寸規模達到上限。如果市場足夠活躍，我們有可能在一天內加滿4個頭寸單位。
請看下面的例子：
黃金
N=2.5
55日突破價=310.00
第一個單位：310.00
第二個單位：310.00+2.5=311.25
第三個單位：311.25+1/22.5=312.50
第四個單位：312.50+1/2*2.5=313.75
止損標準
海龜們根據頭寸風險來設定止損標準。任何一筆交易的風險程度都不得超過2%。
由於1N的價格變動代表著帳戶淨值的1%，在2%的風險限制下，價格變動的上限就是2N。海龜們止損標準就是2N：對多頭頭寸來說，止損價比入市價低2N；對空頭頭寸來說，止損價比入市價高2N。
為了把整體頭寸風險控制在最低水平，如果我們（按1/2N的價格間隔）後續補充了頭寸單位，那麼之前頭寸單位的止損點將相應的調整1/2N。一般來說，這意味著整個頭寸的止損點將與最新新增的頭寸單位相距2N的距離。不過，如果頭寸補充的價格間隔因為市場變化過快或開盤跳空等情況而大於1/2N，止損標準也會有所變化。
下面是一個例子：
原油：
N=1.2
55日突破價=28.30
入市價/止損價
第一個單位 28.30/25.90 diff=2.4=2N
---------------------------------------------
第一個單位 28.30/26.50 diff=1.8=1.5N
第二個單位 28.90/26.50 diff=2.4=2N
第一個頭寸單位和第二個頭寸單位買入價相差1/2N=0.6
---------------------------------------------
第一個單位 28.30/27.10 diff=1.2=1N
第二個單位 28.90/27.10 diff=1.8=1.5N
第三個單位 29.50/27.10 diff=2.4=2N
---------------------------------------------
第一個單位 28.30/27.70 diff=0.6=1/2N
第二個單位 28.90/27.70 diff=1.2=1N
第三個單位 29.50/27.70 diff=1.8=1.5N
第四個單位 30.10/27.70 diff=2.4=2N
假如第四個單位因為市場跳空高開在每股30.80美元成交，那麼結果將變為：
第一個單位 28.30/27.70 diff=0.6=1/2N
第二個單位 28.90/27.70 diff=1.2=1N
第三個單位 29.50/27.70 diff=1.8=1.5N
第四個單位 30.80/28.40 diff=2.4=2N
備選止損策略：雙重損失
海龜們也學習了另外一種叫做雙重損失的止損策略。
在雙重損失策略下，每一筆交易的風險上限不是2%，而是0.5%。也就是說，價格波動的上限是1/2N。在一個頭寸單位止損退出後，交易者將在價格恢復到最初的入市價時重新建立這個單位。
比如，如果採用雙重損失止損策略，上述原油交易將變成下面的樣子：
原油：
N=1.2
55日突破價=28.30
入市價/止損價
第一個單位 28.30/27.70 diff=0.6=1/2N
---------------------------------------------
第一個單位 28.30/27.70 diff=0.6=1/2N
第二個單位 28.90/28.30 diff=0.6=1/2N
---------------------------------------------
第一個單位 28.30/27.70 diff=0.6=1/2N
第二個單位 28.90/28.30 diff=0.6=1/2N
第三個單位 29.50/28.90 diff=0.6=1/2N
---------------------------------------------
第一個單位 28.30/27.70 diff=0.6=1/2N
第二個單位 28.90/28.30 diff=0.6=1/2N
第三個單位 29.50/28.90 diff=0.6=1/2N
第四個單位 30.10/29.50 diff=0.6=1/2N
退出（止盈和止損雙重標準）
系統1採用10日突破退出法則：對多頭頭寸來說，在價格跌破過去10日最低點時退出；對空頭頭寸來說，在價格超過10日最高點時退出。總之，如果價格發生了不利於頭寸的10日突破，所有頭寸單位都要退出。
系統2則採用20日突破退出法則：對多頭來說2是日0向下突破，對空頭來說是20日向上突破。只要價格發生了不利於頭寸的20日突破，所有頭寸單位都會退出。</p>
</blockquote>
<p>以下是我用系統入市法則2，在A股市場上做的回測。由於原版的海龜交易法則是基於期貨市場執行的，與A股市場有較大的差異，所以我也只能儘量貼合原版的規則，而無法做到一模一樣。以下是我的改編版規則：</p>
<p>假設初始資金為1000000（100萬）</p>
<p>1、找出近55日的最高價。</p>
<p>2、計算當日的ATR值。</p>
<p>3、如果當日收盤價大於55日的最高價一個ATR，就產生一個入市訊號。</p>
<p>4、如果a股產生了一個入市訊號，那麼就買入100萬 * 0.01 / (ATR * 100) 手（向下取整）該股股票。</p>
<p>5、買入的股票不重複，比如頭一天買入了a股，第二天a股繼續突破了55日最高價，那麼將不買入此股票。</p>
<p>6、如果找到了多個產生入市訊號的股票，則按順序買入，直到資金不足為止。</p>
<p>7、退出機制：設自買入之日算起到當前日前一天裡的最高收盤價為H，那麼如果當前收盤價-H &lt;= -1 * ATR，就賣出此股票。</p>
<p>奉上聚寬程式碼</p>
<pre><code class="language-python"># 匯入函數庫
from jqdata import *
import numpy as np
import math
import copy
# 初始化函數，設定基準等等
def initialize(context):
    # 設定滬深300作為基準
    set_benchmark('000300.XSHG')
    # 開啟動態復權模式(真實價格)
    set_option('use_real_price', True)
    # 輸出內容到日誌 log.info()
    log.info('初始函數開始運行且全域只運行一次')
    # 過濾掉order系列API產生的比error等級低的log
    # log.set_level('order', 'error')
    g.all_stock = get_all_securities(types=['stock'], date=None).index.values
    g.result = []
    ### 股票相關設定 ###
    # 股票類每筆交易時的手續費是：買入時佣金萬分之三，賣出時佣金萬分之三加千分之一印花稅, 每筆交易佣金最低扣5塊錢
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')

    ## 運行函數（reference_security為執行階段間的參考標的；傳入的標的只做種類區分，因此傳入'000300.XSHG'或'510300.XSHG'是一樣的）
    # 收盤時運行
    run_daily(market_close, '14:50', reference_security='000300.XSHG')
    
def sellSignal(context):
    for stock in context.portfolio.positions.keys():
        hit_record = None
        for item in g.result:
            if item['stock'] == stock:
                hit_record = item
                break
        if hit_record is None:
            break
        stock_price_info = get_price(stock, start_date=hit_record['t'], end_date=context.current_dt, frequency='daily', fields=['open', 'close', 'high', 'low'], skip_paused=True, fq='pre', fill_paused=False)
        if stock_price_info.empty is True:
            continue
        stock_price_info = stock_price_info.iloc[:stock_price_info.shape[0]-1, ]
        if stock_price_info.empty is True:
            continue
        stock_price_info = stock_price_info.dropna(axis=0, how='any')
        if stock_price_info.empty is True:
            continue
        close_list = stock_price_info['close'].tolist()
        break_price = np.max(close_list)
        cur_price = context.portfolio.positions[stock].price
        #當前價減去買入後的最高價小於或等於1個入市時的ATR時退出
        if cur_price - break_price  &lt;= hit_record['atr'] * -1:
            closeable_amount = context.portfolio.positions[stock].closeable_amount
            order_res = order(stock, closeable_amount * -1)
            if order_res is not None:
                if order_res.status == OrderStatus.held:
                    g.result.remove(hit_record)

def buySignal(context):
    for stock in g.all_stock:
        cpp_value_list = []
        for cpp in context.portfolio.positions.keys():
            cpp_value_list.append(context.portfolio.positions[cpp].value)
        if len(cpp_value_list) &gt; 0:
            if context.portfolio.available_cash &lt; np.min(cpp_value_list):
                break
        position_stock_list = context.portfolio.positions.keys()
        #如果這只股票已經持倉了，則跳過
        if stock in position_stock_list:
            continue
        stock_price_info = get_price(stock, count=100, end_date=context.current_dt, frequency='daily', fields=['open', 'close', 'high', 'low'], skip_paused=True, fq='pre', fill_paused=False)
        sumRow = stock_price_info.shape[0]
        last_stock_price_info = get_price(stock, count=1, end_date=context.current_dt, frequency='1m', fields=['open', 'close', 'high', 'low'], skip_paused=True, fq='pre', fill_paused=False)
        last_stock_close_price = last_stock_price_info.iloc[0,:]['close']
        last_stock_high_price = last_stock_price_info.iloc[0,:]['high']
        last_stock_low_price = last_stock_price_info.iloc[0,:]['low']
        last_stock_pdc = stock_price_info.iloc[stock_price_info.shape[0]-2, :]['close']
        if math.isnan(last_stock_close_price) or math.isnan(last_stock_high_price) or math.isnan(last_stock_pdc):
            continue
        if sumRow - (55 + 1) &gt;= 0:
            start_idx = sumRow - (55 + 1)
            #獲取當前交易日的前一天到前55天的資料
            period_data = stock_price_info.iloc[start_idx:sumRow-1, :]
            #過濾掉停牌的日子
            period_data = period_data.dropna(axis=0, how='any')
            #前55天再往前推20個交易日的資料，用來計算前55天裡，第一天的ATR
            if start_idx - 20 &gt;= 0:
                pre_atr_stock_df = stock_price_info.iloc[start_idx-20:start_idx, :]
            else:
                pre_atr_stock_df = stock_price_info.iloc[:start_idx, :]
            #過濾掉停牌的日子
            pre_atr_stock_df = pre_atr_stock_df.dropna(axis=0, how='any')
            pre_atr_list = []
            for pas_row in range(pre_atr_stock_df.shape[0]):
                high_price = pre_atr_stock_df.iloc[pas_row, :]['high']
                low_price = pre_atr_stock_df.iloc[pas_row, :]['low']
                if pas_row == 0:
                    atr = high_price - low_price
                else:
                    pdc = pre_atr_stock_df.iloc[pas_row-1, :]['close']
                    compare_list = [high_price-low_price, abs(high_price-pdc), abs(pdc-low_price)]
                    atr = np.max(compare_list)
                pre_atr_list.append(atr)
            #第一天的ATR
            start_atr = np.mean(pre_atr_list)
        else:
            #如果沒有前55天的資料，那麼就直接選第一天資料到倒數第二條資料，並且用第一天的最高價-最低價當做ATR
            period_data = stock_price_info.iloc[:sumRow-1, :]
            period_data = period_data.dropna(axis=0, how='any')
            start_atr = period_data.iloc[0, :]['high'] - period_data.iloc[0, :]['low']
        atr_list = [start_atr]
        #算前55天內，每天的ATR
        for prow in range(1, period_data.shape[0]):
            high_price = period_data.iloc[prow, :]['high']
            low_price = period_data.iloc[prow, :]['low']
            pdc = period_data.iloc[prow-1, :]['close']
            tr = np.max([high_price-low_price, abs(high_price-pdc), abs(low_price-pdc)])
            cur_atr = (19 * atr_list[prow-1] + tr) / 20
            atr_list.append(cur_atr)
        #入市時的atr，也就是最後一天的ATR
        last_atr = (19 * cur_atr + np.max([last_stock_high_price-last_stock_low_price, abs(last_stock_high_price-last_stock_pdc), abs(last_stock_low_price-last_stock_pdc)])) / 20
        #55天內的最高價
        high_list = period_data['high'].tolist()
        if len(high_list) &gt; 0:
            break_price = np.max(high_list)
            #如果當前價-55日最高價大於等於1個ATR，則入場
            if last_stock_close_price - break_price &gt;= last_atr:
                #計算頭寸單位
                hand = int(int(context.portfolio.starting_cash) * 0.01/(last_atr * 100))
                order_res = order(stock, hand*100)
                if order_res is not None:
                    if order_res.status == OrderStatus.held:
                        #買入成功後，記錄入市時的ATR等資訊
                        g.result.append({'stock': stock, 't': copy.deepcopy(context.current_dt), 'order_id': order_res.order_id, 'atr': last_atr})
    
def market_close(context):
    buySignal(context)
    sellSignal(context)
        
    
</code></pre>
<p>由於時間有限，以下是隨機時間段做了兩次回測的結果，時間週期為三個月</p>
<p><img src="strategy/images/v2-3987ca394b75a0fc05464f8bfb17c254_720w.webp" alt="img" /></p>
<p>2011年3月1日到2011年6月1日</p>
<p><img src="strategy/images/v2-2fa8f6ebdc58058b49ee8692810e5f03_720w.webp" alt="img" /></p>
<p>2014年1月15日到2014年4月15日</p>
<p>從結果來看，效果並不理想，說明市場不同，法則也不同，切莫死記硬背，拿來就用。但是海龜的交易思想是值得借鑑的。總結一下海龜交易的思想：</p>
<p>1、制定交易策略，制定交易策略主要分幾個方面：一、發現市場優勢，也就是我們得平衡勝率和單次收益，如果勝率高，對於單次收益的要求就可以適當降低，如果勝率低，則相反，可以通過計算尋找一個好的平衡點。二、使用風險衡量指標，對我們的策略進行風險衡量。三、資金管理，可以使用海龜的ATR法，也可以使用等量資金。資金管理的方式很多，主要的目的就是控制風險，我們能清楚的知道每次虧損的最大額度，我們能清楚的知道我們能承受最大的連續虧損是多少次，我們能清楚的知道我們破產的機率是多大。</p>
<p>2、有效回測，要把回測的時間定在一個較長的範圍內，這樣既可以覆蓋市場所有的狀態，也可以避免前文所說的譬如近期偏好的一些錯誤。然後要進行隨機性的多次測試，用測試的術語來說就是，我們要把用例覆蓋全，儘量做全量測試，儘量把邏輯的每個分支都覆蓋到。用統計學術語來說就是，如果我們的樣本足夠多，我們離真相就越近。這樣我們計算出來的風險指標就更有說服力，我們進行交易時的信心就會更足。</p>
<p>3、也就是心理，在我看來，你說你是價值投資也好，量化交易也罷，投機也行，反正都是炒股，只是流派風格不同，就像有的人使刀，有的人使劍，本身不存在對錯，在各自的領域都有佼佼者，也有垃圾，說到底，價值投資、量化交易只是拿來賺錢的工具。差勁的劍客，活不過幾天；合格的劍客，能立足於江湖；卓越的劍客，能笑傲江湖。如果你有一本劍譜，練熟它，相信它，執行它，那麼起碼能活著，可能還活的不錯。如果你能寫一本劍譜，那就能在這個江湖呼風喚雨，要尊嚴有尊嚴，要女人有女人。我本人也還處於找劍譜的路上，但我相信是這麼個道理，以上。</p>
<hr />
<p>以上內容如有誤歡迎各位指出，本人也是憑自己有限的能力想儘量解釋清楚海龜交易法則的詳細思想和操作方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="策略優化--如何避免過擬合"><a class="header" href="#策略優化--如何避免過擬合">策略優化 – 如何避免過擬合？</a></h1>
<p>出處:https://www.finlab.tw/backtesting-overfitting-probability/</p>
<p><img src="strategy/images/thumbnail-8-1.png" alt="thumbnail 8 1" /></p>
<p>當你做回測做久了，就會發現，找到「歷史報酬率」好的策略很簡單，但是找到「未來報酬率」好的策略非常難。原因在於做了過多的參數枚舉與優化，當樣本數夠大，自然會有極端的數據產生，就像是夜路走多了會碰到鬼，人多必有白痴，樹多必有枯枝，就像是量子力學中，波函數坍縮成我們所處的現實，代表著均值，但在極端的多重宇宙樣本中，你也有可能是總統，代表著眾多巧合下的極端事件。</p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#ben_wen_jiu_shi_yong_kou_yu_de_fang_shi_dai_ni_liao_jie_ru_he_pan_duan_guo_ni_he_de_yan_suan_fa">1 本文就是用口語的方式，帶你瞭解如何判斷過擬合的演算法</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#wo_men_hen_you_ke_neng_shi_you_hua_za_xun_er_fei_you_hua_jia_ge_de_gui_lu">2 我們很有可能是優化雜訊，而非優化價格的規律。</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#yao_zen_me_bian_bie_zhe_liang_zhe_de_bu_tong_ne">2.1 要怎麼辨別這兩者的不同呢？</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#ting_bu_dong_bie_zou_rang_wo_ju_ge_li_zi">2.2 聽不懂？別走，讓我舉個例子</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#hui_dao_ce_lue_de_jiao_du_ru_he_yan_zheng_huo_zhen_jia_shi_de_ce_lue">3 回到策略的角度，如何驗證「貨真價實的策略」？</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#suo_yi_bi_jiao_hao_de_fang_fa_shi">4 所以比較好的方法是？</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#1_que_ding_can_shu_xiao_guo_zhen_de_bi_jiao_hao">5 1. 確定參數效果真的比較好</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#2_chan_sheng_duo_zhong_de_IS_gen_OOS">6 2. 產生多重的 IS 跟 OOS</a></p>
<p><a href="https://www.finlab.tw/backtesting-overfitting-probability/#shi_yan_jie_guo">7 實驗結果：</a></p>
<h5 id="本文就是用口語的方式帶你瞭解如何判斷過擬合的演算法"><a class="header" href="#本文就是用口語的方式帶你瞭解如何判斷過擬合的演算法">本文就是用口語的方式，帶你瞭解如何判斷過擬合的演算法</a></h5>
<p>牛頓從蘋果落地的現象，發現了萬有引力，F=ma，因為實驗的雜訊很小（風、熱能散失等等），才能有經典簡潔的公式，然而把牛頓的實驗，換到財經領域時，可能就不是這麼管用了，當我們在建模時，價格的雜訊遠大於規律，</p>
<h4 id="我們很有可能是優化雜訊而非優化價格的規律"><a class="header" href="#我們很有可能是優化雜訊而非優化價格的規律">我們很有可能是優化雜訊，而非優化價格的規律。</a></h4>
<h5 id="要怎麼辨別這兩者的不同呢"><a class="header" href="#要怎麼辨別這兩者的不同呢">要怎麼辨別這兩者的不同呢？</a></h5>
<p>我們可以先從直觀的角度出發，究竟歷史上成功的偉人，Bill Gates、Steve Jobs、Elon Musk，這些科技巨擘，他們之所以能夠有今天的成就，是一連串的巧合，還是他們有一些人格特質，促使他們的成功？另一個極端的例子，假如今天某人中了樂透彩而一夕爆富，那很明顯，他很可能是多重宇宙中，非常成功的一個版本，但他的成功，可能並非來自他的人格特質，而是來自運氣。今天就運氣跟命運，來討論策略模型過擬合的問題。</p>
<p>模型的過擬合，就像是簽樂透彩，只要參數夠多了，總會中獎。所以策略績效好，究竟是不是運氣好，最重要的事，就是要確保「實驗是有效的」。如何定義實驗是有效的呢？</p>
<p>樣本內的「最佳參數」在樣本外的「績效」也是顯著的機率是高的</p>
<h5 id="聽不懂別走讓我舉個例子"><a class="header" href="#聽不懂別走讓我舉個例子">聽不懂？別走，讓我舉個例子</a></h5>
<p>這邊的「樣本內」就是指我們現在的現實世界，已經發生了的事情，例如我們知道 Steve Jobs 是頻果創辦人，將科技與時尚結合，促進科技的進步功不可沒，所以他就是我們在樣本內的「最佳人選」。而「樣本外」就是指那些我們沒見過的多重宇宙，在多重宇宙中，假如都有 Steve Jobs 這個人，而他都有一番豐功偉業，那就代表那是他貨真價實的實力。</p>
<h3 id="回到策略的角度如何驗證貨真價實的策略"><a class="header" href="#回到策略的角度如何驗證貨真價實的策略">回到策略的角度，如何驗證「貨真價實的策略」？</a></h3>
<p>最簡單的方式，一般我們會使用 hold-out，將歷史資料分成樣本內（in-sample IS）和樣本外（out-of-sampe OOS）並且在 IS 做最佳化後，再用 OOS 驗證，這樣的方法有幾個缺點：</p>
<ul>
<li>由於 IS 跟 OOS 都是人為定義，所以當重複優化很多次後，還是會對於 OOS 的績效越來越熟悉，最後不免還是用了 OOS 的資訊來設計模型</li>
<li>資料量的問題，回測跟驗證都需要一定長度的歷史數據，將歷史數據分成 IS 跟 OOS 顯然有點浪費</li>
<li>OOS 通常是時間序列的尾端，代表近期的資料，對於策略效能有決定性的影響，然而卻不能拿來開發</li>
</ul>
<h3 id="所以比較好的方法是"><a class="header" href="#所以比較好的方法是">所以比較好的方法是？</a></h3>
<p><a href="https://poseidon01.ssrn.com/delivery.php?ID=868103003064115117125100064075098092016007037010053025100075080026029100071001025108063043035060033044107114028094094091106006057048087011059012084117121014084068060040064001077111012024029099081115109104017084001102009126127067113118116067099111100&amp;EXT=pdf">The probability of backtest overfitting</a>的作者是這樣做的：
Bailey, D.H., Borwein, J., Lopez de Prado, M. and Zhu, Q.J., 2016. The probability of backtest overfitting. Journal of Computational Finance, forthcoming.</p>
<h3 id="1-確定參數效果真的比較好"><a class="header" href="#1-確定參數效果真的比較好">1. 確定參數效果真的比較好</a></h3>
<p>任何策略都有好與不好的時候，要確定參數效果很好，不是看績效是正的就好，而是要跟其他參數的績效作比較，
例如最近臺股上漲，雞犬昇天，所以任何人投資績效都是正的，但不帶表大家都是投資高手，
所以就算績效是正的，還要看績效的排名才行！</p>
<p>所以論文中的作者，針對所有參數產生出來績效，從「樣本內」找到「最佳參數」，並且將「樣本外的績效」由小到大排名，並且觀察「最佳參數」是否位於前 1/2 的機率</p>
<h3 id="2-產生多重的-is-跟-oos"><a class="header" href="#2-產生多重的-is-跟-oos">2. 產生多重的 IS 跟 OOS</a></h3>
<p>假如只有一組 IS 跟 OOS 實再是太少了，這樣驗證的樣本會不足，
所以作者不使用「歷史數據」來區分 IS 跟 OOS，而是將回測整個跑完後，將績效的時間序列切成 S 份，任選 S/2 份當作 IS，其他當作 OOS，這樣的話可以產生超多種組合</p>
<h3 id="實驗結果"><a class="header" href="#實驗結果">實驗結果：</a></h3>
<p>下圖就是作者使用此方法的實驗範例， x 代表「最佳參數」在「樣本外」的效果，越右邊代表效果越好，而 y 軸是樣本的數量
我們會發現，下圖這個例子，整個分佈偏向左邊，也就是 x 軸小於零，代表其實最佳化後，大部分的績效都是比較差的！
每100個樣本，就有74個樣本，最佳化後的效果小於績效的中位數，
所以 74% 的機率，最佳化後的效果比較差</p>
<p><img src="strategy/images/bad_strategy-1.png" alt="bad strategy 1" /></p>
<p>一個比較好的策略，應該會是如下圖，整個
每100個樣本，只有4個樣本，最佳化後的效果小於績效的中位數，
所以只有 4% 的機率，有過擬合的風險，
算是一個很不錯的參數優化過程</p>
<p><img src="strategy/images/good_strategy.png" alt="good strategy" /></p>
<p>結果我上網找了一下，都沒有 python 的程式碼
所以假如大家有興趣，我之後可以提供這篇 paper 的程式碼，
雖然但我不確定大家有沒有興趣就是了XDDD</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="買權賣權是什麼選擇權基本運作與策略運用"><a class="header" href="#買權賣權是什麼選擇權基本運作與策略運用">買權賣權是什麼？選擇權基本運作與策略運用</a></h2>
<p>出處：https://gooptions.cc/%E9%81%B8%E6%93%87%E6%AC%8A%E6%95%99%E5%AD%B8/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E6%93%8D%E4%BD%9C%E9%81%B8%E6%93%87%E6%AC%8A%EF%BC%9F%E9%80%A3%E8%82%A1%E7%A5%9E%E5%B7%B4%E8%8F%B2%E7%89%B9%E9%83%BD%E5%9C%A8%E7%8E%A9%EF%BC%81</p>
<p>選擇權（英文Options）<strong>是一種買賣方可於未來看狀況再決定是否要交易的權利，以權利金進行交易</strong>。買方，買進選擇的權利並付出權利金；賣方，賣出選擇權利可收取權利金。買賣兩方在契約約定日期再決定是否執行交易，而這日期就是選擇權結算日。選擇權交易是為了避險而設計，判斷期貨未來價格將上漲可買CALL（買權），判斷會下跌可買PUT（賣權）。</p>
<p>快速瞭解 選擇權 精華重點 key takeaways：</p>
<ul>
<li><strong>選擇權是一種買賣方可於未來看狀況再決定是否要交易的權利，以權利金進行交易</strong></li>
<li><strong>選擇權優勢：降低持倉成本、看錯不一定賠、小金額對沖高風險</strong></li>
<li><strong>交易立場很重要：賣CALL是看漲不過高但不一定是看空、勝率高</strong></li>
<li><strong>選擇權不建議裸賣，用價差單交易可以有效降低風險，提升勝率</strong></li>
<li><strong>臺股選擇權有『週選擇權』與『月選擇權』，週選擇權每週三結算，月選擇權在每個月第3個星期三進行結算，每月結算一次</strong></li>
<li><strong>同時持有買方、賣方部位的CALL和PUT進行策略組合，可提高交易勝率。例如Iron Condor同時賣出CALL和PUT保持中立</strong></li>
</ul>
<p>著名投資人Michael Benklifa認為：「交易股票就像是你有一個好工具，而交易選擇權就像是有一整個工具箱。」可見選擇權在金融市場中是十分強大的投資工具！透過本文的選擇權教學，我們將帶你輕鬆入門選擇權投資，瞭解買權賣權的運作方式、看懂選擇權策略圖，打造長期穩定的獲利來源。</p>
<h2 id="為什麼要操作選擇權連股神巴菲特都在玩"><a class="header" href="#為什麼要操作選擇權連股神巴菲特都在玩">為什麼要操作選擇權？連股神巴菲特都在玩！</a></h2>
<p>在本文開始之前，也可以先看影音說明，加深學習印象。</p>
<h3 id="選擇權投資優勢1降低持倉成本"><a class="header" href="#選擇權投資優勢1降低持倉成本">選擇權投資優勢1：降低持倉成本</a></h3>
<p>股神<a href="https://zh.wikipedia.org/zh-hk/%E6%B2%83%E5%80%AB%C2%B7%E5%B7%B4%E8%8F%B2%E7%89%B9">巴菲特（Warren Buffett）</a>其實是選擇權大莊家，從他的公司財報就可以看到，<a href="https://gooptions.cc/%E7%BE%8E%E8%82%A1%E9%81%B8%E6%93%87%E6%AC%8A%E6%95%99%E5%AD%B8/">美股選擇權</a>交易佔巴菲特公司營收不小的部分，而他最常用的作法之一就是「賣-賣權（賣put）」，也就是「看不跌破」。</p>
<p>當巴菲特要買入一家公司股票，他的做法是先賣這家公司股票的賣權（Put），假設現在公司股價100元，巴菲特可能會賣履約價60元的Put，收20元權利金。接著巴菲特著手買入該公司的股票。因為大量買入，股價上漲，賣出的put價值降低後，這20元權利金就是實拿獲利。雖說股價是100元，但巴菲特其實只花了100-20=80元買入，賣選擇權同時也幫助巴菲特大幅降低持倉成本。</p>
<h3 id="選擇權投資優勢2看錯不一定賠"><a class="header" href="#選擇權投資優勢2看錯不一定賠">選擇權投資優勢2：看錯不一定賠</a></h3>
<p>假設大盤在17200，如果判斷臺積電財報數字亮眼、準備上漲，可以賣出臺股選擇權 17000的賣權（賣PUT），當臺積電上漲帶動大盤上漲，賣出的PUT則獲利，降低臺積電現貨持有成本；萬一臺積電未如預期上漲，但是臺股也沒下跌，選擇權結算時大盤點位在賣出的17000PUT之上，這口PUT還是獲利的，可見選擇權策略運用正確，就算看錯方向也不一定會虧損。</p>
<h2 id="認識買權賣權call--put"><a class="header" href="#認識買權賣權call--put">認識買權賣權（Call / Put）</a></h2>
<p><img src="strategy/Option/../images/%E8%B2%B7%E6%AC%8A%E8%B3%A3%E6%AC%8A-1024x202.jpg" alt="買權賣權" /></p>
<ul>
<li>買Call （買-買權）⮕ 判斷指數「<strong>會漲到</strong>」某個點位</li>
<li>買Put （買-賣權）⮕ 判斷指數「<strong>會跌到</strong>」某個點位</li>
<li>賣Call （賣-買權）⮕ 判斷指數「<strong>不會漲到</strong>」某個點位</li>
<li>賣Put （賣-賣權）⮕ 判斷指數「<strong>不會跌到</strong>」某個點位</li>
</ul>
<p>Call表示買權，Put表示賣權，而在選擇權操作中，所有策略都是由這4個選擇權動作組合而成，以下為你進一步解析：</p>
<h3 id="買call"><a class="header" href="#買call"><strong>買Call</strong></a></h3>
<p>判斷指數「會漲到」某個點位，屬於「看多」。例如，現在指數是16000，認為會漲到16200，那就可以買16200Call。</p>
<h3 id="買put"><a class="header" href="#買put"><strong>買Put</strong></a></h3>
<p>判斷指數「會跌到」某個點位，屬於「看空」。例如，現在指數是16000，認為會跌到15800，那就可以買15800Put 。</p>
<h3 id="賣call"><a class="header" href="#賣call"><strong>賣Call</strong></a></h3>
<p>判斷指數「**不會漲到」**某個點位。例如，現在指數是16000，認為不會漲到16500，那就可以賣16500Call 。要注意的是，賣Call跟看空、做空是不同的事情，千萬不要覺得賣Call就是看空，賣16500Call就算大盤一天大漲200點，從16100漲到16300，只要沒漲過16500賣Call都是獲利。</p>
<h3 id="賣put"><a class="header" href="#賣put"><strong>賣Put</strong></a></h3>
<p>判斷指數「**不會跌到」**某個點位。例如，現在指數是16000，認為不會跌到15500，那就可以賣15500Put 。同樣地，賣Put 跟看多是不同的事情，千萬不要覺得賣Put 就是看多。我將交易方式、動作意圖和資金列在表格中：</p>
<table><thead><tr><th><strong>交易</strong></th><th><strong>判斷</strong></th><th><strong>資金</strong></th><th><strong>注意事項</strong></th></tr></thead><tbody>
<tr><td>買CALL（買 買權）- 為買方</td><td>判斷指數「<strong>會漲到</strong>」某個點位</td><td>支出權利金，從帳戶內扣款</td><td>看多、勝率低</td></tr>
<tr><td>買PUT（買 賣權）- 為買方</td><td>判斷指數「<strong>會跌到</strong>」某個點位</td><td>支出權利金，從帳戶內扣款</td><td>看空、勝率低</td></tr>
<tr><td>賣CALL（賣 買權）- 為賣方</td><td>判斷指數「<strong>漲不到</strong>」某個點位</td><td>收權利金，但帳戶內要有保證金</td><td>看漲不過高但不一定是看空、勝率高、不建議裸賣</td></tr>
<tr><td>賣PUT（賣 賣權）- 為賣方</td><td>判斷指數「<strong>跌不到</strong>」某個點位</td><td>收權利金，但帳戶內要有保證金</td><td>看漲不破低，不是看多、勝率高、不建議裸賣</td></tr>
</tbody></table>
<p>選擇權交易說明</p>
<p>如果想做空或對沖風險，可參考做空教學 <a href="https://gooptions.cc/%E6%9C%9F%E8%B2%A8%E7%A9%BA%E5%96%AE/">用期貨空單取代股票放空來對沖虧損風險的方式</a></p>
<hr />
<h3 id="你需要這3個能幫助交易更穩定的資訊嗎"><a class="header" href="#你需要這3個能幫助交易更穩定的資訊嗎">你需要這3個『能幫助交易更穩定』的資訊嗎？</a></h3>
<ol>
<li>說明波動率指數影片 x2 （*<em>這些影片我從未發布在任何公開管道</em>）</li>
<li>超優惠開戶管道 x2</li>
<li>選用選擇權策略的評估過程說明影片 x1</li>
</ol>
<p><a href="javascript:;">需領取請點此連結</a></p>
<hr />
<h2 id="選擇權損平點怎麼看買賣選擇權策略解析"><a class="header" href="#選擇權損平點怎麼看買賣選擇權策略解析">選擇權損平點怎麼看？買賣選擇權策略解析</a></h2>
<p>瞭解操作概念要先從「買賣方式」開始理解。以下為你詳細說明：</p>
<h3 id="買進買權買call"><a class="header" href="#買進買權買call">買進買權（買CALL）</a></h3>
<p>買Call 很直覺，因為大家都會買東西，只要一張圖片就可以理解。</p>
<p><img src="strategy/Option/../images/%E8%B2%B7%E9%80%B2%E9%81%B8%E6%93%87%E6%AC%8A%E7%AD%96%E7%95%A5%E5%9C%96-1024x576.jpg" alt="買進選擇權策略圖" /></p>
<p>買東西就要花錢，當大盤在16200時，買16400Call支出20點（臺幣$1000元），需瞭解以下重點：</p>
<ul>
<li>時機：看漲。買Call是看漲，認為大盤會漲到16400，則買入16400Call。</li>
<li>最大虧損：20點。選擇權每週三進行結算，結算時大盤沒漲到16400，則支出的20點權利金歸零，最大虧損為20點。</li>
<li>最大獲利：無限。大盤漲上天買Call就賺上天，但勝率極低就是了。</li>
<li>損平點：16420。</li>
</ul>
<p>買方損平點為什麼是16420呢？雖然看對方向買CALL是看大盤漲到16400，但大盤到了16400其實還沒開始獲利，因為一開始花20點買CALL，所以需要大盤繼續漲，把支出的20點權利金都漲到了才是真的開始獲利。從上圖中也可以看到，低於16400的紅色區塊是最大虧損20點，中間橘色區塊是「虧損漸減區」，漲到16420過後的綠色區塊才開始獲利。</p>
<p>P.S. 上述提到的『16200、16400』是履約價；『20點』則是一口的權利金。</p>
<h3 id="賣出買權賣call"><a class="header" href="#賣出買權賣call">賣出買權（賣CALL）</a></h3>
<p>知道怎麼買東西，就要知道怎麼賣東西，其實真的很簡單，一樣也是看圖就能理解它的運作機制。</p>
<p><img src="strategy/Option/../images/%E8%B3%A3%E5%87%BA%E9%81%B8%E6%93%87%E6%AC%8A%E7%AD%96%E7%95%A5%E5%9C%96-1024x576.jpg" alt="賣出選擇權策略圖" /></p>
<p>賣16400Call（賣出買權）收20點權利金，賣東西收錢一樣很直覺！同時必須掌握以下重點：</p>
<ul>
<li>時機：看漲不過。賣Call是看漲不過，認為大盤不會漲到16400則賣出16400Call。</li>
<li>最大獲利：20點。不管大盤從當初建倉時的16200漲、跌、盤整，只要結算時大盤沒漲過16400，收到的20點權利金全拿。</li>
<li>最大虧損：超過16420後無限。無限虧損聽起來好像很可怕，但其實是個很好打破的迷思。只要用價差單進行賣出，除了可以大幅降低保證金需求，還可以完全控制虧損的風險。（歡迎參考：<a href="https://gooptions.cc/%E9%81%B8%E6%93%87%E6%AC%8A%E5%83%B9%E5%B7%AE%E5%96%AE/">選擇權價差單是什麼？瞭解價差單概念、目的，打破風險迷思！</a>）</li>
<li>損平點：16420。</li>
</ul>
<p>賣出16400Call，表示認為大盤不會漲超過16400，當大盤低於16400都能賺錢，如果漲到16400以上則要開始賠錢給買方，橘色區域是「獲利遞減區」，漲過16420則開始虧損，為什麼是16420才開始虧損？由於賣方是先賣出才收錢，先收了20點，一旦漲超過16400，大盤每漲1點要賠給買方1點，會先從買方那裡收到的20點開始賠，也就是<strong>拿買方自己的錢賠給他</strong>，若是把收到的錢賠完才會賠到本金。</p>
<p>光是這一點「買方vs賣方」的勝率就差很多了，買方要花錢買機會，還要漲到把花掉的錢賺回來才算是真獲利；賣方則是先收錢，若漲到16400，可以先拿收到的錢賠給對方。</p>
<p>於是我們知道了：</p>
<p><strong>買選擇權要先花錢，賣選擇權可以先收錢</strong>！</p>
<h2 id="教你看懂選擇權策略圖掌握賣方損益計算"><a class="header" href="#教你看懂選擇權策略圖掌握賣方損益計算">教你看懂選擇權策略圖，掌握賣方損益計算！</a></h2>
<h3 id="裸賣call損益計算方式"><a class="header" href="#裸賣call損益計算方式">裸賣Call損益計算方式</a></h3>
<p>「裸賣」顧名思義就是隻賣Call ，但沒做價差保護。賣一口16400Call ，收到20點權利金。從下圖來看，橫軸是大盤點位，縱軸是損益變化：</p>
<p><img src="strategy/Option/../images/%E8%A3%B8%E8%B3%A3%E9%81%B8%E6%93%87%E6%AC%8A%E7%AD%96%E7%95%A5%E5%9C%96-1024x521.png" alt="裸賣選擇權策略圖" /></p>
<ul>
<li>最大收益：當大盤結算在16400以下，穩拿20點。</li>
<li>損平點：當大盤結算在16420整，打平。</li>
<li>虧損：當開始往16420以上繼續漲，那就每1點都要賠錢，漲到16500點就賠80點。</li>
</ul>
<p>**我建議千萬不要裸賣CALL，不僅獲利有限、風險無限，還要押很多保證金，大盤上漲會持續虧損，很可能血本無歸，必須用價差單策略控制風險。**下方影片教你用這兩個方式取代裸賣。</p>
<p>那麼賣call該怎麼賺錢呢？我們延續剛剛的例子：</p>
<ul>
<li>狀況1：賣16400的call，當初跟買方收20點權利金，結算後大盤收盤在16300，選擇權價值為0點，賣方需花0點買回來平倉，則獲利20–0=20點。</li>
<li>狀況2：賣16400的call，當初跟買方收20點權利金，結算後大盤收盤在16410，因為大盤漲的比16400call的履約價還要高10點，所以賣方要賠給買方10點。但是當初賣出收的權利金是20點，所以賣方還是獲利，獲利20–10=10點。</li>
</ul>
<h3 id="裸賣put損益計算方式"><a class="header" href="#裸賣put損益計算方式">裸賣PUT損益計算方式</a></h3>
<p>裸賣Put 卻沒有做價差保護，當你賣一口12200Put 收到20點權利金，該如何計算損平點呢？以下帶你一起看選擇權策略圖：</p>
<p><img src="strategy/Option/../images/%E8%A3%B8%E8%B3%A3%E9%81%B8%E6%93%87%E6%AC%8A%E7%AD%96%E7%95%A5-1024x498.png" alt="img" />裸賣選擇權策略圖</p>
<ul>
<li>最大收益：當大盤結算在12200以上，穩拿20點。</li>
<li>損平點：當大盤結算在12180整，打平。</li>
</ul>
<p>為什麼損平點是12180呢？因為賣出Put ，當跌破履約價，每跌1點就要賠給買方1點，跌到12180要賠20點，不過一開始權利金就先收了20點，所以拿權利金去賠給買方。<strong>賣出Put 的履約價減掉收到的權利金等於損平點位。</strong></p>
<p>以下提供50秒影片，為你說明賣Put的獲利方式，幫助您更好理解與記憶！</p>
<h2 id="提高勝率的平倉方式教學"><a class="header" href="#提高勝率的平倉方式教學">提高勝率的平倉方式教學</a></h2>
<p>選擇權平倉是：賣出選擇權能收權利金，之後花較少的權利金買回來跟原本賣出部位互相沖銷就是平倉。以賣CALL為例說明，有3種狀況CALL權利金都會下降，代表賣方賣CALL可獲利平倉：</p>
<ol>
<li>大盤下跌，CALL權利金減少</li>
<li>大盤盤整，時間價值降低讓外在價值降低，CALL權利金會減少</li>
<li>波動率降低於是外在價值降低，CALL權利金減少</li>
</ol>
<p>以上三種狀況賣CALL的賣方都能平倉且獲利。大家都知道獲利平倉，但何時才是適合時機呢？獲利50%時平倉是好時機。</p>
<p>透過數學原理，我在這另一篇文章詳細說明為什麼 <a href="https://gooptions.cc/%E9%81%B8%E6%93%87%E6%AC%8A%E5%B9%B3%E5%80%89-%E7%A7%BB%E9%99%A4%E9%A2%A8%E9%9A%AA%E6%8F%90%E5%8D%87%E5%8B%9D%E7%8E%87/">選擇權獲利50%時平倉就是好時機</a>！這樣做可以提升勝率，而且這是有理論依據與數學證明的。</p>
<h2 id="臺股選擇權2種合約與選擇權結算"><a class="header" href="#臺股選擇權2種合約與選擇權結算">臺股選擇權2種合約與選擇權結算</a></h2>
<p>買賣CALL和PUT是選擇權的交易動作，而臺股選擇權有**「雙週選擇權」<strong>與</strong>「月選擇權」**兩種合約供投資人交易：</p>
<ul>
<li><strong>雙週選擇權</strong>每14天結算一次，於每星期三8:45開放新合約交易，直到兩週後的星期三13:25進行結算，所以每個週三都同時有新、舊合約可交易。</li>
<li><strong>月選擇權</strong>是在每個月第3個星期三進行結算，每月結算一次。</li>
</ul>
<p>*注意事項，選擇權結算價是依照大盤點數，也就是<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%AC%8A%E8%82%A1%E5%83%B9%E6%8C%87%E6%95%B8">加權指數</a>進行計算，不是看<a href="https://gooptions.cc/%E6%9C%9F%E8%B2%A8%E4%BA%A4%E6%98%93/">臺指期貨大臺、小臺</a>，結算日當天所有買、賣的選擇權合約都要進行結算。臺灣券商會於<strong>每月第1週要結算</strong>的週選合約用W1表示，第2週用W2，以此類推。但是不會有W3，因為月選合約會在當月第3週的星期三進行結算，所以不會有W3合約。</p>
<p>下方列出2023選擇權結算日期總整理，幫您快速掌握交易時間。更多細節可以參考 <a href="https://gooptions.cc/%E9%81%B8%E6%93%87%E6%AC%8A%E7%B5%90%E7%AE%97%E6%97%A5/">選擇權結算日與策略運用</a> 說明。</p>
<p><img src="strategy/Option/../images/%E6%88%AA%E5%9C%96-2022-11-23-%E4%B8%8B%E5%8D%885.28.47-1024x701.jpg" alt="2023年選擇權結算日日期" />2023年選擇權結算日日期</p>
<h2 id="選擇權策略運用"><a class="header" href="#選擇權策略運用">選擇權策略運用</a></h2>
<p>除了單純買、賣CALL或PUT的交易，透過同時持有買方、賣方部位的CALL和PUT進行策略組合，可以幫投資人有效避開追漲殺跌看方向操作，進而提高交易勝率。例如Iron Condor（中文：鐵兀鷹）是選擇權最早出現的策略之一，透過同時賣出CALL和PUT保持中立。</p>
<p>常見的<a href="https://gooptions.cc/category/strategy/">選擇權策略</a>與使用時機：</p>
<ul>
<li>當<a href="https://gooptions.cc/%E5%83%B9%E5%85%A7%E5%83%B9%E5%A4%96/">價平和</a>高、震幅低：使用<a href="https://gooptions.cc/category/learn-options-trading/50%E7%A7%92%E5%AD%B81%E6%8B%9B/%E9%81%B8%E6%93%87%E6%AC%8A%E7%AD%96%E7%95%A5%E9%81%8B%E7%94%A8iron-condor/">中立策略Iron Condor</a>，維持中立賺取時間價值。臺股2020年之前適合。</li>
<li>當價平和高、震幅高：適合使用<a href="https://gooptions.cc/%E9%81%B8%E6%93%87%E6%AC%8A%E7%AD%96%E7%95%A5%E6%95%99%E5%AD%B8-%E5%A4%A7%E5%8D%80%E9%96%93%E7%AD%96%E7%95%A5/">大區間進場策略</a>，賺波動價值。臺股2021年走勢適合。</li>
<li>當價平和低、震幅高：<a href="https://gooptions.cc/courses/%E9%81%B8%E6%93%87%E6%AC%8A%E6%90%AD%E9%85%8D%E6%9C%9F%E8%B2%A8%E7%AD%96%E7%95%A5%E3%80%8E%E9%9B%99%E8%B2%B7%EF%BC%8B%E5%B0%8F%E8%87%BA%E3%80%8F/">雙買+小臺進場策略</a>可以大幅交易提昇盈虧比。臺股2021年Q3～2022年Q2適合。</li>
<li>偏多策略 <a href="https://gooptions.cc/%E8%B3%A3%E6%AC%8A%E5%A4%9A%E9%A0%AD%E6%90%AD%E9%85%8D%E8%B2%B7%E6%AC%8A%E7%A9%BA%E9%A0%AD%E7%AD%96%E7%95%A5/">跨合約賣權多頭搭配賣CALL</a> 策略。時機簡單明瞭新手適用。</li>
</ul>
<h2 id="2023年中立策略iron-condor隆重回歸"><a class="header" href="#2023年中立策略iron-condor隆重回歸">2023年中立策略Iron Condor隆重回歸</a></h2>
<p>2023了，邁入新的一年，今年主軸是開發自動化交易機器人，目前已經完成策略初步回測階段，成效非常好，目前有2個策略回測2020~2022的數據，都有傑出表現。我先說在回測過程中意外發現的事情。</p>
<p>上述說到，2020開始的後疫情時期臺股走勢發生變化，我比較少用IRON CONDOR，但在開發交易機器人的過程意外發現，過去兩年期間，週一週二使用iron condor績效出乎意料好，這邊的好不是幾十上百倍回報，而是固定週一或週二在適當時機與點位做iron condor，穩穩做回測數據是能保持長期穩定獲利。</p>
<p>以前中立策略Iron Condor習慣是週三開始建倉，維持中立把時間價值賺起來，遇到危險則調整部位，沒想過是到接近結算的週一才建倉，完全出乎意料。</p>
<p>知道我說『中立策略Iron Condor隆重回歸』的原因後，我帶你好好認識這個策略，不管是新手或是老手，都必須來瞭解這個選擇權最早被發明出來的策略，學會後，再看3種 iron condor分別如何進場建倉。</p>
<p>Iron Condor的做法是同時賣出CALL也賣出PUT，同時看大盤漲不過高點也跌不破低點。假設大盤在15000，同時賣15200 CALL和14800PUT，接下來，不管是從15000開始的漲跌或盤整，結算時大盤落在這個400點的區間中，你都獲利，這就是維持中立的意思。</p>
<p>當你保持中立，讓大盤在這400點區間中上下走，你將很能好好避開典型散戶的追漲殺跌心態。</p>
<h3 id="3種iron-condor建倉方式"><a class="header" href="#3種iron-condor建倉方式">3種iron condor建倉方式</a></h3>
<p>中立策略Iron Condor建倉方式總結有3種：</p>
<ol>
<li><strong>對稱Iron Condor 先做再說</strong>：不管當下狀況是有趨勢還是盤整，直接在大盤往上和往下一樣距離履約價建倉賣出CALL和PUT價差單，把大盤夾在正中間。</li>
<li><strong>有明顯趨勢時建倉</strong>：可透過順勢或逆勢建立出第一邊，接著找相近的delta建立第二邊，做動態Iron Condor。這個狀況主要是用在當下可能有明顯的趨勢，但是也不想只做單邊、不想押注單邊。</li>
<li><strong>看支撐壓力建倉</strong>：大盤移動過程中，用自己的方式判斷支撐、壓力點。接著，在壓力點往後N檔，可能100點、150點或200點，挑選一個合適的履約價賣出第1組價差單，接著再建立另外一邊價差單做對稱位置Iron Condor。</li>
</ol>
<h2 id="選擇權也有夜盤交易"><a class="header" href="#選擇權也有夜盤交易">選擇權也有夜盤交易</a></h2>
<ul>
<li>臺股期貨與選擇權一般交易時段：<strong>08:45~13:45</strong></li>
<li>臺股夜盤時段是：<strong>15:00~次日05:00</strong></li>
</ul>
<p><strong>在夜盤時段都可交易選擇權</strong>：政府設立夜盤目的是讓投資人多一個避險管道。投資人能於夜盤進行交易。臺指期夜盤是跟著國際情勢波動，而夜盤主要交易量以專業投資人的自動交易程式為主。用手機APP可以看到夜盤期貨與選擇權報價，選『臺指近”全”』即可。細節可以參考 <a href="https://gooptions.cc/%E8%87%BA%E8%82%A1%E5%A4%9C%E7%9B%A4/">選擇權夜盤避險方式教學</a>。</p>
<h2 id="選擇權建倉與平倉系統操作教學"><a class="header" href="#選擇權建倉與平倉系統操作教學">選擇權建倉與平倉系統操作教學</a></h2>
<p>選擇權建倉與平倉可以透過多次IOC功能，由電腦監測價差點數並自動連續嘗試建倉直到成交為止（就是洗單），多次IOC是選擇權交易人必用工具。</p>
<p>我們可以善用<a href="https://gooptions.cc/%E9%81%B8%E6%93%87%E6%AC%8A%E5%A4%9C%E7%9B%A4%E7%94%A8%E5%A4%9A%E6%AC%A1ioc/">選擇權多次IOC下單功能</a>來進行自動建倉與平倉，大幅降低盯盤時間。下方影片是多次IOC系統操作手把手教學。</p>
<h2 id="認識put-call-ratio"><a class="header" href="#認識put-call-ratio">認識Put Call Ratio</a></h2>
<p><strong><a href="https://gooptions.cc/put-call-ratio/">選擇權 Put Call Ratio</a>（又寫做 P/C Ratio）是</strong>：把當日選擇權 Put未平倉量 除以 Call未平倉量。從選擇權賣方角度看，P/C Ratio數值越大通常看成偏多指標，因為Put未平倉量比Call未平倉量多，可以推斷賣Put多，更不容易跌破支撐；如果P/C Ratio越小則相反，代表賣CALL較多，看上漲遇壓不容易突破。賣出選擇權需壓保證金，賣方需要準備較多資金，所以Put Call Ratio是從賣方風險角度進行解讀。</p>
<h2 id="選擇權教學結論"><a class="header" href="#選擇權教學結論">選擇權教學結論</a></h2>
<ol>
<li>買選擇權要付出權利金，賣選擇權則收權利金。</li>
<li>買方要大漲、大跌才有機會以小博大，因為除了要看對方向，還要把付出的權利金賺回來。</li>
<li>買方付出權利金，就算看對方向也可能賠錢。</li>
<li>賣方當莊家，先收權利金，就算看錯方向也可能賺錢。</li>
<li>千萬不要裸賣選擇權。可透過同時持有買方賣方部位搭配使用，用交易策略提升勝率。</li>
</ol>
<h2 id="說人話的選擇權課程一步步瞭解選擇權運作打造長期穩定獲利"><a class="header" href="#說人話的選擇權課程一步步瞭解選擇權運作打造長期穩定獲利">說人話的選擇權課程｜一步步瞭解選擇權運作，打造長期穩定獲利</a></h2>
<p>長期經營並製作中文市場最專業的選擇權教學網站，多年來我產出超過150個教學影片並回覆上千則留言，讓我完全清楚新手交易時遇到的問題與解決方法；我知道怎麼進行教學，最能幫助大家快速上手選擇權交易。<strong>今年是課程持續更新的第3年了，一次加入，永久更新</strong>！</p>
<p>幾年前自己默默交易著選擇權，後來因為經營網站和YT頻道，開始認識一些業界前輩，有了更多交流。過程中學到很多選擇權策略，讓我能幫學員把這堂 說人話的選擇權課程 持續更新、優化。</p>
<blockquote>
<p><strong>最新動向！跟業界高手羊叔討論，我把『雙買＋小臺』從原本的策略操作，延伸出更多配置來提高勝率，並免費更新給大家！</strong></p>
</blockquote>
<h2 id="選擇權常見問題qa"><a class="header" href="#選擇權常見問題qa">選擇權常見問題QA</a></h2>
<p><strong>為什麼要操作選擇權？</strong></p>
<p>一是選擇權可以降低持倉成本，二是即使看錯，也不一定賠。假設大盤在17200，看臺積電上漲帶動大盤往上，可以賣出臺股選擇權 17000的賣權（賣PUT）同時買入臺積電。
萬一臺積電未如預期上漲，但臺股也沒下跌，結算時大盤點位在賣出的17000PUT之上，這口PUT還是獲利的：看錯也沒賠，還能降低臺積電持倉成本。</p>
<p><strong>選擇權損平點怎麼看？</strong></p>
<p>選擇權損平點計算方式：把履約價加上支出的權利金即是損平點。例如：買東西要花錢，當大盤在16200時，認為大盤會漲到16400，買進16400Call支出20點（臺幣$1000元），此時損平點是16420，最大虧損為20點，最大獲利為無限，但勝率低就是了。</p>
<p><strong>裸賣是什麼？</strong></p>
<p>「裸賣」顧名思義就是隻賣Call ，但沒做價差保護。交易人可以用『價差單』保護部位控制風險。</p>
<p><strong>雙週選和月選的差別？</strong></p>
<p><strong>雙週選擇權</strong>每週三結算並有新的週合約，所以每個週三都同時有新、舊合約可交易；<strong>月選擇權</strong>是在每個月第3個星期三進行結算。市場上有時候會同時存在高達4份合約。以2022.11.23（三）為例，有：當天要結算的舊合約、當天新雙週選合約、將於下個週三結算的合約和12月的月選合約（如下圖）。<img src="strategy/Option/../images/%E6%88%AA%E5%9C%96-2022-11-23-%E4%B8%8B%E5%8D%885.37.04.jpg" alt="img" /></p>
<p><strong>怎麼建倉和平倉？可以掛單嗎？</strong></p>
<p>選擇權建倉與平倉可以掛單，需透過多次IOC功能，由電腦監測價差點數並自動連續嘗試建倉直到成交為止（就是洗單），多次IOC是選擇權交易人必用工具。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">from line_notify import LineNotify
from retry import retry

import datetime as dt
import sys
import platform
import signal
import datetime
import shioaji as sj
import os
import json
import pandas as pd
import requests

pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x


class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            self.kill()
        sys.exit()

    def kill(self):
        try:
            print(&quot;kill&quot;)
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass


@retry(exceptions=Exception, tries=3, delay=2, backoff=2)
def get_options_data(option_contract_period, queryStartDate=None, queryEndDate=None):
    if queryStartDate is None and queryEndDate is None:
        # now = datetime.datetime.now()
        now = datetime.datetime.now().time()  # 獲取當前時間的時間部分
        # now = datetime.datetime.now() - datetime.timedelta(days=1)
        # 如果超過15:00，日期加一天
        # if now.hour &gt;= 15:
        #    now += datetime.timedelta(days=-1)
        queryStartDate = queryEndDate = now.strftime(&quot;%Y/%m/%d&quot;)
        if now &lt; datetime.time(15, 0):  # 如果當前時間在 15:00 之前
            yesterday = datetime.date.today() - datetime.timedelta(days=1)  # 扣一天
            queryStartDate = queryEndDate = yesterday.strftime(&quot;%Y/%m/%d&quot;)
            print(&quot;目前時間在 15:00 之前，扣一天後為：&quot;, yesterday)

        # 轉換日期格式為年月日

    url = f&quot;https://www.taifex.com.tw/cht/3/dlOptDataDown?down_type=1&amp;commodity_id=txo&amp;queryStartDate={queryStartDate}&amp;queryEndDate={queryEndDate}&quot;
    print(queryStartDate, queryEndDate, &quot;\n&quot;, url)
    df = pd.read_csv(url, encoding=&quot;big5&quot;, index_col=False)
    # df = pd.read_csv(&quot;./夜盤.csv&quot;, encoding=&quot;big5&quot;, index_col=False)
    if not df.empty:
        df = df[
            [&quot;交易日期&quot;, &quot;契約&quot;, &quot;買賣權&quot;, &quot;到期月份(週別)&quot;, &quot;履約價&quot;, &quot;收盤價&quot;, &quot;成交量&quot;, &quot;交易時段&quot;, &quot;未沖銷契約數&quot;]
        ]
        df = df[df[&quot;收盤價&quot;] != &quot;-&quot;]
        df[&quot;收盤價&quot;] = df[&quot;收盤價&quot;].astype(float)
        # df[&quot;收盤價&quot;] = df[&quot;收盤價&quot;].replace(&quot;-&quot;, &quot;0&quot;).astype(float)
        df[&quot;成交量&quot;] = df[&quot;成交量&quot;].replace(&quot;-&quot;, &quot;0&quot;).astype(float)
        df[&quot;未沖銷契約數&quot;] = df[&quot;未沖銷契約數&quot;].replace(&quot;-&quot;, &quot;0&quot;).astype(float)
        df[&quot;履約價&quot;] = df[&quot;履約價&quot;].replace(&quot;-&quot;, &quot;0&quot;).astype(float)
        df[&quot;到期月份(週別)&quot;] = df[&quot;到期月份(週別)&quot;].str.strip()
        df = df[
            (df[&quot;到期月份(週別)&quot;] == option_contract_period)
            &amp; (df[&quot;交易時段&quot;] == &quot;一般&quot;)
            &amp; (df[&quot;收盤價&quot;] &gt; 0)
        ]
        # 新增未平倉金額欄位
        df[&quot;未平倉金額&quot;] = df[&quot;收盤價&quot;] * 50 * df[&quot;未沖銷契約數&quot;]

        # 買權 DataFrame
        df_call = df[df[&quot;買賣權&quot;] == &quot;買權&quot;]
        # 賣權 DataFrame
        df_put = df[df[&quot;買賣權&quot;] == &quot;賣權&quot;]
        print(df.to_markdown(index=False, floatfmt=&quot;.2f&quot;))
        df_call = df_call.sort_values(&quot;未平倉金額&quot;, ascending=False)
        print(df_call.to_markdown(index=False, floatfmt=&quot;.2f&quot;))
        df_put = df_put.sort_values(&quot;未平倉金額&quot;, ascending=False)
        print(df_put.to_markdown(index=False, floatfmt=&quot;.2f&quot;))
        return df
    else:
        return None


def get_TaiwanOptionDaily(symbol):
    date = datetime.datetime.now().time()  # 獲取當前時間的時間部分
    if date &lt; datetime.time(15, 0):  # 如果當前時間在 15:00 之前
        date = (datetime.date.today() - datetime.timedelta(days=1)).strftime(&quot;%Y-%m-%d&quot;)
    else:
        date = date.strftime(&quot;%Y-%m-%d&quot;)
    url = &quot;https://api.finmindtrade.com/api/v3/data&quot;
    parameter = {&quot;dataset&quot;: &quot;TaiwanOptionDaily&quot;, &quot;data_id&quot;: &quot;TXO&quot;, &quot;date&quot;: date}
    data = requests.get(url, params=parameter)
    data = data.json()
    df = pd.DataFrame(data[&quot;data&quot;])
    df = df[
        # (df[&quot;contract_date&quot;] == &quot;202303W5&quot;)
        (df[&quot;contract_date&quot;] == symbol)
        &amp; (df[&quot;date&quot;] == date)
        &amp; (df[&quot;trading_session&quot;] == &quot;position&quot;)
        &amp; (df[&quot;close&quot;] != 0)
    ]
    df[&quot;未平倉資金&quot;] = df[&quot;close&quot;] * 50 * df[&quot;open_interest&quot;]
    print(df.to_markdown(index=False, floatfmt=&quot;.2f&quot;))
    # 依據 call_put 欄位分成兩個 DataFrame
    df_call = df[df[&quot;call_put&quot;] == &quot;call&quot;]
    df_put = df[df[&quot;call_put&quot;] == &quot;put&quot;]
    print(df_call)
    print(df_put)


def get_option_week(api):
    def get_previous_wednesday():
        today = datetime.datetime.today()
        wednesday = (
            today
            - datetime.timedelta(days=today.weekday())
            + datetime.timedelta(days=2)
        )
        previous_wednesday = wednesday - datetime.timedelta(days=7)
        return previous_wednesday.date()

    def get_this_week_wednesday():
        today = datetime.datetime.today()
        wednesday = (today + datetime.timedelta(days=(2 - today.weekday()))).date()
        return wednesday

    def get_next_week_wednesday():
        today = datetime.datetime.today()
        wednesday = (today + datetime.timedelta(days=(2 - today.weekday() + 7))).date()
        return wednesday

    for option in api.Contracts.Options:
        for contract in option:
            if &quot;TX&quot; in contract.category:
                now = datetime.datetime.now()
                wednesday_time = get_this_week_wednesday()
                wednesday_time = datetime.datetime.combine(
                    wednesday_time, datetime.datetime.min.time()
                ) + datetime.timedelta(
                    hours=14
                )  # 因為程式是14:50啟動計算所以改設定14:00
                # print(wednesday_time)

                # 根據當前時間判斷是否在星期三 15:00之前。如果在此時間之前，則列印上週三和本週三的日期；否則列印本週三和下週三的日期：
                if now &lt; wednesday_time:
                    if datetime.datetime.strptime(
                        contract.update_date, &quot;%Y/%m/%d&quot;
                    ).date() &gt;= get_previous_wednesday() and contract.delivery_date == get_this_week_wednesday().strftime(
                        &quot;%Y/%m/%d&quot;
                    ):
                        print(
                            contract.symbol,
                            contract.name,
                            contract.update_date,
                            contract.delivery_date,
                        )
                        return contract.symbol[:3]
                else:
                    if datetime.datetime.strptime(
                        contract.update_date, &quot;%Y/%m/%d&quot;
                    ).date() &gt;= get_this_week_wednesday() and contract.delivery_date == get_next_week_wednesday().strftime(
                        &quot;%Y/%m/%d&quot;
                    ):
                        print(
                            contract.symbol,
                            contract.name,
                            contract.update_date,
                            contract.delivery_date,
                        )
                        return contract.symbol[:9]


if __name__ == &quot;__main__&quot;:
    if platform.system().lower() == &quot;linux&quot;:
        Watcher()

    with open(os.environ[&quot;HOME&quot;] + &quot;/.mybin/shioaji_token.txt&quot;, &quot;r&quot;) as f:
        date = dt.datetime.now().strftime(&quot;%Y-%m-%d&quot;)
        api = sj.Shioaji()
        kw_login = json.loads(f.read())
        api.login(**kw_login, contracts_timeout=300000)
        symbol = get_option_week(api)
        if symbol[:3] == &quot;TXO&quot;:
            option_contract_period = symbol[3:9]
            future_contract_code = &quot;TXF&quot;
        else:
            option_contract_period = symbol[3:9] + &quot;W&quot; + symbol[:3][-1]
            future_contract_code = &quot;MX&quot; + symbol[:3][-1]
            future_contract_period = future_contract_code + symbol[3:9]
            print(future_contract_code, future_contract_period)

            kbars = api.kbars(
                api.Contracts.Futures[future_contract_code][future_contract_period],
                date,
            )
            df = pd.DataFrame({**kbars})
            df.ts = pd.to_datetime(df.ts)
            df.set_index(&quot;ts&quot;, inplace=True)
            print(df)

        print(option_contract_period)
        get_TaiwanOptionDaily(option_contract_period)
        get_options_data(option_contract_period)

        TXF = (
            sorted([x for x in dir(api.Contracts.Futures.TXF) if x.startswith(&quot;TXF&quot;)])
        )[0]
        kbars = api.kbars(api.Contracts.Futures.TXF[TXF], date)
        df = pd.DataFrame({**kbars})
        df.ts = pd.to_datetime(df.ts)
        df.set_index(&quot;ts&quot;, inplace=True)
        print(df)
</code></pre>
<pre><code class="language-python">import requests
import pandas as pd

pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x

url = &quot;https://api.finmindtrade.com/api/v3/data&quot;
parameter = {&quot;dataset&quot;: &quot;TaiwanOptionDaily&quot;, &quot;data_id&quot;: &quot;TXO&quot;, &quot;date&quot;: &quot;2023-03-20&quot;}
data = requests.get(url, params=parameter)
data = data.json()
df = pd.DataFrame(data[&quot;data&quot;])
df = df[
    (df[&quot;contract_date&quot;] == &quot;202303W5&quot;)
    &amp; (df[&quot;date&quot;] == &quot;2023-03-22&quot;)
    &amp; (df[&quot;trading_session&quot;] == &quot;position&quot;)
    &amp; (df[&quot;close&quot;] != 0)
]
df['未平倉資金'] = df['close'] * 50 * df['open_interest']
print(df.to_markdown(index=False, floatfmt=&quot;.2f&quot;))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="from_orders"><a class="header" href="#from_orders">from_orders</a></h2>
<pre><code class="language-python">import pandas as pd
import vectorbt as vbt
import numpy as np
from datetime import datetime, timedelta


# Entry trades
pf_kwargs = dict(
    close=pd.Series([1., 2., 3., 4., 5.]),
    size=pd.Series([1., -2., 2., -2., 1.]),
    fixed_fees=1.
)

entry_trades = vbt.Portfolio.from_orders(**pf_kwargs).entry_trades
print(entry_trades.records_readable)
exit_trades = vbt.Portfolio.from_orders(**pf_kwargs).exit_trades
print(exit_trades.records_readable)

# Entry positions
positions = vbt.Portfolio.from_orders(**pf_kwargs).positions
print(positions.records_readable)

print(entry_trades.pnl.sum() == exit_trades.pnl.sum() == positions.pnl.sum())

price = pd.Series([1., 2., 3., 4., 3., 2., 1.])
size = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])
trades = vbt.Portfolio.from_orders(price, size).trades

print(trades.count())
print(trades.pnl.sum())
print(trades.winning.count())
print(trades.winning.pnl.sum())
print(trades.stats())

np.random.seed(42)
price = pd.DataFrame({
    'a': np.random.uniform(1, 2, size=100),
    'b': np.random.uniform(1, 2, size=100)
}, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])
size = pd.DataFrame({
    'a': np.random.uniform(-1, 1, size=100),
    'b': np.random.uniform(-1, 1, size=100),
}, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])
pf = vbt.Portfolio.from_orders(price, size, fees=0.01, freq='d')
print(pf.trades['a'].stats(settings=dict(incl_open=True)))
</code></pre>
<h2 id="多幣種回測"><a class="header" href="#多幣種回測">多幣種回測</a></h2>
<pre><code class="language-python">import numpy as np
import pandas as pd
import vectorbt as vbt
import warnings
from datetime import datetime


# Prepare data
start = &quot;2019-01-01 UTC&quot;  # crypto is in UTC
end = &quot;2020-01-01 UTC&quot;
btc_price = vbt.YFData.download(&quot;BTC-USD&quot;, start=start, end=end).get(&quot;Close&quot;)
eth_price = vbt.YFData.download(&quot;ETH-USD&quot;, start=start, end=end).get(&quot;Close&quot;)
comb_price = btc_price.vbt.concat(
    eth_price, keys=pd.Index([&quot;BTC&quot;, &quot;ETH&quot;], name=&quot;symbol&quot;)
)
comb_price.vbt.drop_levels(-1, inplace=True)

fast_ma = vbt.MA.run(comb_price, [10, 20], short_name=&quot;fast&quot;)
slow_ma = vbt.MA.run(comb_price, [30, 30], short_name=&quot;slow&quot;)

entries = fast_ma.ma_crossed_above(slow_ma)
exits = fast_ma.ma_crossed_below(slow_ma)

pf = vbt.Portfolio.from_signals(comb_price, entries, exits)
print(pf.total_return())
print(pf.stats())
</code></pre>
<h2 id="multiple-assets-multiple-trade-signals-per-asset"><a class="header" href="#multiple-assets-multiple-trade-signals-per-asset">Multiple assets, multiple trade signals per asset</a></h2>
<pre><code class="language-python">import pandas as pd
import vectorbt as vbt

price = pd.DataFrame({&quot;p1&quot;: [1, 2, 3, 4], &quot;p2&quot;: [5, 6, 7, 8]})
price.columns.name = &quot;asset&quot;
entries = pd.DataFrame(
    {
        &quot;en1&quot;: [True, False, False, False],
        &quot;en2&quot;: [False, True, False, False],
        &quot;en3&quot;: [False, False, True, False],
        &quot;en4&quot;: [False, False, False, True],
    }
)
entries.columns.name = &quot;entries&quot;
exits = pd.DataFrame(
    {
        &quot;ex1&quot;: [False, False, False, True],
        &quot;ex2&quot;: [False, False, False, True],
        &quot;ex3&quot;: [False, False, False, True],
        &quot;ex4&quot;: [False, False, False, True],
    }
)
exits.columns.name = &quot;exits&quot;
entries = entries.vbt.stack_index(pd.Index([&quot;p1&quot;, &quot;p1&quot;, &quot;p2&quot;, &quot;p2&quot;], name=&quot;asset&quot;))
exits = exits.vbt.stack_index(pd.Index([&quot;p1&quot;, &quot;p1&quot;, &quot;p2&quot;, &quot;p2&quot;], name=&quot;asset&quot;))
portfolio = vbt.Portfolio.from_signals(price, entries, exits)  # not grouped portfolio
print(portfolio.total_return())
print(portfolio.total_return(group_by='asset'))  # group not grouped portfolio

portfolio = vbt.Portfolio.from_signals(price, entries, exits, group_by='asset')  # grouped portfolio
print(portfolio.total_return())

print(portfolio.total_return(group_by=False))  # ungroup grouped portfolio

</code></pre>
<h2 id="from_order_func-做資金加減碼"><a class="header" href="#from_order_func-做資金加減碼">from_order_func 做資金加減碼</a></h2>
<pre><code class="language-python">from numba import njit
from vectorbt.portfolio import nb
from vectorbt.portfolio.enums import Direction

import numpy as np
import vectorbt as vbt
import pandas as pd
import warnings

pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x

warnings.simplefilter(&quot;ignore&quot;, UserWarning)


def simulate():
    @njit
    def order_func_nb(c, action, direction, fees):
        # _size = 1000 / float(c.close[c.i, c.col])
        # print(
        #    &quot;Close:&quot;,
        #    c.close[c.i, c.col],
        #    &quot;Direction:&quot;,
        #    direction,
        #    &quot;c.i:&quot;,
        #    c.i,
        #    &quot;c.col:&quot;,
        #    c.col,
        #    &quot;fees:&quot;,
        #    fees,
        #    &quot;_size:&quot;,
        #    round(_size, 2),
        #    &quot;position_now:&quot;,
        #    c.position_now,
        #    &quot;action:&quot;,
        #    action[c.i],
        # )

        size = 0
        if action[c.i] == 1:
            # 1000 / float(c.close[c.i, c.col]) 買入 1000 元的股票
            size = 1000 / float(c.close[c.i, c.col])
        elif action[c.i] == -1:
            # -c.position_now 持有全部的股票賣出
            size = -c.position_now

        return nb.order_nb(
            price=c.close[c.i, c.col], size=size, direction=direction, fees=fees,
        )

    # 加碼策略
    action = pd.Series([1, 1, -1, 1, -1, 0, 0, 1, -1])
    dates = pd.date_range(&quot;20220301&quot;, periods=len(action))
    price = pd.DataFrame(
        {&quot;Price&quot;: [100, 200, 300, 400, 500, 600, 700, 800, 900]}, index=dates
    )
    fees = 0.002  # per frame
    pf = vbt.Portfolio.from_order_func(
        price,
        order_func_nb,
        np.asarray(action),
        Direction.LongOnly,
        fees,
        init_cash=1000000,
    )
    orders_records_readable = pf.orders.records_readable.drop(&quot;Column&quot;, axis=1)
    print(orders_records_readable.to_markdown(index=False, floatfmt=&quot;.2f&quot;))
    print(pf.assets().rename(columns={&quot;Price&quot;: &quot;assets&quot;}))
    print(pf.cash().rename(columns={&quot;Price&quot;: &quot;cash&quot;}))
    print(pf.stats())


if __name__ == &quot;__main__&quot;:
    simulate()
</code></pre>
<h2 id="ordercontext"><a class="header" href="#ordercontext">OrderContext</a></h2>
<pre><code class="language-python">class OrderContext(tp.NamedTuple):
    target_shape: tp.Shape  # 目標形狀
    group_lens: tp.Array1d  # 分組長度
    init_cash: tp.Array1d  # 初始現金
    cash_sharing: bool  # 是否共享現金
    call_seq: tp.Optional[tp.Array2d]  # 呼叫順序
    segment_mask: tp.ArrayLike  # 分段遮罩
    call_pre_segment: bool  # 是否在分段之前呼叫
    call_post_segment: bool  # 是否在分段之後呼叫
    close: tp.ArrayLike  # 收盤價
    ffill_val_price: bool  # 是否向前填充估值價格
    update_value: bool  # 是否更新持倉估值
    fill_pos_record: bool  # 是否填充持倉紀錄
    flex_2d: bool  # 是否彈性處理2D數據
    order_records: tp.RecordArray  # 訂單紀錄
    log_records: tp.RecordArray  # 日誌紀錄
    last_cash: tp.Array1d  # 上次現金
    last_position: tp.Array1d  # 上次持倉
    last_debt: tp.Array1d  # 上次負債
    last_free_cash: tp.Array1d  # 上次自由現金
    last_val_price: tp.Array1d  # 上次估值價格
    last_value: tp.Array1d  # 上次持倉估值
    second_last_value: tp.Array1d  # 倒數第二次持倉估值
    last_return: tp.Array1d  # 上次收益率
    last_oidx: tp.Array1d  # 上次訂單索引
    last_lidx: tp.Array1d  # 上次日誌索引
    last_pos_record: tp.RecordArray  # 上次持倉紀錄
    group: int  # 分組
    group_len: int  # 分組長度
    from_col: int  # 起始欄位
    to_col: int  # 終止欄位
    i: int  # 迭代器
    call_seq_now: tp.Optional[tp.Array1d]  # 當前呼叫順序
    col: int  # 當前欄位
    call_idx: int  # 當前呼叫索引
    cash_now: float  # 現金餘額
    position_now: float  # 持倉量
    debt_now: float  # 負債金額
    free_cash_now: float  # 自由現金餘額
    val_price_now: float  # 估值價格
    value_now: float  # 持倉估值
    return_now: float  # 當前收益率
</code></pre>
<pre><code class="language-sh">報告列出了許多評估指標：

Start：回測開始日期。
End：回測結束日期。
Period：回測時間段。
Start Value：回測開始時的資產價值。
End Value：回測結束時的資產價值。
Total Return [%]：回測期間的總回報率。
Benchmark Return [%]：基準指數的回報率。
Max Gross Exposure [%]：最大總槓桿率。
Total Fees Paid：交易費用總額。
Max Drawdown [%]：最大回撤率。
Max Drawdown Duration：最大回撤期間。
Total Trades：總交易次數。
Total Closed Trades：總平倉交易次數。
Total Open Trades：總持倉交易次數。
Open Trade PnL：未平倉交易的盈虧。
Win Rate [%]：勝率。
Best Trade [%]：最佳交易回報率。
Worst Trade [%]：最差交易回報率。
Avg Winning Trade [%]：平均勝利交易回報率。
Avg Losing Trade [%]：平均虧損交易回報率。
Avg Winning Trade Duration：平均勝利交易持續時間。
Avg Losing Trade Duration：平均虧損交易持續時間。
Profit Factor：盈虧比。
Expectancy：預期值。
Sharpe Ratio：夏普比率。
Calmar Ratio：卡爾馬比率。
Omega Ratio：歐米茄比率。
Sortino Ratio：索提諾比率。

其中一些指標的定義可能需要參考具體的金融概念，例如回報率、總槓桿率、回撤率、夏普比率等等。這些指標可以幫助用戶評估交易策略的表現，以便做出相應的調整和優化。
</code></pre>
<h2 id="asset_flow"><a class="header" href="#asset_flow">asset_flow</a></h2>
<pre><code class="language-python">import numpy as np
from vectorbt.records.nb import col_map_nb
from vectorbt.portfolio.nb import simulate_from_orders_nb, asset_flow_nb
from vectorbt.portfolio.enums import Direction

close = np.array([1, 2, 3, 4, 5])[:, None]
order_records, _ = simulate_from_orders_nb(
    target_shape=close.shape,
    close=close,
    group_lens=np.array([1]),
    init_cash=np.array([100]),
    call_seq=np.full(close.shape, 0)
)

print(order_records)

col_map = col_map_nb(order_records['col'], close.shape[1])
asset_flow = asset_flow_nb(close.shape, order_records, col_map, Direction.Both)
print(asset_flow)
</code></pre>
<h2 id="資金1000-加碼-size-統計"><a class="header" href="#資金1000-加碼-size-統計">資金1000 加碼 size 統計</a></h2>
<pre><code class="language-python">import pandas as pd

# create a date range
dates = pd.date_range(&quot;20220301&quot;, periods=7)

# create a price dataframe
price = pd.DataFrame({&quot;price&quot;: [50, 100, 200, 250, 300, 400, 500]}, index=dates)

# create entry and exit dataframes
entries = pd.DataFrame(
    {&quot;entry&quot;: [False, True, True, False, False, True, False]}, index=dates
)
exits = pd.DataFrame(
    {&quot;exit&quot;: [False, False, False, False, True, False, True]}, index=dates
)

# concatenate the dataframes horizontally
df = pd.concat([price, entries, exits], axis=1)

# calculate the size column based on entries and exits
size = []
current_size = 0
for i in range(len(df)):
    if df[&quot;entry&quot;][i]:
        current_size = 1000 / df[&quot;price&quot;][i]
    elif df[&quot;exit&quot;][i]:
        current_size = -sum(size)
    elif not df[&quot;entry&quot;][i] and not df[&quot;exit&quot;][i]:
        current_size = 0
    size.append(current_size)

# add the size column to the dataframe
df[&quot;size&quot;] = size

# print the resulting dataframe
print(df)
</code></pre>
<pre><code class="language-python">from numba import njit
from vectorbt.portfolio import nb
from vectorbt.portfolio.enums import (
    SizeType,
    Direction,
    NoOrder,
    OrderStatus,
    OrderSide,
)


import numpy as np
import vectorbt as vbt
import pandas as pd
import warnings

warnings.simplefilter(&quot;ignore&quot;, UserWarning)


@njit
def pre_sim_func_nb(c):
    # We need to define stop price per column once
    stop_price = np.full(c.target_shape[1], np.nan, dtype=np.float_)
    return (stop_price,)


@njit
def order_func_nb(c, stop_price, entries, exits, size):
    # Select info related to this order
    entry_now = nb.get_elem_nb(c, entries)
    exit_now = nb.get_elem_nb(c, exits)
    size_now = nb.get_elem_nb(c, size)
    price_now = nb.get_elem_nb(c, c.close)
    stop_price_now = stop_price[c.col]

    # Our logic
    if entry_now:
        if c.position_now == 0:
            return nb.order_nb(
                size=size_now, price=price_now, direction=Direction.LongOnly
            )
    elif exit_now or price_now &gt;= stop_price_now:
        if c.position_now &gt; 0:
            return nb.order_nb(
                size=-size_now, price=price_now, direction=Direction.LongOnly
            )
    return NoOrder


@njit
def post_order_func_nb(c, stop_price, stop):
    # Same broadcasting as for size
    stop_now = nb.get_elem_nb(c, stop)

    if c.order_result.status == OrderStatus.Filled:
        if c.order_result.side == OrderSide.Buy:
            # Position entered: Set stop condition
            stop_price[c.col] = (1 + stop_now) * c.order_result.price
        else:
            # Position exited: Remove stop condition
            stop_price[c.col] = np.nan


def simulate(close, entries, exits, size, threshold):
    return vbt.Portfolio.from_order_func(
        close,
        order_func_nb,
        vbt.Rep(&quot;entries&quot;),
        vbt.Rep(&quot;exits&quot;),
        vbt.Rep(&quot;size&quot;),  # order_args
        pre_sim_func_nb=pre_sim_func_nb,
        post_order_func_nb=post_order_func_nb,
        post_order_args=(vbt.Rep(&quot;threshold&quot;),),
        broadcast_named_args=dict(  # broadcast against each other
            entries=entries, exits=exits, size=size, threshold=threshold
        ),
    )


if __name__ == &quot;__main__&quot;:
    close = pd.Series([10, 11, 12, 13, 14])
    entries = pd.Series([True, True, False, False, False])
    exits = pd.Series([False, False, False, True, True])
    pf = simulate(close, entries, exits, np.inf, 0.1)
    print(pf.orders.records_readable)
    print(pf.assets())
    print(pf.cash())
    print(pf.stats())

</code></pre>
<h2 id="使用-from_order_func-動態加碼"><a class="header" href="#使用-from_order_func-動態加碼">使用 from_order_func 動態加碼</a></h2>
<pre><code class="language-python">from numba import njit
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.portfolio import nb
from vectorbt.portfolio.enums import (
    SizeType,
    Direction,
    NoOrder,
    OrderStatus,
    OrderSide,
)


import yfinance as yf
import numpy as np
import vectorbt as vbt
import pandas as pd
import warnings

warnings.simplefilter(&quot;ignore&quot;, UserWarning)

# 下載股票價格數據
# symbols = [&quot;GOOG&quot;]
# raw_data = yf.download(symbols, start=&quot;2010-01-01&quot;, end=&quot;2023-03-09&quot;)
# close = raw_data.loc[:, &quot;Close&quot;]

# Buy 10 units each tick using closing price:
def test():
    @njit
    def order_func_nb(c, size):
        return nb.order_nb(size=size)

    close = pd.Series([1, 2, 3, 4, 5])
    pf = vbt.Portfolio.from_order_func(close, order_func_nb, 10, init_cash=100000,)
    print(pf.assets())
    print(pf.cash())
    print(pf.stats())


def from_order_function_test():
    @njit
    def order_func_nb(c, size, direction, fees):
        print(
            &quot;Close:&quot;,
            c.close[c.i, c.col],
            &quot;Size:&quot;,
            size[c.i],
            &quot;Direction:&quot;,
            direction[c.col],
            &quot;c.i:&quot;,
            c.i,
            &quot;c.col:&quot;,
            c.col,
            &quot;fees:&quot;,
            fees,
        )
        return nb.order_nb(
            price=c.close[c.i, c.col],
            size=size[c.i],
            direction=direction[c.col],
            fees=fees,
        )

    if True:
        # 加碼策略
        size = pd.Series([1, 1, -2, 1, -1])  # per row
        dates = pd.date_range(&quot;20220301&quot;, periods=5)
        price = pd.DataFrame(
            {&quot;a&quot;: [100, 200, 300, 400, 500], &quot;b&quot;: [500, 400, 300, 200, 100]},
            index=dates,
        )  # per element
    else:
        size = pd.Series([1, -1, 1, -1])  # per row
        dates = pd.date_range(&quot;20220301&quot;, periods=4)
        price = pd.DataFrame(
            {&quot;a&quot;: [100, 200, 300, 400], &quot;b&quot;: [400, 300, 200, 100]}, index=dates,
        )  # per element

    direction = [&quot;longonly&quot;, &quot;shortonly&quot;]  # per column
    fees = 0.01  # per frame
    direction_num = map_enum_fields(direction, Direction)
    pf = vbt.Portfolio.from_order_func(
        price,
        order_func_nb,
        np.asarray(size),
        np.asarray(direction_num),
        fees,
        init_cash=10000,
    )
    print(pf.orders.records_readable)
    print(pf.assets())
    print(pf.cash())
    print(pf.stats())


if __name__ == &quot;__main__&quot;:
    # Disable scientific notation
    pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x
    test()
    print(&quot;\n=================================================\n&quot;)
    from_order_function_test()
</code></pre>
<h2 id="vectotbt--example"><a class="header" href="#vectotbt--example">VectotBT  example</a></h2>
<pre><code class="language-py">from datetime import datetime
import vectorbt as vbt

interval = '4h'
cols = ['Open', 'High', 'Low', 'Close', 'Volume']
start_str = '360 days ago UTC'
end_str = f'{datetime.now()}'
#symbols = [&quot;BTCUSDT&quot;, &quot;ETHUSDT&quot;, &quot;LTCUSDT&quot;, &quot;BNBUSDT&quot;, &quot;XRPUSDT&quot;]
symbols = [&quot;BTCUSDT&quot;]
df = vbt.BinanceData.download(symbols,start=start_str,interval=interval).get(cols)
ma99 = vbt.MA.run(df[&quot;Close&quot;], 99, short_name=&quot;ma99&quot;)

entries = ma99.close_crossed_above(ma99.ma) 
exits = ma99.close_crossed_below(ma99.ma) 
pf = vbt.Portfolio.from_signals(df[&quot;Close&quot;], entries, exits)
print(pf.stats())
</code></pre>
<h1 id="python筆記--股票策略回測-by-vectorbt"><a class="header" href="#python筆記--股票策略回測-by-vectorbt">Python筆記 : 股票策略回測 by Vectorbt</a></h1>
<h2 id="大致介紹"><a class="header" href="#大致介紹">大致介紹</a></h2>
<p>vectorbt是一套拿來進行量化分析的套件，特別的點在於他有numpy的速度,以及pandas的方便性。
因此比起其他的回測套件，他擁有極佳的速度，可以在短時間之內分析大量的策略。其中，套到這個套件裡面的所有參數都可以進行向量化，允許我們同時對所有元素執行相同的操作。另外，也使用 Numba 解決了與向量化相關的路徑依賴問題。</p>
<p>這邊大部分使用的套件說明都可以在<a href="https://vectorbt.pro/api/">這裡</a>看到詳細說明。</p>
<h2 id="模組"><a class="header" href="#模組">模組</a></h2>
<pre><code class="language-python">import vectorbt as vbt 
# import plotly 可不用，因vectorbt有自帶視覺化套件
import datetime
import pandas as pd
import numpy as np
</code></pre>
<h2 id="時間設定以及視覺化分析資料的位置"><a class="header" href="#時間設定以及視覺化分析資料的位置">時間設定以及視覺化分析資料的位置</a></h2>
<pre><code class="language-python">filename='某個位置路徑'
end_date=datetime.datetime.now()
start_date=end_date - datetime.timedelta(days=3) #限制在3天之內
</code></pre>
<p>這邊設3天是因為等等要抓取的時間單位為一分鐘，故三天已經夠長了。</p>
<h2 id="data-import"><a class="header" href="#data-import">Data Import</a></h2>
<pre><code class="language-python">btc_price = vbt.YFData.download('BTC-USD',  
                                #['BTC-USD','ETH-USD'], 可以用列表同時import多重的data
                                interval='1m',  #改變時間的單位
                                start = start_date,
                                end=end_date,
                                missing_idnex='drop').get('Close') 
</code></pre>
<p>vectorbt會自動抓取yfinace的api，只要yfinance有的，都可以抓的到。
標的可以分為:</p>
<table><thead><tr><th style="text-align: left">臺股</th><th style="text-align: left">美股</th><th style="text-align: left">加密貨幣</th></tr></thead><tbody>
<tr><td style="text-align: left">Ex : <a href="http://2330.tw/">2330.TW</a></td><td style="text-align: left">Ex : TSLA</td><td style="text-align: left">Ex : BTC-USD</td></tr>
</tbody></table>
<h2 id="交易策略"><a class="header" href="#交易策略">交易策略</a></h2>
<p>這裡使用的交易策略相當簡單，因為主要目的是為了熟悉vectorbt的使用。</p>
<table><thead><tr><th style="text-align: left">情況</th><th style="text-align: left">操作</th></tr></thead><tbody>
<tr><td style="text-align: left">rsi&gt;設定的高標</td><td style="text-align: left">賣出</td></tr>
<tr><td style="text-align: left">rsi&lt;設定的低標 且 最近的收盤價低於ma</td><td style="text-align: left">買入</td></tr>
</tbody></table>
<p>當rsi大於我們設定的高標，代表目前股市可能進入過熱的壯臺，則我們可以選擇在這時候進行賣出的操作。當相反情況出現，rsi低於我們設定的低標的話，而且這時候的收盤價低於ma線，表示這時候或許是一個很好的入場點，則我們可以在這時候進行買入的操作。(這邊都是極度簡單的操作，要是這樣就可以穩穩贏過大盤就太感謝了…)</p>
<h2 id="客製化訊號以及策略"><a class="header" href="#客製化訊號以及策略">客製化訊號以及策略</a></h2>
<p>這邊主要可以分成三個區塊，分別為:</p>
<ol>
<li>Define一個函數，裡面主要用來計算出是否可以進入市場的訊號 -&gt; 1及-1。</li>
<li>算是一個用來做出策略的食譜，裡面放著等等產出的資料變數名稱以及一些默認變數。</li>
<li>實際執行策略，裡麵包含一些變數的範圍。</li>
</ol>
<h3 id="1-define-a-function"><a class="header" href="#1-define-a-function">1. Define a function</a></h3>
<pre><code class="language-python">def custom_indicator(close,               #每當在這邊增加一個參數，就要在第二步驟的ind裡面的param_names裡面增加
                     rsi_window = 14,
                     ma_window = 50,
                     entry=30,
                     exits=70
                     ):    
    close_5m = close.resample('5T').last() #將資料型態從1min變成5min
    rsi = vbt.RSI.run(close_5m, window = rsi_window).rsi  #rsi中的rsi值(因為在這裡的前面rsi出來的不會只有單純的rsi)
    rsi, _ =rsi.align(close,    #將5min的資料重新展開成1min
                     broadcast_axis=0,
                     method='ffill',  #並將空值以第5分鐘的copy塞進去
                     join='right'  #rsi是right table，close是left table
                     ) #by doing so, rsi跟close有same shape，只是rsi是5min的資料，close是1分鐘的資料
    close = close.to_numpy()
    rsi = rsi.to_numpy()
    ma = vbt.MA.run(close, window = ma_window).ma.to_numpy()
    trend = np.where(rsi &gt; exits, -1, 0) #要是rsi&gt;70，則賣出(-1)，否則甚麼都不做(0)
    trend = np.where((rsi &lt; entry)&amp;(close &lt; ma),  1, trend)  #要是rsi&lt;30而且收盤價&lt;ma，則買入(1)，如果沒有的話就按照原本的trend
    return trend
</code></pre>
<h3 id="2-策略的食譜"><a class="header" href="#2-策略的食譜">2. 策略的食譜</a></h3>
<pre><code class="language-python">ind = vbt.IndicatorFactory(   
    class_name = 'Combination',
    short_name = 'comb', 
    input_names=['close'], #輸入的parameter的名字
    #param_names=['window'], #hyper parameter的名字，也可用列表呈現
    param_names=['rsi_window','ma_window','entry','exits'],
    output_names=['value']  #output出來的名字
    ).from_apply_func(   #提供一些默認值給recipe，就是上面define的function裡面的parameter
        custom_indicator,
        rsi_window=14,
        ma_window=50,
        entry=70,
        exits=30,
        keep_pd=True #保持資料型態為pandas，避免變成numpy arrays
        )
</code></pre>
<h3 id="3-實際執行策略"><a class="header" href="#3-實際執行策略">3. 實際執行策略</a></h3>
<pre><code class="language-python">res = ind.run(  #run 一個策略
    btc_price,
    #rsi_window = [14,35,21], #給定特定值
    rsi_window = np.arange(10,40,step=3,dtype=int), #給定一個範圍
    #ma_window = [21,50,100],
    ma_window = np.arange(20,200,step=15,dtype=int),
    #entry=[30,40],
    entry = np.arange(10,40,step=4,dtype=int),
    #exits=[60,70],
    exits = np.arange(60,85,step=4,dtype=int),
    param_product=True) #如果沒有這個的話，只會按照list的順序，並不會兩兩配對
</code></pre>
<p>這邊有兩種險方式來定義變數，一個是給定特定值的list，Ex:[14,35,21]，表示將rsi_window分別設定為14、35、21，代表只會嘗試這三個數值。另一種方式則是使用np.arange，將在這個range的數值全部帶進去進行計算，進而求出每一種狀況下的獲利。</p>
<h3 id="執行結果"><a class="header" href="#執行結果">執行結果</a></h3>
<pre><code>print(res.value)
</code></pre>
<p>output:</p>
<pre><code class="language-python">comb_rsi_window                10                  ...      37                
comb_ma_window                20                   ...     185                
comb_entry                     10                  ...      38                
comb_exits                     60              64  ...      80      84        
symbol                    BTC-USD ETH-USD BTC-USD  ... ETH-USD BTC-USD ETH-USD
Datetime                                           ...                        
2022-08-11 03:07:00+00:00       0       0       0  ...       0       0       0
2022-08-11 03:09:00+00:00       0       0       0  ...       0       0       0
2022-08-11 03:11:00+00:00       0       0       0  ...       0       0       0
2022-08-11 03:13:00+00:00       0       0       0  ...       0       0       0
2022-08-11 03:15:00+00:00       0       0       0  ...       0       0       0
                          ...     ...     ...  ...     ...     ...     ...
2022-08-14 03:00:00+00:00       0       0       0  ...       0       0       0
2022-08-14 03:01:00+00:00       0       0       0  ...       0       0       0
2022-08-14 03:02:00+00:00       0       0       0  ...       0       0       0
2022-08-14 03:03:00+00:00       0       0       0  ...       0       0       0
2022-08-14 03:04:00+00:00       0       0       0  ...       0       0       0

[3690 rows x 13440 columns]
</code></pre>
<p>如果將結果攤開來看，會呈現</p>
<p><img src="strategy/images/cffT5wr.png" alt="img" /></p>
<p>以及</p>
<p><img src="strategy/images/BATll7T.png" alt="img" /></p>
<p>代表著我們進出場的訊號。</p>
<h2 id="將訊號帶入策略執行"><a class="header" href="#將訊號帶入策略執行">將訊號帶入策略執行</a></h2>
<p>這時我們將剛剛得到的res進行處裡，其中1設定為entries，-1設定為exits。</p>
<pre><code>entries = res.value == 1
exits = res.value == -1
</code></pre>
<p>實際執行</p>
<pre><code>pf = vbt.Portfolio.from_signals(btc_price, entries, exits)
</code></pre>
<p>試著看看執行結果</p>
<pre><code>print(pf.stats().to_string()) #to_string()可以將全部結果攤開
</code></pre>
<p>會得到:</p>
<pre><code>Output from spyder call 'get_namespace_view':
Start                         2022-08-11 03:07:00+00:00
End                           2022-08-14 03:04:00+00:00
Period                                             3690
Start Value                                       100.0
End Value                                    100.179789
Total Return [%]                               0.179789
Benchmark Return [%]                           3.590516
Max Gross Exposure [%]                        83.020833
Total Fees Paid                                     0.0
Max Drawdown [%]                               2.078304
Max Drawdown Duration                       2193.187668
Total Trades                                    4.26994
Total Closed Trades                            3.966369
Total Open Trades                              0.303571
Open Trade PnL                                 0.076599
Win Rate [%]                                  63.829362
Best Trade [%]                                 0.680632
Worst Trade [%]                                -0.39365
Avg Winning Trade [%]                          0.607418
Avg Losing Trade [%]                            -0.6351
Avg Winning Trade Duration                   260.345941
Avg Losing Trade Duration                    445.916595
Profit Factor                                       inf
Expectancy                                     0.202725
</code></pre>
<p>執行此段程式碼則可以獲得所有變數組合的報酬</p>
<pre><code>print(pf.total_return().to_string())
</code></pre>
<p>只擷取其中一小段</p>
<pre><code>                 170             10          60          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             64          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             68          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             72          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             76          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             80          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             84          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                 14          60          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             64          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             68          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             72          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             76          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             80          BTC-USD    0.000000
                                                         ETH-USD    0.000000
                                             84          BTC-USD    0.000000
                                                         ETH-USD    0.000000
</code></pre>
<p>只抽取此策略的報酬率</p>
<pre><code>returns = pf.total_return()
print(returns.max()) #最大的報酬率
print(returns.idxmax()) #最大的組合
print(returns.to_string()) #所有組合
</code></pre>
<p>可以得到</p>
<pre><code>0.06338762101981515 
(37, 20, 30, 84, 'ETH-USD') #分別代表rsi_window, ma_window, entry, exits 
</code></pre>
<h2 id="資料視覺化"><a class="header" href="#資料視覺化">資料視覺化</a></h2>
<p>vectorbt套件中有附兩種資料視覺化的模式，分別為:</p>
<ol>
<li>Heatmap</li>
<li>Volume</li>
</ol>
<h3 id="heatmap"><a class="header" href="#heatmap">Heatmap</a></h3>
<pre><code>fig = returns.vbt.heatmap(
    x_level = 'comb_rsi_window',
    #y_level = 'comb_ma_window',
    y_level = 'comb_entry',
    slider_level = 'symbol' #如果同時分析不同標的，則可以透過slider切換
    )
fig.write_html(filename,auto_open=True)#圖片儲存並自動展開
</code></pre>
<p><img src="strategy/images/A3dTzS8.png" alt="img" /></p>
<h3 id="volume-1"><a class="header" href="#volume-1">Volume</a></h3>
<p>將資料以3d的樣式呈現，可同時比較多個變數。</p>
<pre><code>fig = returns.vbt.volume(
    x_level = 'comb_exits',
    y_level = 'comb_ma_window',
    z_level = 'comb_entry',
    slider_level = 'symbol'
    )
fig.write_html(filename,auto_open=True)#圖片儲存並自動展開
</code></pre>
<p><img src="strategy/images/RN85DH1.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="量化交易學習-訂單簿建模"><a class="header" href="#量化交易學習-訂單簿建模">量化交易學習-訂單簿建模</a></h2>
<p>出處:https://zhuanlan.zhihu.com/p/499342831</p>
<h2 id="相關資料蒐集"><a class="header" href="#相關資料蒐集">相關資料蒐集：</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/37825746">Quant最愛：【HFT系列】基於機器學習的動態高頻限價訂單簿框架（Tick資料）</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.sysengi.com/CN/10.12011/1000-6788(2018)01-0016-19">Optimal high-frequency market making strategy research based on limit order book</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/timothyyu/gdax-orderbook-ml">https://github.com/timothyyu/gdax-orderbook-ml</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/oxuzhenyi/article/details/77586465">R語言對高頻交易訂單流進行建模分析 3</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/oxuzhenyi/article/details/77586479">R語言對高頻交易訂單流進行建模分析 4</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/417149085">Quant最愛：重構訂單簿！基於深度學習的A股Tick級價格變動預測</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/335257490">數量技術宅：股指期貨高頻資料機器學習預測</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/417118422">張楚珩：【強化學習 187】Order Book Trading + RL</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22335838">陳穎：基於高頻limit order book資料的短程價格方向預測——via multi-class SVM</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24910472">文兄：【量化策略】基於Level 2高頻資料的機器學習預測研究</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20116878">Haitian Wei：orderbook模型論文筆記</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.doc88.com/p-95329032997779.html">基於深度學習的股票限價訂單簿中間價格預測研究</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//xueqiu.com/8188497048/198528860">基於Order Book的簡單特徵：以Optiver競賽為例</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/N12GzvYCOpcqDlkaei5moA">基於Order Book的深度學習模型：預測多時間段收益序列</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//towardsdatascience.com/price-impact-of-order-book-imbalance-in-cryptocurrency-markets-bf39695246f6">https://towardsdatascience.com/price-impact-of-order-book-imbalance-in-cryptocurrency-markets-bf39695246f6</a></p>
<p>相關的論文可是老多了，挑幾個：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1901.10534v1">Investigating Limit Order Book Characteristics for Short Term Price Prediction: a Machine Learning Approach</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2007.07319">https://arxiv.org/abs/2007.07319</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1808.03668v6">DeepLOB: Deep Convolutional Neural Networks for Limit Order Books</a></p>
<h2 id="一張圖解釋訂單簿"><a class="header" href="#一張圖解釋訂單簿">一張圖解釋訂單簿：</a></h2>
<p><img src="strategy/images/v2-227be12d17aa821f17f11d529a0844de_720w.webp" alt="img" /></p>
<h2 id="可能能用的特徵"><a class="header" href="#可能能用的特徵">可能能用的特徵：</a></h2>
<ol>
<li>基本：K線、交易量、大單交易量、趨勢指標等。</li>
<li>訂單簿快照資料，價格、數量、訂單數量、訂單持續時間</li>
<li>買單賣單跨度，買單賣單均值</li>
<li>加權平均價格</li>
<li>訂單價格差，累計加權價格差</li>
<li>買賣訂單密度，分佈刻畫。泊松分佈建模</li>
<li>訂單分佈的變化，變化速率</li>
<li>時間相關：每檔變化量，變化率，買賣檔位的變化差異。一段時間的新增限價單、市價單、取消單的總量，當前時段相對歷史的比例，總量變化率。對數收益率</li>
</ol>
<h2 id="模型目標"><a class="header" href="#模型目標">模型目標：</a></h2>
<ol>
<li>趨勢分類：一段時間後的價格變化，分類模型</li>
<li>做市商演算法：AS模型的保留價格與最優差價</li>
</ol>
<h2 id="問題"><a class="header" href="#問題">問題：</a></h2>
<ol>
<li>模型低訊號雜訊比，如何進行設計</li>
<li>間隔時間的參數調優，論文說2horizon最好。標的物的流動性建模。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-個步驟設定選股條件股票爆發力更上一層樓"><a class="header" href="#5-個步驟設定選股條件股票爆發力更上一層樓">5 個步驟設定選股條件，股票爆發力更上一層樓！</a></h1>
<p>出處：https://www.finlab.tw/5-%e5%80%8b%e6%ad%a5%e9%a9%9f%e8%a8%ad%e5%ae%9a%e9%81%b8%e8%82%a1%e6%a2%9d%e4%bb%b6%ef%bc%8c%e8%82%a1%e7%a5%a8%e7%88%86%e7%99%bc%e5%8a%9b%e6%9b%b4%e4%b8%8a%e4%b8%80%e5%b1%a4%e6%a8%93%ef%bc%81/</p>
<blockquote>
<p>策略公開，大部分都會無效化，唯有自己打造，永不失效</p>
</blockquote>
<p>我們在<a href="https://ai.finlab.tw/strategies">新的選股平臺中，分享了一堆策略</a>，但是這些是公開的策略，大家都看得到，所以難保之後不會失效。所以唯有打造自己的策略，你才更有底氣，在股票市場中生存！</p>
<p>設計股票策略，對剛開始進入股市，或是剛使用選股系統的人來說，並不簡單。我有看過初學者，花很多精力，直接爆寫長達 100 行程式碼選股，用了超多條件，但效果還是不太好。所以決定分享一個 SOP，只要遵照以下幾個步驟，通常都可以找到不錯的策略，量化交易不難，而設計策略其實可以很單純。</p>
<p><strong>內容目錄</strong> <a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#">隱藏</a> </p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#1_xun_zhao_yin_zi">1 1. 尋找因子</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#2_pan_ding_xiao_guo">2 2. 判定效果</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#3_jue_ding_shi_fou_qi_yong_yin_zi">3 3. 決定是否棄用因子</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#4_shai_xuan_tiao_jian">4 4. 篩選條件</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#5_zhong_fu_14_bu_zhou">5 5. 重複 1~4 步驟</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#jin_jie_fei_xian_xing">6 進階：非線性</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#jin_jieN_jie_yin_zi">7 進階：N 階因子</a></p>
<p><a href="https://www.finlab.tw/5-%E5%80%8B%E6%AD%A5%E9%A9%9F%E8%A8%AD%E5%AE%9A%E9%81%B8%E8%82%A1%E6%A2%9D%E4%BB%B6%EF%BC%8C%E8%82%A1%E7%A5%A8%E7%88%86%E7%99%BC%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%A4%E6%A8%93%EF%BC%81/#zong_jie">8 總結</a></p>
<h2 id="1-尋找因子"><a class="header" href="#1-尋找因子">1. 尋找因子</a></h2>
<p>這邊說的因子，也不是什麼特別的東西，而是日常所使用的一些指標，可以是「股東權益報酬率」或是「RSI」指標，不論是技術面或是基本面，只要是可以量化的數值，都可以拿來當作因子。可以到我們的<a href="https://ai.finlab.tw/database">資料庫搜索</a>看看，是否有你感興趣的資料。我們提供了大部分股票的資料，除了分點券商外（太貴還沒買），你想的到的因子都可以製作。目前（2021/11/21）完全免費，你可以趁這個時機全部下載下來試試看。</p>
<h2 id="2-判定效果"><a class="header" href="#2-判定效果">2. 判定效果</a></h2>
<p>找到了想選股的資料，我們要先確定因子是否有效果，你要設計一個條件式，來測試單一因子是否有選股的效果。以「股東權益報酬率」來說明，我會設計從寬鬆到嚴苛，撰寫選股條件，範例如下：</p>
<pre><code class="language-python">from finlab import data
roe = data.get('fundamental_features:ROE稅後')

roe_rank = roe.rank(axis=1, pct=True)
stocks1 = roe_rank &gt; 0.2 # 寬鬆，選擇前 80% 的股票
stocks2 = roe_rank &gt; 0.4
stocks3 = roe_rank &gt; 0.6
stocks4 = roe_rank &gt; 0.8 # 嚴苛，選擇前 20% 的股票
</code></pre>
<p>我會將上述四個條件都試試，回測總報酬率或是夏普值，以程式碼中的 stocks4 為範例：</p>
<pre><code class="language-python">from finlab import backtest

report = backtest.sim(stocks4, resample=&quot;Q&quot;, fee_ratio=0, tax_ratio=0))
</code></pre>
<p>這邊的換股頻率是「每季 (Q)」，因為「股東權益報酬率」是每個季度會公佈，所以我們只關注每季價格的變化，但假如你的指標是價格，則可以使用其他的頻率，例如「每週 (W)」或是「每月 (M)」。有些人製作因子，也會用「近四季平均或累計」來表示，並且以「每年 (A)」為單位換股，這樣也是可以的。假如上述回測有長期打贏大盤，那可以說，這個因子可能是有用的！</p>
<p>但很多人看回測看的是「報酬率累計是否比大盤高」，這是不正確的做法，一個極端的例子就是，當一個策略報酬率如下：</p>
<ul>
<li>第一天比大盤多 3%</li>
<li>之後每一天都跟大盤的報酬率一模一樣。</li>
</ul>
<p>這樣此策略的「報酬率累加」永遠都比大盤的高，但實際交易並沒有顯著的效果。所以平常除了看 alpha beta sharpe 之外，也可以目測「報酬率累計跟大盤差距越來越大」，假如有的話，才代表此因子時時刻刻都在發揮作用。</p>
<h2 id="3-決定是否棄用因子"><a class="header" href="#3-決定是否棄用因子">3. 決定是否棄用因子</a></h2>
<p>假如你發現此因子沒有任何作用（回測都比大盤爛），請你先直接棄用，而不是加入其他的因子。有點像是蓋大樓，假如地基沒有打穩，地震就會垮。你要設想 2000 檔股票裡面，其實只有幾檔是寶，假如今天用了差勁的因子不小心過濾移除了，錯過挑選它的好機會，有可能只選出一些烏合之眾，就算再用好的濾網，也選不出好股票。所以請直接將此因子移除吧！</p>
<h2 id="4-篩選條件"><a class="header" href="#4-篩選條件">4. 篩選條件</a></h2>
<p>當做完上述檢測，你發現這個因子真的有用！就可以開始針對因子設定條件，你可以將第二步驟已經回測的數據拿出來，例如總報酬率如下（示意）：</p>
<ol>
<li>篩選出前 80％ 的股票：總報酬 300%</li>
<li>篩選出前 60% 的股票：總報酬 500%</li>
<li>篩選出前 40％ 的股票：總報酬 700%</li>
<li>篩選出前 20% 的股票：總報酬 700%</li>
</ol>
<p>以上四種條件，從寬鬆到嚴格，你會使用哪一個條件呢？要記住我們的目的在於「總體報酬率高」及「有效分散風險」，前者當然是為了賺錢，而後者是為了「少賠錢」。有了以上得目的，相信你不難選出第三個：「篩選出前 40％ 的股票」當作是最佳的條件了。你會發現 3 跟 4 篩選出的股票數量不同，但是報酬率都差不多，在同樣的報酬率下，越多股票對你越有利，除了分散風險外的好處，由於樣本數多，也不太會過擬合。還有額外的好處是：你保留足夠多的股票，可以再加入其他的因子來篩選出更有上漲潛力的股票。</p>
<h2 id="5-重複-14-步驟"><a class="header" href="#5-重複-14-步驟">5. 重複 1~4 步驟</a></h2>
<p>假如你留有足夠多的股票，這時候就可以再加入因子，看看是否能提升報酬率。有些因子之間會有加成效果，而有些則沒有。你甚至可以調整因子篩選的順序，不過會建議主要的因子不要再改順序了，除非你想做一個完全不同的策略。至於到底有多少因子才夠呢？其實並不一定，但最終目的是篩選出 20～30 檔股票以內，畢竟太多股票對一般人來說也是很難一次買齊。</p>
<p>選擇較少股票，這其實是一件不容易的事情，因為股票少，整體投資組合勢必波動變大。因此在股票少的狀況下，必須確保策略報酬波動小，就是這個階段的關鍵。</p>
<p>新因子額外篩選股票，程式的寫法，如下：</p>
<pre><code class="language-python">stocks4 = (stocks4 * new_factor).is_largest(30)
</code></pre>
<p>其中 stocks4 就是原本篩選出來的股票，數值為 0 (False) 或 1 (True) 代表是否被選入，而 new_factor 就是新因子，這樣就可以用新的因子篩選出前 30 名的股票，這邊的 new_factor 是大於零，且越大越好。假如所有股票的 new_factor 同時有正負，要記得加上一個 threshold，讓 new_factor + th 的數值一定為正：</p>
<pre><code class="language-python">stocks1 = (stocks1 * (new_factor + th)).is_largest(10)
</code></pre>
<p>組合好就可以將篩選完的股票進行回測囉！</p>
<pre><code class="language-python">backtest.sim(stocks1, resample='Q')
</code></pre>
<p>以下還有一些複雜的方法，但是個人覺得用以上的方法找好策略已經綽綽有餘，除非你每一種因子都已經玩很無聊，那以下比較進階的方法就適合你：</p>
<h2 id="進階非線性"><a class="header" href="#進階非線性">進階：非線性</a></h2>
<p>這個世界並不是線性的，以上述的範例「股東權益報酬率」來說，我們只是假設其數值越高越好，將因子與績效之間的關係假想成是線性。但現實生活中，報酬率與因子之間可能是非線性的，例如「股東權益報酬率」太高，有可能會有均值回歸的狀況發生，使未來股票走勢不好。假如希望可以做的更精細，可以在上述第四步驟中，再額外調整篩選股票的區間段，例如將股票依照因子大小分成五份來回測。</p>
<h2 id="進階n-階因子"><a class="header" href="#進階n-階因子">進階：N 階因子</a></h2>
<p>另外，上述步驟中，是假設因子之間並沒有關連，但事實上它們之間會交互作用，例如你單純買「投信買進」的股票可能沒什麼用，但是假如你買「股價暴跌投信還買進」的股票，可能就有用。可以在上述第四步驟中，再額外加入這種反向因子，但是條件越多就會越複雜，要盡量避免過於複雜而導致過擬合喔！</p>
<h2 id="總結-11"><a class="header" href="#總結-11">總結</a></h2>
<p>選股策略千百種，上述方法是我覺得一定可以產生出好策略的 SOP，但關鍵在於，不要盲目加入一堆條件，把好的股票都篩掉了！要慎選因子。現在就開始使用我們免費公開的超好用回測系統來選股吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="順大逆小交易哪種回調入場點勝率最高"><a class="header" href="#順大逆小交易哪種回調入場點勝率最高">順大逆小交易，哪種回調入場點勝率最高？</a></h2>
<p>https://www.zhihu.com/question/309137888</p>
<p>入場方式
1.左側交易，提前預測進場點位最好，試錯率最高，
2突破進場，點位次之，試錯率比第一種低，
3突破回調進場，可能回調，也可能不回調，每人知道回調那個位置，試錯率最低，點位最差。</p>
<p>你要最高勝率就順大逆小，順大週期，逆次級週期建倉</p>
<hr />
<p>勝率這東西本身就挺扯的其實，同等賠率下，單個的任意開倉訊號樣本越多越接近50%，只不過在某一時間段，根據行情波動節奏的不同會產生偏離，今年行情走的比較迎合這個訊號，那他可能勝率能達6成以上，明年行情進入不應期，勝率可能只有4成不到，當然 賠率越高 勝率的均值就越小。</p>
<p>同樣的，遇到支撐或者阻力 能有反應是常態，直接過去了沒反應是強，到不了是弱。只要它有反應，大機率是會產生開倉訊號的，但此時起的這波屬於反彈還是反轉，短期是否會有反覆，你事前終究無法預知，只能走一步看一步。</p>
<p>勝率的提高得靠綜合性主觀判斷來提高，任何機械性的簡單行為絕對無法把控勝率。它是事後統計的結果，你無法事前設定勝率，你只能事前設定賠率。（除非你本身就能決定價格或影響價格）</p>
<p>若你要執著勝率，多數時候是吃不到大行情的，行情初期有持續反覆是常態，為了勝率你通常不能承受浮盈回撤，只能提前處理單子 微利止盈或平保，只有少數極強的流暢行情才是你的主營菜。這雖也是一條路，但對心性和能力的要求更高。</p>
<p>若一定要給幾條提勝率的術法的話可以看下我之前寫過的專欄，根據多週期空間位置力量的全域評估來做單。早期寫的比較粗糙，只能算部分指導方針，但大致思路已呈現，懶得重新打字了。其實一個機會是否值得參與 進去後在看哪個週期能拿多久 都得依靠空間位置力量的大局觀，而何時開倉何時退出最重要的是靠對力量的理解。若要簡單粗暴的方法的話，順大逆小中 放大初期止損遠比研究開倉訊號本身來的有效，只要主勢不變 你就無需止損。而在短線中最簡單粗暴的就是降低賠率 再加單子的提前處理了，比如幽靈的時間止損等等，短線只追求流暢強勢行情，多角度凡見弱必出。</p>
<hr />
<p>題主應該是新手，對於新手來說盡量從大週期開始做，這樣你做回調成功率比較高，如果你直接從小週期做回調，會被經常打止損，能從小週期養到大週期的單子很少，就算養大了，你的止損成本也很高了，可是性價比不高。小週期確實有節奏，但操作之前是需要嚴格選擇的，不是什麼行情都做的，很多人覺得既然是短線，那麼我就增加交易機會來彌補短線利潤不足的問題，然後就開始標準模糊化，看見跟標準相似的機會就做，最後就以頻繁打損結束。你可能會說，頻繁止損肯定是止損設置錯誤導致的，這種說法有一定道理，但是首先主要問題還是機會選擇的問題，好的機會是不會隨便打損的，不好的機會就會頻繁打損，你可以看看自己的歷史訂單，看看盈利的單子是不是很少會出現測試自己止損的現象，就算測試也是很少的次數，而不好的機會，會頻繁測試你的止損位。當然了，中長線的操作方式又不一樣，因為你有一個長期的目標，所以為了這個目標你肯定會被小幅度的多次止損，但不是頻繁止損，只要拿到了就是一條大魚，中長線以後再說。</p>
<p>日內這種就屬於小週期，你的目標不是切節奏，而是看壓力支撐，到位置就跑，或者有利潤就跑，因為你本身就是日內，所以你就不要想的太遠，吃碗裡就不要看鍋裡，喜歡YY是人的本性。</p>
<p>這樣操作之後，熟練了日內確實能賺錢，但是你會發現自己非常累，你不可能什麼也不幹，就天天盯著行情看，你還要生活和工作呢。</p>
<p>所以儘量選擇中長線，這樣自己也有時間來思考，等技術成熟了之後，再玩玩短線，看看自己是否適合。</p>
<div style="break-before: page; page-break-before: always;"></div><p>　俗話說得好，會買股票是徒弟，會賣股票才是師傅。飆股人人都買過，但真正賺到大錢的百不得一。  by <a href="https://www.facebook.com/groups/ssd9971/">奇正2</a></p>
<p><strong>多重出場點：單純性與多個出場點</strong>　　</p>
<p>交易系統設計應該採用單純的概念。我們之所以強調單純性，因為這代表相關系統是建構在「瞭解」的基礎上，而不是最佳化。　　單純的概念可以引用到許多不同市場與不同交易工具。我們雖然強調單純，但交易系統仍然可以設定多個出場點。這是兩個不相互衝突的概念，單純性是交易系統之能夠有效的必要條件，多重出場點則是滿足交易目標的必要條件。出場點雖然有很多個，但每個出場點都可以源自簡單的概念。</p>
<p>讓我們看個例子。假定我們想使用順勢系統，而且希望留在市場久一點。我們不相信神奇的進場訊號，所以要留給部位較大的迴旋空間。另外，萬一出現重大不利走勢，系統必須保障資本，部位必須認賠。最後，由於起始停損相當寬鬆，我們將儘可能獲取較大的利潤，當獲利達到4R時，停止點將設定得更緊密一些。因此，我們要根據這些信念，設計一套適用的交易系統。這個例子顯示一項重要觀念:交易系統設計上必須符合個人信念。這也是交易系統設計的秘訣之一。　　</p>
<p>首先，進場點的起始停損必須相當寬鬆，提供充分的迴旋空間，不至於造成訊號反覆而增添交易成本。我們決定採用前文提到的辦法：3倍的價格波動。這是最糟狀況的停損，但也是後續的追蹤型停止點，因為每天收盤價如果朝有利方向變動，我們將依此重新設定停止點。　　</p>
<p>其次，我們相信，如果市場出現強勁的反向走勢，就應該結束部位。所以，我們決定，只要任何一天的價格反向走勢超過每天價格波動的2倍(由前一天收盤價起算)，就結束部位。這個停止點與前一段的停止點是並存的。　　</p>
<p>最後，獲利一旦到達4R，將採用緊密的停止點，避免吐回太多帳面獲利。所以，獲利到達4R之後，停止點將設定為平均真實區間的1．6倍(不是原來的3倍)：從此之後，這也是唯一的停止點。　　請注意，這些停止設定都很單純，清楚反映我們所想要的目的。沒有經過歷史測試，所以沒有最佳化的問題。完全沒有涉及火箭科學，所以很簡單。總共有3種停止點，但任何時刻都只有一個停止點真正有效，也就是最接近當時市場價格者。(摘自「交易‧創造自己的聖盃」/ 凡‧沙普)</p>
<p><strong>我的多重出場點</strong>　　</p>
<ol>
<li>初始停損點：小於10%。　　</li>
<li>特殊出場點：如果跌破重要支撐。　　</li>
<li>追蹤型停止點：從高點(收盤)回落15%～30%則出場。　　</li>
<li>緊密停利點：獲利一旦到達30%～100%，則採用緊密停止點－－跌破ma5或ma20(不下移)*0.96。　　</li>
<li><strong>彈性原則：浩劫餘生與太空漫步，採取的策略當然有所不同。所以設計有一般波段模式與股災模式。</strong></li>
</ol>
<p><strong>波段模式</strong>　　</p>
<ol>
<li>初始停損點為最大虧損 <strong>10%</strong>，越小越好但不能太小。　　</li>
<li>由最高點回落 <strong>20%</strong>。　　</li>
<li>不要求在期限內要漲多少。　　</li>
<li>漲幅達到 <strong>30%</strong> ，改用 max(ma20)*0.96 為浮動停利點。</li>
</ol>
<p><strong>股災模式</strong>　　</p>
<ol>
<li>初始停損點為最大虧損 <strong>10%</strong>。　　</li>
<li>由最高點回落 <strong>30%</strong>。　　</li>
<li>不要求在期限內要漲多少。　　</li>
<li>漲幅達到 <strong>100%</strong> ，改用 max(ma20)*0.96 為浮動停利點。　</li>
</ol>
<p><strong>虧損不超過10%</strong>　　</p>
<p>「...限制虧損之後，雖然有些轉敗為勝的成功交易消失了，但這方面的不利影響，遠低於迅速認賠的有利影響。根據這項虛擬測試，整個投資組合的績效改善程度，實在顯著到到令人難以置信。我重複驗證相關的計算程序，數據都是正確的。我的投資組合表現，從原來的兩位數字虧損，變成了獲利超過百分之七十。」(摘自「超級績效－－投資冠軍的操盤思維」/ Mark Minervini)</p>
<p><strong>特殊出場點</strong>　　</p>
<p>一般情形下原則上虧損不超過10%，但你可以設定的更緊密一點，然而你永遠無法逃過主力裝死、蹲伏、甩轎、洗盤的磨難，所以必須有所瞭解與對策。</p>
<p><strong>交易儘量接近危險點</strong>　　「...真正優秀的交易者，他知道如何判斷正常的價格拉回整理，以及具有危險的價格行為，他們會把停損設定在正常回檔即將演變為危險走勢的關鍵位置，然後讓交易進場價位儘量接近危險點。...」(摘自「超級績效2」)</p>
<p><strong>蹲伏與反轉復甦</strong>　　「...交易者建立部位之後，皆希望看到股票呈現應有的「行為」，但我們也想避免在不必要的情況下扼殺交易機會。行情沒有立即發動，並不代表相關交易就是失敗。...進場建立部位之後，不妨讓股票保有一、兩個禮拜的時間可以正常波動當然必須維持在停損範圍內。股票如果出線蹲伏情況，不必覺得恐慌，,只要停損沒有被引發，沒有出現主要違例現象，不妨等待看看股票是否會發生反轉復甦走勢。」(摘自「超級績效2」)</p>
<p><strong>重新進場</strong>　　「某些股票可能呈現理想的架構，吸引買盤進場，但走勢很快進行修正或急遽拉回，引發部位的起始停損。這種情況之所以發生，通常是因為大盤走勢轉弱或劇烈波動。一般來說，股票的基本面條件如果優異，價格向下修正或拉回之後，通常會再出現新的買點。這種新的買進架構往往較先前的買進架構更為優異，因為籌碼得到更一進一步的清洗。　　</p>
<p>部位的起始停損遭到引發之後，不能預期該股票絕對會再出現買進架構；換言之，起始停損一旦遭到引發，就必須停損出場。反之，部位遭到停損之後，並不能排除相關股票再度成為買進對象的可能性；只要該股票滿足了所有買進條件，就可以重新進場建立部位，雖然時機可能相對落後。請注意，真正的重大獲利機會，經常是在重新進場兩、三次才得以掌握。可是，這點往往也是區別真正專業玩家的分野。業餘玩家可能被停損一、兩次之後，就不會考慮再進場，但專業玩家則永遠保持客觀立場，他們只考慮進場條件是否滿足，把每個潛在機會都視為全新投資進行評估。」(摘自「超級績效2」)　　</p>
<p>頂尖交易員喬治．席格(George Segal)說：「我相信你想知道，我是如何得知應該何時進場的？在我真正建立部位前可能已出場二、三次(停損出場)；有時我可以一次便成功地建立部位。但通常需要嘗試數次後，我才會覺得對盤。我願意隨情況的需要不斷試盤，這是一種獨特的觀念；多數人在市場中挫敗，因為他們只做一兩次的嘗試，往往在節骨眼上放棄。而我是不斷地回頭嘗試，不斷地敲著大門，直到大口敞開為止。」</p>
<p><strong>為什麼不用其他出場法?</strong>　　</p>
<p>　以臺積電為例，本文比較型態學出場法、均線出場法、基本面出場法、潛力股出場法。</p>
<p><strong>使用形態學出場</strong>以臺積電為例。</p>
<p>[0066_臺積電漲倍圖]</p>
<p><img src="strategy/images/kvN3xRW8KwFTiU9RfOZjbWK-pUtN0ReJOiuVi5wRx0MaasBFr4zDNmt7j0HMv3DYGoHWEE1nPpfxn8rh9EmlLUm9-JEWGXwuAE86g5ZKEgxTUwEWT5mFy6qJWSaIi7sjvh-5Ikeg6jyofqSyhxV9opg" alt="img" /></p>
<p>下圖[0067_臺積電型態出場]顯示在2015年，使用型態學出場會被洗出兩次。</p>
<p><img src="strategy/images/RuI-NDE9WzY-uXAEI-nBwbRWLL6XdCOk-8IXz5oR1XMctnlAt4o5UjNkbAYf3c5xPlN0gxUV6TaeimVKxJpGVK5wc17HaJGyLsg5mGyizSLRcvfrIiaeFo5maU0xlqUsfi7EdKQC1-hTBMi3RLUAhJI" alt="img" /></p>
<p>但這兩次的振盪在整個上漲中微不足道，可見得型態學並不適合長線操作。</p>
<p><strong>使用均線出場</strong></p>
<p>如果使用長線150日線作為出場條件，下圖顯示至少會被洗出三次。</p>
<p>[0068_臺積電均線出場]</p>
<p><img src="strategy/images/q4WrRwyzQ4DcvoIZUDgMiBkeODQxYqMDc3qxRdujGzBTaRV2XCwALJKXwQCvRS4QYJrLGZT9prhNrBDiNfn6x-4jMhZNrAuFgtdYica7AVLCQV85kkA2hX8DoMsJT10UU5bTEj4HWSA5VzAF4BWEWDk" alt="img" /></p>
<p>均線眾所週知的缺點就是「太慢」，如下圖，等到出場已經吐回58%以上獲利。</p>
<p>[0069_國巨均線出場太慢]</p>
<p><img src="https://lh4.googleusercontent.com/6d-5Si4VIsFmMM70kPYlbKMNb-cd2rOe9rQcgVOpdMVtBxPdiwgY0f0wrinExtqYPEVtv7DALrsk04lqUhpKVGyhSYpK_xWUjzpBHbGrAg0BguP6RCmk6Lo7JYm-myl-tCKCxbAb_vzY91pN4fBEAG4" alt="img" /></p>
<p>由從可見，使用均線出場，不是太快就是太慢。</p>
<p><strong>使用基本面出場</strong></p>
<p>以下使用「超級績效－－金融怪傑交易之道」/Mark Minervini舉的例子說明，散戶如果要依據公司的營運狀況變差來出場，那叫作「天方夜談」。</p>
<p>[0070_基本面出場太慢1]</p>
<p><img src="strategy/images/_0Gd7sBkvILzAnZZMN4cPcnAoCncJL9JwViZRqWpL_o4XwauO0n1sluao0hBJwik71wd8hF3Ge_H3N6Pfef4HNIiFceVgoXjmHoiG25Eaq4Z6PMuVdyl1R43kjzd5DQEugvecT0agHxiBMoHRVXW5mU" alt="img" /></p>
<p>[0071_基本面出場太慢2]</p>
<p><img src="strategy/images/bSkrqQdIwUiK1UdjbQkOtWrvv1LAtHaHUp5CqUd20WbqnLqmcxDcBClqkse79pHN_wAo_LB7S5i8v1TWY9MtR-DrKR-TtLFky37Gy0hAXcvO06AqtZQ6SYpWjqFEBIiiA3cA0lG3GK2U3qD2XTTXIP0" alt="img" /></p>
<p>[0072_基本面出場太慢3]</p>
<p><img src="strategy/images/ehhZ58iolE8FpB2i4jvD9rK7bsQyjSaUaE9Vmvif_V4ZcfhB5V-cagw8AzIpoWo2SQNXIqGY4pIZ3tkUw7Qn78j6_U0gMQxrzkC1hgTcFMRuuUW7FFc8aabnGJHT_mVQFAal2oKvMhVhMLZajpKhkGA" alt="img" /></p>
<p>[0073_基本面出場太慢4]</p>
<p><img src="strategy/images/NX_Oq4AtMlzsZ6WtGTo1088PrJqqlFSQBiHH4Kx3_nYA6TbCx2IG8FVLJD9V_drNZxnaJW1Jlyno1hgSd6O6Ct-KfkvW3S9kChn0Ovp4puB4C94V_6YcuFAOJSIFEzOmbzBsMtJZNxTXfKeMObICY3U" alt="img" /><strong>使用潛力股投資法股災模式</strong></p>
<p>下圖顯示使用股災模式出場法有不錯效果。</p>
<p>[0074_股災模式1]</p>
<p><img src="strategy/images/8gqm0mjOW44KQqFmpz1dT7IqHdw_OwT7X3jVJt9owRL74K-RNvT24gCd4uwJFoo8qX79EMH7ABhez03BQHjiub9hLWThuQhzV67bzTSnX1guEej7rgz0AiBdXsAVBdRhOplawkdwaf1oaqMIgfLPTMc" alt="img" /></p>
<p>[0075_股災模式2]</p>
<p><img src="strategy/images/TrCRwmItp6O2yIOcQgPscB5P8v1IByDlFhvLSkWNZYKjU9fn1KaZqIb6scrjvtwsPJEoVtXOFQwttHT3gaEIqSsb5j_RrF-_MDY1OxBCV3uJPsi5tPytrs0Wlek5fxemIH8RJNDKSIVrak4gL_d4nl0" alt="img" /></p>
<p>注意，只有在低檔，你認為有一倍以上的潛力時才使用「股災模式」，如果已經漲到第三波、第四波，就只能使用「波段模式」（預期有30%以上獲利），短線模式不要使用，你應該使用經過驗證過的「短線交易系統」，陰陽線、指標等不是經過驗證的系統，只不過是「見證」，見證與驗證不同，驗證是可複製的科學邏輯，見證大多隻是偶然。</p>
<p>[0076_股災模式3]</p>
<p><img src="strategy/images/PGPBCqGAtVi-vI2Z-zxrtf4BJRQCKhlXl55mIjnOpAFxpYHorbzxbwwa81HW-Gcy4AEPTd6VYbbzLKbpbBNNrG__jO3eApRj-EPnb1klIoSgdI0eOBL0kXH6PIm31h1xgXn8OyFlFma6EPsRTS-y_4U" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="分批在操作前期的應用---建倉"><a class="header" href="#分批在操作前期的應用---建倉">分批在操作前期的應用   建倉</a></h2>
<ul>
<li>分批買進，只是建倉，壓低成本，抱得住後面才能暴賺</li>
<li>美股要拆太多筆(10筆) ，可以向下分批</li>
<li>美股震盪大15~20% 才加碼一次</li>
<li>假設分三批進場，在三批全部打進去之前都視為建倉，所以在完成建倉之前，風險都控制在10元，所以在第二筆打進去之後，成本110應該是在105的時候就會止損了，&quot;有賺不能賠&quot;應該是建倉完畢後才開始執行</li>
<li>前期建倉完成後是用一個沒有賠到錢心情在拼後面大利潤</li>
<li>每後一次進場風險都變小</li>
<li>暴賺哲學 選股標的同時持有不同股票</li>
</ul>
<p>https://youtu.be/dS4VszQ0CbQ?t=428</p>
<p><img src="strategy/images/%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_038.png" alt="" /></p>
<p><img src="strategy/images/%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_039.png" alt="" /></p>
<p>QA:</p>
<pre><code>如果我計劃性向下總共分3批買進，當我決定在100塊進場第一批資金，停損一般都設10%，其實我不太清楚我第二批的進場價位跟停損價位到底是要設在多少比較合理？［假設第三批資金是等股價超過前兩批平均成本再進場。］ 想請教老師下面哪種策略比較好？還是您建議如何改良？ 
A. 93塊入場第二批資金，然後當價位跌到90塊時，第一批資金跟第二批資金一起停損出場，然後再等時機重新入場。 
B. 93塊入場第二批資金，然後當價位跌到90塊時，第一批資金先停損出場，第二批資金當跌到83.7塊時（-10%）才停損出場。然後再等時機重新入場。 C. 第一跟第二批資金平均成本96.5，當股價跌到86.9（-10%），兩批資金一起停損出場。然後再等待時機重新入場。

我選股是以基本面為主，籌碼面為輔，技術分析只看簡單K線而已，因為我不是用技術分析找買點，通常決定進場價位是等股價相對跌一大段進場。
</code></pre>
<pre><code>A.平均成本10%是偏純策略的做法
B.90全出是技術分析關鍵點的做法
C.83.7再出的做法算是有點混合技術+策略的做法
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="投資哲學"><a class="header" href="#投資哲學"><strong>投資哲學</strong></a></h2>
<h3 id="操作"><a class="header" href="#操作"><strong>操作</strong></a></h3>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406263802-%E8%B3%87%E9%87%91%E6%8E%A7%E7%AE%A1%E6%B3%95">資金控管與試單策略</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406498297-ema1030%E4%BA%A4%E5%8F%89%E6%B3%95">EMA1030交叉法</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/405322031-%E5%A6%82%E4%BD%95%E5%87%BA%E5%A0%B4">如何出場</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406127218-%E8%90%AC%E4%BD%9B%E6%AD%B8%E5%AE%97%E2%80%94%E9%97%9C%E9%8D%B5%E9%BB%9E%E6%93%8D%E7%9B%A4%E8%A1%93">關鍵點操盤術</a></p>
<h3 id="選股"><a class="header" href="#選股"><strong>選股</strong></a></h3>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406283262-%E9%BB%83%E9%87%91%E5%BE%8B%EF%BC%9A%E8%B2%B7%E9%80%B2%E5%BC%B7%E5%8B%A2%E9%A1%9E%E8%82%A1%E4%B8%AD%E7%9A%84%E6%9C%80%E5%BC%B7%E5%8B%A2%E8%82%A1%E7%A5%A8">黃金律：買進強勢類股中的最強勢股票</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406155958-%E7%94%A2%E6%A5%AD%E5%A4%A7%E8%B6%A8%E5%8B%A2%E9%81%B8%E8%82%A1">產業大趨勢選股</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406155194-%E6%8A%80%E8%A1%93%E9%9D%A2%E9%81%B8%E8%82%A1">技術面選股</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/405914183-%E4%BD%8E%E5%83%B9%E8%BD%89%E6%A9%9F%E8%82%A1">低價轉機股</a></p>
<p>　　■ </p>
<h3 id="原理"><a class="header" href="#原理"><strong>原理</strong></a></h3>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406158938-%E5%83%B9%E6%A0%BC%E8%B5%B0%E5%8B%A2%E6%89%8D%E6%98%AF%E7%B5%82%E6%A5%B5%E7%9C%9F%E7%90%86">價格走勢才是終極真理</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/405816291-%E7%82%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%A4%9A%E5%85%83%E7%B3%BB%E7%B5%B1">為何需要多元系統</a></p>
<h2 id="技術分析"><a class="header" href="#技術分析"><strong>技術分析</strong></a></h2>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406287542-%E6%8A%80%E8%A1%93%E6%8C%87%E6%A8%99ma">技術指標MA</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406500357-%E5%B8%B6%E6%9F%84%E6%9D%AF%E7%8B%80%E6%8E%92%E5%88%97">帶柄杯狀排列</a></p>
<p>　　■ <a href="https://htm0606.pixnet.net/blog/post/406500385-3c%E8%88%87%E5%85%B6%E4%BB%96%E6%9C%89%E7%94%A8%E5%9E%8B%E6%85%8B">3C與其他有用型態</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="資金控管與試單策略"><a class="header" href="#資金控管與試單策略">資金控管與試單策略</a></h1>
<p>https://htm0606.pixnet.net/blog/post/406263802-%E8%B3%87%E9%87%91%E6%8E%A7%E7%AE%A1%E6%B3%95?fbclid=IwAR2k9DWoI8dGox8EDvM1j4bnLkRnT_82zlaMwlGVg2imrOoaOsUix8si11w</p>
<p>　　1.討論你要投入多少錢(即部位)進入股市？專家建議你要「由小而大」一開始先小部位，有賺錢才逐漸加大部位。</p>
<p>　　2.每一張股票要投入多少錢?專家建議每一筆交易的金額都要一致，這樣才不會被運氣左右績效。</p>
<p>　　3.每一張股票是一次投入所有的資金還是分批買入？李佛摩建議使用試單策略。</p>
<h2 id="你要投入多少錢"><a class="header" href="#你要投入多少錢"><strong>你要投入多少錢?</strong></a></h2>
<p>　　Larry Williams說道：「<strong>投機客生財之道來自他們的資金管理方法，而不是一些神奇的、神秘的系統或煉金術士的秘方。成功的交易會賺錢，成功的交易加上適當的資金管理則會創造龐大的財富。</strong>」(「短線交易秘訣」)</p>
<p>　　在「交易‧創造自己的聖盃」/ 凡‧沙普一書中，也把「部位大小」的設計作為交易上最關鍵的技術</p>
<p>　　Victor Sperandeo在1978年到1989年的12年間，沒有一年的操作發生虧損，平均年投資報酬率高達70.7%，而被Barron's譽為「華爾街的終結者」，由以下所述的投資哲學，可以看出Victor對於「資金控管」尤為重視。</p>
<p>　　「...假定你是以季為基礎操作。在一季的開始，<strong>任何新部位的規模都應該很小(相對於風險資本而言)，因為當期還沒有累積獲利。</strong>...反之，如果你有獲利，應該將一部份獲利運用在新部位上，並將其餘獲利存入銀行；如此，你不但可以增加獲利的潛能，又可以保障一部份的獲利。...」（詳見後文）</p>
<p>　　本文討論資金控管的方法，以下各種方法本人較喜歡Mark Minervini的「由小而大」。</p>
<p>　　馬克的方法簡述如下：<strong>由小而大，把資金分為三個部位大小(25%,50%,100%)，最大虧損為每個部位的25%，規則一：總獲利賺到某個部位的最大虧損，部位就提升為那個部位，規則二：總獲利小於某個部位的最大虧損，就降級到總獲利仍大於該部位最大虧損之部位。</strong></p>
<p>※超級績效的舉例很難懂，倒不如用歸納法歸納為２個規則。</p>
<p>　　以下以總資金$4000說明如下：</p>
<table><thead><tr><th>部位大小</th><th>A(25%)</th><th>B(50%)</th><th>C(100%)</th></tr></thead><tbody>
<tr><td></td><td>$1000</td><td>$2000</td><td>$4000</td></tr>
<tr><td>最大虧損25%</td><td>AL</td><td>BL</td><td>CL</td></tr>
<tr><td></td><td>$250</td><td>$500</td><td>$1000</td></tr>
</tbody></table>
<p>　　第一次交易，起始部位為A($1000)，如果賺到$500&gt;=BL(規則一)，則部位提升為B($2000)。</p>
<p>　　第二次交易，如果再賺到$500，則總獲利為$1000&gt;=CL(規則一)，則部位提升為C($4000)。</p>
<p>　　第三次交易，若虧損$500，則總獲利為$500(1000-500)&lt;=CL AND &gt;=BL(規則二)，則部位降為</p>
<p>以下列出各家的資金控管方法供參考，你可以選擇你喜歡的。</p>
<p>※上表可下載google試算表範本【<a href="https://docs.google.com/spreadsheets/d/1doHJaYJVXPh5rSDB1MV0gqn1cICvr9pAcO9L4vR32bE/edit?usp=sharing">資金控管計算範本</a>】</p>
<h2 id="每一張股票要投入多少錢"><a class="header" href="#每一張股票要投入多少錢"><strong>每一張股票要投入多少錢？</strong></a></h2>
<p>　　專家建議每一筆交易的金額都要一致，這樣才不會被運氣左右績效。</p>
<p>　　比如說你買2支股票，一支賺10%，一支賠10%，你的績效本應是0，但因為股價不同，如前一支股價100元賺10%，是賺10元，後一支股價20元賠10%，是賠2元，總計賺8元，但其實是因為運氣造成績效的波動。每筆交易金額不一致，即使你使用一套正報酬率是２０％的無敵系統，得到的績效也是被運氣主宰的。</p>
<p>所以你必須每一支股票交易金額都一樣(資金不大者可用零股)，才能維持穩定的績效表現。在【<a href="https://docs.google.com/spreadsheets/d/1doHJaYJVXPh5rSDB1MV0gqn1cICvr9pAcO9L4vR32bE/edit?usp=sharing">資金控管計算範本</a>】中有「零股計算」工作表，如下：</p>
<table><thead><tr><th>A股票檔數</th><th>10.00</th><th></th></tr></thead><tbody>
<tr><td>B可投入資金(千元)</td><td>250.00</td><td>見[資金控管法之部位]</td></tr>
<tr><td>C每檔股票可投入金額(元)</td><td>25,000.00</td><td>=B*1000/A</td></tr>
<tr><td>D股價</td><td>100.00</td><td></td></tr>
<tr><td>E可買零股股數</td><td>250.00</td><td>=C/D(四捨五入)</td></tr>
<tr><td>F半刀</td><td>125</td><td>=E/2</td></tr>
<tr><td>G投入金額</td><td>12,500</td><td></td></tr>
</tbody></table>
<p>　　說明如下：</p>
<p>　　A股票檔數：基本面操作者建議不要超過7檔，技術面操作者可10檔。</p>
<p>　　B可投入資金(千元)：就是前面的你要投入多少錢？比如你股票總資金為100萬，一開始只投入25%就是25萬，則B=250(千元)</p>
<p>　　C每檔股票可投入金額(元)：＝B*1000/A，</p>
<p>　　D股價：輸入股價</p>
<p>　　E可買零股股數：=C/D</p>
<p>　　F半刀或三刀或四刀：</p>
<p>　　李佛摩提到：「<strong>很多投機客在買進或賣出時都太衝動，幾乎所有部位都是在同一價位取得，而那是錯誤且危險的作法。</strong>」李佛摩採用的試單操作方法，是將資金分成20%、20%、20%、40%，試單時先投入第一筆20%的資金，如果行情發展正確（帳面上呈現獲利），才會再投入後續的資金部位。</p>
<h2 id="我的試單策略"><a class="header" href="#我的試單策略"><strong>我的試單策略</strong></a></h2>
<p>　　使用三刀流。自上次買進點漲3%加碼一次，共加碼2次。</p>
<p>　　雖然在測試中(見C:\Users\eagle9971\Google 雲端硬碟\我的投資\StockSD\系統測試\BBBRO_1.ods\試單策略Y))6刀流在行情好的時候可以獲得「讓我一次賺個夠」的效果，但也只有在2020/6/18~2022/4/22這種史無前例的瘋牛行情中出現，而三刀流在12年的測試期間表現得比四刀流「穩定」，犧牲一點獲利(&lt;3%)，所以決定使用三刀流。</p>
<p>　　<strong>而變動出場點為-12%,-6%,0%。指總獲利1批時-12%，2批時-6%，3批時沒獲利就出場</strong>。</p>
<h2 id="一日二刀流"><a class="header" href="#一日二刀流"><strong>一日二刀流</strong></a></h2>
<p>　　所謂的「自上次買進點漲3%加碼一次」是指隔日尾盤嗎？本來無此限制，比如原先跌5%時買進第一筆，盤中漲3%加碼1次，再漲3%再加碼1次，三刀流一日內就能完成全部部位。但要考慮實際情況，如果盤中所有部位買滿，然後從漲停跌到跌停，你有沒有辦法及時出脫？除非你有融資、融券可當日沖銷，否則你只好等到明日開盤再賣，如果明日開盤再跌停，結果你一次就是滿檔虧損20%。這種情形會不會發生？老實說，不常見但有機會發生。</p>
<p>　　所以，最多你「一日二刀流」，第二刀必須在尾盤才出手。這樣就不可能加碼後變成跌停（因為已經是尾盤）。那如果一日尾盤漲幅超過６％是否一次加２碼？還是不要，因為大漲後回檔的機率很大，沒有必要讓自己陷於險境。</p>
<h2 id="參考文章-1"><a class="header" href="#參考文章-1"><strong>參考文章</strong></a></h2>
<h3 id="由小而大"><a class="header" href="#由小而大"><strong>由小而大</strong></a></h3>
<p>(摘自「超級績效2－－投資冠軍的操盤思維」/ Mark Minervini)</p>
<p>　　我渴望達成偉大而高貴的工作，但我最重要的任務，就是把小工作都當成偉大而高貴的工作來做。 ——海倫，凱勒</p>
<p>人生的任何重大成就，都是由小而大，慢慢累積而成。 股票交易也是如此。 這不是一種「不成功便成仁」的活動，沒有必要將其視為全有或全無的決策，你大可一點一滴慢慢來。 我幾乎從未奮不顧身地跳進股票市場，反之一般會先試試水溫，建立幾個規模很小的部位。 如果情況順利，我才會加碼，或增添其他部位。如果情況仍然符合預期，我才會增加整體曝險，態度變得更為積極。如此才不至於招致麻煩，當一切都順利時， 才具有賺大錢的條件。</p>
<p>　　剛開始從事股票交易，應該先從現金部位開始，而且要等到立足點穩定之後，交易規模與整體曝險程度才應該慢慢增加。 關於擴大交易規模，我秉持簡單的哲學：如果二五％或五O％的現金部位都無法賺錢，那為什麼要擴大曝險程度到七五％或百分之百，甚至動用融資呢？ 事實的情況剛好相反：交易發展如果不符合預期，應該考慮縮小交易規模，或是繼續維持現狀。</p>
<p>　　嚴格遵循交易規則，每逢交易不順利，就縮小部位規模；因此，當交易最不順遂的時候，你的交易規模呈現最小狀態。這才符合風險控制的原理！反之，如果抱著「輸多賭大」的心理，交易愈不順利，愈是增添曝險程度，則在交易最 不順手的時候，你將持有最大部位，這等於是在替自己找麻煩。</p>
<p>　　以上這方面的紀律，功能不全然在於防禦。 嚴格遵循這項法則，部位曝險將在交易最順手的時候，擴張到最大程度，這才有助於創造超級績效。 所以，你是讓資金發揮複利作用，不是虧損，但前提是你必須嚴格遵循這項法則。</p>
<p>　　總之，部位如果呈現虧損，實在沒有理由擴大交易規模。反之，交易如果順手，可以運用一帳面獲利融通部位，而且不至於增添風險。</p>
<p>　　容我稍微說明我的作法：我通常最初只建立四分之一的部位（請參考圖表5-5）。賺錢之後，我會讓既有部位擴大一倍，直到持有完全部位為止。我的賺錢部位會擴張規模，虧損部位則縮減規模 。</p>
<p>　　假定我的盈/虧比率為二：一，勝率為五O％。 如果交易順利而得以連續進行三筆成功交易四分之一部位，二分之一部位，以及全額部位其獲利將足以讓我融通三個完整部位和一個二分之一部位（請參考圖表5- 6）。</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/vVcGKN99xR4jZ50EmlLZ3rluHoj4vFkK9zvn97iQ-3wLdm-2H1Lv3Xk56cq_kKwr9qpx52L9q_6-sRhjQRUR-6vaGdN1tWFXwiGUTHY0odSQGdvL_ZUg5eo-XI00zhVfUDTv1Q81BuRybqACwPO-uSA" alt="img" /></p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/UfcstSsi-88XRStGBT39tLAXHsQCTi9-4KvJJbrDY_QIY3eRO2WsPmhRrJlFj-Z0YEYshFe5LOzRHZu6p-2XrD7njicShu3Qe3Dc5p1RJn7pmWDxQejXFTmtw9U1aDrZmyR2Tcj-ZyhVAJNAfRlJRCI" alt="img" /></p>
<h4 id="圖5-6說明"><a class="header" href="#圖5-6說明"><strong>圖5-6說明</strong></a></h4>
<table><thead><tr><th>部位大小</th><th>A(25%)</th><th>B(50%)</th><th>C(100%)</th></tr></thead><tbody>
<tr><td></td><td>$1000</td><td>$2000</td><td>$4000</td></tr>
<tr><td>最大虧損25%</td><td>AL</td><td>BL</td><td>CL</td></tr>
<tr><td></td><td>$250</td><td>$500</td><td>$1000</td></tr>
</tbody></table>
<table><thead><tr><th><strong>交易序次</strong></th><th><strong>投入部位</strong></th><th><strong>獲利</strong></th><th><strong>總盈虧</strong></th><th><strong>備註</strong></th></tr></thead><tbody>
<tr><td>1</td><td>$1000</td><td>$500</td><td>$500</td><td>獲利達BL，擴大部位至B(50%)</td></tr>
<tr><td>2</td><td>$2000</td><td>$1000</td><td>$1500</td><td>獲利達CL，擴大部位至C(100%)</td></tr>
<tr><td>3</td><td>$4000</td><td>$2000</td><td>$3500</td><td>獲利達CL，繼續維持部位C(100%)</td></tr>
<tr><td>4</td><td>$4000</td><td>-$1000</td><td>$2500</td><td>獲利仍達CL，繼續維持部位C(100%)</td></tr>
<tr><td>5</td><td>$4000</td><td>-$1000</td><td>$1500</td><td>獲利仍達CL，繼續維持部位C(100%)</td></tr>
<tr><td>6</td><td>$4000</td><td>-$1000</td><td>$500</td><td>獲利只達BL，縮小部位至B(50%)</td></tr>
<tr><td>7</td><td>$2000</td><td></td><td></td><td></td></tr>
</tbody></table>
<h3 id="幽靈規則二"><a class="header" href="#幽靈規則二"><strong>幽靈規則二</strong></a></h3>
<p>　　「毫無例外並且正確的對你的獲利部位加碼。正確的交易本身實際上並不能產生豐厚的利潤。如果你真的希望自己擁有以交易謀生或賺外快的能力，你就應該在你的獲利倉位上增加籌碼。否則的話，你最多只能保本。」</p>
<h3 id="幽靈理論的見證"><a class="header" href="#幽靈理論的見證"><strong>幽靈理論的見證</strong></a></h3>
<p>出處：https://www.cmoney.tw/notes/note-detail.aspx?nid=13886</p>
<h3 id="掌握加碼2大原則讓你避免風險獲利加倍"><a class="header" href="#掌握加碼2大原則讓你避免風險獲利加倍"><strong>掌握加碼2大原則！讓你避免風險，獲利加倍！</strong></a></h3>
<p>7月 2014年</p>
<p>　　到底要怎麼加碼才對?1.有獲利了，才能加碼下單2.下跌時千萬不能追買攤平成本，這樣只會越攤越平這邊用2個故事來跟大家分享，贏家們他們是怎麼做加碼的。</p>
<h4 id="期貨當沖高手的加碼策略"><a class="header" href="#期貨當沖高手的加碼策略"><strong>期貨當沖高手的加碼策略</strong></a></h4>
<p>　　在我的公司裡面，有一位每天來看盤下單的大哥，在期貨市場10多年，已經賺到了好幾棟房子，但每天的穿著卻是很簡樸，在這邊早上安安靜靜的在下單，下完收盤後就走了。
我很好奇他怎麼有辦法做到這樣，10多年來都靠期貨為生，</p>
<p>　　我就厚著臉皮開口問他，他人很好，跟我講了一個很重要的觀念。</p>
<p>　　「我賠錢時永遠只賠 1 口，賺錢時卻是 5口、20口在賺！」這位大哥說。我問，什麼意思？</p>
<p>　　他說 「我還沒有很明確趨勢出來以前，我會先用一口單試單，嚴守停損。」</p>
<p>　　「一旦趨勢很明確出現了，我有獲利就代表我做對邊，我就會開始加碼。」</p>
<p>　　「所以，一整個波段抱下來，我都是10口、20口在賺的。」</p>
<h4 id="程式交易高手s先生的加碼策略"><a class="header" href="#程式交易高手s先生的加碼策略"><strong>程式交易高手S先生的加碼策略</strong></a></h4>
<p>　　又有一個很好的機會，跟一位程式交易的贏家Steven聊天(有出書的作者)，
發現他的加碼邏輯很值得學習。他說，他永遠都是把他的風險值賺到了，才允許進場訊號下單。什麼意思？</p>
<p>　　假設，我總資金100萬。 我每一筆交易的風險是1萬元。也就是每一筆交易，要是虧損超過1萬元，就立刻砍倉。所以每一次的交易風險只有 1%，不會傷到本。</p>
<p>　　舉例：假設我在8500買進一口期貨契約(1點200元），風控50點(1萬元）。假如行情向上，上漲到了8550，這時我的未平倉獲利已經到了1萬元，是不是跟我的風險值相當了？那這時，就允許加碼第二口單。</p>
<p>　　因為第二口單下單時，你口袋已經有1萬的獲利了，所以第二口單，幾乎等同於新單。</p>
<p>　　這時，停損點跟著上移到8500。然後這時候，若是出現反向出場訊號，全出。</p>
<p>　　(上面這個例子只是概念說明，並不是他的程式真的這樣執行喔～）</p>
<p>　　為什麼要這樣做？因為我們無法預測明天，我們只能在目前的市況，站在機率比較高的那邊交易，但這也是無法100％保證一定會照我們想的走。所以，我們在試單階段，要一定要先用很小很小的部位試單。小心謹慎操作。...</p>
<h3 id="資金管理才是輸贏的關鍵"><a class="header" href="#資金管理才是輸贏的關鍵"><strong>資金管理才是輸贏的關鍵</strong></a></h3>
<p>　　在賭場理最常見到賭客賠掉所有賭金的方法是：輸的時候加碼再玩，也就是說，越輸就玩越大。贏家會反其道而行，輸的時候減碼經營，贏的時候大膽出擊。當然，如果每次都全押，他會以可怕驚人的速度一直贏到最後一次，那一次把之前贏的全部歸零。你的資金必須有適當的管理，每次全押，或越賠玩越大的方法都是必須避免的。</p>
<p>　　Larry Williams說道：「投機客生財之道來自他們的資金管理方法，而不是一些神奇的、神秘的系統或煉金術士的秘方。成功的交易會賺錢，成功的交易加上適當的資金管理則會創造龐大的財富。」(「短線交易秘訣」)</p>
<p>　　在「交易‧創造自己的聖盃」/ 凡‧沙普一書中，也把「部位大小」的設計作為交易上最關鍵的技術。</p>
<p>　　Victor Sperandeo在1978年到1989年的12年間，沒有一年的操作發生虧損，平均年投資報酬率高達70.7%，而被Barron's譽為「華爾街的終結者」，由以下所述的投資哲學，可以看出Victor對於「資金控管」尤為重視。</p>
<h3 id="victor一致性的獲利能力"><a class="header" href="#victor一致性的獲利能力"><strong>Victor：一致性的獲利能力</strong></a></h3>
<p>專業投機原理 - Victor Sperandeo / ISBN:9578457189寰宇</p>
<p>　　...**如果資本要穩定增加，你必須要有一致性的獲利能力；如果你要有一致性的獲利能力，必須要保障你的獲利，並儘可能降低損失。**因此，你必須衡量每一項決策的風險與報酬的關係，根據已經累積的獲利或虧損評估風險，如此才能增加一致性的勝算。</p>
<p>　　例如，<strong>假定你是以季為基礎操作。在一季的開始，任何新部位的規模都應該很小(相對於風險資本而言)，因為當期還沒有累積獲利。另外，你應該預先設定承認自己錯誤的出場點，一旦行情觸及這個價位，你便應該認賠出場。如果第一筆交易發生虧損，任何新部位都應該根據損失而按比例縮小。依此方式交易，任何一季結束時，你都不會虧損所有的風險資本－－你永遠還有籌碼。反之，如果你有獲利，應該將一部份獲利運用在新部位上，並將其餘獲利存入銀行；如此，你不但可以增加獲利的潛能，又可以保障一部份的獲利。</strong></p>
<p>　　如果我是一位年輕的投機者，並擁有5萬美元的資金交易商品期貨，我最初的部位不曾超過總資本的10%－－5.000美元並設定停損而將潛在的損失侷限在10%至20%之間－－500美元至1,000美元之間的損失。換言之，根據這項設計，我的虧損絕對不曾超過總風險資本的1%至2%。如果第一筆交易發生1,000美元的損失，則次筆交易的部位將減至4，000美元，並將潛在損失設定在400美元至800美元之間。依此類推。</p>
<p>就另一方面來說，如果我第一筆交易獲利2,000美元，我將存入銀行1,000美元，並將次一個交易部位增至6,000美元，這將增加我的起始(initial)風險資本(5.000美元)達20%，而實際(actual)風險資本也增加相同的金額。依此方式，即使我下一筆交易發生虧損，就整個期間來說還是有獲利(譯按：這是指一筆交易最多虧損20%而言)。如果我對於行情的判斷有50%的正確機會，則這種交易策略將可以創造相當可觀的收獲。假設我頂多只接受1:3的風險/報酬比率，即使我每二筆交易僅有一次獲利，我的收入仍然相當可觀。換言之，如果你每一筆交易，可能的(probable)報酬至少是客觀可衡量(objectively measurable)之潛在損失的三倍，長期下來，你便可以維持一致性的獲利能力。...</p>
<h3 id="三一理論"><a class="header" href="#三一理論"><strong>三一理論</strong></a></h3>
<p>「孫子兵法與期貨股票實戰」 - 陳富村 / ISBN:9861275002 </p>
<p>　　依筆者在擲骰子的經驗中，發現資金控管的問題，完全是由市場決定的；贏時加碼，贏三倍以上才可以加碼一倍。例如以美金10元為基本下注，贏30元以上才可加碼為每次20元下注；最好是贏50元才加碼。當加碼後輸時，下次下注立刻減碼為10元，如果又輸，還是10元，再輸還是10元；一贏之後立刻恢復20元，又贏還是20元；等到贏三倍60元時，再考慮加碼為40元；輸時立刻又回到20元，最後例如贏到180元，這時可加碼到60元下注了!但若一輸則立刻回到30元，再輸還是30元下注；當基本金額加到100元與300元層級時，還是要保持三比一的比例；輸絕不加碼，贏了就加碼。以全部的資金為單位，每次最大下注的金額不超過全部資金的百分之十五。因為台灣的期貨經紀商在下注虧損百分之七十時，就會自動把客戶三振出局；因此用全部資金的百分之十五為最高限制，也就是虧損金額最高不可超過百分之十。這樣的資金控管，進可攻退可守，以保命為最高設計；絕不是由自己的意志來決定下注多少，這是筆者的發明，是由隨機理論的賭骰子中得到的證明。</p>
<p>　　用之於期貨交易，虧損不超過一倍。贏時緊咬不放，贏多少由獲利停損決定出場，而不是投資者用波浪理論，或什麼壓力、支撐決定；出場是沒有自我的意志的。因此，資金控管絕不是投資人高興如何下注就怎麼下，投資人所能決定的只有基本額度的下注；加減碼沒有個人意志，這是贏家贏大輸小之法。其重要性比任何技術理論或電腦系統更關鍵，也不需仰賴一大堆公式；那些公式一般人看不懂也不必懂，投資人只要會加減乘除即可！股票加減碼也能比照這原理，投資者可自行調整。</p>
<h3 id="elder如何防範鯊魚與食人魚的攻擊"><a class="header" href="#elder如何防範鯊魚與食人魚的攻擊"><strong>Elder：如何防範鯊魚與食人魚的攻擊</strong></a></h3>
<p>　　「... 食人魚是一種熱帶淡水魚，比一個男人的手大不了多少，卻有兩排銳利牙齒。這種魚看起來不是很危險，但如果狗、人或驢子掉進熱帶河流，一群食人魚就會一撲而上，不停撕咬，受害者根本招架不住。一頭走進水裡的公牛若是遭到食人魚攻擊，只消幾分鐘，水裡就只剩下骨骸上下浮沉。交易人以2%準則防範鯊魚攻擊，但仍然需要防範食人魚。6%準則可以讓你不致被一小口一小口咬死。...」-- Elder</p>
<p>Elder的資金管理方程式</p>
<p>以下摘自「走進我的交易室」/ Dr. Alexander Elder</p>
<p>　　先計算利潤的交易新手是本末倒置，他們應該先計算風險。如果你遵循2%和6%準則，要問自己：最大的容許風險是多少?</p>
<p>　　適當的資金管理步驟如下：</p>
<p>　　1. 每個月第一天衡量你的帳戶價值－－現金、相當於現金的資產，以及末軋平部位的總和。</p>
<p>　　2. 計算交易資金的2%，這是任何一筆交易能夠承受風險的上限。</p>
<p>　　3. 計算資金的6%，這是任何一個月容許發生虧損的上限，超過這個上限，你就必須軋平所有交易，停止交易，直到月底。</p>
<p>　　4. 每一筆交易都要決定進場點和到價出場點，以金額表示每股或每口合約所能承受的風險。</p>
<p>　　5. 拿「交易資金的2%」除以「每股風險」，算出你可以交易多少股或多少口合約。取整數時，是向下取較低的數字。</p>
<p>　　6. 計算所有未軋平部位的風險，方法是以「進場點到目前到價出場點的距離」，乘以「股數或合約數」。如果總風險占帳戶的4%或以下，或許可以再建立另一個部位，因為目前的交易將增加2%風險，使得總風險達到6%。請記住：你不必每股交易都承受2%風險，如果需要，你可以承受較低風險。
　　6. 只有在達到以上所有條件之後才交易。</p>
<p>範例</p>
<p>　　把2%準則加上6%準則，當作你自己的交易經理。我舉個例子來說明，如何利用這些準則進場交易。為了簡單起見，在此假設任何一筆交易拿去冒險的錢占淨值的2%，但事實上我們希望承受更低的風險。</p>
<p>　　一位交易人在月底時計算他的淨值，發現有l0萬美元，沒有末軋平部位。他記下下個月最高的風險水準：每筆交易2%或2，000美元，以及整個帳戶6%或6，000美元。</p>
<p>　　幾天後，這位交易人發現股票A非常吸引人。他算好在哪裡下到價出場單，建立了一個部位，承受2，000美元的風險，占資金的2%。幾天後，他又發現股票B不錯，做了一筆類似的交易，再拿2，000美元去冒險。</p>
<p>　　那個星期結束前，他再買進股票C，一樣承受2，000美元的風險。</p>
<p>　　下個星期，他看到股票D，比前面三檔股票還吸引人。應該買嗎?不可以，因為他的帳戶已經承受6%的風險。他有三個末軋平交易，各冒2%的風險，如果市場走勢不利，可能虧損6%。6%準則禁止他再拿任何錢去冒險。</p>
<p>　　幾天後，股票A大漲，他將到價出場點移到損益兩平點之上。僅僅幾天之前，他不能買的股票D看起來仍然很吸引人。現在他可以買嗎?可以，因為他目前承受的風險只占帳戶4%。股票B承受2%風險，股票C承受另外2%風險，但股票A沒有承受任何風險，因為它的到價出場點高於損益兩平水準。這位交易人買了股票D，砸下另外2，000美元或帳戶的2%去冒險。</p>
<p>　　那個星期稍後，這位交易人看到後市極為看漲的股票E。他可以買嗎?根據6%準則，不能買，因為他的帳戶已經有股票B、C、D承受了6%的風險(他的股票A已經沒有承受任何資金上的風險)。他必須放棄股票E。</p>
<p>　　幾天後，股票B下跌，跌到它的到價出場點。股票E看起來仍然很好。他可以買嗎?不可以，因為他已經在股票B賠了2%，而股票C和D仍然承受4%的風險。這時再建立另一個部位，會使他超過每個月承受6%風險的上限。</p>
<p>　　6%準則保護你不受食人魚攻擊。當牠們開始撕咬你，就立刻離開水中，不要讓那駭人的魚咬死你。如果你每筆交易承受的風險低於2%，那麼你可能同時擁有三個以上的部位。如果每筆交易只承受帳戶淨值1%的風險，那麼你可以建立六個部位，才會到達6%的上限。6%準則根據上個月月底的帳戶餘額，保護你的淨值，不考慮你這個月可能賺到的額外利潤。</p>
<p>　　如果進入新月分時，你擁有很大的末軋平利潤，那麼你必須重新計算自己的到價出場點和交易規模，不讓新的總淨值中，有任何一筆交易暴露在2%以上的風險，而所有的末軋平交易加起來則不超過6%。每當你表現不錯，月底之前帳戶價值上升，那麼6%準則允許你下個月加大交易規模。如果你表現不好，帳戶金額縮水，它就會限縮你下個月的交易規模。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何出場"><a class="header" href="#如何出場">如何出場</a></h1>
<p>https://htm0606.pixnet.net/blog/post/405322031-%e5%a6%82%e4%bd%95%e5%87%ba%e5%a0%b4</p>
<p>俗話說得好，會買股票是徒弟，會賣股票才是師傅。飆股人人都買過，但真正賺到大錢的百不得一。</p>
<h2 id="多重出場點單純性與多個出場點"><a class="header" href="#多重出場點單純性與多個出場點"><strong>多重出場點：單純性與多個出場點</strong></a></h2>
<p>　　交易系統設計應該採用單純的概念。我們之所以強調單純性，因為這代表相關系統是建構在「瞭解」的基礎上，而不是最佳化。</p>
<p>　　單純的概念可以引用到許多不同市場與不同交易工具。我們雖然強調單純，但交易系統仍然可以設定多個出場點。這是兩個不相互衝突的概念，單純性是交易系統之能夠有效的必要條件，多重出場點則是滿足交易目標的必要條件。出場點雖然有很多個，但每個出場點都可以源自簡單的概念。</p>
<p>　　讓我們看個例子。假定我們想使用順勢系統，而且希望留在市場久一點。我們不相信神奇的進場訊號，所以要留給部位較大的迴旋空間。另外，萬一出現重大不利走勢，系統必須保障資本，部位必須認賠。最後，由於起始停損相當寬鬆，我們將儘可能獲取較大的利潤，當獲利達到4R時，停止點將設定得更緊密一些。因此，我們要根據這些信念，設計一套適用的交易系統。這個例子顯示一項重要觀念:交易系統設計上必須符合個人信念。這也是交易系統設計的秘訣之一。</p>
<p>　　首先，進場點的起始停損必須相當寬鬆，提供充分的迴旋空間，不至於造成訊號反覆而增添交易成本。我們決定採用前文提到的辦法：3倍的價格波動。這是最糟狀況的停損，但也是後續的追蹤型停止點，因為每天收盤價如果朝有利方向變動，我們將依此重新設定停止點。</p>
<p>　　其次，我們相信，如果市場出現強勁的反向走勢，就應該結束部位。所以，我們決定，只要任何一天的價格反向走勢超過每天價格波動的2倍(由前一天收盤價起算)，就結束部位。這個停止點與前一段的停止點是並存的。</p>
<p>　　最後，獲利一旦到達4R，將採用緊密的停止點，避免吐回太多帳面獲利。所以，獲利到達4R之後，停止點將設定為平均真實區間的1．6倍(不是原來的3倍)：從此之後，這也是唯一的停止點。</p>
<p>　　請注意，這些停止設定都很單純，清楚反映我們所想要的目的。沒有經過歷史測試，所以沒有最佳化的問題。完全沒有涉及火箭科學，所以很簡單。總共有3種停止點，但任何時刻都只有一個停止點真正有效，也就是最接近當時市場價格者。</p>
<p>(摘自「交易‧創造自己的聖盃」/ 凡‧沙普)</p>
<h3 id="簡單多重出場策略摘要"><a class="header" href="#簡單多重出場策略摘要"><strong>「簡單多重出場策略」摘要</strong></a></h3>
<p>　　根據上述，它提出的是三個出場點的設計。簡述要點如下：</p>
<p>　　1. 初始停損點：進場點的起始停損必須相當寬鬆，提供充分的迴旋空間。</p>
<p>　　2. 特殊出場點：如果市場出現強勁的反向走勢，就應該結束部位。</p>
<p>　　3. 停利點：獲利一旦到達4R，則採用緊密停止點。</p>
<h2 id="我的多重出場點"><a class="header" href="#我的多重出場點"><strong>我的多重出場點</strong></a></h2>
<p>　　1. 初始停損點：小於10%。</p>
<p>　　2. 特殊出場點：如果跌破重要支撐。</p>
<p>　　3. 追蹤型停止點：從高點(收盤)回落15%～30%則出場。</p>
<p>　　4. 緊密停利點：獲利一旦到達30%～100%，則採用緊密停止點－－跌破ma5或ma20(不下移)*0.96。</p>
<p>　　5. <strong>彈性原則：浩劫餘生與太空漫步，採取的策略當然有所不同。所以設計有一般波段模式與股災模式。</strong></p>
<h3 id="波段模式"><a class="header" href="#波段模式"><strong>波段模式</strong></a></h3>
<p>　　1. 初始停損點為最大虧損 <strong>10%</strong>，越小越好但不能太小。</p>
<p>　　2. 由最高點回落 <strong>20%</strong>。</p>
<p>　　3. 不要求在期限內要漲多少。</p>
<p>　　4. 漲幅達到 <strong>30%</strong> ，改用 max(ma20)*0.96 為浮動停利點。</p>
<h3 id="股災模式"><a class="header" href="#股災模式"><strong>股災模式</strong></a></h3>
<p>　　1. 初始停損點為最大虧損 <strong>10%</strong>。</p>
<p>　　2. 由最高點回落 <strong>30%</strong>。</p>
<p>　　3. 不要求在期限內要漲多少。</p>
<p>　　4. 漲幅達到 <strong>100%</strong> ，改用 max(ma20)*0.96 為浮動停利點。　　</p>
<h3 id="虧損不超過10"><a class="header" href="#虧損不超過10"><strong>虧損不超過10%</strong></a></h3>
<p>　　「...限制虧損之後，雖然有些轉敗為勝的成功交易消失了，但這方面的不利影響，遠低於迅速認賠的有利影響。根據這項虛擬測試，整個投資組合的績效改善程度，實在顯著到到令人難以置信。我重複驗證相關的計算程序，數據都是正確的。我的投資組合表現，從原來的兩位數字虧損，變成了獲利超過百分之七十。」(摘自「超級績效－－投資冠軍的操盤思維」/ Mark Minervini)</p>
<h3 id="特殊出場點"><a class="header" href="#特殊出場點"><strong>特殊出場點</strong></a></h3>
<p>　　一般情形下原則上虧損不超過10%，但你可以設定的更緊密一點，然而你永遠無法逃過主力裝死、蹲伏、甩轎、洗盤的磨難，所以必須有所了解與對策。</p>
<h3 id="交易儘量接近危險點"><a class="header" href="#交易儘量接近危險點"><strong>交易儘量接近危險點</strong></a></h3>
<p>　　「...真正優秀的交易者，他知道如何判斷正常的價格拉回整理，以及具有危險的價格行為，他們會把停損設定在正常回檔即將演變為危險走勢的關鍵位置，然後讓交易進場價位儘量接近危險點。...」(摘自「超級績效2」)</p>
<h3 id="蹲伏與反轉復甦"><a class="header" href="#蹲伏與反轉復甦"><strong>蹲伏與反轉復甦</strong></a></h3>
<p>　　「...交易者建立部位之後，皆希望看到股票呈現應有的「行為」，但我們也想避免在不必要的情況下扼殺交易機會。行情沒有立即發動，並不代表相關交易就是失敗。...進場建立部位之後，不妨讓股票保有一、兩個禮拜的時間可以正常波動當然必須維持在停損範圍內。股票如果出線蹲伏情況，不必覺得恐慌，,只要停損沒有被引發，沒有出現主要違例現象，不妨等待看看股票是否會發生反轉復甦走勢。」(摘自「超級績效2」)</p>
<h3 id="重新進場"><a class="header" href="#重新進場"><strong>重新進場</strong></a></h3>
<p>　　「某些股票可能呈現理想的架構，吸引買盤進場，但走勢很快進行修正或急遽拉回，引發部位的起始停損。這種情況之所以發生，通常是因為大盤走勢轉弱或劇烈波動。一般來說，股票的基本面條件如果優異，價格向下修正或拉回之後，通常會再出現新的買點。這種新的買進架構往往較先前的買進架構更為優異，因為籌碼得到更一進一步的清洗。</p>
<p>　　部位的起始停損遭到引發之後，不能預期該股票絕對會再出現買進架構；換言之，起始停損一旦遭到引發，就必須停損出場。反之，部位遭到停損之後，並不能排除相關股票再度成為買進對象的可能性；只要該股票滿足了所有買進條件，就可以重新進場建立部位，雖然時機可能相對落後。請注意，真正的重大獲利機會，經常是在重新進場兩、三次才得以掌握。可是，這點往往也是區別真正專業玩家的分野。業餘玩家可能被停損一、兩次之後，就不會考慮再進場，但專業玩家則永遠保持客觀立場，他們只考慮進場條件是否滿足，把每個潛在機會都視為全新投資進行評估。」(摘自「超級績效2」)</p>
<p>　　頂尖交易員喬治．席格(George Segal)說：「我相信你想知道，我是如何得知應該何時進場的？在我真正建立部位前可能已出場二、三次(停損出場)；有時我可以一次便成功地建立部位。但通常需要嘗試數次後，我才會覺得對盤。我願意隨情況的需要不斷試盤，這是一種獨特的觀念；多數人在市場中挫敗，因為他們只做一兩次的嘗試，往往在節骨眼上放棄。而我是不斷地回頭嘗試，不斷地敲著大門，直到大口敞開為止。」</p>
<h2 id="為什麼不用其他出場法"><a class="header" href="#為什麼不用其他出場法"><strong>為什麼不用其他出場法?</strong></a></h2>
<p>　　以台積電為例，本文比較型態學出場法、均線出場法、基本面出場法、潛力股出場法。</p>
<h3 id="使用形態學出場"><a class="header" href="#使用形態學出場"><strong>使用形態學出場</strong></a></h3>
<p>以台積電為例。[0066_台積電漲倍圖]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939294-2961990707-g_n.png" alt="image" /></p>
<p>下圖[0067_台積電型態出場]顯示在2015年，使用型態學出場會被洗出兩次。</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939295-1141631505-g_n.png" alt="image" /></p>
<p>但這兩次的振盪在整個上漲中微不足道，可見得型態學並不適合長線操作。</p>
<h3 id="使用均線出場"><a class="header" href="#使用均線出場"><strong>使用均線出場</strong></a></h3>
<p>如果使用長線150日線作為出場條件，下圖顯示至少會被洗出三次。</p>
<p>[0068_台積電均線出場]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939294-2611269491-g_n.png" alt="image" /></p>
<p>均線眾所週知的缺點就是「太慢」，如下圖，等到出場已經吐回58%以上獲利。</p>
<p>[0069_國巨均線出場太慢]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939295-3939692043-g_n.png" alt="image" /></p>
<p>由從可見，使用均線出場，不是太快就是太慢。</p>
<h3 id="使用基本面出場"><a class="header" href="#使用基本面出場"><strong>使用基本面出場</strong></a></h3>
<p>以下使用「超級績效－－金融怪傑交易之道」/Mark Minervini舉的例子說明，散戶如果要依據公司的營運狀況變差來出場，那叫作「天方夜談」。</p>
<p>[0070_基本面出場太慢1]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939294-1827928982-g.png" alt="image" /></p>
<p>[0071_基本面出場太慢2]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939294-754337663-g.png" alt="image" /></p>
<p>[0072_基本面出場太慢3]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939297-4127690461-g.png" alt="image" /></p>
<p>[0073_基本面出場太慢4]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939300-4248165903-g_n.png" alt="image" /></p>
<h3 id="使用潛力股投資法股災模式"><a class="header" href="#使用潛力股投資法股災模式"><strong>使用潛力股投資法股災模式</strong></a></h3>
<p>下圖顯示使用股災模式出場法有不錯效果。</p>
<p>[0074_股災模式1]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939300-30749515-g_n.png" alt="image" /></p>
<p>[0075_股災模式2]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939307-4159931267-g_n.png" alt="image" /></p>
<p>注意，只有在低檔，你認為有一倍以上的潛力時才使用「股災模式」，如果已經漲到第三波、第四波，就只能使用「波段模式」（預期有30%以上獲利），短線模式不要使用，你應該使用經過驗證過的「短線交易系統」，陰陽線、指標等不是經過驗證的系統，只不過是「見證」，見證與驗證不同，驗證是可複製的科學邏輯，見證大多只是偶然。</p>
<p>[0076_股災模式3]</p>
<p><img src="strategy/%E5%A5%87%E6%AD%A3/../images/1683939307-2666774370-g_n.png" alt="image" /></p>
<h2 id="其他多重出場法"><a class="header" href="#其他多重出場法"><strong>其他多重出場法</strong></a></h2>
<h3 id="歐尼爾的出場方法"><a class="header" href="#歐尼爾的出場方法"><strong>歐尼爾的出場方法</strong></a></h3>
<p>　　綜觀大多數名家的出場策略，大都包括兩種以上的不同策略。以威廉‧歐尼爾為例，其出場方法其實甚為複雜，如下：</p>
<p>　　1. 初始停損點：8%。2. 停利點：20%。好像很單純，其實不然，因為還有以下幾點；</p>
<p>　　3. 走勢超強的個股，即在8週內上漲20%的股票，則不理會20%獲利了結的規則，至少要繼續持有8週。</p>
<p>　　4. 8個繼續持有的法則</p>
<p>　　5. 36個提早賣出的法則。</p>
<h3 id="達華斯的出場方法"><a class="header" href="#達華斯的出場方法"><strong>達華斯的出場方法</strong></a></h3>
<p>　　這個也許不能謂之為單純了，也許找另一個例子比較好，尼可拉‧達華斯：</p>
<p>　　1. 初始停損點：箱型頂部往下一盤(買進點為往上一盤)，所以其風險報酬率是所有系統中最低的。</p>
<p>　　2. 獲利出場點：當另一個箱型建構完成後，停利點往上移到這個箱形的底部下一檔。</p>
<p>　　真的是再明確不過了，撇開那個停利點似乎有一些問題(不是每個下跌的股票都會先建立箱型)，其實這是一個最佳的範例：多重出場點。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="反市場-jg股市操作原理"><a class="header" href="#反市場-jg股市操作原理">反市場 JG股市操作原理</a></h2>
<p>出處: https://stu15834.pixnet.net/blog/post/352668034</p>
<p><img src="strategy/Book/../images/1595400940-360988748-g.png" alt="image" /></p>
<p><img src="strategy/Book/../images/1595835216-1398700816-g_n.png" alt="image" /></p>
<ul>
<li>
<p>J派核心原理 – 反市場</p>
</li>
<li>
<p>世界上存在許多可遵循的重要規則，如看見紅燈停下，看見綠燈才起步</p>
<ul>
<li>「人們規定」的常識，這些規則可以看到多數人興奮和恐懼時，便是可以利用的東西。</li>
</ul>
</li>
<li>
<p>範例 逆KD用法</p>
<ul>
<li>出現上升趨勢時</li>
<li>在KD向下交叉且股價下跌時買進</li>
<li>以前波低點作為停損</li>
<li>當KD向下交叉失敗又突破前高時，將這次反轉失敗低點作為停損</li>
</ul>
</li>
</ul>
<h3 id="停損"><a class="header" href="#停損">停損</a></h3>
<ul>
<li>
<p>買進後續走跌並達到心理停損點 (感到壓力)</p>
</li>
<li>
<p>跌破確認過的低點</p>
</li>
<li>
<p>範例 逆布林+極限加碼</p>
</li>
</ul>
<h3 id="精神"><a class="header" href="#精神">精神</a></h3>
<ul>
<li>
<p>抓住群眾恐懼時 – 在恐懼時買進</p>
</li>
<li>
<p>只管買進，除非暴利不然不停立</p>
</li>
</ul>
<h3 id="操作-1"><a class="header" href="#操作-1">操作</a></h3>
<ul>
<li>
<p>在出現上升趨勢時</p>
</li>
<li>
<p>在布林下緣位置買進</p>
</li>
<li>
<p>突破上緣後不設技術分析停利，直到滿意報酬才停利</p>
</li>
<li>
<p>每漲250點(期貨3%)或股價10%等比買進第二筆</p>
</li>
<li>
<p>布林中線(20MA)上彎，同上每250點依承受風報比投入3.4筆</p>
</li>
</ul>
<h3 id="進場後操作"><a class="header" href="#進場後操作">進場後操作</a></h3>
<ul>
<li>
<p>若非勝率高過9成，要遵守有賺不能賠</p>
</li>
<li>
<p>好的買點買進後都會漲一下</p>
<ul>
<li>沒漲一下 : 買點錯了，立即出場</li>
<li>彈一下跌回 : 量能弱應退出</li>
<li>彈後向上 : 進入移動停利操作，向上加碼</li>
<li>彈後噴出 : 以K棒低點移停，根據風報比加碼</li>
<li>進場後股價在停損停利間遊移 :
<ul>
<li>賭博式停利法(目前最高價到停損價的一半停利，賭大獲利)</li>
<li>進場時應看該股過去上漲時回檔%數，看報酬率能否承受</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一口單</p>
<ul>
<li>拿過去一週的線圖找出事後看好的出手點，將這個出手點依據套用到過去一段時間看是否也完美接下來一段時間只在看到這個依據時才場，不然不動作</li>
</ul>
</li>
<li>
<p>回測</p>
<ul>
<li>過去不代表未來，關鍵在於建立信心，看看自己當下能否做出正確的決策</li>
<li>ex: 線圖網站 – Trading View、Stock-ai</li>
<li>回測要把握三個方向的表現</li>
<li>多頭、空頭、盤整</li>
</ul>
</li>
</ul>
<h3 id="客製化交易sop四步驟"><a class="header" href="#客製化交易sop四步驟">客製化交易SOP四步驟</a></h3>
<ul>
<li>
<p>目標設定 : 放大心中報酬率，待找出最大痛苦值來制定報酬率</p>
</li>
<li>
<p>回測技術: 找出適合反市場的武器。</p>
<ul>
<li>用一樣技術的人哪裡會興奮? 哪裡會恐懼? 獨立思考這些事)</li>
</ul>
</li>
<li>
<p>根據風險報酬比設定停損停利和分批計畫</p>
</li>
<li>
<p>下一口單，寫交易日至，隨時調整SOP</p>
</li>
<li>
<p>如何設定目標獲利 : <strong>先回測過去暴漲型態前會出現的跡象，操作就是跡象出現時如何去賺到這筆錢，當找出過去暴漲跡象時就可得出風險報酬比，但漲跌前跡象其實差不多，所以只挑選一個方向做，猜對照計畫加碼，猜錯依風險報酬比停損。</strong></p>
</li>
</ul>
<h3 id="jg八原則"><a class="header" href="#jg八原則">JG八原則</a></h3>
<ol>
<li>
<p>股票市場就是賭 : 承認運氣的重要性，運氣不對就離開</p>
</li>
<li>
<p>務必和股市預言保持距離 : 預測應著重預測過程的「資料」而非結果</p>
</li>
<li>
<p>用財報選股離暴賺太遠</p>
<ol>
<li>財報 – 過去式</li>
<li>買點 – 技術面</li>
<li>持有 – 想像力</li>
</ol>
</li>
<li>
<p>暴賺是最健康的股市態度</p>
<ol>
<li>不想暴賺的人容易短進短出，只有想大賺的人懂得持有</li>
<li>兩種人在挑選股票的方向和心態會有差異</li>
</ol>
</li>
<li>
<p>當然要知道輸家的下一步</p>
<ol>
<li>在輸家最容易恐慌的地方，便是最安全的地方</li>
<li>輸家的特徵
<ol>
<li>沒耐心 → 持有時間要長</li>
<li>短線容易恐慌 → 只在恐慌時進場</li>
<li>喜歡當沖 → 絕不用市價單，要習慣掛低兩檔買進。</li>
<li>盤中短線振幅越大代表短線客停損造成波動，不該進場</li>
</ol>
</li>
</ol>
</li>
<li>
<p>「優勢」為輸贏最大分水嶺</p>
<ol>
<li>找到自己可用的優勢
<ol>
<li>能否盯盤累積盤感</li>
<li>有無產業背景</li>
<li>人脈充足?有無內線可用?</li>
</ol>
</li>
</ol>
</li>
<li>
<p>風險報酬比</p>
<ol>
<li>股市賺錢不是靠預測，而是在最好的買點買進(符合風險報酬比)</li>
</ol>
<ul>
<li>風報比的觀念在於好的防守，把防守當成最好的進攻</li>
</ul>
</li>
<li>
<p>要賺一輩子，一定要有全面性的操盤力</p>
<ol>
<li>每個人都有心理極限，即使靠技術賺錢了，在達到極限後成長會減緩甚至賠錢。</li>
</ol>
<ul>
<li>基本面和技術面雙能力才能讓交易長久，技術找買點，基本找信心。</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="日本股神cis研究會"><a class="header" href="#日本股神cis研究會">日本股神CIS研究會</a></h2>
<p>只要待在股市一天，手上的現金就是力量。
愈是靠投資賺錢的人，花在投資以外的錢就要更小心謹慎。
要是沒了本金，就無法賺大錢，也無法採取比較強勢的策略。
我個人認為最有效率的投資方法是找出能大撈一筆的機會，盡可能把全部財產都投進去。
所以我才會<strong>鎖定股價波動比較劇烈的個股</strong>，小心翼翼的保管著可以孤注一擲的資金。
我認為效率就是一切，絕對不會像他那樣。就我的判斷來說，他大概有20~25％的機率會被股票市場洗出去。</p>
<h2 id="從小手川隆來思考乖離率"><a class="header" href="#從小手川隆來思考乖離率">從小手川隆來思考乖離率</a></h2>
<p>出處: https://vocus.cc/article/608f9e22fd8978000194b374</p>
<p>當初月光在看過CIS所寫:主力的思維這本書後，對於當沖這個交易法，有了大概的印象。而具體的操作方式，要另外買專書來學習。而作者另外提到的好友或是師父?是B.N.F，是比他更厲害的超級散戶，個人資產來到二百多億日圓。他的本名是小手川隆，從本金160萬日圓開始發跡。</p>
<p>他所崇拜的偶像是美國知名投資人尼德厚夫，針對這位大師的書，目前只買的到尼德厚夫投機術上下冊這套書。這位大師經過破產後從新出發，想必有許多體悟，寫成此書也應有參考性。 至少有書可以參考就很不錯了，因為小手兄本人並沒有出書，因為完全不缺錢，也不想要出名，自然沒有出書的必要。缺點就是無法讓好奇的大眾瞭解他的投資方法為何。幸好，小手兄有接受電視臺訪問，留下一些資料給大眾去揣摩。</p>
<p><strong>首先可以瞭解到的是，小手兄是透過每日的大量交易來快速提升自己的資產。他自己也坦言，無時無刻都在思考投資的策略，甚至連吃飯都可以盡量簡單，旅遊也不想去，真正做到超級專業投資人的境界!已非常人可以達到的!</strong> 而想要在臺灣從事這樣大量頻繁的交易，光成本就不划算，因此一開始就無法複製這樣的操作手法。但即使如此，提高勝率的方法還是可以學習的，對於全球的消息面掌握度要夠，如此才能在每次下單時掌握先機。</p>
<p><strong>一般散戶投資人常常是隔天甚至隔兩天才知道消息，此時再進場操作已經來不及了。真正是錢有四隻腳，追也追不上。而要做那麼多筆交易，就必須要盡快的掌握最新的消息。任何的風吹草動，都可能是造成價格波動的原因。</strong></p>
<p>有專家認為小手兄是採取所謂的逆乖離買法。這是一種反市場投資法嗎?看起來就像是高點時賣出，低點時買入。乖離率本來就是判斷進出場時點的指標，當負乖離率高的時候，就可以考慮進場，小手兄認為這樣的勝率比較大。</p>
<p>甚至也可以說，買低不買高，才可以快速的賣出獲利。而且因為要快速的進行多筆交易，因此要保持冷靜，要不帶感情的做出很多判斷。所以也有專家也主張就交給程式來就好，因為是機械式的操作，程式就是沒有感情的操作。仔細思考小手兄的交易法，發現實際上，上班族無法作到這種強度的交易頻率，況且臺灣也沒有像日本這麼低的稅率。因此，頂多隻能作短日期的交易，例如以持股一至兩周為目標，沒賺到或虧損都得要出場。</p>
<p>而所謂順勢交易，也要看能否買在起漲點，而獲取較大的勝率。因為如果把錢投注在漲最多的，風險過大。上漲的標的這麼多，總不用去挑最多人的，還有很多其他的可以挑，也可以避免被主力倒貨。</p>
<p>的確，順勢交易有很多好處，而長期持有的價值投資，在短期看來獲利不佳。**一般散戶透過基本面的分析資訊，看來也落後在那些強大的法人分析報告之後。人家都研究透徹了，也已反應在價格上，當然不容易有獲利機會，只能等待發生壞事情時再大量買入。**而且，像小手兄這種持續的高強度交易，有幾人撐得住？整天都想著交易的事情，其他的事情可以全都拋下不管嗎?或許對小手兄而言，那些生活瑣事反而比交易還要麻煩許多。</p>
<p>對月光來說，獲利方法百百種，一定要選這麼累的方式嗎？但即使如此，小手兄的交易策略還是帶來許多不一樣的思考衝擊。至少在選股時，可以多參考乖離率作為進出場的輔助標準。月光在網路看到一則廣告說，當沖為交易之母，因為可以在短短一兩天內，看到許多走勢的變化，並且試著從中獲利。這段話或許有些誇大，那不會當沖交易的投資人不就無法成為投資大師?</p>
<p>月光覺得，透過小手兄樸實無華的交易生活，讓自己見識到，真的有人可以因此而成功，只要先能夠把交易擺在生命中的第一位，全心全力的不斷執行交易，就有可能達到。真能做到每日幾個億的交易量，那還有什麼好害怕的呢?</p>
<hr />
<ul>
<li>BNF 操作
<ul>
<li>25日爆量V轉點</li>
<li>做多 等待型: 只做爆量不跌</li>
<li>做多 等待型: 只做V轉守今低停損</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cis的投資哲學"><a class="header" href="#cis的投資哲學">CIS的投資哲學</a></h2>
<p>https://zhuanlan.zhihu.com/p/368672327</p>
<p>今天分享一本國內影響力不大，但是我覺得裡面的內容真的是直擊交易本質的。該書封面標題是【憑一己之力左右日經指數的男人的投資哲學】，起這個標題我覺得稍微有點太用力，可能是需要考慮到書籍的銷售方面。如果可以的話，我覺得作者更想起一個【CIS的投資哲學】這樣的標題。因為不管是作者本身的風格，或者說以短線交易的態度來說，後面這個標題更直擊本質。很多人說CIS是日本或者是當代最像利弗莫爾的人，這個說法且本身沒有一個衡量標準，而且很多偉大的交易員都是十分低調的，除了CIS還有BNF等交易員如果不是因為J-COM事件可能到現在還是不為人所知。但是我認為如果拿兩者的書籍相比的話（股票大作手回憶錄），我很難判斷出哪本書對於我來說更喜歡。股票大作手回憶錄影響力毋庸置疑，但僅有一百多頁的CIS的書，更簡單精要，關鍵點突出，一下就點破了很多至關重要的內容。我在讀完CIS後，我又想馬上拿起來再認真看一遍，因為實在太精彩了，裡面的一些關鍵點要是我能早點看到的話，可能能節約很多我在市場學習的時間。我在網上評價看到這本書的評分並不高，不乏有很多人給出一星和三星的差評，還有人評論“這是我讀過最沒用的投資書了”。這只是視角問題，大眾更傾向於獲取簡單、能直接操作的技巧，或者是更多找到共鳴的經歷故事。</p>
<p>按照作者的性格，本是不會去做寫書這樣費力又得不到應有樂趣的事，這本書的問世也是因為他的一個麻將朋友鼓勵、支援下才得以與我們見面。作者在書中寫到“我的投資方式比較類似電玩玩家或賭徒，而我真的是個遊戲玩家，也嘗試過賭博，所以判斷股票行情對我來說，就像是一場遊戲（賭博）”，CIS是個不折不扣的遊戲迷，和一般遊戲迷不一樣，他對（單場）勝利本身不感興趣，他執著於弄懂遊戲的獲勝邏輯、獲勝原則。從小便在玩遊戲中一直獲得比較好的成績，再往後，規則複雜點的麻將，股票，就成了CIS的熱衷。開始時CIS也不是就馬上學習到市場的正確方向，和大多數人一樣，他是從基本面開始投資股票的，通過市值和營收來決定買入的股票。但是這個情況持續了兩年半左右，陸續虧了一千萬日元。他意識到他走錯方向了，從一次交流會得到啟發後，確定了自己正確的短線交易風格。</p>
<p>CIS在書中提到數個交易原則，這些原則一個一個相互串聯，沒有什麼秘訣，但是秘訣卻是所有的細節組合起來，方有可能成功。以下是書中提到的部分重要原則，我在這裡簡單地展開說明：</p>
<p><strong>1.“順勢操作，勝算最高”</strong></p>
<p>順勢操作是做交易的人聽到最多的一句話，但是理解起來卻五花八門。持續上漲的股票會繼續上漲，持續下跌的股票會再跌，你無需知道背後的原因是什麼，你也無從得知，但是股價現在處於上漲的時期中，必定是大部分人和資本在進行買進操作，才會推升股價的上行。所以順著市場趨勢操作，勝算最高。但是需要注意的是，操作等級的問題，你是以什麼樣的週期來操作的，這點你必須自己明確。</p>
<p><strong>2.“真正的隨機，比你以為的還要殘酷”</strong></p>
<p>大多數人的腦子裡對隨機、平均的概念不夠貼近現實。什麼是現實，現實就是投十次硬幣，八次正面朝上的情況時常發生，‘概念上的隨機，多半給人分散得很平均的印象，但是從微觀角度來看，其實很容易側重一方’。CIS舉例打麻將，你聽很多張牌，但是對家只聽一張牌，但是被對家自摸了，這種被機率背叛的狀況要多少有多少。解決這個問題，只能將自己的視角從本能的直覺中糾正過來，以一個更宏觀的視角來看待結果的隨機性。</p>
<p><strong>3.“基本上請不要預設立場，上漲的時候就要勇敢進場”</strong></p>
<p>這個點作者沒有專門設定一個小標題來說明，但是我覺得也很重要。一旦你有立場，對市場有了主觀預期，無論是交易計畫，還是止損，你都沒辦法很好地執行。“我通常不在意微幅的波動，而是下跌到一定程度才賣掉”，這也是不預設立場的表現。</p>
<p>4.“千萬不能在回呼時買進”</p>
<p>CIS在文中表示回呼時買進屬於逆勢操作，認為上漲的股票會繼續上漲，基本上就要立刻買進。“預測反轉的時機或價格，只是一廂情願的揣測”。關於這點我不能做太多的說明，我說明的太多了很容易造成誤會，需要自己去理解。</p>
<p>5.“只顧著止盈會錯失大波段”</p>
<p>人的本能會在有盈利的時候傾向於止盈，而浮虧的時候不願意承認虧損。當有盈利的時候應該抱著你的頭寸，直到行情出現改變，在趨勢向上的時候止盈多單，絕不是聰明的方法，這跟順勢操作是同一個理念。</p>
<p><strong>6.“重點不是勝率，而是加總的損益——有沒有這種概念，是能不能靠股票賺錢的關鍵”</strong></p>
<p>上面這句話非常關鍵，如果你什麼時候能在心底真正品嚐出這句話的含義，那你就有了盈利的最底層基礎，以一個更接近真實的眼光來看待機率，並突破“隨機”，盈利在向你招手。CIS統計自己的操作下來，單筆勝率只有30%左右，但是都是小賠收場，賺到的金額是小賠的十倍、二十倍，所以這就是以整體的眼光來看待市場，才能突破盈虧平衡。</p>
<ol start="7">
<li>“攤平是最差勁的買法”</li>
</ol>
<p>這點沒什麼好過多解釋的，攤平是知道錯了還增加賭金，與順勢的大原則背道而馳。玩股票最重要的是迅速停損，必須勇於認錯，儘可能把損失控制在最小的範圍內。</p>
<ol start="8">
<li>“已經停損的股票，再次上漲時可以買進嗎”</li>
</ol>
<p>“首先止損的那一刻承認了自己的失敗，然後漲到比自己賣出的金額更高的價位買回，承認止損也是錯誤的決定，或許有人不願意承認兩次錯誤，但我不在乎面子問題，總是可以心平靜氣的操作。我不會把每次的買賣視為勝負，所以不在乎”。單次或單天的盈虧毫無意義，當你能以一個系統的眼光來看待盈虧時，才能走得平穩。但是凡事都有例外，要是連續止損三次以上怎麼辦，CIS給出了他的答案“要是同一隻股票買賣三次以上都看走眼，我也會承認自己看不懂那隻股票，決定不陷入泥沼，就此收手，但我不會放在心上，繼續操作下一隻股票。拘泥局部的勝負，一點意義都沒有”。</p>
<p><strong>9. “計算幾賺幾賠，沒有意義”</strong></p>
<p>“很多人都說賭博時，見好就收很重要，這個說法，與只顧止盈的心態大同小異。考慮到注意力及體力，的確要見好就收，但是如果有勝算，繼續撐下去可以越贏越多。之所以想要見好就收，不過是出於凡事都會取得平衡的想法”。這個話題非常有意思，時常會有人說，他當天無論盈虧10%，就此罷手，不做了。那這麼做到底有沒有用呢？我的建議是，如果你是人工交易，那麼可以這樣設定一個每天的上限值。可能有的人會說可能你正好止損到一天的規定，行情就來了呢，是有這種情況，但是相反在盈利方面也是一樣的（賺到了規定值後又回吐利潤），所以以這個角度來看是一個對稱，但是這個問題不是這麼簡單，因為討論起來有太多內容的，在此不詳細探究。那我為什麼建議這樣做，人工交易往往會出現情緒的波動和注意力、體力消耗，即使當天內的潛在盈虧振幅被你抹掉了不少，但是長期下來你還是走在上破路的，走得更平滑。</p>
<p><strong>10. “不願認賠的心情，會輸得一敗塗地”</strong></p>
<p>形勢不利時，迅速止損，比起技巧，更接近心態。CIS書中舉例，他曾經因為太快止損而錯過了接下來的大行情，但是他卻毫不在意。一旦察覺到不對勁，無論結果如何，應該馬上賣出，他雖然結果上來說止損太早，但是以心態而言，他認為自己沒做錯。這就是一個頂級操盤手的操盤守則，永遠不以單次的結果論輸贏，將自己思維層面提高到與市場真正同頻的“道”上。</p>
<p>沒錯，真實的頂級操盤手的原則就是這麼簡單的幾條，並沒有什麼複雜的操作技術，當你真正地把這些市場哲學理解、融會貫通後，會發現基本上任何簡單技術都是可以賺錢的，能通過觀察市場學到最適合你的技術。但是每一條都需要你以最大的熱情來進行思考、領悟，信心的建立過程不是三天兩天就能完成得，真實的操作水平取決於你理論的理解深度，這個過程是漫長的，需要一個人最深處激發出的堅持和認真才有可能成功。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<p>多方趨勢</p>
<ul>
<li>觀察大盤指數(道瓊指數/上市櫃指數)</li>
<li>只做初升跟主升 </li>
<li>追趨勢盤整後第一天突破5% 做隔日沖 or 抱波段</li>
</ul>
</li>
<li>
<p>盤整</p>
<ul>
<li>做短線 (當沖/隔日沖)
<ul>
<li>均線糾結第一天發動&gt; 5% 尾盤進場</li>
<li>篩選盤整股票隔天程式掛9.5% 進場</li>
</ul>
</li>
</ul>
</li>
<li>
<p>向上加碼 (槓桿商品) or 美股 (趨勢太長幾年連續上漲)</p>
</li>
<li>
<p>ex: 臺指每賺200點加碼一次</p>
<ul>
<li>期貨拆10筆進場</li>
<li>看對行情，等待回檔才向上加碼，並不是每格200點加碼這樣風險大，要等回檔再加碼通常都是技術分析上，一個很好的買點
<ul>
<li>應該要賺300點後，回檔到200點再加碼</li>
<li>後期脫離總成本遠安全就可以加大點 (需要計算)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>向下攤平 (臺股勝率高)</p>
<ul>
<li>用在止跌反轉 (崩跌線型 ？)</li>
<li>進場點
<ul>
<li>第二筆打進去需判斷
<ul>
<li>離止跌點很近</li>
<li>近情要起漲</li>
<li>波動率邊緣進場 ATR 低波動？</li>
</ul>
</li>
</ul>
</li>
<li>如何設定停損？
<ul>
<li>需根據分析設定停損，所以停損要小 5~8%？</li>
<li>分析的止跌點停損設很大是凹單</li>
</ul>
</li>
<li>保留一筆資金在股價高於成本區後再進場 ex: 40萬 30萬  拉過成均成本再進去 30萬(最後一筆)
<ul>
<li>為什麼最後一筆要拉過成本再進怕遇到崩跌，全部錢會吐回去</li>
</ul>
</li>
</ul>
</li>
<li>
<p>爆賺</p>
<ul>
<li>下時代會是誰？ ex: 現在是特斯拉在火，誰讓特斯拉逼著起來</li>
<li>找好商品(獨角獸)</li>
<li>找好買點才可以持續加碼
<ul>
<li>崩跌後出現</li>
</ul>
</li>
<li>轉機股、未來成長股</li>
<li>成本低才好加碼</li>
<li>張松允月K長紅發動後，等待拉回量縮持續買(能爆賺?)</li>
</ul>
</li>
<li>
<p>逆勢好處</p>
<ul>
<li>順勢交易進場點價位通常不好</li>
<li>所以要順大逆小(逆KD)</li>
</ul>
</li>
<li>
<p>JG</p>
<ul>
<li>
<p>逆KD /逆布林</p>
<ul>
<li>逆布林
<ul>
<li>多頭趨勢使用
跌破下緣買進，並設好停損
通過通道上緣不要停利，向上分批賣出</li>
</ul>
</li>
</ul>
</li>
<li>
<p>恐慌 定義 </p>
<ul>
<li>多頭趨勢裡 </li>
<li>技術分析者恐慌</li>
</ul>
</li>
<li>
<p>賭博式停利法</p>
<ul>
<li>拿獲利一半來賭</li>
</ul>
</li>
<li>
<p>YT 網友: 多頭市場很適合向下攤平 </p>
<ul>
<li>https://www.youtube.com/watch?v=5AQHkBoUybA</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>https://medium.com/blacksecurity/%E8%88%87%E7%9C%BE%E4%B8%8D%E5%90%8C%E7%9A%84%E6%80%9D%E8%80%83-%E5%8F%8D%E5%B8%82%E5%A0%B4-jg%E8%82%A1%E5%B8%82%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%AE%80%E5%BE%8C%E5%BF%83%E5%BE%97-990c5cb13fc3</p>
<ul>
<li>
<p>股市是一個推理遊戲，想贏就得先搞懂「反市場」</p>
<ul>
<li>十次跌破裡面有八次是假跌破，是不是跌破去買進才是真道理？</li>
<li>停損停利人人會設，你是機械式地提早賣掉飆漲股，還是有策略放大你的好運？</li>
<li>許多人推崇KD指標、布林通道，但是否可以改良、做出不同選擇？</li>
<li>避開主流，別把自己交給機率，盡可能的放大運氣才能暴賺。</li>
</ul>
</li>
<li>
<p>不合人性，任何方法都會賠錢</p>
<ul>
<li>存股很健康正向，但你知道六成優質股曾股價腰斬，許多人「存不住」而虧損出場嗎？</li>
<li>看財報、看線圖……有各種預測股價的技術，但你想過「高勝率」不如「暴賺致富」嗎？</li>
<li>操盤賺錢的關鍵不在預測，不在求穩定，而是要用符合人性的方式來長期操作。</li>
<li>弄懂「反市場」心理，你才能在別人害怕的時機買進，在別人過於樂觀的時機賣出！</li>
</ul>
</li>
<li>
<p>用買賣來攻擊，用情緒來防守</p>
<ul>
<li>股市裡沒有一個人是技術超強但心理脆弱，卻還能成為贏家。</li>
</ul>
</li>
<li>
<p>JG的八原則:</p>
<ul>
<li>股票市場就是賭</li>
<li>務必和股市預言保持距離</li>
<li>財報選股，離爆賺實在太遠</li>
<li>爆賺，是最健康的股市態度</li>
<li>當然要知道輸家的下一步</li>
<li>優勢為輸贏之間的最大分水嶺</li>
<li>贏家第一課:風險報酬比</li>
<li>要賺一輩子，一定要有全面性的操盤力</li>
</ul>
</li>
</ul>
<h2 id="ch1-反市場股市致富之道"><a class="header" href="#ch1-反市場股市致富之道">CH1 反市場:股市致富之道</a></h2>
<p>第一章部分提到<strong>運氣</strong>的重要性，JG強調運氣是股市重要的一個點，對於運氣的信仰決定你成為怎麼樣的投資者，運氣型玩家有個精神就是拿到好牌就要爆賺一筆。不過拿到好牌大多數人也不知道怎麼打這副好牌。</p>
<h2 id="ch2-j派買賣原則"><a class="header" href="#ch2-j派買賣原則">CH2 J派買賣原則</a></h2>
<h2 id="停損-1"><a class="header" href="#停損-1">停損</a></h2>
<blockquote>
<p>停損並非代表自己看錯，而是讓自己把握其他賺錢機會</p>
</blockquote>
<h3 id="風險報酬比"><a class="header" href="#風險報酬比">風險報酬比</a></h3>
<p>JG有強調<strong>風險報酬比</strong>在投資前的心態很重要</p>
<p>風險報酬比為:</p>
<pre><code>虧損:獲利  --&gt; 建議為 1:3 
</code></pre>
<p>意思是<strong>賺一次可以抵賠錢三次</strong>，進場四次贏超過一次就可以</p>
<h2 id="ch3-j派核心原理反市場"><a class="header" href="#ch3-j派核心原理反市場">CH3 J派核心原理:反市場</a></h2>
<h3 id="技術指標"><a class="header" href="#技術指標">技術指標</a></h3>
<p>KD人人皆知但充滿不確定性，指標是不精確的結果而且不是原因，打開五分線看盤會發現一下交叉一下沒交叉，會有無數次的<strong>假</strong>交叉。臺股和美股不同，絕對不能追高，因為波動有限。</p>
<h3 id="kd指標"><a class="header" href="#kd指標">KD指標</a></h3>
<p>JG推薦逆KD，像是<strong>KD向下交叉+下跌買進搭配書中寫得停利與停損和其他條件。</strong></p>
<h3 id="股市預言"><a class="header" href="#股市預言">股市預言</a></h3>
<p>股市預言請<strong>全部打叉</strong>，市場的短期波動是被<strong>消息與躁動散戶</strong>所影響。</p>
<h3 id="summary"><a class="header" href="#summary">SUMMARY</a></h3>
<p>用反市場避開主流才能爆賺，別把人生交給機率，拿到好牌就狠狠賭下去</p>
<h2 id="ch4-不合人性任何方法都會賠錢存股與複利"><a class="header" href="#ch4-不合人性任何方法都會賠錢存股與複利">CH4 不合人性，任何方法都會賠錢(存股與複利)</a></h2>
<p>我看了不少有關存股、複利、價值投資或中長期投資的影片或書籍，這段大概會有很多爭議或不同觀點，也會有人提出解法或觀點，但一百種人就有一百種投資方法(與觀點)，能賺錢就是好方法，而且我更好奇JG對於ETF看法就是。</p>
<p>中長期投資入門可參考另一篇心得:<a href="https://medium.com/blacksecurity/%E8%82%A1%E5%B8%82%E7%B6%93%E5%85%B8%E6%95%99%E7%A7%91%E6%9B%B8-%E6%88%91%E7%9A%84%E8%81%B7%E6%A5%AD%E6%98%AF%E8%82%A1%E6%9D%B1-%E8%AE%80%E5%BE%8C%E5%BF%83%E5%BE%97%E7%AD%86%E8%A8%98-11fe370f5ec7">我的職業是股東</a>、<a href="https://medium.com/blacksecurity/%E9%87%91%E8%9E%8D%E4%B9%9D%E5%A4%A7%E6%8C%87%E6%A8%99%E8%A7%A3%E9%87%8B-%E6%AE%96%E5%88%A9%E7%8E%87-eps-roa%E8%88%87roe-%E6%9C%AC%E7%9B%8A%E6%AF%94per-pbr-%E8%82%A1%E5%83%B9%E6%B7%A8%E5%80%BC%E6%AF%94-6d97a9fab7ba">金融名詞解釋</a></p>
<h3 id="複利"><a class="header" href="#複利">複利</a></h3>
<p>市場流行一種觀念，<strong>低報酬=安全。</strong></p>
<p>複利本身意義是用賺來的錢不斷在投入股市去利滾利，關鍵不是安全而是要<strong>持續不斷高報酬。</strong></p>
<p>但<strong>心理</strong>上大多人想要快速致富，<strong>盲目地投入就導致失敗</strong>，JG建議先求爆賺後求穩定，最後求不敗</p>
<h3 id="存股"><a class="header" href="#存股">存股</a></h3>
<p>存股概念:隨時買+賭不會倒閉+高殖利率</p>
<p>前提是你在<strong>低點買</strong>，加上人性很容易導致失敗，市面上老師大多數都是從金融海嘯後才出來出書，又遇到大多頭市場所以全部都是對的。</p>
<p><strong>盲點:忽略買點</strong></p>
<p>假設以2009存到2019<strong>績效最好</strong></p>
<p>假設以2006存到2016 <strong>績效稍微差一點</strong></p>
<p>假設以2004存到2014 <strong>績效會非常差</strong></p>
<p>心理上還是最大的敵人，靠配股配息會失敗是因為賺得少、賠得多，大金額的帳面虧損下跌顯違反人性，無法抱住。</p>
<p><strong>優化存股:</strong></p>
<ol>
<li>買在最有利的景氣區間</li>
<li>買成長股，例如當時的玉山金，不是因為他很安全而是他會成長。</li>
<li>成長股要挑資本額20億以下比較好的成長動能</li>
<li>成長擺第一 ，股利股息擺第一</li>
<li>找好機會一次出手，除了巴菲特，年輕的投機客大多數都是基本面與基數面雙主修。</li>
</ol>
<h3 id="預測"><a class="header" href="#預測">預測</a></h3>
<p>這點倒是和經典書一樣的道理，股市不能預測。</p>
<h2 id="ch5-脫離輸家的反市場思考"><a class="header" href="#ch5-脫離輸家的反市場思考">CH5 脫離輸家的反市場思考</a></h2>
<h3 id="下單"><a class="header" href="#下單">下單</a></h3>
<p>下單沒有邏輯，用感覺下單，而不是推論。</p>
<p>在<strong>趨勢</strong>底下，所有技術分析都是一坨屎</p>
<h3 id="明牌"><a class="header" href="#明牌">明牌</a></h3>
<p>聽到的<strong>必死無疑</strong> ，沒有更多資訊，只有一句話，若有資訊也不知道轉了幾手的消息。</p>
<p>好明牌一定要<strong>有未來性</strong>，還要追查<strong>來源</strong>與<strong>證實理由</strong></p>
<h3 id="雜誌與市場"><a class="header" href="#雜誌與市場">雜誌與市場</a></h3>
<p>當市場的氣氛是恐慌時候，一定要當個冷靜的人，因為股票市場大多是賠錢的，而賠錢的人說話不需要聽，股市多頭時候誰講的話都是對的。</p>
<h2 id="ch6-建立贏家的心理正回饋"><a class="header" href="#ch6-建立贏家的心理正回饋">CH6 建立贏家的心理正回饋</a></h2>
<p>贏家的心理與技術是兼具的。</p>
<h3 id="股市癮"><a class="header" href="#股市癮">股市癮</a></h3>
<p>每天都想進出股市，一定要下單穩+準確的目標。</p>
<h2 id="ch8-反市場贏家的八個原則"><a class="header" href="#ch8-反市場贏家的八個原則">CH8 反市場贏家的八個原則</a></h2>
<ol>
<li>股票市場就是賭 — <strong>不要以為自己可以掌控市場</strong>，很多情況都是運氣。不把股市<strong>當賭</strong>且不停損停利。容易患得失。</li>
<li>務必和股市預言保持距離 — 應思考是否為正確的真利多。</li>
<li>財報選股，離爆賺實在太遠 — 唯一要注意的是<strong>資本支出</strong>，代表董監持股信心。</li>
<li>爆賺，是最健康的股市態度 — <strong>不要有短進短出</strong>的壞毛病</li>
<li>當然要知道輸家的下一步</li>
<li>優勢為輸贏之間的最大分水嶺</li>
<li>贏家第一課:風險報酬比</li>
<li>要賺一輩子，一定要有全面性的操盤力 — 總體經濟學搭配技術面<strong>比對</strong></li>
</ol>
<p>總體經濟弱+技術強=市場超強-&gt;重壓</p>
<p>總體經濟好+技術弱=市場超漲有短線疑慮-&gt;減碼</p>
<p>總體經濟好+技術強=安心持有</p>
<p>總體經濟差+技術弱=空手</p>
<h1 id="崩潰線型"><a class="header" href="#崩潰線型">崩潰線型</a></h1>
<h2 id="-2"><a class="header" href="#-2"><img src="strategy/images/%E5%B4%A9%E6%BD%B0%E7%B7%9A%E5%9E%8B-1.jpg" alt="img" /></a></h2>
<h2 id="-3"><a class="header" href="#-3"><img src="strategy/images/%E5%B4%A9%E6%BD%B05.png" alt="img" /></a></h2>
<h2 id="正方形黃色發動點第一根藍色圓圈是買點"><a class="header" href="#正方形黃色發動點第一根藍色圓圈是買點">**正方形黃色=發動點第一根；**<strong>藍色圓圈是買點。</strong></a></h2>
<p>我建議要抓就抓兩根以上的大黑棒，每根超過1%(越多越好、越猛越好)
基本上已經可以用這個推論出很多更進階甚至更漂亮的買點。</p>
<p>這招在季線上揚(包括向上震盪)的時候非常關鍵好用
而且這種買點通常都是投資人最恐慌的時候，但知識就是力量，賺錢就是靠這個。</p>
<p>只是務必不要太求精準，太精準會錯過許多買點，瞭解其中的涵義更為重要
例如你可以想想，那空頭怎麼用，反著用就好。</p>
<p>而這些你如果願意再花點時間回測，我相信你還可以找到更多更好的潛在買點來提升報酬率，祝大家在股市順利！</p>
<p><img src="strategy/images/Blogger.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="資源"><a class="header" href="#資源">資源</a></h2>
<ul>
<li>fmz</li>
</ul>
<p>https://github.com/fmzquant/strategies/blob/master/README.md</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="nansen"><a class="header" href="#nansen"><strong>Nansen</strong></a></h4>
<p>Nansen專注於追蹤鏈上活動，以&quot;為鏈上地址打標簽&quot;而出名，其中最有名的標簽就是“smart money”--聰明錢。擁有聰明錢標簽的是加密世界中的精英們的錢包地址，他們的交易行為通常能帶來不菲的收益，其他交易者自然也想要跟隨他們的交易行為。</p>
<p>Nansen擁有很強的快速迭代能力，比如在NFT市場興起之後，快速推出了一係列NFT相關的產品服務，如NFT Paradise、 NFT God Mode、NFT Wallet Profiler等。</p>
<p><strong>【主要功能】</strong></p>
<p>Nansen提供的功能主要有portfolio、smart alerts、watchlist等。在Nansen的主界麵上，可以查看主要公鏈的宏觀數據、defi數據、穩定幣數據和NFT市場的基本情況，包括主要NFT的市值、地板價、成交量、成交額和持有錢包數等。</p>
<p><img src="https://cdn-img.panewslab.com/panews/images/79VH92a9Br.png" alt="鏈上數據分析工具盤點" /></p>
<p>portfolio：Nansen的用戶可以使用錢包地址登錄他們的網站，登錄後，就可以在頁麵上查看錢包地址下所有的資產、交易記錄、資產分析等。</p>
<p><img src="https://cdn-img.panewslab.com/panews/images/VMx9I300FC.png" alt="鏈上數據分析工具盤點" /></p>
<p>smart alerts：Nansen允許用戶訂閱智能警報，在他們訂閱的地址進行活動時他們會收到通知。</p>
<p>watchlist：用戶可以向watchlist中添加想要監測的錢包地址，來隨時監測該地址的動向。</p>
<p>目前Nansen提供一部分免費功能，但絕大部分功能需要付費使用，這也是nansen的主要收入來源。</p>
<p><strong>【是否支持自定義數據】</strong></p>
<p>目前Nansen提供的數據都是經過他們處理的，不支持用戶自定義的數據分析。由於他們麵向的主要是需要高可用數據的機構投資者，因此提供的數據基本都是已經建模處理過後的成品數據。</p>
<p><strong>【覆蓋區塊鏈】</strong></p>
<p>Nansen已經支持了包括 Layer 2 在內的41條公鏈上的數據。</p>
<p><strong>【數據延遲】</strong></p>
<p>分鐘級彆延遲。</p>
<p><strong>【研報】</strong></p>
<p>Nansen擁有一個由18名分析師組成的分析團隊，在他們網站的nansen research板塊中為用戶提供研報，研究的內容涵蓋了L1/L2, NFT, GAMING, DEFI和宏觀趨勢等。</p>
<p>https://pro.nansen.ai/</p>
<p>交易所資金流動狀況
https://pro.nansen.ai/exchange-flows/exchanges</p>
<p>https://portfolio.nansen.ai/dashboard/binance
https://portfolio.nansen.ai/dashboard/okx
https://portfolio.nansen.ai/dashboard/bybit
https://portfolio.nansen.ai/dashboard/bitfinix</p>
<h4 id="通知--slack--tele"><a class="header" href="#通知--slack--tele">通知  slack , tele</a></h4>
<p><a href="https://pro.nansen.ai/alert-triggers">Smart Alerts</a></p>
<p><a href="https://www.youtube.com/watch?v=wwCZ11lAC4Y&amp;ab_channel=mrblock%E5%8D%80%E5%A1%8A%E5%85%88%E7%94%9F">Nansen.ai - 如何追蹤大戶</a></p>
<p><a href="https://www.youtube.com/watch?v=yiirdqwDJHQ&amp;ab_channel=GRENADE%E6%89%8B%E6%A6%B4%E5%BD%88">Nansen：鏈上數據分析初步指南</a></p>
<hr />
<p><a href="https://disp.cc/b/DigiCurrency/fyaw">幣安出現什麼徵兆時要塊陶？</a></p>
<p>作為一個hodler 熊市時我其實不太關注市場消息
這也導致此次FTX事件中後知後覺 被關廁所損失近40萬鎂</p>
<p>雖然主要資產是放在冷錢包中, 但這個損失還是不少
如果回到11/05, 是否有什麼確切證據可以知道FTX已經發生擠兌?</p>
<p>(板上的示警文章已看過, 有板友也因此得救, 但我想知道的是確實數據)</p>
<ol>
<li>
<p>以前常用的例如 Whale Alert:
https://twitter.com/whale_alert</p>
<p>能否事先看出來? 在搜尋列輸入過濾條件
ftx from:whale_alert since:2022-11-05
從11/05到寫這篇文章的期間只有30筆alert, 坦白說看不出什麼跡象</p>
<p>過濾條件:
binance from:whale_alert since:2022-11-05
可以看到過去幾天有相當大額的#USDC burned (可能為提現)</p>
<p>實際來說, 一家交易所如果要避開whale alert的偵測, 只要切細成較小額度
就能辦到, 例如100M USD切成1M x 100, 就偵測不到
所以也許FTX原本就是都切成小額居多, 而幣安比較沒這樣做
無論如何, 用whale alert似乎不太靠譜</p>
</li>
<li>
<p>使用鏈上數據分析, 例如Nansen:
https://pro.nansen.ai/</p>
<p>有七天試用期, 長期用要繳費, 另外它有twitter:
https://twitter.com/nansen_ai</p>
<p>正在示警各穩定幣和ETH大量流出:</p>
<p>Exchange ETH &amp; ERC20 tokens netflow in the last hour</p>
<p>Binance -$72.9M
Huobi -$12.7M
Gateio -$7.3M
Cryptocom -$4.7M
OKX -$3.1M</p>
<p>Bittrex +$771K
Bitkub +$496K
Paribu +$191K
Bitpanda +$55K
Probit +$51K</p>
<p>*ETH &amp; ERC20 tokens only, from addresses that we have labeled</p>
</li>
</ol>
<p><img src="strategy/images/FhbNHaSVEAEQY6k" alt="" /></p>
<p>Most of the withdrawals/negative netflows are in</p>
<p>USDT -$24.3M
ETH -$11.7M
USDC -$10.7M
LDO -$6.8M
BUSD -$6.5M</p>
<p><img src="strategy/images/FhbQIu3UUAIBiFF" alt="" /></p>
<p>過去7天交易所流出排行:
https://twitter.com/nansen_ai/status/1591617986275966976/photo/1</p>
<p>Jump Trading in the last 24 hours:</p>
<p>Total withdrawals from exchanges:
$32.5M</p>
<p>Total deposits: 
$1.5M</p>
<p>*ETH &amp; ERC20 tokens only, from addresses that we have labeled</p>
<p><img src="strategy/images/FhaMvBCaMAEUOgF" alt="" /></p>
<p>In the last 7 days: </p>
<p>Total withdrawals:
$691M</p>
<p>Total deposits: 
$229M</p>
<p><img src="strategy/images/FhaQFh2aEAARRju" alt="" /></p>
<p>過去30天交易所流出排行:
https://twitter.com/nansen_ai/status/1591617991648890880/photo/1</p>
<p>In the last 30 days:</p>
<p>Total withdrawals:
$1.5B</p>
<p>Total deposits: 
$750M</p>
<p><img src="strategy/images/FhaPvMbaEAMoTlw" alt="" /></p>
<p>不意外的看到FTX流出42B, 但只回補了39B, 而幣安則流出45B
此外鏈新聞在11/07示警FTX流出大量穩定幣也是採用nansen的數據:
https://abmedia.io/20221107-ftx-stable-coin-outflow</p>
<p><a href="https://abmedia.io/20221107-ftx-stable-coin-outflow"><strong>用戶避風頭？FTX穩定幣發生大量提幣，幣安流入超過3億！ | 鏈新聞 ABMedia</strong></a>
[<img src="https://abmedia.io/20221107-ftx-stable-coin-outflow" alt="圖]" />資產機構 Alameda Research 的資產結構疑雲事件在近期引起不少討論，甚至引起 FTX 及幣安執行長的網路論戰、籌碼較勁。若從鏈上數據角度出發，可發現此事件已對 FTX 用戶造成影響並引發大量提幣，使數億美元的穩定幣從 FTX 流出。 ...</p>
<p><img src="https://abmedia.io/wp-content/uploads/2022/11/GTLQ0G88P7WP72YDEL9MLV5VSDLXD34IW0H6TIG147JE1W98AP2ROJS7GNC0IQEO.png" alt="" /></p>
<p>但這篇新聞的圖表並非來自twitter, 且它還列出各家交易所穩定幣餘額
並示警FTX在11/07時就只剩261M美金的穩定幣了</p>
<p>看來使用Nansen是可以看得出來, 前提是付費使用者以及有習慣看圖表</p>
<ol start="3">
<li>
<p>追蹤名人的推特:
除了以上提到的以外, CZ呀、kraken官方..等等的也許能得到警訊</p>
</li>
<li>
<p>查看交易所列出的錢包:
在這個恐慌期中, 各家交易所又想起了PoR的重要性, 但這也不是能短時間做好的,
以幣安為例, 就先給出了它的冷熱錢包:
https://reurl.cc/LXMAmy</p>
<p>其中BUSD和BNB先不用管, 專注看它的BTC, ETH, 和USDC錢包即可</p>
<p>這三種錢包加總約有十幾B美金的價值, 但別忘了FTX光11/08單日就被提款50B
如果爆發恐慌擠兌, 以幣安市佔為FTX 4倍來估算, 這點錢應該是瞬間就空了</p>
</li>
</ol>
<p>實際動作：
鑒於FTX的爆炸, 我開始轉出除了kraken以外交易所裡的資產
BTC和ETH直接打入冷錢包, 其餘小幣都賣成穩定幣
以幣安來說就是都賣成BUSD, 然後走erc20匯出成USDC</p>
<p>如果很多人也正在跟我做一樣的事, 則BTC和ETH相對抗跌
也不排除有人是賣小幣買成ETH存冷錢包的
而其他幣無可避免要先崩一波了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1"><a class="header" href="#example-1">example</a></h1>
<pre><code class="language-py">from plotly.offline import plot
import plotly.graph_objs as go
import pandas as pd
import talib as ta
import re 
import numpy as np

o = np.array([ 39.00, 39.00, 39.00, 39.00, 40.32, 40.51, 38.09, 35.00, 27.66, 30.80, 39.00, 39.00, 39.00, 39.00, 40.51, 38.09, 35.00, 27.66, 30.80])
h = np.array([ 40.84, 39.00, 40.84, 40.84, 41.69, 40.84, 38.12, 35.50, 31.74, 32.51, 40.84, 39.00, 40.84, 40.84, 40.84, 38.12, 35.50, 31.74, 32.51])
l = np.array([ 35.80, 35.80, 35.80, 35.80, 39.26, 36.73, 33.37, 30.03, 27.03, 28.31, 35.80, 35.80, 35.80, 35.80, 36.73, 33.37, 30.03, 27.03, 28.31])
c = np.array([ 40.29, 40.29, 40.29, 40.29, 40.46, 37.08, 33.37, 30.03, 31.46, 28.31, 40.29, 40.29, 40.29, 40.29, 37.08, 33.37, 30.03, 31.46, 28.31])

print('CDL3BLACKCROWS ', ta.CDL3BLACKCROWS(o, h, l, c))

trace = go.Candlestick( #x= pd.to_datetime(dfohlc.index.values),
            open=o,
            high=h,
            low=l,
            close=c)
data = [trace]

plot(data, filename='go_candle1.html')

</code></pre>
<pre><code class="language-py">import pandas as pd
import mpl_finance as mpf
import matplotlib.pyplot as plt
from FinMind.data import DataLoader


def draw_candle_stick(df, index):
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(1, 1, 1)
    ax.set_xticks(range(0, len(df.index)))
    ax.set_xticklabels(df[index])
    mpf.candlestick2_ochl(
        ax,
        df[&quot;open&quot;],
        df[&quot;close&quot;],
        df[&quot;max&quot;],
        df[&quot;min&quot;],
        width=0.7,
        colorup=&quot;r&quot;,
        colordown=&quot;g&quot;,
        alpha=1,
    )


dl = DataLoader()

stock_data = dl.taiwan_stock_daily(
    stock_id=&quot;TAIEX&quot;, start_date=&quot;2018-09-01&quot;, end_date=&quot;2022-08-31&quot;
)
print(stock_data)

# 新增月份與星期欄位

stock_data[&quot;weekday&quot;] = pd.to_datetime(stock_data[&quot;date&quot;]).dt.weekday
stock_data[&quot;month&quot;] = pd.to_datetime(stock_data[&quot;date&quot;]).dt.month
stock_data = stock_data[stock_data[&quot;weekday&quot;] &lt; 5]
stock_data = stock_data.dropna()

# 把數據normalize到開盤價, 方便我們做比較

stock_data[&quot;max&quot;] = stock_data[&quot;max&quot;] / stock_data[&quot;open&quot;]
stock_data[&quot;min&quot;] = stock_data[&quot;min&quot;] / stock_data[&quot;open&quot;]
stock_data[&quot;close&quot;] = stock_data[&quot;close&quot;] / stock_data[&quot;open&quot;]
stock_data[&quot;open&quot;] = stock_data[&quot;open&quot;] / stock_data[&quot;open&quot;]


# 對星期做簡單平均

stock_data_gb_week = stock_data.groupby([&quot;weekday&quot;]).mean().reset_index()
weekday = [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;]
stock_data_gb_week[&quot;weekday&quot;] = stock_data_gb_week[&quot;weekday&quot;].apply(
    lambda x: weekday[x]
)
draw_candle_stick(stock_data_gb_week, &quot;weekday&quot;)

stock_data_gb_month = stock_data.groupby([&quot;month&quot;]).mean().reset_index()
month = [f&quot;{i}月&quot; for i in range(0, 13)]
stock_data_gb_month[&quot;month&quot;] = stock_data_gb_month[&quot;month&quot;].apply(lambda x: month[x])
draw_candle_stick(stock_data_gb_month, &quot;month&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ema-楊雲翔"><a class="header" href="#ema-楊雲翔">EMA 楊雲翔</a></h2>
<pre><code class="language-python">import yfinance as yf
import pandas as pd

def ema(data, period, N=2):
    &quot;&quot;&quot;
    計算 EMA（指數移動平均）指標
    :param data: 包含價格數據的 Pandas DataFrame
    :param period: EMA 的時間週期
    :return: 包含 EMA 指標數據的 Pandas Series
    &quot;&quot;&quot;
    # 計算平滑因子
    alpha = N / (period + 1)

    # 計算首個 EMA 值
    ema = data['Close'].ewm(alpha=alpha, adjust=False).mean()

    # 計算後續 EMA 值
    for i in range(1, len(data)):
        ema[i] = alpha * data['Close'][i] + (1 - alpha) * ema[i - 1]

    return ema

# 獲取股票數據
symbol = 'AAPL'  # 股票代碼
start_date = '2021-01-01'  # 開始日期
end_date = '2021-12-31'  # 結束日期
data = yf.download(symbol, start=start_date, end=end_date)

# 計算 EMA 指標
data['N2'] = ema(data, 10)
data['N1'] = ema(data, 10, 1)

# 輸出結果
print(data)
</code></pre>
<h2 id="統計大盤每年平均日k振幅"><a class="header" href="#統計大盤每年平均日k振幅">統計大盤每年平均日K振幅</a></h2>
<pre><code class="language-python">import yfinance as yf
import pandas as pd

# Fetch the TWSE index
twse = yf.Ticker(&quot;^TWII&quot;)

# Get the historical data for the longest possible time
history = twse.history(period=&quot;max&quot;)

# Calculate the daily range
history[&quot;Range&quot;] = history[&quot;High&quot;] - history[&quot;Low&quot;]

# Group the data by year and calculate the average daily range
yearly_adr = history.groupby(pd.Grouper(freq=&quot;Y&quot;))[&quot;Range&quot;].mean()

# Print the yearly ADR
print(yearly_adr)
</code></pre>
<h2 id="統計假突破次數"><a class="header" href="#統計假突破次數">統計假突破次數</a></h2>
<pre><code class="language-python">'''
統計假突破次數的方法因策略而異，以下提供一個假設進場條件的範例：

假設在 5 日均線上，且 5 日均線上穿 20 日均線時買進，其他時間賣出。
接下來我們將 K 線資料與以 5 日、20 日為週期的均線做比較，並建立一個叫做假突破的佈林通道，當價格穿越了假突破的通道時，就表示有一個假突破信號。 通道的計算方式為：
上通道：上一期假突破的最高價+1.5*(上一期假突破的最高價-上一期假突破的最低價)
下通道：上一期假突破的最低價-1.5*(上一期假突破的最高價-上一期假突破的最低價)
當發現股價穿越了假突破區間時，即可記錄一次假突破。
'''
import numpy as np
import pandas as pd
import yfinance as yf

# 下載開高低收成交量（ohlcv）資料
symbol = 'AAPL' # 蘋果公司
ohlcv = yf.download(symbol, start=&quot;2016-01-01&quot;, end=&quot;2021-11-17&quot;)

# 設定進場和出場訊號
ohlcv['ma5'] = ohlcv['Close'].rolling(window=5).mean()
ohlcv['ma20'] = ohlcv['Close'].rolling(window=20).mean()

ohlcv[&quot;in_signal&quot;] = np.where(ohlcv['ma5'] &gt; ohlcv['ma20'].shift(1), 1, 0)
ohlcv[&quot;out_signal&quot;] = np.where(ohlcv['ma5'] &lt;= ohlcv['ma20'].shift(1), 1, 0)

# 設定假突破的條件
ohlcv_in = ohlcv[ohlcv['in_signal'] == 1]
ohlcv_out = ohlcv[ohlcv['out_signal'] == 1]

fake_breakout_upper = np.nan
fake_breakout_lower = np.nan

fake_breakout_upper_list = []
fake_breakout_lower_list = []
in_signal_flag = False

for date, row in ohlcv.iterrows():
    if in_signal_flag:
        if row['High'] &gt; fake_breakout_upper:
            fake_breakout_upper = row['High']
        if row['Low'] &lt; fake_breakout_lower:
            fake_breakout_lower = row['Low']
        
        if row['Low'] &lt;= fake_breakout_lower and row['Close'] &gt; fake_breakout_lower and not np.isnan(fake_breakout_lower):
            fake_breakout_upper_list.append(fake_breakout_upper)
            fake_breakout_lower_list.append(fake_breakout_lower)
            
            fake_breakout_upper = np.nan
            fake_breakout_lower = np.nan
            
            in_signal_flag = False
            
    else:
        if date in ohlcv_in.index:
            fake_breakout_upper = row['High']
            fake_breakout_lower = row['Low']
            in_signal_flag = True
            
counts = len(fake_breakout_upper_list)

print(f&quot;假突破次數: {counts}&quot;)
</code></pre>
<h1 id="how-to-implement-a-grid-trading-strategy-python-tutorial"><a class="header" href="#how-to-implement-a-grid-trading-strategy-python-tutorial">How to implement a Grid Trading Strategy (Python Tutorial)</a></h1>
<p>https://medium.com/@chris_42047/how-to-implement-a-grid-trading-strategy-python-tutorial-338b38fc5e84</p>
<pre><code class="language-python">from pandas.tseries.holiday import USFederalHolidayCalendar
from pandas.tseries.offsets import CustomBusinessDay

US_BUSINESS_DAY = CustomBusinessDay(calendar=USFederalHolidayCalendar())
from pandas.tseries.holiday import USFederalHolidayCalendar
from pandas.tseries.offsets import CustomBusinessDay

US_BUSINESS_DAY = CustomBusinessDay(calendar=USFederalHolidayCalendar())
import pandas as pd
from backtesting import Strategy
from backtesting import Backtest
import pandas_ta as ta
import yfinance as yf
import plotly.graph_objects as go
from plotly.subplots import make_subplots


def CHOP(df, chop_len, atr_len):
    #  Calculate Choppiness
    chop_series = ta.chop(
        high=df[&quot;High&quot;],
        low=df[&quot;Low&quot;],
        close=df[&quot;Close&quot;],
        length=chop_len,
        atr_length=atr_len,
    )
    return chop_series


def plot_chart(
    i, symbol, df, current_price, buy_grid, sell_grid, buy_stop_loss, sell_stop_loss
):
    light_palette = {}
    light_palette[&quot;bg_color&quot;] = &quot;#ffffff&quot;
    light_palette[&quot;plot_bg_color&quot;] = &quot;#ffffff&quot;
    light_palette[&quot;grid_color&quot;] = &quot;#e6e6e6&quot;
    light_palette[&quot;text_color&quot;] = &quot;#2e2e2e&quot;
    light_palette[&quot;dark_candle&quot;] = &quot;black&quot;
    light_palette[&quot;light_candle&quot;] = &quot;steelblue&quot;
    light_palette[&quot;volume_color&quot;] = &quot;#c74e96&quot;
    light_palette[&quot;border_color&quot;] = &quot;#2e2e2e&quot;
    light_palette[&quot;color_1&quot;] = &quot;#5c285b&quot;
    light_palette[&quot;color_2&quot;] = &quot;#802c62&quot;
    light_palette[&quot;color_3&quot;] = &quot;#a33262&quot;
    light_palette[&quot;color_4&quot;] = &quot;#c43d5c&quot;
    light_palette[&quot;color_5&quot;] = &quot;#de4f51&quot;
    light_palette[&quot;color_6&quot;] = &quot;#f26841&quot;
    light_palette[&quot;color_7&quot;] = &quot;#fd862b&quot;
    light_palette[&quot;color_8&quot;] = &quot;#ffa600&quot;
    light_palette[&quot;color_9&quot;] = &quot;#3366d6&quot;
    palette = light_palette
    #  Array of colors for support/resistance lines
    buy_grid_colors = [&quot;#e28743&quot;, &quot;#e28743&quot;, &quot;#e28743&quot;, &quot;#e28743&quot;, &quot;#e28743&quot;]
    sell_grid_colors = [&quot;#2596be&quot;, &quot;#2596be&quot;, &quot;#2596be&quot;, &quot;#2596be&quot;, &quot;#2596be&quot;]
    #  Create sub plots
    fig = make_subplots(
        rows=1,
        cols=1,
        subplot_titles=[f&quot;{i} {symbol} Chart&quot;,],
        specs=[[{&quot;secondary_y&quot;: False}]],
        vertical_spacing=0.04,
        shared_xaxes=True,
    )
    #  Plot close price
    fig.add_trace(
        go.Scatter(
            x=df.index, y=df[&quot;Close&quot;], line=dict(color=&quot;blue&quot;, width=1), name=f&quot;Close&quot;
        ),
        row=1,
        col=1,
    )
    #  Current price
    fig.add_hline(
        y=current_price,
        line_width=0.6,
        line_dash=&quot;solid&quot;,
        line_color=&quot;blue&quot;,
        row=1,
        col=1,
    )
    #  Add buy and sell grids
    i = 0
    for level in buy_grid:
        line_color = (
            buy_grid_colors[i] if i &lt; len(buy_grid_colors) else buy_grid_colors[0]
        )
        fig.add_hline(
            y=level,
            line_width=0.6,
            line_dash=&quot;dash&quot;,
            line_color=line_color,
            row=1,
            col=1,
        )
        i += 1
    #  stop loss
    fig.add_hline(
        y=buy_stop_loss,
        line_width=0.6,
        line_dash=&quot;solid&quot;,
        line_color=&quot;red&quot;,
        row=1,
        col=1,
    )
    i = 0
    for level in sell_grid:
        line_color = (
            sell_grid_colors[i] if i &lt; len(sell_grid_colors) else sell_grid_colors[0]
        )
        fig.add_hline(
            y=level, line_width=1, line_dash=&quot;dash&quot;, line_color=line_color, row=1, col=1
        )
        i += 1
    #  stop loss
    fig.add_hline(
        y=sell_stop_loss,
        line_width=1,
        line_dash=&quot;solid&quot;,
        line_color=&quot;red&quot;,
        row=1,
        col=1,
    )
    fig.update_layout(
        title={&quot;text&quot;: &quot;&quot;, &quot;x&quot;: 0.5},
        font=dict(family=&quot;Verdana&quot;, size=12, color=palette[&quot;text_color&quot;]),
        autosize=True,
        width=1280,
        height=720,
        xaxis={&quot;rangeslider&quot;: {&quot;visible&quot;: False}},
        plot_bgcolor=palette[&quot;plot_bg_color&quot;],
        paper_bgcolor=palette[&quot;bg_color&quot;],
    )
    fig.update_yaxes(visible=False, secondary_y=True)
    #  Change grid color
    fig.update_xaxes(
        showline=True,
        linewidth=1,
        linecolor=palette[&quot;grid_color&quot;],
        gridcolor=palette[&quot;grid_color&quot;],
    )
    fig.update_yaxes(
        showline=True,
        linewidth=1,
        linecolor=palette[&quot;grid_color&quot;],
        gridcolor=palette[&quot;grid_color&quot;],
    )
    file_name = f&quot;{i}_{symbol}_grid_trading_1.png&quot;
    fig.write_image(file_name, format=&quot;png&quot;)
    return fig


class GridStrategy(Strategy):
    chop_len = 14
    atr_len = 1
    num_grid_lines = 5  #  number of grid lines for buy/sell
    grid_interval = 10 / 10000  # 10 pips, 50 pips, or 100 pips or whatever
    take_profit_interval = 20 / 10000  #  pips
    stop_loss_interval = 10 / 10000  # pips
    buy_grid_prices = []
    sell_grid_prices = []
    executed_buy_grid_prices = []
    executed_sell_grid_prices = []
    last_purchase_price = 0
    long_hold = 0
    short_hold = 0
    buy_stop_loss_price = 0
    sell_stop_loss_price = 0
    grid_in_progress = False
    grid_start_index = 0  #  time index when grid starts
    grid_max_interval = 2000  #  max time steps to run the grid
    i = 0

    def init(self):
        super().init()
        #  Calculate indicators
        self.chop = self.I(CHOP, self.data.df, self.chop_len, self.atr_len)

    def reset_grid(self):
        self.grid_in_progress = False
        self.buy_grid_prices = []
        self.sell_grid_prices = []
        self.grid_start_index = 0
        self.buy_stop_loss_price = 0
        self.sell_stop_loss_price = 0

    def next(self):
        super().init()
        self.i += 1
        #  Check ranging or trending markets
        is_ranging = False
        if self.chop[-1] &gt; 50 and self.chop[-2] &lt;= 50:
            is_ranging = True
        #  Set up new grid for ranging -&gt; against the trend
        current_price = self.data.Close[-1]
        if not self.grid_in_progress and is_ranging:
            self.reset_grid()
            self.grid_in_progress = True
            self.grid_start_index = self.i
            #  Stop loss
            buy_stop_loss = (
                current_price
                - (self.num_grid_lines * self.grid_interval)
                - self.stop_loss_interval
            )
            sell_stop_loss = (
                current_price
                + (self.num_grid_lines * self.grid_interval)
                + self.stop_loss_interval
            )
            #  Set buy/sell grid prices
            for i in range(1, self.num_grid_lines + 1):
                #  Calculate buy grid price
                grid_buy_price = current_price - (i * self.grid_interval)
                buy_take_profit = grid_buy_price + self.take_profit_interval
                self.buy_grid_prices.append(grid_buy_price)
                #  Create buy order
                self.buy(
                    size=0.1, limit=grid_buy_price, sl=buy_stop_loss, tp=buy_take_profit
                )
                #  Calculate sell grid price
                grid_sell_price = current_price + (i * self.grid_interval)
                sell_take_profit = grid_sell_price - self.take_profit_interval
                self.sell_grid_prices.append(grid_sell_price)
                #  Create sell order
                self.sell(
                    size=0.1,
                    limit=grid_sell_price,
                    sl=sell_stop_loss,
                    tp=sell_take_profit,
                )
            #  Optional - Plot the grid
            # plot_chart(self.i, symbol, df, current_price, self.buy_grid_prices, self.sell_grid_prices, buy_stop_loss, sell_stop_loss)


def run_backtest(df):
    # If exclusive orders (each new order auto-closes previous orders/position),
    # cancel all non-contingent orders and close all open trades beforehand
    bt = Backtest(
        df,
        GridStrategy,
        cash=10000,
        commission=0.00075,
        trade_on_close=True,
        exclusive_orders=False,
        hedging=False,
    )
    stats = bt.run()
    print(stats)
    bt.plot()


# MAIN
if __name__ == &quot;__main__&quot;:
    symbol = &quot;EURUSD=X&quot;
    #  Download data
    # intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo
    interval = &quot;1m&quot;
    #  periods:  1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max
    data = yf.download(tickers=symbol, period=&quot;5d&quot;, interval=interval)
    df = pd.DataFrame(data)
    df.dropna(inplace=True)
    df.reset_index(inplace=True)
    #  Run backtest
    run_backtest(df)
</code></pre>
<hr />
<h2 id="td-ameritrade-api"><a class="header" href="#td-ameritrade-api">TD Ameritrade API</a></h2>
<pre><code class="language-py">import requests
import datetime
import pandas as pd

apikey = &quot;&quot;
url = &quot;https://api.tdameritrade.com/v1/marketdata/hours&quot;
payload = {&quot;apikey&quot;: apikey, &quot;markets&quot;: &quot;EQUITY&quot;}
response = requests.get(url=url, params=payload)
data = response.json()
print(data)
</code></pre>
<hr />
<h1 id="網格買賣單數量計算"><a class="header" href="#網格買賣單數量計算">網格買/賣單數量計算</a></h1>
<ul>
<li>
<p>base_diff_ratio :</p>
<ul>
<li>此值動態計算得到, 如果大於1則設定為1 </li>
<li>網格預估需要的base數量與實際外站能買到base數量比例 </li>
<li>ex: 網格預估5顆 但實際外站買到4.5顆, - base_diff_ratio = (4.5 / 5) = 0.9</li>
</ul>
</li>
<li>
<p>各價位點計算</p>
</li>
</ul>
<pre><code class="language-py">def round_to_rule(value: float, rule: str) -&gt; float:
    return round(value, int(rule))


def round_to_rule_floor(n, decimals=0):
    multiplier = 10 ** int(decimals)
    return math.floor(n * multiplier) / multiplier

# 網格間距
grid_step = round_to_rule_floor((upper_limit - lower_limit) / float(grid_count), quotePrecision) 

price_points = []
price_points.append(upper_limit)
while True:
    price_point = round_to_rule(price_points[-1] - grid_step, quotePrecision)

    if upper_limit &gt;= price_point and price_point &gt;= lower_limit:
        price_points.append(price_point)

    if price_point &lt;= lower_limit:
        print(f&quot;各價位點:{price_points}&quot;)
        break

</code></pre>
<h2 id="全買單--現價--上限"><a class="header" href="#全買單--現價--上限">全買單  (現價 &gt; 上限)</a></h2>
<p><code>註: 全買單沒有站外買幣需要因此 base_diff_ratio 固定為1</code></p>
<pre><code>current_price = 658990 
capital = 1000 
grid_count = 2 
upper_limit = 4 
lower_limit = 1 
base_diff_ratio = 1
</code></pre>
<pre><code># capital = capital * base_diff_ratio * 0.998;  
1000 * 1 * 0.998 = 998

# grid_position = capital / (SUM(各價位點, 不包含最下面那格)  
round(998 / (4+3+2), 8) = 110.88888888888889

# fee = (grid_position * 最高價 * 0.002 * grid_count) + (1 * grid_count) 
(110.88888888888889 * 4 * 0.002 * 2) + (1 * 2) = 3.774222222222222

# capital = capital - fee  
(998 - 3.774222222222222) = 994.2257777777778

# grid_position = capital / (SUM(各價位點, 不包含最下面那格)  
round(994.2257777777778 / (4+3+2), 8) = 110.46953086
</code></pre>
<h2 id="全賣單--現價--下限"><a class="header" href="#全賣單--現價--下限">全賣單  現價 &lt; 下限</a></h2>
<p><code>註: 全賣單會先預扣買單所需要手續費 </code></p>
<pre><code>current_price = 658990 
capital = 1000 
grid_count = 2 
upper_limit = 800000 
lower_limit = 700000 
base_diff_ratio = 1.0894263392162356
</code></pre>
<pre><code># grid_position = capital / (SUM(各價位點, 不包含最下面那格) 
round(1000 / (800000 + 750000), 8) = 0.00064516

# fee = (grid_position * 最高價 * 0.002 * grid_count) + (1 * grid_count)  
(0.00064516 * 800000 * 0.002 * 2) + (1 * 2) = 4.064512000000001

# capital = (capital - fee) * 1 * 0.998;    # base_diff_ratio 大於1則設定為1
(1000 - 4.064512000000001) * 1 * 0.998 = 993.943617024

# grid_position = capital / (SUM(各價位點, 不包含最下面那格) 
round(993.943617024 / (800000 + 750000), 8) = 0.00064125
</code></pre>
<h2 id="部份買單部份賣單-上限-現價-下限"><a class="header" href="#部份買單部份賣單-上限-現價-下限">部份買單部份賣單 (上限&gt; 現價 &gt;下限)</a></h2>
<pre><code>current_price = 658990 
capital = 1000 
grid_count = 2 
upper_limit = 800000 
lower_limit = 600000 
base_diff_ratio = 0.86
</code></pre>
<pre><code># capital = capital * base_diff_ratio * 0.998
(1000 * 0.86 * 0.998) = 858.28

# grid_position = capital / (SUM(各價位點, 不包含最下面那格)  
round(858.28 / (800000 + 700000), 8) = 0.00057219

# fee = (grid_position * 最高價 * 0.002 * grid_count) + (1 * grid_count) 
(0.00057219 * 800000 * 0.002 * 2) + (1 * 2) = 3.8310079999999997

# capital = capital - fee  
(858.28 - 3.8310079999999997) = 854.448992

# grid_position = capital / (SUM(各價位點, 不包含最下面那格)
round(854.448992 / (800000 + 700000), 8) = 0.00056963
</code></pre>
<h1 id="網格顆數計算"><a class="header" href="#網格顆數計算">網格顆數計算</a></h1>
<pre><code class="language-py">import math


def round_to_rule(value: float, rule: str) -&gt; float:
    return round(value, int(rule))


def round_to_rule_floor(n, decimals=0):
    multiplier = 10 ** int(decimals)
    return math.floor(n * multiplier) / multiplier


def get_fee(upper_limit, lower_limit, grid_count, basePrecision, quotePrecision):
    price_points = []
    grid_step = round_to_rule_floor(
        (upper_limit - lower_limit) / float(grid_count), quotePrecision
    )
    print(f&quot;grid step:{grid_step}&quot;)
    price_points.append(upper_limit)
    while True:
        price_point = round_to_rule(price_points[-1] - grid_step, quotePrecision)

        if upper_limit &gt;= price_point and price_point &gt;= lower_limit:
            price_points.append(price_point)

        if price_point &lt;= lower_limit:
            print(f&quot;各價位點:{price_points}&quot;)
            break

    # round(998 / (200000+ 160080.0+ 120160.0+ 80240.0+ 40320.0), 8) = 0.00166112
    grid_position = round_to_rule(capital / sum(price_points[:-1]), basePrecision)
    # print(grid_position)
    return (
        (grid_position * price_points[0] * 0.002 * grid_count) + (1 * grid_count),
        price_points,
    )


def get_grid_position(
    capital, upper_limit, lower_limit, grid_count, basePrecision, quotePrecision
):
    fee, price_points = get_fee(
        upper_limit, lower_limit, grid_count, basePrecision, quotePrecision
    )
    # 資金扣除預留手續費
    # 998 - ((0.0016611185086551265 * 200000 * 0.002 * 5) + (1+5)) = 988.6777629826897
    if current_price &lt; lower_limit:
        fee = 0

    print(f&quot;get_grid_position fee:{fee}&quot;)
    capital = capital - fee
    print(f&quot;扣除手續費後的資金:{capital}&quot;)

    # 扣掉預留費用，每格該下的btc數量，之後下單以這個為準
    grid_position = round_to_rule(capital / sum(price_points[:-1]), basePrecision)
    return grid_position


if __name__ == &quot;__main__&quot;:
    current_price = # Test Log - base price bitopro
    capital = 1000
    grid_count = 2
    upper_limit = 800000
    lower_limit = 600000
    base_diff_ratio = # Test Log - base difference ratio
    basePrecision = 8
    quotePrecision = 0
    fee = 0

    # 目前價格小於網格最低價
    if current_price &lt; lower_limit:
        fee, _ = get_fee(
            upper_limit, lower_limit, grid_count, basePrecision, quotePrecision
        )

    if base_diff_ratio &gt; 1.0:
        capital = (capital - fee) * 0.998
    else:
        capital = (capital - fee) * base_diff_ratio * 0.998

    print(f&quot;capital:{capital}, fee:{fee}&quot;)
    grid_position = get_grid_position(
        capital, upper_limit, lower_limit, grid_count, basePrecision, quotePrecision
    )
    print(f&quot;grid position:{grid_position}&quot;)
</code></pre>
<h2 id="defillama"><a class="header" href="#defillama">DeFiLlama</a></h2>
<pre><code class="language-py">from defillama import DefiLlama
import json

import requests

# initialize api client
llama = DefiLlama()

# Get all protocols data
response = llama.get_all_protocols()
#print(response, type(response[0]))
print(json.dumps(response[0], indent=4, ensure_ascii=False))

# Get a protocol data
response = llama.get_protocol(name='uniswap')
print(json.dumps(response, indent=4, ensure_ascii=False))

# Get historical values of total TVL
response = llama.get_historical_tvl()
print(json.dumps(response[0], indent=4, ensure_ascii=False))

# Get protocol TVL
response = llama.get_protocol_tvl(name='uniswap')
print(json.dumps(response, indent=4, ensure_ascii=False))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="multicharts用斜率角度linearregangle定義趨勢變化"><a class="header" href="#multicharts用斜率角度linearregangle定義趨勢變化">MultiCharts用「斜率」/「角度(LinearRegAngle)」定義趨勢變化</a></h2>
<p>https://www.pfcf.com.tw/featured/detail/2010</p>
<h4 id="線性回歸"><a class="header" href="#線性回歸">線性回歸</a></h4>
<p>首先讀者要稍微回憶一下中學數學--線性回歸(linear regression)，可自行GOOGLE相關資料，不想花時間知其所以然，也沒關係，直接往下讀也不難上手應用。</p>
<p>透過線性回歸計算，我們可以把某個區間的價格(例如過去5根K棒收盤價)計算其線性關係，如下圖所示，θ即是這條線與Y軸的角度，m斜率即是度量y與x變動比率。無論角度或斜率，在Powerlanguage都有內建函式可供直接引用計算。</p>
<p><a href="https://2.bp.blogspot.com/-u0yXfr_5zIg/XJ-QDdc5EmI/AAAAAAAACNM/Rrg8V0v8Tuk6BpA1Fs0TFkGWTOQOEUWXwCLcBGAs/s1600/Multicharts_%E6%96%9C%E7%8E%87%E8%A7%92%E5%BA%A6201903001.jpg"><img src="strategy/images/5cde19d52121a1335C19B2368D4A4D9E0631C6F3DF4D920190517101757.png" alt="img" /></a></p>
<h4 id="-4"><a class="header" href="#-4"></a></h4>
<h4 id="角度linearregangle"><a class="header" href="#角度linearregangle">角度(LinearRegAngle)</a></h4>
<p>行情強勢多頭，漲勢就會越接近90度，反之，行情重挫，下跌的角度就會接近-90度，很多人以為是要用斜率來表達價格趨勢的變化，其實用角度更為直觀。我們用LinearRegAngle這個函式可計算出角度：</p>
<p>LinearRegAngle(Price, Len)</p>
<p>例如我們想表達上漲強度變強，也就是角度越來越陡，PowerLanguage我們可以這樣寫：</p>
<p><em>Value1= LinearRegAngle(close, 5);</em>
<em>Condition1=Value1&gt;Value1[1];</em></p>
<p>意即，我們計算出最近5根K棒收盤價的線性角度，然後比較前一個角度，變大就代表角度變陡。因為單算收盤價的線性回歸往往變動太大反而難以定向趨勢，可以用均線來平滑取而代之，如下：</p>
<p><em>Value1=Average(close,5);</em>
<em>Value2= LinearRegAngle(Value1, 5);</em>
<em>Condition1=Value2&gt;Value2[1] and Value2&gt;60;</em></p>
<p>如上，我們可以再多指定一個閥值，例如60度，角度上升且大於60度，定義出行情為強勢多頭。也有人再深入，就進到微積分的領域了。</p>
<h4 id="斜率linearregslope"><a class="header" href="#斜率linearregslope">斜率(LinearRegSlope)</a></h4>
<p>如前面所言，我們想表達(趨勢)斜率變陡或變平，我們其實想要的是角度而非斜率，或者說採用角度(LinearRegAngle)是比較值觀好用的，當然如果你堅持要用斜率也無不可，用法與上面角度一樣，斜率函式為：</p>
<p>LinearRegSlope(Price, Len)</p>
<h4 id="結論與後記"><a class="header" href="#結論與後記">結論與後記</a></h4>
<p>其實我們都知道市場價格非線性，橫豎也回歸不出來，卻使用從線性回歸得出的角度或斜率似乎有些矛盾弔詭，不過無妨，這樣的運用提供我們一個量化且具體的數字跟邏輯，仍有其價值。在MultiCharts裡尚有Linear Reg Curve這個指標，主要是用到LinearRegValue這個函式，可以根據線性回歸公式算出目前甚至未來的”理論”價格，這類預測價格的做法，實務價值反而就不大了。</p>
<hr />
<pre><code class="language-python">#!/usr/bin/env python
# coding: utf-8

# # Algo Trad Pipeline
# &gt; A basic example of a algo trading pipeline with data fetch, strategy, backtest and online trading.
# 
# - toc: true 
# - badges: true
# - comments: true
# - categories: [jupyter]
# 

# ### Install dependence &amp; init setting

# In[ ]:


pip install cryptota -U


# In[ ]:


# INIT
# Fetch data setting
CRYPTO    = &quot;ADAUSDT&quot;
START     = '7 day ago UTC'
END       = 'now UTC'
INTERVAL  = '1m'
# trading strategy parameter
PARAMETER = { &quot;initial_state&quot;: 1, &quot;delay&quot;: 500, &quot;initial_money&quot;: 100,&quot;max_buy&quot;:10, &quot;max_sell&quot;:10 }
# binance api key and secret
APIKEY    = &quot;&quot;
APISECRET = &quot;&quot;


# In[ ]:


import cryptota
import vectorbt as vbt
import numpy as np
from binance import Client, ThreadedWebsocketManager, ThreadedDepthCacheManager
import matplotlib.pyplot as plt
import time
from datetime import timedelta

client = Client(APIKEY,APISECRET)


# In[ ]:


UNITS = {&quot;s&quot;:&quot;seconds&quot;, &quot;m&quot;:&quot;minutes&quot;, &quot;h&quot;:&quot;hours&quot;, &quot;d&quot;:&quot;days&quot;, &quot;w&quot;:&quot;weeks&quot;}

def convert_to_seconds(s):
    count = int(s[:-1])
    unit = UNITS[ s[-1] ]
    td = timedelta(**{unit: count})
    return td.seconds + 60 * 60 * 24 * td.days


# ### Fetch data

# In[ ]:


binance_data = vbt.BinanceData.download(
    CRYPTO,
    start=START,
    end=END,
    interval=INTERVAL
)


# In[ ]:


price = binance_data.get()


# In[ ]:


price


# ### Get technology analysis feature

# In[ ]:


ta = cryptota.TA_Features()
df_full = ta.get_all_indicators(price.copy())


# In[ ]:


df_full


# ### Purpose a strategy

# In[ ]:


def buy_stock(
    real_movement,
    delay = 5,
    initial_state = 1,
    initial_money = 10000,
    max_buy = 1,
    max_sell = 1,
    print_log=True
):
    &quot;&quot;&quot;
    real_movement = actual movement in the real world
    delay = how much interval you want to delay to change our decision from buy to sell, vice versa
    initial_state = 1 is buy, 0 is sell
    initial_money = 1000, ignore what kind of currency
    max_buy = max quantity for share to buy
    max_sell = max quantity for share to sell
    &quot;&quot;&quot;
    starting_money = initial_money
    delay_change_decision = delay
    current_decision = 0
    state = initial_state
    current_val = real_movement[0]
    states_sell = []
    states_buy = []
    states_entry = []
    states_exit = []
    current_inventory = 0

    def buy(i, initial_money, current_inventory):
        shares = initial_money // real_movement[i]
        if shares &lt; 1:
            if print_log:
                print(
                    'day %d: total balances %f, not enough money to buy a unit price %f'
                    % (i, initial_money, real_movement[i])
                )
        else:
            if shares &gt; max_buy:
                buy_units = max_buy
            else:
                buy_units = shares
            initial_money -= buy_units * real_movement[i]
            current_inventory += buy_units
            if print_log:
                print(
                    'day %d: buy %d units at price %f, total balance %f'
                    % (i, buy_units, buy_units * real_movement[i], initial_money)
                )
            states_buy.append(0)
        return initial_money, current_inventory

    if state == 1:
        initial_money, current_inventory = buy(
            0, initial_money, current_inventory
        )

    for i in range(0, real_movement.shape[0], 1):
        sentry = False
        sexit = False
        if real_movement[i] &lt; current_val and state == 0:
            if current_decision &lt; delay_change_decision:
                current_decision += 1
            else:
                state = 1
                initial_money, current_inventory = buy(
                    i, initial_money, current_inventory
                )
                current_decision = 0
                states_buy.append(i)
                sentry = True
                
        if real_movement[i] &gt; current_val and state == 1:
            if current_decision &lt; delay_change_decision:
                current_decision += 1
            else:
                state = 0

                if current_inventory == 0:
                    if print_log:
                        print('day %d: cannot sell anything, inventory 0' % (i))
                else:
                    if current_inventory &gt; max_sell:
                        sell_units = max_sell
                    else:
                        sell_units = current_inventory
                    current_inventory -= sell_units
                    total_sell = sell_units * real_movement[i]
                    initial_money += total_sell
                    try:
                        invest = (
                            (real_movement[i] - real_movement[states_buy[-1]])
                            / real_movement[states_buy[-1]]
                        ) * 100
                    except:
                        invest = 0
                    if print_log:
                        print(
                            'day %d, sell %d units at price %f, investment %f %%, total balance %f,'
                            % (i, sell_units, total_sell, invest, initial_money)
                        )

                current_decision = 0
                states_sell.append(i)
                sexit = True
        states_entry.append(sentry)
        states_exit.append(sexit)
        current_val = real_movement[i]
        
    invest = ((initial_money - starting_money) / starting_money) * 100
    total_gains = initial_money - starting_money
    return states_buy, states_sell,states_entry,states_exit, total_gains, invest


# ### Backtest

# In[ ]:


states_buy, states_sell, states_entry, states_exit, total_gains, invest = buy_stock(df_full.close,**PARAMETER)


# In[ ]:


close = df_full['close']
fig = plt.figure(figsize = (15,5))
plt.plot(close, color='r', lw=2.)
plt.plot(close, '^', markersize=10, color='m', label = 'buying signal', markevery = states_buy)
plt.plot(close, 'v', markersize=10, color='k', label = 'selling signal', markevery = states_sell)
plt.legend()
plt.show()


# In[ ]:


fees = 0.001
try:
  fees = client.get_trade_fee(symbol=CRYPTO)[0]['makerCommission']
except:
  pass


# In[ ]:


portfolio_kwargs = dict(size=np.inf, fees=float(fees), freq=INTERVAL)
portfolio = vbt.Portfolio.from_signals(df_full['close'], states_entry, states_exit, **portfolio_kwargs)


# In[ ]:


portfolio.plot().show()


# In[ ]:


portfolio.stats()


# ### Online

# In[ ]:


info = client.get_symbol_info(CRYPTO)
info


# In[ ]:


while True: 
    binance_data = binance_data.update()
    price = binance_data.get()

    states_buy, states_sell, states_entry, states_exit, total_gains, invest = buy_stock(price.Close, 
                                                                                        initial_state = 1, 
                                                                                        delay = 10, 
                                                                                        initial_money = 1,
                                                                                        max_buy=1,
                                                                                        max_sell=1,
                                                                                        print_log=False)

    states_entry[-1],states_exit[-1]
    
    if not (states_entry[-1] or states_exit[-1]):
        print(&quot;doing_noting&quot;)
    if states_entry[-1]:
        order = client.create_test_order( ## use test_order for real~
        symbol='ADAUSDT',
        side=Client.SIDE_BUY,
        type=Client.ORDER_TYPE_MARKET,
        quantity=8)
        print(&quot;buy&quot;,order)
    if states_exit[-1]:
        order = client.create_test_order( ## use test_order for real~
        symbol='ADAUSDT',
        side=Client.SIDE_BUY,
        type=Client.ORDER_TYPE_MARKET,
        quantity=8)
        print(&quot;sell&quot;,order)
    
    time.sleep(convert_to_seconds(INTERVAL))

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="python的grpc"><a class="header" href="#python的grpc">Python的gRPC</a></h2>
<p>Python的gRPC可以幫助你將不同的參數映射到不同的策略類別。對於介面包含初始化參數的問題，你可以考慮使用類別的繼承機制。以下是一個簡單的範例：</p>
<pre><code class="language-python">class BaseStrategy:
    def __init__(self, grid_num, upper_bound, lower_bound, funds):
        self.grid_num = grid_num
        self.upper_bound = upper_bound
        self.lower_bound = lower_bound
        self.funds = funds

    def generate_grid_batch(self):
        raise NotImplementedError

    def max_profit(self):
        raise NotImplementedError

    def min_profit(self):
        raise NotImplementedError

class GridStrategy(BaseStrategy):
    def __init__(self, grid_num, upper_bound, lower_bound, funds):
        super().__init__(grid_num, upper_bound, lower_bound, funds)

    def generate_grid_batch(self):
        # 生成網格批次單
        pass

    def max_profit(self):
        # 最大利潤
        pass

    def min_profit(self):
        # 最小利潤
        pass

class AnotherStrategy(BaseStrategy):
    def __init__(self, param1, param2, funds):
        self.param1 = param1
        self.param2 = param2
        super().__init__(None, None, None, funds)

    def generate_grid_batch(self):
        # 生成網格批次單
        pass

    def max_profit(self):
        # 最大利潤
        pass

    def min_profit(self):
        # 最小利潤
        pass
</code></pre>
<p>在這個範例中，我們定義了一個<code>BaseStrategy</code>基礎類別，包含一些共同的屬性和函數，並且我們明確表示<code>generate_grid_batch()</code>，<code>max_profit()</code>和<code>min_profit()</code>需要被子類別覆寫。</p>
<p>接下來，我們定義了<code>GridStrategy</code>和<code>AnotherStrategy</code>類別，這兩個類別都繼承自<code>BaseStrategy</code>類別。<code>GridStrategy</code>類別的初始化函數接受網格數、上界、下界和資金參數，而<code>AnotherStrategy</code>類別的初始化函數接受兩個自定義的參數<code>param1</code>和<code>param2</code>，並且也需要提供資金參數。</p>
<p>透過這種方式，你可以定義任意數量的策略類別，並根據不同的情況傳遞相應的參數。當你需要使用某個策略時，只需要實例化對應的類別即可。例如：</p>
<pre><code class="language-python">strategy1 = GridStrategy(10, 100, 50, 1000)
strategy2 = AnotherStrategy(0.5, 0.1, 2000)
</code></pre>
<p>在實例化之後，你可以根據需要調用每個策略對應的方法：</p>
<pre><code class="language-python">strategy1.generate_grid_batch()
strategy1.max_profit()
strategy1.min_profit()

strategy2.generate_grid_batch()
strategy2.max_profit()
strategy2.min_profit()
</code></pre>
<p>當你需要新增其他的策略時，只需要繼承<code>BaseStrategy</code>類別，並且實現相應的方法即可。這種方式不僅讓你的程式碼更易於擴展，同時也讓你的程式碼更加可讀和可維護。</p>
<p>當使用gRPC時，你需要定義服務和消息類別，並且實現相應的方法。在這個範例中，我們定義了一個<code>StrategyService</code>服務，其中包含一個<code>GetStrategy</code>方法，用於返回一個指定策略的實例。在客戶端，我們可以通過gRPC通道將參數傳遞給服務端，並獲取相應的策略實例。</p>
<p>以下是一個簡單的範例程式碼：</p>
<pre><code class="language-protobuf"># strategy_service.proto
syntax = &quot;proto3&quot;;

package strategy;

message StrategyRequest {
  string strategy_name = 1;
  int32 grid_num = 2;
  int32 upper_bound = 3;
  int32 lower_bound = 4;
  int32 funds = 5;
}

message StrategyResponse {
  // 將策略序列化後傳回客戶端
  bytes strategy = 1;
}

service StrategyService {
  rpc GetStrategy (StrategyRequest) returns (StrategyResponse) {}
}
</code></pre>
<pre><code class="language-python"># strategy_service.py
import grpc
from concurrent import futures
import strategy_service_pb2
import strategy_service_pb2_grpc
from strategy import GridStrategy, AnotherStrategy

class StrategyServicer(strategy_service_pb2_grpc.StrategyServiceServicer):
    def GetStrategy(self, request, context):
        strategy_name = request.strategy_name
        grid_num = request.grid_num
        upper_bound = request.upper_bound
        lower_bound = request.lower_bound
        funds = request.funds

        if strategy_name == 'GridStrategy':
            strategy = GridStrategy(grid_num, upper_bound, lower_bound, funds)
        elif strategy_name == 'AnotherStrategy':
            param1 = request.param1
            param2 = request.param2
            strategy = AnotherStrategy(param1, param2, funds)
        else:
            # 錯誤處理
            pass

        # 將策略序列化
        serialized_strategy = strategy.SerializeToString()

        # 返回策略
        return strategy_service_pb2.StrategyResponse(strategy=serialized_strategy)

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    strategy_service_pb2_grpc.add_StrategyServiceServicer_to_server(StrategyServicer(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
</code></pre>
<p>在這個範例中，我們定義了一個<code>StrategyServicer</code>類別，繼承自自動生成的<code>StrategyServiceServicer</code>類別。在<code>GetStrategy</code>方法中，我們根據客戶端傳遞的參數實例化對應的策略類別，並將策略序列化後返回給客戶端。</p>
<p>在服務端啟動之後，我們需要定義客戶端程式碼，用於將參數傳遞給服務端並獲取策略實</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pine語言學習指令碼"><a class="header" href="#pine語言學習指令碼">pine語言學習指令碼</a></h2>
<pre><code class="language-sh">//@version=4
study(&quot;SMA Trend Strategy&quot;)

// 設置參數
fastLength = input(title=&quot;Fast Length&quot;, type=input.integer, defval=10)
slowLength = input(title=&quot;Slow Length&quot;, type=input.integer, defval=20)

// 計算指標
fastSMA = sma(close, fastLength)
slowSMA = sma(close, slowLength)

// 設置止盈止損
longStop = strategy.position_avg_price * (1 - 0.01)
shortStop = strategy.position_avg_price * (1 + 0.01)
longlimit = strategy.position_avg_price * (1 + 0.01)
shortlimit = strategy.position_avg_price * (1 - 0.01)

// 開倉條件
longCondition = crossover(fastSMA, slowSMA)
shortCondition = crossunder(fastSMA, slowSMA)

// 開倉
strategy.entry(&quot;Long&quot;, strategy.long, when=longCondition)
strategy.entry(&quot;Short&quot;, strategy.short, when=shortCondition)

// 止盈止損
strategy.exit(&quot;Long Stop&quot;, &quot;Long&quot;, stop=longStop,limit=longlimit)
strategy.exit(&quot;Short Stop&quot;, &quot;Short&quot;, stop=shortStop,limit=shortlimit)
</code></pre>
<h1 id="the-art-of-trading"><a class="header" href="#the-art-of-trading"><a href="https://www.youtube.com/c/TheArtofTrading">The Art of Trading</a></a></h1>
<p>https://courses.theartoftrading.com/pages/pine-script-mastery-code#strategy1</p>
<p>https://www.youtube.com/watch?v=h-erJbnBj6A&amp;feature=youtu.be</p>
<h2 id="how-to-create-a-regime-filter"><a class="header" href="#how-to-create-a-regime-filter">How To Create A Regime Filter</a></h2>
<p><a href="https://youtu.be/MV61WcTkV54">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / www.PineScriptMastery.com
// @version=5
indicator(&quot;Regime Filter&quot;)

// Get user input
res = input.timeframe(title=&quot;Timeframe&quot;, defval=&quot;D&quot;)
len = input.int(title=&quot;EMA Length&quot;, defval=20)
market = input.symbol(title=&quot;Market&quot;, defval=&quot;NASDAQ:NDX&quot;)

// Define custom security function
f_sec(_market, _res, _exp) =&gt; request.security(_market, _res, _exp[barstate.isconfirmed ? 0 : 1])

// Get EMA value
ema = ta.ema(close, len)
emaValue = f_sec(market, res, ema)

// Check if price is above or below EMA filter
marketPrice = f_sec(market, res, close)
regimeFilter = marketPrice &gt; emaValue or marketPrice[1] &gt; emaValue[1]

// Change background color
bgcolor(regimeFilter ? color.green : color.red)
</code></pre>
<h2 id="auto-fibonacci-tool"><a class="header" href="#auto-fibonacci-tool">AUTO-FIBONACCI Tool</a></h2>
<p><a href="https://youtu.be/SdYHqTlsDWo">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / PineScriptMastery.com
// @version=5
indicator(&quot;Auto-Fib&quot;, overlay=true)

// Get user input
var devTooltip          = &quot;Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot.&quot;
var depthTooltip        = &quot;The minimum number of bars that will be taken into account when calculating the indicator.&quot;
threshold_multiplier    = input.float(title=&quot;Deviation&quot;, defval=3, minval=0, tooltip=devTooltip)
depth                   = input.int(title=&quot;Depth&quot;, defval=10, minval=1, tooltip=depthTooltip)
reverse                 = input.bool(title=&quot;Reverse&quot;, defval=false, tooltip=&quot;Flips the fibonacci levels around.&quot;)
extendLeft              = input.bool(title=&quot;Extend Left    |    Extend Right&quot;, defval=false, inline=&quot;Extend Lines&quot;)
extendRight             = input.bool(title=&quot;&quot;, defval=false, inline=&quot;Extend Lines&quot;)
prices                  = input.bool(title=&quot;Show Prices&quot;, defval=false)
deleteLastLine          = input.bool(title=&quot;Delete Last Line&quot;, defval=true)
levels                  = input.bool(title=&quot;Show Levels&quot;, defval=true, inline=&quot;Levels&quot;)
levelsFormat            = input.string(title=&quot;&quot;, defval=&quot;Values&quot;, options=[&quot;Values&quot;, &quot;Percent&quot;], inline=&quot;Levels&quot;)
labelsPosition          = input.string(title=&quot;Labels Position&quot;, defval=&quot;Left&quot;, options=[&quot;Left&quot;, &quot;Right&quot;])
backgroundTransparency  = input.int(title=&quot;Background Transparency&quot;, defval=85, minval=0, maxval=100)

// Check extending parameter
var extending = extend.none
if extendLeft and extendRight
    extending := extend.both
if extendLeft and not extendRight
    extending := extend.left
if not extendLeft and extendRight
    extending := extend.right

// Calculate deviation threshold for identifying major swings
dev_threshold = ta.atr(10) / close * 100 * threshold_multiplier

// Prepare pivot variables
var line lineLast = na
var int iLast = 0
var int iPrev = 0
var float pLast = 0
var isHighLast = false // Otherwise the last pivot is a low pivot

// Custom function for detecting pivot points
pivots(src, length, isHigh) =&gt;
    l2 = length * 2
    c = nz(src[length])
    ok = true
    for i = 0 to l2
        if isHigh and src[i] &gt; c
            ok := false
        if not isHigh and src[i] &lt; c
            ok := false
    if ok
        [bar_index[length], c]
    else
        [int(na), float(na)]

// Get bar index &amp; price high/low for current pivots
[iH, pH] = pivots(high, depth / 2, true)
[iL, pL] = pivots(low, depth / 2, false)

// Custom function for calculating price deviation
calc_dev(base_price, price) =&gt; 100 * (price - base_price) / price

// Custom function for detecting pivots that meet our deviation criteria
pivotFound(dev, isHigh, index, price) =&gt;
    if isHighLast == isHigh and not na(lineLast)
        // New pivot in same direction as last, so update line (ie. trend-continuation)
        if isHighLast ? price &gt; pLast : price &lt; pLast
            line.set_xy2(lineLast, index, price)
            [lineLast, isHighLast]
        else
            [line(na), bool(na)] // No valid pivot detected, return nothing
    else // Reverse the trend/pivot direction (or create the very first line if lineLast is na)
        if math.abs(dev) &gt; dev_threshold
            // Price move is significant - create a new line between the pivot points
            id = line.new(iLast, pLast, index, price, color=color.gray, width=1, style=line.style_dashed)
            [id, isHigh]
        else
            [line(na), bool(na)]

// If bar index for current pivot high is not NA (ie. we have a new pivot):
if not na(iH)
    dev = calc_dev(pLast, pH) // Calculate the deviation from last pivot
    [id, isHigh] = pivotFound(dev, true, iH, pH)
    if not na(id) // If the line has been updated, update price values and delete previous line
        if id != lineLast and deleteLastLine
            line.delete(lineLast)
        lineLast := id
        isHighLast := isHigh
        iPrev := iLast
        iLast := iH
        pLast := pH
else 
    if not na(iL) // If bar index for current pivot low is not NA (ie. we have a new pivot):
        dev = calc_dev(pLast, pL) // Calculate the deviation from last pivot
        [id, isHigh] = pivotFound(dev, false, iL, pL)
        if not na(id) // If the line has been updated, update price values and delete previous line
            if id != lineLast and deleteLastLine
                line.delete(lineLast)
            lineLast := id
            isHighLast := isHigh
            iPrev := iLast
            iLast := iL
            pLast := pL

// Draw fibonacci level as a line and return the line object ID
draw_fib_line(price, col) =&gt;
    var id = line.new(iLast, price, bar_index, price, color=col, width=1, extend=extending)
    if not na(lineLast)
        line.set_xy1(id, line.get_x1(lineLast), price)
        line.set_xy2(id, line.get_x2(lineLast), price)  
	id  

// Draw fibonacci labels
draw_label(price, txt, txtColor) =&gt;
    x = labelsPosition == &quot;Left&quot; ? line.get_x1(lineLast) : not extendRight ? line.get_x2(lineLast) : bar_index
    labelStyle = labelsPosition == &quot;Left&quot; ? label.style_label_right : label.style_label_left
    align = labelsPosition == &quot;Left&quot; ? text.align_right : text.align_left
    labelsAlignStrLeft = txt + '\n ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏ \n'
    labelsAlignStrRight = '       ' + txt + '\n ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏ \n'
    labelsAlignStr = labelsPosition == &quot;Left&quot; ? labelsAlignStrLeft : labelsAlignStrRight
    var id = label.new(x=x, y=price, text=labelsAlignStr, textcolor=txtColor, style=labelStyle, textalign=align, color=#00000000)
    label.set_xy(id, x, price)
    label.set_text(id, labelsAlignStr)
    label.set_textcolor(id, txtColor)

// Format the given string
format(txt) =&gt; &quot; (&quot; + str.tostring(txt, &quot;#.####&quot;) + &quot;)&quot;

// Return the formatted label text for Fibonacci levels
label_txt(level, price) =&gt;
    l = levelsFormat == &quot;Values&quot; ? str.tostring(level) : str.tostring(level * 100) + &quot;%&quot;
    (levels ? l : &quot;&quot;) + (prices ? format(price) : &quot;&quot;)

// Returns true if price is crossing the given fib level
crossing_level(price, fib) =&gt; (fib &gt; price and fib &lt; price[1]) or (fib &lt; price and fib &gt; price[1])

// Get starting and ending high/low price of the current pivot (for calculating fib levels)
startPrice = reverse ? line.get_y1(lineLast) : pLast
endPrice = reverse ? pLast : line.get_y1(lineLast)

// Calculate price difference between high and low
iHL = startPrice &gt; endPrice
diff = (iHL ? -1 : 1) * math.abs(startPrice - endPrice)

// Process the given fib level (calculate fib, draw line &amp; label, detect alerts, fill bgcolor between last fib)
processLevel(show, value, colorL, lineIdOther) =&gt;
    if show
	    fibPrice = startPrice + diff * value
		lineId = draw_fib_line(fibPrice, colorL)
        draw_label(fibPrice, label_txt(value, fibPrice), colorL)
        if crossing_level(close, fibPrice) // Trigger alert if price is crossing this fib level
            alert(&quot;Autofib: &quot; + syminfo.ticker + &quot; crossing level &quot; + str.tostring(value))
        if not na(lineIdOther) // Fill background color between each fib level
            linefill.new(lineId, lineIdOther, color=color.new(colorL, backgroundTransparency))
		lineId
    else
		lineIdOther

//{=============================================================================
var g_fibs = &quot;Fibonacci Levels&quot;
// Get Fibonacci level user inputs
show_0 = input(true, &quot;&quot;, inline = &quot;Level0&quot;, group=g_fibs)
value_0 = input(0, &quot;&quot;, inline = &quot;Level0&quot;, group=g_fibs)
color_0 = input(#787b86, &quot;&quot;, inline = &quot;Level0&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_0_236 = input(true, &quot;&quot;, inline = &quot;Level0&quot;, group=g_fibs)
value_0_236 = input(0.236, &quot;&quot;, inline = &quot;Level0&quot;, group=g_fibs)
color_0_236 = input(#f44336, &quot;&quot;, inline = &quot;Level0&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_0_382 = input(true, &quot;&quot;, inline = &quot;Level1&quot;, group=g_fibs)
value_0_382 = input(0.382, &quot;&quot;, inline = &quot;Level1&quot;, group=g_fibs)
color_0_382 = input(#81c784, &quot;&quot;, inline = &quot;Level1&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_0_5 = input(true, &quot;&quot;, inline = &quot;Level1&quot;, group=g_fibs)
value_0_5 = input(0.5, &quot;&quot;, inline = &quot;Level1&quot;, group=g_fibs)
color_0_5 = input(#4caf50, &quot;&quot;, inline = &quot;Level1&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_0_618 = input(true, &quot;&quot;, inline = &quot;Level2&quot;, group=g_fibs)
value_0_618 = input(0.618, &quot;&quot;, inline = &quot;Level2&quot;, group=g_fibs)
color_0_618 = input(#009688, &quot;&quot;, inline = &quot;Level2&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_0_65 = input(false, &quot;&quot;, inline = &quot;Level2&quot;, group=g_fibs)
value_0_65 = input(0.65, &quot;&quot;, inline = &quot;Level2&quot;, group=g_fibs)
color_0_65 = input(#009688, &quot;&quot;, inline = &quot;Level2&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_0_786 = input(true, &quot;&quot;, inline = &quot;Level3&quot;, group=g_fibs)
value_0_786 = input(0.786, &quot;&quot;, inline = &quot;Level3&quot;, group=g_fibs)
color_0_786 = input(#64b5f6, &quot;&quot;, inline = &quot;Level3&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_1 = input(true, &quot;&quot;, inline = &quot;Level3&quot;, group=g_fibs)
value_1 = input(1, &quot;&quot;, inline = &quot;Level3&quot;, group=g_fibs)
color_1 = input(#787b86, &quot;&quot;, inline = &quot;Level3&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_1_272 = input(false, &quot;&quot;, inline = &quot;Level4&quot;, group=g_fibs)
value_1_272 = input(1.272, &quot;&quot;, inline = &quot;Level4&quot;, group=g_fibs)
color_1_272 = input(#81c784, &quot;&quot;, inline = &quot;Level4&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_1_414 = input(false, &quot;&quot;, inline = &quot;Level4&quot;, group=g_fibs)
value_1_414 = input(1.414, &quot;&quot;, inline = &quot;Level4&quot;, group=g_fibs)
color_1_414 = input(#f44336, &quot;&quot;, inline = &quot;Level4&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_1_618 = input(false, &quot;&quot;, inline = &quot;Level5&quot;, group=g_fibs)
value_1_618 = input(1.618, &quot;&quot;, inline = &quot;Level5&quot;, group=g_fibs)
color_1_618 = input(#2196f3, &quot;&quot;, inline = &quot;Level5&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_1_65 = input(false, &quot;&quot;, inline = &quot;Level5&quot;, group=g_fibs)
value_1_65 = input(1.65, &quot;&quot;, inline = &quot;Level5&quot;, group=g_fibs)
color_1_65 = input(#2196f3, &quot;&quot;, inline = &quot;Level5&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_2_618 = input(false, &quot;&quot;, inline = &quot;Level6&quot;, group=g_fibs)
value_2_618 = input(2.618, &quot;&quot;, inline = &quot;Level6&quot;, group=g_fibs)
color_2_618 = input(#f44336, &quot;&quot;, inline = &quot;Level6&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_2_65 = input(false, &quot;&quot;, inline = &quot;Level6&quot;, group=g_fibs)
value_2_65 = input(2.65, &quot;&quot;, inline = &quot;Level6&quot;, group=g_fibs)
color_2_65 = input(#f44336, &quot;&quot;, inline = &quot;Level6&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_3_618 = input(false, &quot;&quot;, inline = &quot;Level7&quot;, group=g_fibs)
value_3_618 = input(3.618, &quot;&quot;, inline = &quot;Level7&quot;, group=g_fibs)
color_3_618 = input(#9c27b0, &quot;&quot;, inline = &quot;Level7&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_3_65 = input(false, &quot;&quot;, inline = &quot;Level7&quot;, group=g_fibs)
value_3_65 = input(3.65, &quot;&quot;, inline = &quot;Level7&quot;, group=g_fibs)
color_3_65 = input(#9c27b0, &quot;&quot;, inline = &quot;Level7&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_4_236 = input(false, &quot;&quot;, inline = &quot;Level8&quot;, group=g_fibs)
value_4_236 = input(4.236, &quot;&quot;, inline = &quot;Level8&quot;, group=g_fibs)
color_4_236 = input(#e91e63, &quot;&quot;, inline = &quot;Level8&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_4_618 = input(false, &quot;&quot;, inline = &quot;Level8&quot;, group=g_fibs)
value_4_618 = input(4.618, &quot;&quot;, inline = &quot;Level8&quot;, group=g_fibs)
color_4_618 = input(#81c784, &quot;&quot;, inline = &quot;Level8&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_neg_0_236 = input(false, &quot;&quot;, inline = &quot;Level9&quot;, group=g_fibs)
value_neg_0_236 = input(-0.236, &quot;&quot;, inline = &quot;Level9&quot;, group=g_fibs)
color_neg_0_236 = input(#f44336, &quot;&quot;, inline = &quot;Level9&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_neg_0_382 = input(false, &quot;&quot;, inline = &quot;Level9&quot;, group=g_fibs)
value_neg_0_382 = input(-0.382, &quot;&quot;, inline = &quot;Level9&quot;, group=g_fibs)
color_neg_0_382 = input(#81c784, &quot;&quot;, inline = &quot;Level9&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_neg_0_618 = input(false, &quot;&quot;, inline = &quot;Level10&quot;, group=g_fibs)
value_neg_0_618 = input(-0.618, &quot;&quot;, inline = &quot;Level10&quot;, group=g_fibs)
color_neg_0_618 = input(#009688, &quot;&quot;, inline = &quot;Level10&quot;, group=g_fibs)
//------------------------------------------------------------------------------
show_neg_0_65 = input(false, &quot;&quot;, inline = &quot;Level10&quot;, group=g_fibs)
value_neg_0_65 = input(-0.65, &quot;&quot;, inline = &quot;Level10&quot;, group=g_fibs)
color_neg_0_65 = input(#009688, &quot;&quot;, inline = &quot;Level10&quot;, group=g_fibs)
//-----------------------------------------------------------------------------}
//{=============================================================================
// Process each fibonacci level
//==============================================================================
lineId0  = processLevel(show_neg_0_65, value_neg_0_65, color_neg_0_65, line(na))
lineId1  = processLevel(show_neg_0_618, value_neg_0_618, color_neg_0_618, lineId0)
lineId2  = processLevel(show_neg_0_382, value_neg_0_382, color_neg_0_382, lineId1)
lineId3  = processLevel(show_neg_0_236, value_neg_0_236, color_neg_0_236, lineId2)
lineId4  = processLevel(show_0, value_0, color_0, lineId3)
lineId5  = processLevel(show_0_236, value_0_236, color_0_236, lineId4)
lineId6  = processLevel(show_0_382, value_0_382, color_0_382, lineId5)
lineId7  = processLevel(show_0_5, value_0_5, color_0_5, lineId6)
lineId8  = processLevel(show_0_618, value_0_618, color_0_618, lineId7)
lineId9  = processLevel(show_0_65, value_0_65, color_0_65, lineId8)
lineId10 = processLevel(show_0_786, value_0_786, color_0_786, lineId9)
lineId11 = processLevel(show_1, value_1, color_1, lineId10)
lineId12 = processLevel(show_1_272, value_1_272, color_1_272, lineId11)
lineId13 = processLevel(show_1_414, value_1_414, color_1_414, lineId12)
lineId14 = processLevel(show_1_618, value_1_618, color_1_618, lineId13)
lineId15 = processLevel(show_1_65, value_1_65, color_1_65, lineId14)
lineId16 = processLevel(show_2_618, value_2_618, color_2_618, lineId15)
lineId17 = processLevel(show_2_65, value_2_65, color_2_65, lineId16)
lineId18 = processLevel(show_3_618, value_3_618, color_3_618, lineId17)
lineId19 = processLevel(show_3_65, value_3_65, color_3_65, lineId18)
lineId20 = processLevel(show_4_236, value_4_236, color_4_236, lineId19)
lineId21 = processLevel(show_4_618, value_4_618, color_4_618, lineId20)
//-----------------------------------------------------------------------------}
</code></pre>
<h2 id="pivots--impulsive-moves"><a class="header" href="#pivots--impulsive-moves">Pivots &amp; Impulsive Moves</a></h2>
<p><a href="https://youtu.be/5I8rLVvcbok">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / PineScriptMastery.com
// @version=5
indicator(&quot;Pivot Points&quot;, overlay=true)

// Get user input
var devTooltip          = &quot;Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot.&quot;
var depthTooltip        = &quot;The minimum number of bars that will be taken into account when analyzing pivots.&quot;
threshold_multiplier    = input.float(title=&quot;Deviation&quot;, defval=2.5, minval=0, tooltip=devTooltip)
depth                   = input.int(title=&quot;Depth&quot;, defval=10, minval=1, tooltip=depthTooltip)
deleteLastLine          = input.bool(title=&quot;Delete Last Line&quot;, defval=false)
bgcolorChange           = input.bool(title=&quot;Change BgColor&quot;, defval=false)

// Calculate deviation threshold for identifying major swings
dev_threshold = ta.atr(10) / close * 100 * threshold_multiplier

// Prepare pivot variables
var line lineLast = na
var int iLast = 0 // Index last
var int iPrev = 0 // Index previous
var float pLast = 0 // Price last
var isHighLast = false // If false then the last pivot was a pivot low

// Custom function for detecting pivot points (and returning price + bar index)
pivots(src, length, isHigh) =&gt;
    l2 = length * 2
    c = nz(src[length])
    ok = true
    for i = 0 to l2
        if isHigh and src[i] &gt; c // If isHigh, validate pivot high
            ok := false
        if not isHigh and src[i] &lt; c // If not isHigh, validate pivot low
            ok := false
    if ok // If pivot is valid, return bar index + high price value
        [bar_index[length], c]
    else // If pivot is invalid, return na
        [int(na), float(na)]

// Get bar index &amp; price high/low for current pivots
[iH, pH] = pivots(high, depth / 2, true)
[iL, pL] = pivots(low, depth / 2, false)

// Custom function for calculating price deviation for validating large moves
calc_dev(base_price, price) =&gt; 100 * (price - base_price) / price

// Custom function for detecting pivots that meet our deviation criteria
pivotFound(dev, isHigh, index, price) =&gt;
    if isHighLast == isHigh and not na(lineLast) // Check bull/bear direction of new pivot
        // New pivot in same direction as last (a pivot high), so update line upwards (ie. trend-continuation)
        if isHighLast ? price &gt; pLast : price &lt; pLast // If new pivot is above last pivot, update line
            line.set_xy2(lineLast, index, price)
            [lineLast, isHighLast]
        else
            [line(na), bool(na)] // New pivot is not above last pivot, so don't update the line
    else // Reverse the trend/pivot direction (or create the very first line if lineLast is na)
        if math.abs(dev) &gt; dev_threshold
            // Price move is significant - create a new line between the pivot points
            id = line.new(iLast, pLast, index, price, color=color.gray, width=1, style=line.style_dashed)
            [id, isHigh]
        else
            [line(na), bool(na)]

// If bar index for current pivot high is not NA (ie. we have a new pivot):
if not na(iH)
    dev = calc_dev(pLast, pH) // Calculate the deviation from last pivot
    [id, isHigh] = pivotFound(dev, true, iH, pH) // Pass the current pivot high into pivotFound() for validation &amp; line update
    if not na(id) // If the line has been updated, update price &amp; index values and delete previous line
        if id != lineLast and deleteLastLine
            line.delete(lineLast)
        lineLast := id
        isHighLast := isHigh
        iPrev := iLast
        iLast := iH
        pLast := pH
else 
    if not na(iL) // If bar index for current pivot low is not NA (ie. we have a new pivot):
        dev = calc_dev(pLast, pL) // Calculate the deviation from last pivot
        [id, isHigh] = pivotFound(dev, false, iL, pL) // Pass the current pivot low into pivotFound() for validation &amp; line update
        if not na(id) // If the line has been updated, update price values and delete previous line
            if id != lineLast and deleteLastLine
                line.delete(lineLast)
            lineLast := id
            isHighLast := isHigh
            iPrev := iLast
            iLast := iL
            pLast := pL

// Get starting and ending high/low price of the current pivot line
startIndex = line.get_x1(lineLast)
startPrice = line.get_y1(lineLast)
endIndex   = line.get_x2(lineLast)
endPrice   = line.get_y2(lineLast)

// Draw top &amp; bottom of impulsive move
topLine    = line.new(startIndex, startPrice, endIndex, startPrice, extend=extend.right, color=color.red)
bottomline = line.new(startIndex, endPrice, endIndex, endPrice, extend=extend.right, color=color.green)
line.delete(topLine[1])
line.delete(bottomline[1])
//plot(startPrice, color=color.green)
//plot(endPrice, color=color.red)

// Do what you like with these pivot values :)
// Keep in mind there will be an X bar delay between pivot price values updating based on Depth setting
dist = math.abs(startPrice - endPrice)
plot(dist, color=color.new(color.purple,100))
bullish = endPrice &gt; startPrice
offsetBG = -(depth / 2)
bgcolor(bgcolorChange ? bullish ? color.new(color.green,90) : color.new(color.red,90) : na, offset=offsetBG)
</code></pre>
<h2 id="tracking-ichimoku-base-line"><a class="header" href="#tracking-ichimoku-base-line">Tracking Ichimoku Base Line</a></h2>
<p><a href="https://youtu.be/yPiys6dJF4M">Watch Lesson</a></p>
<pre><code class="language-python">// PineScriptMastery.com
// @version=5
indicator(title=&quot;Ichimoku Cloud&quot;, shorttitle=&quot;Ichimoku&quot;, overlay=true)

// Get user input
conversionPeriods       = input.int(9, minval=1, title=&quot;Conversion Line Length&quot;)
basePeriods             = input.int(26, minval=1, title=&quot;Base Line Length&quot;)
laggingSpan2Periods     = input.int(52, minval=1, title=&quot;Leading Span B Length&quot;)
displacement            = input.int(26, minval=1, title=&quot;Lagging Span&quot;)
donchian(len)           =&gt; math.avg(ta.lowest(len), ta.highest(len))
conversionLine          = donchian(conversionPeriods)
baseLine                = donchian(basePeriods)
leadLine1               = math.avg(conversionLine, baseLine)
leadLine2               = donchian(laggingSpan2Periods)

// Draw cloud
plot(conversionLine, color=#2962FF, title=&quot;Conversion Line&quot;, display=display.none)
plot(baseLine, color=#B71C1C, title=&quot;Base Line&quot;, display=display.none)
plot(close, offset = -displacement + 1, color=#43A047, title=&quot;Lagging Span&quot;, display=display.none)
p1 = plot(leadLine1, offset = displacement - 1, color=#A5D6A7, title=&quot;Leading Span A&quot;, display=display.none)
p2 = plot(leadLine2, offset = displacement - 1, color=#EF9A9A, title=&quot;Leading Span B&quot;, display=display.none)
fill(p1, p2, color = leadLine1 &gt; leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90), display=display.none)

// Track horizontal baseline
var baseLineSaved = baseLine
if baseLine != baseLine[1]
    baseLineSaved := na
else
    baseLineSaved := baseLine

// Draw baseline
plot(baseLineSaved, color=color.purple, style=plot.style_linebr, title=&quot;Base Line Saved&quot;)

// Track price trading above/below baseline
isPriceAboveBaseLine = close &gt; baseLineSaved
priceTradingAboveBL = isPriceAboveBaseLine and not na(baseLineSaved)
priceTradingBelowBL = not isPriceAboveBaseLine and not na(baseLineSaved)

// Draw condition
bgcolor(priceTradingAboveBL ? color.new(color.green,80) : na)
bgcolor(priceTradingBelowBL ? color.new(color.red,80) : na)

// Track candle pattern tests of baseline (example purposes - needs more conditions to be actually useful!)
candlePatternBull = priceTradingAboveBL and priceTradingAboveBL[1] and low[1] &lt; baseLineSaved and close &gt; baseLineSaved
candlePatternBear = priceTradingBelowBL and priceTradingBelowBL[1] and high[1] &gt; baseLineSaved and close &lt; baseLineSaved
plotshape(candlePatternBull, style=shape.triangleup, color=color.green, location=location.belowbar)
plotshape(candlePatternBear, style=shape.triangledown, color=color.red)
</code></pre>
<h2 id="a-simple-pullback-strategy"><a class="header" href="#a-simple-pullback-strategy">A Simple Pullback Strategy</a></h2>
<p><a href="https://youtu.be/h-erJbnBj6A">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / www.PineScriptMastery.com
// @version=5
strategy(&quot;Simple Pullback Strategy&quot;, 
     overlay=true, 
     initial_capital=50000,
     default_qty_type=strategy.percent_of_equity, 
     default_qty_value=100, // 100% of balance invested on each trade
     commission_type=strategy.commission.percent, 
     commission_value=0.2)

// Get user input
i_ma1           = input.int(title=&quot;MA 1 Length&quot;, defval=120, step=10, group=&quot;Strategy Parameters&quot;, tooltip=&quot;Long-term MA&quot;)
i_ma2           = input.int(title=&quot;MA 2 Length&quot;, defval=10, step=10, group=&quot;Strategy Parameters&quot;, tooltip=&quot;Short-term MA&quot;)
i_stopPercent   = input.float(title=&quot;Stop Loss Percent&quot;, defval=0.10, step=0.1, group=&quot;Strategy Parameters&quot;, tooltip=&quot;Failsafe Stop Loss Percent Decline&quot;)
i_lowerClose    = input.bool(title=&quot;Exit On Lower Close&quot;, defval=false, group=&quot;Strategy Parameters&quot;, tooltip=&quot;Wait for a lower-close before exiting above MA2&quot;)
i_startTime     = input.time(title=&quot;Start Filter&quot;, defval=timestamp(&quot;01 Jan 1995 13:30 +0000&quot;), group=&quot;Time Filter&quot;, tooltip=&quot;Start date &amp; time to begin searching for setups&quot;)
i_endTime       = input.time(title=&quot;End Filter&quot;, defval=timestamp(&quot;1 Jan 2099 19:30 +0000&quot;), group=&quot;Time Filter&quot;, tooltip=&quot;End date &amp; time to stop searching for setups&quot;)

// Get indicator values
ma1 = ta.sma(close, i_ma1)
ma2 = ta.sma(close, i_ma2)

// Check filter(s)
f_dateFilter = time &gt;= i_startTime and time &lt;= i_endTime

// Check buy/sell conditions
var float buyPrice = 0
buyCondition    = close &gt; ma1 and close &lt; ma2 and strategy.position_size == 0 and f_dateFilter
sellCondition   = close &gt; ma2 and strategy.position_size &gt; 0 // (not i_lowerClose or close &lt; low[1])
stopDistance    = strategy.position_size &gt; 0 ? ((buyPrice - close) / close) : na
stopPrice       = strategy.position_size &gt; 0 ? buyPrice - (buyPrice * i_stopPercent) : na
stopCondition   = strategy.position_size &gt; 0 and stopDistance &gt; i_stopPercent

// Enter positions
if buyCondition
    strategy.entry(id=&quot;Long&quot;, direction=strategy.long)

if buyCondition[1]
    buyPrice := open

// Exit positions
if sellCondition or stopCondition
    strategy.close(id=&quot;Long&quot;, comment=&quot;Exit&quot; + (stopCondition ? &quot;SL=true&quot; : &quot;&quot;))
    buyPrice := na

// Draw pretty colors
plot(buyPrice, color=color.lime, style=plot.style_linebr)
plot(stopPrice, color=color.red, style=plot.style_linebr, offset=-1)
plot(ma1, color=color.blue)
plot(ma2, color=color.orange)
</code></pre>
<h2 id="macd-strategy--2-profit-targets"><a class="header" href="#macd-strategy--2-profit-targets">MACD Strategy + 2 Profit Targets</a></h2>
<p><a href="https://www.youtube.com/watch?v=P1Lol05qb5s">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / www.PineScriptMastery.com
//
// System Rules:
// Indicators: MACD indicator (default values), ATR (14), EMA (200)
// 1. Price must be trading above/below the 200 EMA
// 2. Only 1 bar can close above/below the 200 EMA over the past 5 bars
// 3. We take the FIRST MACD cross and ignore subsequent signals until TP/SL is hit
// 4. Stop Loss = 0.5 ATR above/below the recent swing high/low (7 bars lookback)
// 5. First take profit = 1:1 (25%)
// 6. Second take profit = 2:1 (100%)
// 7. Move stop loss to break-even after 1st target is hit
//
// @version=5
strategy(&quot;[2022] MACD Cross Strategy&quot;, overlay=true,
     currency=&quot;USD&quot;,
     calc_on_order_fills=true,
     use_bar_magnifier=true,
     initial_capital=10000,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100, // 100% of balance invested on each trade
     commission_type=strategy.commission.cash_per_contract)
     //commission_value=0.005) // Interactive Brokers rate

// Import ZenLibrary
import ZenAndTheArtOfTrading/ZenLibrary/5 as zen

// Get user input
var g_system    = &quot;System Entry Settings&quot;
i_ema_filter    = input.int(title=&quot;EMA Filter Length&quot;, defval=200, group=g_system)
i_ema_filter2   = input.int(title=&quot;EMA Max Bars Above/Below&quot;, defval=1, group=g_system)
i_stop_multi    = input.float(title=&quot;Stop Loss Multiplier&quot;, defval=0.5, step=0.5, group=g_system)
i_stop_lookback = input.int(title=&quot;Stop Loss Lookback&quot;, defval=7, group=g_system)
var g_risk      = &quot;System Risk Settings&quot;
i_rr1           = input.float(title=&quot;Risk:Reward Target 1&quot;, defval=1.0, group=g_risk)
i_rr2           = input.float(title=&quot;Risk:Reward Target 2&quot;, defval=2.0, group=g_risk)
i_target1       = input.float(title=&quot;Profit % Target 1&quot;, defval=25, group=g_risk)
i_riskPerTrade  = input.float(title=&quot;Forex Risk Per Trade %&quot;, defval=1.0)
var g_macd      = &quot;MACD Settings&quot;
i_price_src     = input.source(title=&quot;Price Source&quot;, defval=close, group=g_macd)
i_fast_length   = input.int(title=&quot;Fast Length&quot;, defval=12, group=g_macd)
i_slow_length   = input.int(title=&quot;Slow Length&quot;, defval=26, group=g_macd)
i_signal_length = input.int(title=&quot;Signal Smoothing&quot;, minval=1, maxval=50, defval=9, group=g_macd)
i_sma_source    = input.string(title=&quot;Oscillator MA Type&quot;, defval=&quot;EMA&quot;, options=[&quot;SMA&quot;, &quot;EMA&quot;], group=g_macd)
i_sma_signal    = input.string(title=&quot;Signal Line MA Type&quot;, defval=&quot;EMA&quot;, options=[&quot;SMA&quot;, &quot;EMA&quot;], group=g_macd)

//------------- DETERMINE CURRENCY CONVERSION RATE -------------//
// Check if our account currency is the same as the base or quote currency or neither (for risk $ conversion purposes)
accountSameAsCounterCurrency = strategy.account_currency == syminfo.currency
accountSameAsBaseCurrency = strategy.account_currency == syminfo.basecurrency
accountNeitherCurrency = not accountSameAsCounterCurrency and not accountSameAsBaseCurrency
// Get currency conversion rates if applicable
conversionCurrencyPair = accountSameAsCounterCurrency ? syminfo.tickerid : strategy.account_currency + syminfo.currency
conversionCurrencyRate = accountSameAsBaseCurrency or accountNeitherCurrency ? request.security(conversionCurrencyPair, &quot;D&quot;, close, ignore_invalid_symbol=true) : 1.0
// Display the current conversion currency ticker (for debug purposes)
if barstate.islastconfirmedhistory
    table t = table.new(position.top_right, 1, 2, color.black)
    table.cell(t, 0, 0, &quot;Conversion: &quot; + conversionCurrencyPair + &quot; (&quot; + str.tostring(conversionCurrencyRate) + &quot;)&quot;, text_color=color.white, text_size=size.small)
    table.cell(t, 0, 1, &quot;Account: $&quot; + str.tostring(zen.truncate(strategy.equity)), text_color=color.white, text_size=size.small)
//------------- END CURRENCY CONVERSION RATE CODE -------------//

// Calculate MACD
[macdLine, signalLine, histLine] = ta.macd(i_price_src, i_fast_length, i_slow_length, i_signal_length)

// Get indicator values
ema = ta.ema(close, i_ema_filter)
atr = ta.atr(14)

// Check for zero-point crosses
crossUp     = ta.crossover(signalLine, macdLine)
crossDown   = ta.crossunder(signalLine, macdLine)

// Check general system filters
tradeFilters = not na(ema) and not na(atr)

// Check trend conditions
upTrend     = close &gt; ema
downTrend   = close &lt; ema

// Check trade conditions
longConditions  = tradeFilters and macdLine[1] &lt; 0 and signalLine[1] &lt; 0
shortConditions = tradeFilters and macdLine[1] &gt; 0 and signalLine[1] &gt; 0

// Confirm long &amp; short setups
longSignal   = longConditions and upTrend and crossDown
shortSignal  = shortConditions and downTrend and crossUp

// Calculate stop loss
longStop    = ta.lowest(low, i_stop_lookback) - (atr * i_stop_multi)
shortStop   = ta.highest(high, i_stop_lookback) + (atr * i_stop_multi)

// Save stops &amp; targets
var float tradeStop = na
var float tradeTarget1 = na
var float tradeTarget2 = na
var float tradeSize = na

// Count bars above/below MA
int barsAboveMA = 0
int barsBelowMA = 0

for i = 1 to 5
    if close[i] &lt; ema[i]
        barsBelowMA += 1
    if close[i] &gt; ema[i]
        barsAboveMA += 1

// Combine signal filters
longTrade   = longSignal  and barsBelowMA &lt;= i_ema_filter2 and strategy.position_size == 0
shortTrade  = shortSignal and barsAboveMA &lt;= i_ema_filter2 and strategy.position_size == 0

// Handle long trade entry (enter position, reset stops &amp; targets)
if longTrade
    if syminfo.type == &quot;forex&quot;
        tradeStop := longStop
        stopDistance = close - tradeStop
        tradeTarget1 := close + (stopDistance * i_rr1)
        tradeTarget2 := close + (stopDistance * i_rr2)
        tradeSize := na
        positionSize = zen.av_getPositionSize(strategy.equity, i_riskPerTrade, zen.toWhole(stopDistance) * 10, conversionCurrencyRate)
        strategy.entry(id=&quot;Long&quot;, direction=strategy.long, qty=positionSize)
    else
        strategy.entry(id=&quot;Long&quot;, direction=strategy.long)
        tradeStop := na
        tradeTarget1 := na
        tradeTarget2 := na

// Handle short trade entry (enter position, reset stops &amp; targets)
if shortTrade
    if syminfo.type == &quot;forex&quot;
        tradeStop := shortStop
        stopDistance = tradeStop - close
        tradeTarget1 := close - (stopDistance * i_rr1)
        tradeTarget2 := close - (stopDistance * i_rr2)
        tradeSize := na
        positionSize = zen.av_getPositionSize(strategy.equity, i_riskPerTrade, zen.toWhole(shortStop - close) * 10, conversionCurrencyRate)
        strategy.entry(id=&quot;Short&quot;, direction=strategy.short, qty=positionSize)
    else
        strategy.entry(id=&quot;Short&quot;, direction=strategy.short)
        tradeStop := na
        tradeTarget1 := na
        tradeTarget2 := na
    
// Handle forex trade size tracking variable
if syminfo.type == &quot;forex&quot; and strategy.position_size != 0 and na(tradeSize)
    tradeSize := strategy.position_size

// Handle long stops &amp; target calculation
if strategy.position_size &gt; 0 and na(tradeStop) and syminfo.type != &quot;forex&quot;
    tradeStop := longStop
    stopDistance = strategy.position_avg_price - tradeStop
    tradeTarget1 := strategy.position_avg_price + (stopDistance * i_rr1)
    tradeTarget2 := strategy.position_avg_price + (stopDistance * i_rr2)
    tradeSize := strategy.position_size

// Handle short stops &amp; target calculation
if strategy.position_size &lt; 0 and na(tradeStop) and syminfo.type != &quot;forex&quot;
    tradeStop := shortStop
    stopDistance = tradeStop - strategy.position_avg_price
    tradeTarget1 := strategy.position_avg_price - (stopDistance * i_rr1)
    tradeTarget2 := strategy.position_avg_price - (stopDistance * i_rr2)
    tradeSize := strategy.position_size

// Handle trade exits
strategy.exit(id=&quot;Long Exit #1&quot;,  from_entry=&quot;Long&quot;,  limit=tradeTarget1, stop=tradeStop, qty_percent=i_target1)
strategy.exit(id=&quot;Long Exit #2&quot;,  from_entry=&quot;Long&quot;,  limit=tradeTarget2, stop=tradeStop, qty_percent=100)
strategy.exit(id=&quot;Short Exit #1&quot;, from_entry=&quot;Short&quot;, limit=tradeTarget1, stop=tradeStop, qty_percent=i_target1)
strategy.exit(id=&quot;Short Exit #2&quot;, from_entry=&quot;Short&quot;, limit=tradeTarget2, stop=tradeStop, qty_percent=100)

// Handle both long &amp; short trade break-even stops (do this AFTER first position has exited above ^)
if strategy.position_size != tradeSize
    tradeStop := strategy.position_avg_price
    tradeTarget1 := na

// Draw conditional data
plot(ema, color=close &gt; ema ? color.green : color.red, linewidth=2, title=&quot;EMA&quot;)
plotshape(longTrade,  style=shape.triangleup,   color=color.green, location=location.belowbar, title=&quot;Long Setup&quot;)
plotshape(shortTrade, style=shape.triangledown, color=color.red,   location=location.abovebar, title=&quot;Short Setup&quot;)

// Draw stops &amp; targets
plot(strategy.position_size != 0 ? tradeStop : na,   color=color.red,   style=plot.style_linebr, title=&quot;Stop Loss&quot;)
plot(strategy.position_size != 0 ? tradeTarget1 : na, color=color.green, style=plot.style_linebr, title=&quot;Profit Target 1&quot;)
plot(strategy.position_size != 0 ? tradeTarget2 : na, color=color.green, style=plot.style_linebr, title=&quot;Profit Target 2&quot;)
</code></pre>
<h2 id="calculating-forex-lot-sizes"><a class="header" href="#calculating-forex-lot-sizes">Calculating Forex LOT SIZES</a></h2>
<p><a href="https://youtu.be/Dp1C3oHrq7g">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / www.PineScriptMastery.com
//
// System Rules:
// Indicators: MACD indicator (default values), ATR (14), EMA (200)
// 1. Price must be trading above/below the 200 EMA
// 2. Only 1 bar can close above/below the 200 EMA over the past 5 bars
// 3. We take the FIRST MACD cross and ignore subsequent signals until TP/SL is hit
// 4. Stop Loss = 0.5 ATR above/below the recent swing high/low (7 bars lookback)
// 5. First take profit = 1:1 (25%)
// 6. Second take profit = 2:1 (100%)
// 7. Move stop loss to break-even after 1st target is hit
//
// @version=5
strategy(&quot;[2022] MACD Cross Strategy&quot;, overlay=true,
     currency=&quot;USD&quot;,
     calc_on_order_fills=true,
     use_bar_magnifier=true,
     initial_capital=10000,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100, // 100% of balance invested on each trade
     commission_type=strategy.commission.cash_per_contract)
     //commission_value=0.005) // Interactive Brokers rate

// Get user input
var g_system    = &quot;System Entry Settings&quot;
i_ema_filter    = input.int(title=&quot;EMA Filter Length&quot;, defval=200, group=g_system)
i_ema_filter2   = input.int(title=&quot;EMA Max Bars Above/Below&quot;, defval=1, group=g_system)
i_stop_multi    = input.float(title=&quot;Stop Loss Multiplier&quot;, defval=0.5, step=0.5, group=g_system)
i_stop_lookback = input.int(title=&quot;Stop Loss Lookback&quot;, defval=7, group=g_system)
var g_risk      = &quot;System Risk Settings&quot;
i_rr1           = input.float(title=&quot;Risk:Reward Target 1&quot;, defval=1.0, group=g_risk)
i_rr2           = input.float(title=&quot;Risk:Reward Target 2&quot;, defval=2.0, group=g_risk)
i_target1       = input.float(title=&quot;Profit % Target 1&quot;, defval=25, group=g_risk)
i_riskPerTrade  = input.float(title=&quot;Forex Risk Per Trade %&quot;, defval=1.0)
i_useLots       = input.bool(title=&quot;Use Lots Instead Of Units&quot;, defval=false)
var g_macd      = &quot;MACD Settings&quot;
i_price_src     = input.source(title=&quot;Price Source&quot;, defval=close, group=g_macd)
i_fast_length   = input.int(title=&quot;Fast Length&quot;, defval=12, group=g_macd)
i_slow_length   = input.int(title=&quot;Slow Length&quot;, defval=26, group=g_macd)
i_signal_length = input.int(title=&quot;Signal Smoothing&quot;, minval=1, maxval=50, defval=9, group=g_macd)
i_sma_source    = input.string(title=&quot;Oscillator MA Type&quot;, defval=&quot;EMA&quot;, options=[&quot;SMA&quot;, &quot;EMA&quot;], group=g_macd)
i_sma_signal    = input.string(title=&quot;Signal Line MA Type&quot;, defval=&quot;EMA&quot;, options=[&quot;SMA&quot;, &quot;EMA&quot;], group=g_macd)

//------------- DETERMINE CURRENCY CONVERSION RATE ------------- { //
// Import ZenLibrary
import ZenAndTheArtOfTrading/ZenLibrary/5 as zen
// Custom function for converting units into lot sizes
unitsToLots(units) =&gt;
    float lots = units / 100000
    lots := math.round(lots, 2)
    _return = lots * 100000
// Check if our account currency is the same as the base or quote currency or neither (for risk $ conversion purposes)
accountSameAsCounterCurrency = strategy.account_currency == syminfo.currency
accountSameAsBaseCurrency = strategy.account_currency == syminfo.basecurrency
accountNeitherCurrency = not accountSameAsCounterCurrency and not accountSameAsBaseCurrency
// Get currency conversion rates if applicable
conversionCurrencyPair = accountSameAsCounterCurrency ? syminfo.tickerid : strategy.account_currency + syminfo.currency
conversionCurrencyRate = accountSameAsBaseCurrency or accountNeitherCurrency ? request.security(conversionCurrencyPair, &quot;D&quot;, close, ignore_invalid_symbol=true) : 1.0
// Display the current conversion currency ticker (for debug purposes)
if barstate.islastconfirmedhistory
    table t = table.new(position.top_right, 1, 2, color.black)
    table.cell(t, 0, 0, &quot;Conversion: &quot; + conversionCurrencyPair + &quot; (&quot; + str.tostring(conversionCurrencyRate) + &quot;)&quot;, text_color=color.white, text_size=size.small)
    table.cell(t, 0, 1, &quot;Account: $&quot; + str.tostring(zen.truncate(strategy.equity)), text_color=color.white, text_size=size.small)
//------------- END CURRENCY CONVERSION RATE CODE ------------- }//

// Calculate MACD
[macdLine, signalLine, histLine] = ta.macd(i_price_src, i_fast_length, i_slow_length, i_signal_length)

// Get indicator values
ema = ta.ema(close, i_ema_filter)
atr = ta.atr(14)

// Check for zero-point crosses
crossUp     = ta.crossover(signalLine, macdLine)
crossDown   = ta.crossunder(signalLine, macdLine)

// Check general system filters
tradeFilters = not na(ema) and not na(atr)

// Check trend conditions
upTrend     = close &gt; ema
downTrend   = close &lt; ema

// Check trade conditions
longConditions  = tradeFilters and macdLine[1] &lt; 0 and signalLine[1] &lt; 0
shortConditions = tradeFilters and macdLine[1] &gt; 0 and signalLine[1] &gt; 0

// Confirm long &amp; short setups
longSignal   = longConditions and upTrend and crossDown
shortSignal  = shortConditions and downTrend and crossUp

// Calculate stop loss
longStop    = ta.lowest(low, i_stop_lookback) - (atr * i_stop_multi)
shortStop   = ta.highest(high, i_stop_lookback) + (atr * i_stop_multi)

// Save stops &amp; targets
var float tradeStop = na
var float tradeTarget1 = na
var float tradeTarget2 = na
var float tradeSize = na

// Count bars above/below MA
int barsAboveMA = 0
int barsBelowMA = 0

for i = 1 to 5
    if close[i] &lt; ema[i]
        barsBelowMA += 1
    if close[i] &gt; ema[i]
        barsAboveMA += 1

// Combine signal filters
longTrade   = longSignal  and barsBelowMA &lt;= i_ema_filter2 and strategy.position_size == 0
shortTrade  = shortSignal and barsAboveMA &lt;= i_ema_filter2 and strategy.position_size == 0

// Handle long trade entry (enter position, reset stops &amp; targets)
if longTrade
    if syminfo.type == &quot;forex&quot;
        tradeStop := longStop
        stopDistance = close - tradeStop
        tradeTarget1 := close + (stopDistance * i_rr1)
        tradeTarget2 := close + (stopDistance * i_rr2)
        tradeSize := na
        positionSize = zen.av_getPositionSize(strategy.equity, i_riskPerTrade, zen.toWhole(stopDistance) * 10, conversionCurrencyRate)
        strategy.entry(id=&quot;Long&quot;, direction=strategy.long, qty=i_useLots ? unitsToLots(positionSize) : positionSize)
    else
        strategy.entry(id=&quot;Long&quot;, direction=strategy.long)
        tradeStop := na
        tradeTarget1 := na
        tradeTarget2 := na

// Handle short trade entry (enter position, reset stops &amp; targets)
if shortTrade
    if syminfo.type == &quot;forex&quot;
        tradeStop := shortStop
        stopDistance = tradeStop - close
        tradeTarget1 := close - (stopDistance * i_rr1)
        tradeTarget2 := close - (stopDistance * i_rr2)
        tradeSize := na
        positionSize = zen.av_getPositionSize(strategy.equity, i_riskPerTrade, zen.toWhole(shortStop - close) * 10, conversionCurrencyRate)
        strategy.entry(id=&quot;Short&quot;, direction=strategy.short, qty=i_useLots ? unitsToLots(positionSize) : positionSize)
    else
        strategy.entry(id=&quot;Short&quot;, direction=strategy.short)
        tradeStop := na
        tradeTarget1 := na
        tradeTarget2 := na
    
// Handle forex trade size tracking variable
if syminfo.type == &quot;forex&quot; and strategy.position_size != 0 and na(tradeSize)
    tradeSize := strategy.position_size

// Handle long stops &amp; target calculation
if strategy.position_size &gt; 0 and na(tradeStop) and syminfo.type != &quot;forex&quot;
    tradeStop := longStop
    stopDistance = strategy.position_avg_price - tradeStop
    tradeTarget1 := strategy.position_avg_price + (stopDistance * i_rr1)
    tradeTarget2 := strategy.position_avg_price + (stopDistance * i_rr2)
    tradeSize := strategy.position_size

// Handle short stops &amp; target calculation
if strategy.position_size &lt; 0 and na(tradeStop) and syminfo.type != &quot;forex&quot;
    tradeStop := shortStop
    stopDistance = tradeStop - strategy.position_avg_price
    tradeTarget1 := strategy.position_avg_price - (stopDistance * i_rr1)
    tradeTarget2 := strategy.position_avg_price - (stopDistance * i_rr2)
    tradeSize := strategy.position_size

// Handle trade exits
float exitPartialUnits = math.abs(strategy.position_size / (100 / i_target1))
float exitPartialLots = unitsToLots(exitPartialUnits)
strategy.exit(id=&quot;Long Exit #1&quot;,  from_entry=&quot;Long&quot;,  limit=tradeTarget1, stop=tradeStop, qty=i_useLots ? exitPartialLots : exitPartialUnits)
strategy.exit(id=&quot;Long Exit #2&quot;,  from_entry=&quot;Long&quot;,  limit=tradeTarget2, stop=tradeStop, qty_percent=100)
strategy.exit(id=&quot;Short Exit #1&quot;, from_entry=&quot;Short&quot;, limit=tradeTarget1, stop=tradeStop, qty=i_useLots ? exitPartialLots : exitPartialUnits)
strategy.exit(id=&quot;Short Exit #2&quot;, from_entry=&quot;Short&quot;, limit=tradeTarget2, stop=tradeStop, qty_percent=100)

// Handle both long &amp; short trade break-even stops (do this AFTER first position has exited above ^)
if strategy.position_size != tradeSize
    tradeStop := strategy.position_avg_price
    tradeTarget1 := na

// Draw conditional data
plot(ema, color=close &gt; ema ? color.green : color.red, linewidth=2, title=&quot;EMA&quot;)
plotshape(longTrade,  style=shape.triangleup,   color=color.green, location=location.belowbar, title=&quot;Long Setup&quot;)
plotshape(shortTrade, style=shape.triangledown, color=color.red,   location=location.abovebar, title=&quot;Short Setup&quot;)

// Draw stops &amp; targets
plot(strategy.position_size != 0 ? tradeStop : na,   color=color.red,   style=plot.style_linebr, title=&quot;Stop Loss&quot;)
plot(strategy.position_size != 0 ? tradeTarget1 : na, color=color.green, style=plot.style_linebr, title=&quot;Profit Target 1&quot;)
plot(strategy.position_size != 0 ? tradeTarget2 : na, color=color.green, style=plot.style_linebr, title=&quot;Profit Target 2&quot;)
</code></pre>
<h2 id="mean-reversion-strategy"><a class="header" href="#mean-reversion-strategy">Mean Reversion Strategy</a></h2>
<p><a href="https://youtu.be/yz_T1gpAw6Y">Watch Lesson</a></p>
<pre><code class="language-python">// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ZenAndTheArtOfTrading / www.PineScriptMastery.com
// @version=5
strategy(&quot;ATR Reversion System&quot;, 
     overlay=true, 
     currency=currency.USD,
     initial_capital=100000, 
     default_qty_type=strategy.percent_of_equity, 
     default_qty_value=100, 
     commission_type=strategy.commission.cash_per_order, 
     commission_value=9.95)

// Get user input
i_EmaLongLength     = input.int(title=&quot;Long-term EMA&quot;, defval=200)
i_EmaShortLength    = input.int(title=&quot;Short-term EMA Length&quot;, defval=20)
i_ATRPeriod         = input.int(title=&quot;ATR Period&quot;, defval=5)
i_ATRBand           = input.float(title=&quot;ATR Band Distance&quot;, defval=1)
i_ATRStretch        = input.float(title=&quot;ATR Buy Stretch&quot;, defval=1)
i_SellBand          = input.string(title=&quot;Sell At Band:&quot;, defval=&quot;Middle&quot;, options=[&quot;Top&quot;, &quot;Middle&quot;, &quot;Bottom&quot;])
i_SellSrc           = input.source(title=&quot;Sell Price Source&quot;, defval=high)

// Get indicator values
emaLongTerm     = ta.ema(close, i_EmaLongLength)
emaShortTerm    = ta.ema(close, i_EmaShortLength)
atrValue        = ta.atr(i_ATRPeriod)

// Get ATR bands
atrBandTop = emaShortTerm + (atrValue * i_ATRBand)
atrBandBot = emaShortTerm - (atrValue * i_ATRBand)

// Define price stretch
float buyLimitPrice = na

// Check setup conditions = bar close is below ATR band, above long-term EMA
setupCondition = close &lt; atrBandBot and low &gt; emaLongTerm

// Clear any pending limit orders
strategy.cancel_all()

// Enter trades on next bar after setup condition is met
if setupCondition
    buyLimitPrice := low - (atrValue * i_ATRStretch)
    strategy.entry(&quot;Long&quot;, strategy.long, limit=buyLimitPrice)

// Get sell price
sellPrice = switch i_SellBand
    &quot;Top&quot;       =&gt; atrBandTop
    &quot;Middle&quot;    =&gt; emaShortTerm
    &quot;Bottom&quot;    =&gt; atrBandBot

// Exit trades
if i_SellSrc &gt;= sellPrice or close &lt; emaLongTerm
    strategy.close(&quot;Long&quot;, comment=&quot;Exit trade&quot;)

// Draw data to chart
plot(emaLongTerm, &quot;EMA Filter&quot;, color.red, 2)
plot(emaShortTerm, &quot;ATR Band Middle&quot;, color.blue)
plot(atrBandBot, &quot;ATR Band Bottom&quot;, color=color.green)
plot(atrBandTop, &quot;ATR Band Top&quot;, color=color.new(color.gray, 75))
plot(setupCondition ? buyLimitPrice : na, &quot;Buy Limit&quot;, color.lime, 1, plot.style_cross)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拾人牙慧"><a class="header" href="#拾人牙慧">拾人牙慧</a></h1>
<h2 id="判斷趨勢"><a class="header" href="#判斷趨勢">判斷趨勢</a></h2>
<ul>
<li>美股 台股 亞股 歐股 一起看</li>
<li>台股上市櫃指數站上月線才做多</li>
</ul>
<h2 id="選股-1"><a class="header" href="#選股-1">選股</a></h2>
<ul>
<li>
<p>美股會領先反應誰是主流類股 ，當台股某股票發動時去跟美股主流股比較是否是相同類股</p>
<ul>
<li>ex: 2023/01~2023/05  Nvidia 漲100%  ，台股AI相關股票5月發動也是Nvidia 受惠股</li>
</ul>
</li>
<li>
<p>選產業未來</p>
</li>
<li>
<p>台股找產業未來 or 題材</p>
</li>
<li>
<p>看月K or 周K 長紅棒超過12根漲幅% 該股可能後面有大行情</p>
</li>
<li>
<p>阿魯米</p>
<ul>
<li>空頭選股跟大盤比，哪些股票先回到起跌時候的股價</li>
<li>個股漲幅需比大盤強，找出強勢股名單</li>
</ul>
</li>
<li>
<p>張捷</p>
<ul>
<li>「買對(個股)，押大(部位)，長抱！」</li>
<li>張捷口中的「長抱」，指的是波段投資，個股買進後平均持有時間約3個月，講「長抱」的用意是提醒學員不要做太短，因為當沖的短線交易成本(手續費、證交稅)太高，短線的買賣點也會因誤判而無法精準掌握，賣掉後可能又被迫追高買回來，把自己搞得緊張兮兮，甚至嚴重影響心情，得不償失。</li>
<li>產業趨勢一旦成形，可能持續1、2年，甚至更久，但該產業成長股的股價通常會提前反映，而且漲勢通常會集中在幾個波段，張捷因此認為，投資人若能領先掌握產業及相關個股的成長動能，在相對低檔進場做波段投資，會比買進個股長抱1年以上更有效率。</li>
</ul>
</li>
<li>
<p>奇正</p>
<ul>
<li>買進強勢類股中的最強勢股票
<ul>
<li>依據我多年的觀察與驗證，在強勢類股中，強勢股與弱勢股表現也是差很多；而漲最兇的通常不是基本面最好的，所以你如果以基本面去選，而不是以強弱去選，很可能買到的都不會漲，別人漲一倍兩倍，你是漲１０％，２０％。以近期的「美國寬頻基建概念股」來說，華星光、仲琦是類股中其他股票漲幅的數倍，到底在漲什麼？就像ＡＩ為什麼會漲到緯創，不就是一代工廠嗎？也能飆成就好像它是OPEN AI在台灣上市，總之，股市就是無厘頭啦！簡而言之，股市黃金律就是「買進強勢類股中的最強勢股票」不是買進最好的股票。對於10個裡面有9.9999個不懂得這個道理的股市小白你叫他去開槓桿快速致富，是要害人吧！</li>
</ul>
</li>
<li>專心致力研究當時表現最突出的股票
<ul>
<li>為什麼李佛摩是投機的祖師爺，因為他所講過的話到最後都被驗證是至理名言。追隨主流股，別不信邪，什麼技術分析、籌碼分析、產業分析、宇宙奧秘、包寧傑通道…，攏總沒路用。唯一有用的就只有，辨識主流股。「…專心致力研究當時表現最突出的股票。假如你無法從表現領先的熱門股身上賺到錢，你就別想從整個股市裡賺到錢。正如女人的服裝、帽子與珠寶永遠都在變一樣，股市中的主流類股也是此起彼落的變換。多年以前的主流類股是鐵路股、美國糖業和煙草類股。再來換成鋼鐵，美國糖業和煙草類股則悄悄走入歷史。按著汽車類股出現，這樣的戲碼至今仍不斷上演。…」</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="當沖-阿老師"><a class="header" href="#當沖-阿老師">當沖 (阿老師)</a></h2>
<ul>
<li>賭紅K 當沖
<ul>
<li>https://www.youtube.com/watch?v=gg2VILaU3jc</li>
<li>開盤價是一個關鍵點</li>
<li>V 轉的低點要爆量往上</li>
<li>在開盤價以下不能太久時間 反之賭黑K  也是不能在開盤價之上太久</li>
<li>在開盤價上面遊走很久收紅K機會大</li>
</ul>
</li>
</ul>
<h2 id="隔日沖-阿老師"><a class="header" href="#隔日沖-阿老師">隔日沖 (阿老師)</a></h2>
<ul>
<li>https://www.youtube.com/watch?v=003FKXkyNII</li>
<li>隔日沖屬於波段單的範疇</li>
<li>隔日沖位階很重要</li>
<li>乖離過大 不要做隔日沖</li>
<li>波段單建立部位最好是在短期波段突破不一定要長紅K 只要是紅K 收盤價是最近幾日最高點  (也適合當天收盤買做隔日沖)</li>
</ul>
<h2 id="資金配置"><a class="header" href="#資金配置">資金配置</a></h2>
<ul>
<li>https://www.youtube.com/watch?v=mV-hhdsINyI</li>
<li>各種資產配置
<ul>
<li>股票集中管理3~5檔  ，操作不同產業股票或同產業不同屬性
<ul>
<li>ex: 1000萬 分3檔股票操作，資金分10等份 一次丟一份100~150萬</li>
</ul>
</li>
<li>同產業不太一樣～ 或是產業不同</li>
</ul>
</li>
</ul>
<h2 id="暴大量"><a class="header" href="#暴大量">暴大量</a></h2>
<ul>
<li>
<p>暴大量隔天是觀察日</p>
</li>
<li>
<p>低檔爆量</p>
<ul>
<li>上攻力道強</li>
</ul>
</li>
<li>
<p>高檔暴大量</p>
<ul>
<li>換手失敗長黑K，連續K 可能就是頭部形成，可能要休息一陣子</li>
<li>換手成功上去壓力變支撐</li>
</ul>
</li>
</ul>
<h2 id="進場"><a class="header" href="#進場">進場</a></h2>
<ul>
<li>觀察位階，漲過一波位階高要小心</li>
<li>低檔暴大量</li>
<li>高檔暴大量換手區，換手成功變支撐</li>
<li>發動後第一波沒跟上等盤整後發動第一根尾盤買盈虧比會漂亮</li>
<li>多頭股價上漲一般都是走階梯</li>
<li>上市櫃指數站上月線 or 10日均線  or 突破盤整
<ul>
<li>檢視抗跌或率先突破的細產業，並跟大盤比較，找出強勢族群＆又有量  https://www.youtube.com/watch?v=0c4D-3Bh6M0</li>
</ul>
</li>
<li>阿魯米
<ul>
<li>波段單建立部位最好是在短期波段突破收盤價是最近幾日最高點(不一定要長紅K，只要是紅K) </li>
<li>量縮到極致，之後慢慢出量上漲可能是發動前兆 https://galaxyinvestment.my-galaxy.com.tw/GalaxyAcademy/groupCourse/groupCourse.do?id=20230104464156</li>
</ul>
</li>
</ul>
<h2 id="出場"><a class="header" href="#出場">出場</a></h2>
<ul>
<li>等幅會跟上一波大於等於上波漲幅去觀察</li>
<li>進場沒獲利情況設 5~10％停損，當獲利10% 以上移動停利或周K翻黑出場</li>
<li>停損設突破長紅棒最低點</li>
<li>停損跳空上漲缺口區 (回補缺口代表弱掉)</li>
<li>高檔暴大量，換手常常伴隨大黑K</li>
<li>期貨當天噴出去瘋狂時候賣</li>
</ul>
<h2 id="加碼建倉"><a class="header" href="#加碼建倉">加碼(建倉)</a></h2>
<ul>
<li>
<p>現股與期貨不同</p>
<ul>
<li>
<p>現貨：需要交割，沒賣出股票之前，錢回不來，資金要分配分批加碼建倉</p>
</li>
<li>
<p>期貨：期貨只要有交易，保證金可以滾入再交易，可以把賺來錢再加碼</p>
</li>
</ul>
</li>
<li>
<p>當沖加碼不適合加碼太多次 ex:  試單對了之後關鍵點位 all in 再減碼出場 </p>
</li>
<li>
<p>金字塔加碼  https://www.youtube.com/watch?v=JI9uSxGu2_U</p>
<ul>
<li>
<p>做波段資金要分配，所以要分批加碼建倉</p>
</li>
<li>
<p>正金字塔順勢交易，越買越少，往上加碼越少成本不會墊高太多，底倉比較大  ex:  10口 8口 3口 1口，加碼4次</p>
</li>
<li>
<p>倒金字塔逆勢交易 (存股族)，越買越多，往下加碼 ex: 指數型 ETF</p>
</li>
</ul>
</li>
<li>
<p>加碼次數跟行情有關係，台股可以預設分三批加碼</p>
</li>
<li>
<p>JG</p>
<ul>
<li>
<p>趨勢多頭格局，在拉回收黑都是進場加碼的時候</p>
</li>
<li>
<p>分批買進，只是建倉，壓低成本，抱得住後面才能暴賺</p>
</li>
<li>
<p>美股要拆太多筆(10筆) ，可以向下分批</p>
</li>
<li>
<p>美股震盪大15~20% 才加碼一次</p>
</li>
<li>
<p>假設分三批進場，在三批全部打進去之前都視為建倉，所以在完成建倉之前，風險都控制在10元，所以在第二筆打進去之後，成本110應該是在105的時候就會止損了，&quot;有賺不能賠&quot;應該是建倉完畢後才開始執行</p>
</li>
<li>
<p>前期建倉完成後是用一個沒有賠到錢心情在拼後面大利潤</p>
</li>
<li>
<p>每後一次進場風險都變小</p>
</li>
<li>
<p>暴賺哲學 選股標的同時持有不同股票</p>
</li>
</ul>
</li>
<li>
<p>10倍股法則 林子揚</p>
<ul>
<li>金字塔分批，越買越少</li>
</ul>
</li>
</ul>
<h2 id="波段"><a class="header" href="#波段">波段</a></h2>
<ul>
<li>
<p>阿魯米</p>
<ul>
<li>
<p>空頭短線必勝法  順勢交易   https://www.youtube.com/watch?v=FF49VYNzFYA</p>
<ul>
<li>
<p>要有停損點</p>
</li>
<li>
<p>要有參考點 (參考點右側是順勢交易，左側是逆勢交易)</p>
<ul>
<li>確定低點出來才進去買，確定高點出來才去賣</li>
</ul>
</li>
<li>
<p><img src="strategy/images/%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_040.png" alt="擷取選取區域_040" /></p>
</li>
<li>
<p>10天以上超過1周就要看周K方向</p>
</li>
<li>
<p><img src="strategy/images/%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_041.png" alt="擷取選取區域_041" /></p>
</li>
<li>
<p>主級別上一層來判斷方向</p>
<ul>
<li>
<p>ex: 做3~10日 &lt;-主級別是60分K</p>
<ul>
<li>日K方向往上</li>
<li>主級別是60分，上個級別(日)看方向，下個級別(15分)找進場點</li>
<li>小級別是15分，做停損架構，去享受大級別的方向，當它推動走出去是日線的收獲，15分K的停損</li>
</ul>
</li>
<li>
<p>ex:做10~60日 主級別是日K</p>
<ul>
<li>周K看趨勢方向</li>
<li>主級別看型態結構</li>
<li>小級別從微觀看進出位置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>設定R值 </p>
<ul>
<li>R值：進場點 ～ 停損點</li>
<li>目標區: 2~3倍R，在目標區之前設定停損即可，之後 follow trend</li>
<li><img src="strategy/images/%E6%93%B7%E5%8F%96%E9%81%B8%E5%8F%96%E5%8D%80%E5%9F%9F_042.png" alt="擷取選取區域_042" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>買在波段起漲點</p>
</li>
<li>
<p>買在最具有動能的地方</p>
</li>
<li>
<p>盤區偏高地方是危險</p>
</li>
<li>
<p>證偽循環的步驟</p>
<ul>
<li>
<p>趨勢猜測</p>
</li>
<li>
<p>趨勢證明</p>
</li>
<li>
<p>追蹤趨勢加減碼</p>
</li>
<li>
<p>停損價在總部位的均價以上</p>
<ul>
<li>一旦涉及加碼移動停損點要在成本上面不能虧錢</li>
</ul>
</li>
<li>
<p>出場原則</p>
</li>
</ul>
</li>
<li>
<p>在不確定性中，尋找確定性</p>
</li>
</ul>
</li>
<li>
<p>波段先看大環境 美國  台灣 經濟 ＆ 大盤指數</p>
</li>
<li>
<p>做多:</p>
<ul>
<li>多頭/空頭/盤整都需要跟大盤相比都要超過大盤</li>
</ul>
</li>
<li>
<p>股票波段噴出大紅K價位點，可能都不容易回來，不會回頭的價位點通常都是噴出的價位點</p>
</li>
<li>
<p>波段加減碼 or 空手 看櫃買指數跟大盤指數</p>
<ul>
<li>上市上櫃指數站上月線 or 10MA
<ul>
<li>初升段 -&gt; 主升段力道最強，後面出現盤整可能是末升段，資金要控制縮小，提防回檔修正</li>
</ul>
</li>
<li>波浪理論
<ul>
<li>初升段跟主升段資金可以放大點</li>
</ul>
</li>
</ul>
</li>
<li>
<p>波段單建立部位最好是在短期波段突破不一定要長紅K 只要是紅K 收盤價是最近幾日最高點</p>
</li>
<li>
<p>想辦法找出當下主流股</p>
<ul>
<li>真正主流股美股通常先會反應 ex: NVIDIA 2023/01~2023/5 漲100%  台股2023/5月才開始發動</li>
</ul>
</li>
<li>
<p>做短線靠技巧，做波段靠天吃飯</p>
</li>
<li>
<p>做波段沒走出來不知道是波段終點在哪 ～ 波段資金是慢慢加碼不是一次買</p>
</li>
<li>
<p>周K/月K 長紅棒(超過過去12根漲幅) 可能後面有大行情 ，日K級別找進行點</p>
</li>
<li>
<p>發動中股票之後盤整均線糾結後第一根長紅棒尾盤買進， 盈虧比漂亮</p>
</li>
</ul>
<h2 id="抄底"><a class="header" href="#抄底">抄底</a></h2>
<ul>
<li>BNF </li>
<li>郭泰小抄底
<ul>
<li>選找未來3~6個月主流趨勢類股，哪檔最強</li>
<li>皮球理論</li>
</ul>
</li>
<li>權證小哥
<ul>
<li>急跌大綠棒爆大量進場賭反彈
<ul>
<li>馬丁策略賭10次 ex: 第一次10元  失敗, 第二次20元 , 第三次 40元，依此類推</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="總結-12"><a class="header" href="#總結-12">總結</a></h2>
<ul>
<li>多頭行情想辦法找出主流股</li>
<li>沒行情 
<ul>
<li>空手 </li>
<li>盤整小資金練功能獲利</li>
</ul>
</li>
<li>大賺小賠 (控制賠)</li>
<li>資金配置</li>
<li>嚴格停損</li>
<li>停利？</li>
<li>看對 壓力 抱緊  &lt;- 使用加碼</li>
<li>心態 : 資金風控 ＆ 停損  ＆ 紀律 ＆ 停損相關 </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何衡量風險與報酬夏普比率告訴你"><a class="header" href="#如何衡量風險與報酬夏普比率告訴你">如何衡量風險與報酬？夏普比率告訴你</a></h1>
<p>出處:https://www.finlab.tw/python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E9%A2%A8%E9%9A%AA%E8%88%87%E5%A0%B1%E9%85%AC/</p>
<h3 id="sharp-ratio-簡單講就是報酬--風險"><a class="header" href="#sharp-ratio-簡單講就是報酬--風險">sharp ratio 簡單講，就是「報酬 / 風險」！</a></h3>
<p>以這著比率，可以想像，sharp ratio 越高，代表獲利大於風險，
而sharp ratio 越低，代表風險大於獲利，那就會有點危險了！
所以找一個sharp ratio 越高的指數，就等於找出了「獲利大且風險相對小」的指數喔！</p>
<h3 id="如何定義獲利"><a class="header" href="#如何定義獲利">如何定義獲利？</a></h3>
<p>獲利可以用每天平均的漲跌來代表，也就是今天漲1％，明天跌1％，平均獲利就是0％，
接下來我們就用python來計算每天平均獲利吧</p>
<p>首先，記得回去前一個單元，找出上次的adjclose：</p>
<p><img src="strategy/images/1-5-1536x617.png" alt="" /></p>
<p>接下來，我們就可以來計算獲利：</p>
<pre><code class="language-python">pct_change = close.pct_change()
profit = pct_change.mean()
profit.sort_values()
</code></pre>
<p>上方的程式碼，
第一行，有好用的功能，叫做<code>adjclose.pct_change()</code>，這個函示會計算今天漲了x％，並且以x/100來表示，將整個table中的每一條時間序列都進行計算喔！
第二行，針對每一檔指數，將每一天的漲跌都平均起來，
第三行，進行由小到大的排序</p>
<p><img src="strategy/images/2-6-1536x880.png" alt="" /></p>
<p>以平均獲利來說，看到臺股（TSEC weighted index）竟然排在倒數第三位，
可以見臺灣投資人多麼可憐XDD</p>
<h3 id="如何衡量風險"><a class="header" href="#如何衡量風險">如何衡量風險</a></h3>
<p>風險通常會用標準差（standard deviation）來計算，標準差，可以想像是股票震盪的程度，例如金融海嘯的時候，股票上上下下的比較劇烈，標準差很大。今天就不折磨各位了，有興趣請參考<a href="https://zh.wikipedia.org/zh-tw/%E6%A8%99%E6%BA%96%E5%B7%AE">wiki介紹</a>，我們直接用 python 當中現有的程式碼來計算即可：</p>
<pre><code class="language-python">risk = pct_change.std()
</code></pre>
<h3 id="計算sharpe-ratio"><a class="header" href="#計算sharpe-ratio">計算sharpe ratio</a></h3>
<p>這個就更簡單了，直接相除即可</p>
<pre><code class="language-python">sharpe = profit / risk * (252 ** 0.5)
sharpe.sort_values()
</code></pre>
<p>可以看到上述程式，我們額外乘了一個「252 ** 0.5」
因為我們希望算年化 annual sharpe ratio，
其中的252是一年大約的交易天數，
而「**」是「次方」的意思。
為什麼要乘這個常數？最主要是因為大家幫自己的歷史回測計算sharpe ratio時候，都有乘上這個數字，要乘了才有辦法跟別人比較XD，
當然這背後可能有更深層的數學邏輯，但我傾向於這樣理解（懶）。</p>
<p><img src="strategy/images/6-4-1536x906.png" alt="" /></p>
<p>你會發現</p>
<h3 id="臺股竟然倒數第三名"><a class="header" href="#臺股竟然倒數第三名">臺股竟然倒數第三名！</a></h3>
<p>註：2020年更新，臺灣排名第六名！超級前面～～～</p>
<p>可以發現臺股真的好慘，慘不忍睹，為什麼會這樣呢，我們可以將歷史圖表畫出來：</p>
<p><img src="strategy/images/3-5-1536x610.png" alt="" /></p>
<p>可以發現因為我們是從1998年開始計算的，那個時候剛好也上萬點，跟現在的萬點是同一個萬點，反觀我們來看美股：</p>
<p><img src="strategy/images/4-5-1536x614.png" alt="" /></p>
<p>可以看到從1998年開始，直到現在漲了將近3倍！
可見臺股的獲利不理想是導致於sharpe ratio比較低的很大的因素。</p>
<p>我們目前計算的sharpe ratio，是所有歷史資料的平均值，
然而我們知道，雖然臺股總平均來說很爛，但是應該有時也有可圈可點之處，
我們希望用時間移動窗格，每日都計算252天以前的sharpe值，</p>
<p>來找出臺股表現比較好的時段</p>
<h3 id="移動窗格"><a class="header" href="#移動窗格">移動窗格</a></h3>
<p>你以為這個很難嗎？其實超簡單，跟上面幾乎一樣，只要做一點小更改：</p>
<pre><code class="language-python"># before
profit = pct_change.mean()
risk = pct_change.std()
sharpe = profit / risk * (252 ** 0.5)

# after
profit = pct_change.rolling(252).mean()
risk = pct_change.rolling(252).std()
sharpe = profit / risk * (252 ** 0.5)
</code></pre>
<p>幾乎長的一模一樣對吧？唯一不一樣的是<code>rolling(252)</code>這個功能，
這是移動窗格252天的意思。
額外要注意的是，之前的寫法中，sharpe是一個series，index為指數名稱，而在現在的寫法中，sharpe變成了一個dataframe（table），其index代表日期，而columns代表每檔指數，其中的數值是 252 天的 sharpe ratio，神奇吧！</p>
<p>這就是python跟R最強大的資料處理功能！</p>
<p>有了這個移動窗格版的sharpe ratio，我們做圖後，就可以來看一些端倪：</p>
<h3 id="做圖看端倪"><a class="header" href="#做圖看端倪">做圖看端倪</a></h3>
<pre><code class="language-python">close['TSEC weighted index'].plot()
sharpe['TSEC weighted index'].plot(secondary_y=True)
</code></pre>
<p>以上的代碼可以繪出下面這張圖，其中藍色的為加權指數，而黃色的為sharpe ratio，由於這兩個時間序列的數值差非常多，臺股可能是在4000～10000左右，而sharpe可能是在-2～2左右，所以上方第二行程式中，我們用<code>secondary_y=True</code>這個參數，來將兩個數值的座標分開，所以下方的圖中，可以看到sharpe ratio的大小標示在右邊。</p>
<p>以上所有程式碼，都可以在<a href="https://colab.research.google.com/drive/1W-pA4jdlPVfil9WZqsRK0Nd8Mel4tMlx?usp=sharing"> colab 範例中</a>找到喔！</p>
<p><img src="strategy/images/5-5-1536x642.png" alt="" /></p>
<p>可以看到，sharpe ratio （黃）在臺股加權指數（藍）高點時，會比較大，而臺股低點時，會比較低
圖中還可以看出，在大盤高點時，sharpe ratio會領先大盤往下落，接下來我們就可以利用這個特點，來模擬一些買賣的實驗。</p>
<h1 id="避開危險的投資時機--夏普指數策略"><a class="header" href="#避開危險的投資時機--夏普指數策略">避開危險的投資時機 – 夏普指數策略</a></h1>
<p>出處：https://www.finlab.tw/python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E5%A4%8F%E6%99%AE%E6%8C%87%E6%95%B8%E7%AD%96%E7%95%A5/</p>
<p>可以用來衡量風險跟報酬的指標（也就是報酬 / 風險），這集我們就利用Sharpe ratio來進行臺股的模擬買賣，假裝我們這20年來，都使用sharpe ratio的策略，可以得到多少獲利呢？</p>
<h3 id="為何sharpe-ratio幾乎都小於一"><a class="header" href="#為何sharpe-ratio幾乎都小於一">為何Sharpe ratio幾乎都小於一</a></h3>
<p>上次有人問我，夏普指標小於一，代表風險（分母）大於獲利（分子），而為什麼市面上所有的指數，其sharpe ratio都小於一，難道股票都不能賺錢嗎？</p>
<p>這只是代表，在股市中，我們為了要獲利，往往需要承受很大的風險！但不代表長期投資下來是不能獲利的。我們必須要找到sharpe ratio比較高的策略，才能使風險降低，獲利升高。</p>
<h3 id="利用python研發一個策略"><a class="header" href="#利用python研發一個策略">利用Python研發一個策略</a></h3>
<p>首先，我們得準備臺股的歷史紀錄，還有臺股的夏普指標，假如之前沒有跟上，可以到<a href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E9%A2%A8%E9%9A%AA%E8%88%87%E5%A0%B1%E9%85%AC/">上一個單元</a>複習一下喔！：</p>
<pre><code class="language-python">close['TSEC weighted index'].plot()
sharpe['TSEC weighted index'].plot(secondary_y=True)
</code></pre>
<p><img src="strategy/images/1-1-2.png" alt="" /></p>
<p>可以發現，當sharpe ratio比較低時，臺股也都是在比較低點，
可以發現，當sharpe ratio比較高時，臺股也都是在比較高點，
當sharpe ratio 轉折時，通常也是臺股會轉折的時候</p>
<p>利用這個觀察，我們就可以來編寫一個策略：</p>
<ol>
<li>當sharpe ratio往上轉折時，則買入</li>
<li>當sharpe ratio往下轉折時，則賣出</li>
</ol>
<h3 id="利用python快速編寫"><a class="header" href="#利用python快速編寫">利用Python快速編寫</a></h3>
<p>為了找出轉折點，我們必須做一點資料處理：</p>
<ol>
<li>時間序列的平滑</li>
<li>時間序列的斜率</li>
<li>找出斜率由正到負，或由負到正的訊號</li>
</ol>
<p>為了使用python寫出上述的策略，我們要先將夏普值平滑一下，不然雜訊太多了：</p>
<pre><code class="language-python">sr = sharpe['TSEC weighted index'].dropna()

d = 60
srsma = sr.rolling(d).mean()
sr.plot()
srsma.plot()
</code></pre>
<p><img src="strategy/images/2-1-2.png" alt="" /></p>
<p>來色的線是我們就將sharpe ratio做移動窗格的平均，可以發現平均之後，時間序列比較平滑，這樣子我們找轉折點比較方便，所謂的轉折點，就是斜率由正到負，或由負到正的瞬間，所以我們要先找出夏普曲線的斜率。</p>
<h3 id="夏普曲線的斜率"><a class="header" href="#夏普曲線的斜率">夏普曲線的斜率</a></h3>
<p>斜率非常簡單，可以使用<code>diff</code>這個功能：</p>
<pre><code class="language-python">srsma = sr.rolling(d).mean()
srsmadiff = srsma.diff()
srsma.plot()
srsmadiff.plot(secondary_y=True)
</code></pre>
<p><img src="strategy/images/3-1-3.png" alt="" /></p>
<p>可以發現上圖中，橘色的為sharpe ratio，藍色的為斜率，當橘色線由上而下轉折時，藍色的線會快速向下穿越0，有了這個特性，我們就可以來找轉折點了！</p>
<h3 id="找轉折點"><a class="header" href="#找轉折點">找轉折點</a></h3>
<p>接下來我們可以來找轉折點了，就是斜率由正到負，或由負到正的瞬間。</p>
<pre><code class="language-python">buy = (srsmadiff &gt; 0) &amp; (srsmadiff.shift() &lt; 0)
sell = (srsmadiff &lt; 0) &amp; (srsmadiff.shift() &gt; 0)

(buy * 1).plot()
(sell * -1).plot()
</code></pre>
<p><img src="strategy/images/4-1-3.png" alt="" /></p>
<p>以上就是簡單的訊號產生</p>
<h3 id="找出持有的時段"><a class="header" href="#找出持有的時段">找出持有的時段</a></h3>
<p>那我們就可以來看一下，假如天都用一樣的方式來產生這些訊號，當 <code>buy</code>訊號為<code>True</code>時，買入，而當<code>sell=True</code>時空手，如此執行20年的持有加權指數的時段：</p>
<pre><code class="language-python">import numpy as np
hold = pd.Series(np.nan, index=buy.index)
hold[buy] = 1
hold[sell] = -1
hold.ffill(inplace=True)
hold.plot()
</code></pre>
<p><img src="strategy/images/5-1-2.png" alt="" /></p>
<p>交易頻率似乎有點高，不過沒關係，我們之後還會再做調整
接來是回測</p>
<h3 id="回測"><a class="header" href="#回測">回測</a></h3>
<p>今天我們先簡單算一算，不考慮手續費，但是真實情況是必須考慮的喔！請謹記在心</p>
<pre><code class="language-python">twii = adjclose['TSEC weighted index'][buy.index]

pct_change = twii.pct_change()
pct_ratio = (pct_change.shift(-1)+1) # 今天到明天的價格變化

pct_ratio.fillna(1)[hold == 1].cumprod().plot()
</code></pre>
<p>這段程式碼，有點複雜，當中的<code>pct_change</code>是一個每天獲利上下 x％。
而<code>pct_ratio</code>代表買入之後每天的變化（不漲不跌是1，大於1則漲，小於1則跌）
我們希望將「持有」時間段的<code>pct_ratio</code>全部都乘起來，代表獲利。</p>
<p><img src="strategy/images/6-2-1.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="揭開策略的波動面紗maemfe分析圖組使用指南"><a class="header" href="#揭開策略的波動面紗maemfe分析圖組使用指南">揭開策略的波動面紗｜MAE&amp;MFE分析圖組使用指南</a></h1>
<p>出處 : https://www.finlab.tw/display_mae_mfe_analysis/</p>
<p>一般我們跑回測會取得報酬率曲線、最大回撤、夏普率等策略總體數值，但這些指標讓我們難以一窺策略下每筆交易的實際波動細節。交易就像跑步比賽，若只看總體數值結果，就像只看一個人跑步的結果，不看過程細節，但這些過程都是我們可以觀察、優化的階段，比如要觀察策略波動時序、勝敗手交易的波動分佈是否明顯分群、策略的停損停利怎麼放比較好？藉由對波動性的分析，就不用每次都要堅持跑完煎熬的過程，可能讓我們在更佳點位出場，減少被洗掉、沒高歌離席的遺憾。</p>
<p>內容目錄  隱藏 
1 如何顯示MAE&amp;MFE分析圖組</p>
<p>1.1 程式範例
1.2 輸出圖組範例
2 名詞定義2.1 波幅
2.2 Edge ratio
3 如何解讀圖組
3.1 報酬率統計圖
3.2 Edge Ratio 時序圖
3.2.1 參數設定
3.2.2 應用解釋
3.3 MAE/Return 分佈圖
3.4 MFE/MAE 分佈圖
3.4.1 分佈象限圖解
3.5 MDD/GMFE 分佈圖
3.6 MAE、ＭFE 密度分佈圖
4 Indices Stats
5 結論
6 相關學習資源</p>
<h2 id="如何顯示maemfe分析圖組"><a class="header" href="#如何顯示maemfe分析圖組">如何顯示MAE&amp;MFE分析圖組</a></h2>
<p>Finlab的<a href="https://doc.finlab.tw/reference/analysis/#finlab.analysis.Report.display_mae_mfe_analysis">回測分析模組</a>可以輕鬆將<code>Report.get_trades(...)</code> 的結果帶入<a href="https://plotly.com/graphing-libraries/">Plotly.python</a>做視覺化呈現。</p>
<h3 id="程式範例"><a class="header" href="#程式範例">程式範例</a></h3>
<pre><code class="language-python">from finlab import data
from finlab.backtest import sim

pb = data.get('price_earning_ratio:股價淨值比')
close = data.get('price:收盤價')

position = (1/(pb * close) * (close &gt; close.average(60)) * (close &gt; 5)).is_largest(20)
report = sim(position, resample='Q',mae_mfe_window=30,mae_mfe_window_step=2)
report.display_mae_mfe_analysis()
</code></pre>
<h3 id="輸出圖組範例"><a class="header" href="#輸出圖組範例">輸出圖組範例</a></h3>
<p><img src="strategy/images/newplot-1-1024x1024.png" alt="newplot 1" /></p>
<h2 id="名詞定義"><a class="header" href="#名詞定義">名詞定義</a></h2>
<h3 id="波幅"><a class="header" href="#波幅">波幅</a></h3>
<p>再分析接下來的圖表前，要先認識一下波幅的分類，有利於分析前建立基礎知識。</p>
<p><img src="strategy/images/price-data.png" alt="price data" /></p>
<ul>
<li>AE (adverse excursion) : 不利方向幅度，做多的話，就是下跌的波段。</li>
<li>MAE : 最大不利方向幅度，做多的話，就是持有過程中的最大累積跌幅。</li>
<li>FE (favorable excursion) : 有利方向幅度，做多的話，就是上漲的波段。</li>
<li>BMFE : MAE之前發生的最大有利方向幅度。若BMFE越高，越有可能在碰上MAE之前，先觸及停利出場 (註1)。</li>
<li>GMFE (Global MFE) : 全域最大有利方向幅度。若發生在MAE之前，則BMFE等於GMFE。若在MAE之後，則代表要先承受MAE才可能吃到較高的獲利波段。</li>
<li>MDD (Max Drawdown) : 最大回撤幅度。</li>
<li>Return : 報酬率。</li>
</ul>
<h3 id="edge-ratio"><a class="header" href="#edge-ratio">Edge ratio</a></h3>
<p><img src="strategy/images/newplot-1-1024x1024.png" alt="newplot 1" /></p>
<p>來自海龜法則 (註2) 的指標，中文稱優勢比率。
edge ratio為平均GMFE / 平均MAE，這可以藉此評估進場優勢，一個真正隨機性的訊號大致上會帶來相等的MFE與MAE。
若大於1，代表存在正優勢，潛在最大獲利空間比最大虧損多，在持有過程中保有優勢可以中途停利或做其他操作，也就是策略的容錯率較高。反之則為劣勢，可能要抗衡較多的虧損狀態。</p>
<h2 id="如何解讀圖組"><a class="header" href="#如何解讀圖組">如何解讀圖組</a></h2>
<p>將交易分為獲利 (profit-藍點) 與虧損 (loss-紅點) 分別呈現，圖組右方的legend可以任一點選，只看profit或loss的分群呈現。接著會「由上到下、由左至右」，解釋各子圖用途。</p>
<h3 id="報酬率統計圖"><a class="header" href="#報酬率統計圖">報酬率統計圖</a></h3>
<p><img src="strategy/images/testtest.png" alt="截圖 2022 07 25 上午11.40.10" /></p>
<p>子圖1-1，呈現策略下每筆交易的報酬率分佈，計算出勝率及平均每筆報酬。
圖片標題為交易勝率，綠色虛線為平均每筆交易的報酬率。
分佈曲線越平坦，代表報酬率範圍大，可能有較多的極端報酬率要處理，通常出現在波動大的策略。
若呈現右偏型態(右側的尾部更長，分佈的主體集中在左側)，代表多數交易為虧損，若整體策略為獲利，則獲利為少筆交易為主要貢獻。
若呈現左偏型態(左側的尾部更長，分佈的主體集中在右側)，代表多數交易為獲利。
若呈現鐘型曲線，代表分佈較為平均。</p>
<h3 id="edge-ratio-時序圖"><a class="header" href="#edge-ratio-時序圖">Edge Ratio 時序圖</a></h3>
<p><img src="strategy/images/edge_ratio.png" alt="edge ratio" /></p>
<p>子圖1-2是策略edge ratio隨進場時間 (x軸) 後的變化，可以判斷隨著持有時間推移，策略有沒有波幅操作優勢。</p>
<h4 id="參數設定"><a class="header" href="#參數設定">參數設定</a></h4>
<p>edge ratio的計算設定由回測函數<code> backtest.sim()</code> 裡的mae_mfe_window, mae_mfe_window_step 兩個參數來控制。</p>
<ul>
<li>mae_mfe_window : 計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為優勢比率計算。預設為0，只會產生出場階段的mae_mfe。</li>
<li>mae_mfe_window_step : 與 mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step 設定為2，相當於 python 的range(0,20,2)，以2日為間距計算mae_mfe。</li>
</ul>
<h4 id="應用解釋"><a class="header" href="#應用解釋">應用解釋</a></h4>
<p>edge ratio若一直保持在1以上，持有都具有優勢，子圖範例就是這類情況，開局就有不錯表現，明顯的谷底落在第8天後持續走高，代表可能延遲到第8天進場會有低點，之後獲利一路放大優勢。
edge ratio時序圖走勢有很多種，若是開低走高，一開始都低於1，代表策略可能太早進場，一開始都要先承受虧損，這時可以檢討進場時機點，考慮延遲進場。</p>
<p>若edge ratio走勢保持在1以上，代表策略優勢明顯。若還隨著時間走高，獲利空間也上升，策略容錯率就較大，就算因一些因素延遲進場仍有較大機率有獲利範圍。
若edge ratio走勢很常在1以下，代表策略經常被虧損壓著打，是策略負面訊號。</p>
<p>若隨持有時間變化，優勢漸漸流失，比率開始下降，代表MAE普遍變高，可能是策略催化劑褪色，該策略適合短線操作並考慮加上停利提早出場。
若edge ratio走勢跳動，代表無明顯趨勢可判斷。
若策略週期是20天，發現time_scale大於20時，edge ratio趨勢持續走升，則透露策略可能太早出場，錯過後面更大的報酬，可以考慮修正持股週期，吃到更大的獲利。</p>
<h3 id="maereturn-分佈圖"><a class="header" href="#maereturn-分佈圖">MAE/Return 分佈圖</a></h3>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8A%E5%8D%8811.43.44.png" alt="截圖 2022 07 25 上午11.43.44" /></p>
<p>子圖1-3，x軸為報酬率，Y軸為MAE，將勝敗手分群顯示成散點圖，比對報酬率與MAE的關係。
此範例中可以發現多數獲利的藍點都有較小的MAE，虧損的紅點有較大的MAE。
虧損部位的MAE第75%位數為10.77%，幾乎所有的藍點都低於這個位置，也就是說過了這個位置，交易最終就容易是虧損結果，可<strong>設為停損</strong>參考位置，可保留多數獲利部位、減少大賠部位損失。
獲利部位的MAE第75%位數為2.93%，代表多數獲利部位在持有過程中可能的最低點區間，碰到這位置後就有較高機率再往上，積極操作者或分批進場者可<strong>設為攤平加碼點</strong>位置，有機會讓獲利空間更多或賠更多。</p>
<h3 id="mfemae-分佈圖"><a class="header" href="#mfemae-分佈圖">MFE/MAE 分佈圖</a></h3>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8B%E5%8D%8812.00.35.png" alt="" /></p>
<p>從子圖 2-1、2-2 可以觀察MAE與MFE的數據關係，散點圖大小由報酬率來決定。
比對兩張圖可發現，策略內許多GMFE很大的標的，都比BMFE大，代表許多漲幅都發生在MAE之後。想要有較高獲利，就要先忍受回檔，通常這容易發生在趨勢波段策略。
若是短線優異的策略，BMFE 會比較高，可以有較高機率在接觸MAE或停損前先做停利。</p>
<h4 id="分佈象限圖解"><a class="header" href="#分佈象限圖解">分佈象限圖解</a></h4>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2020-09-29-%E4%B8%8A%E5%8D%887.48.31-1536x997.png" alt="" /></p>
<p>MAE/BMFE分佈圖(註3) 能幫助我們看出策略體質、優化設置停損停利。
大原則是「分佈在第二象限的點越多越好， 第四象限的點越少越好」、「獲利與虧損明顯分群在不同象限」。
如此 stop_loss過濾掉多數mae過大的標的，少過濾掉獲利的標的。take_profit盡量讓多數虧損的交易先觸及停利出場。</p>
<h3 id="mddgmfe-分佈圖"><a class="header" href="#mddgmfe-分佈圖">MDD/GMFE 分佈圖</a></h3>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8A%E5%8D%8811.59.11.png" alt="" /></p>
<p>子圖2-3，判斷損益兩平點與鎖利點，橘線為45度線。
橘線以上為MDD &gt; GMFE，如果越多獲利點位於這個位置，代表持有歷程可能歷經大回檔吃掉獲利轉為虧損，雖然最終會是獲利，但我們原本有機會賺更多。</p>
<p>MDD &gt; GMFE 的情況常是一開始就吃大虧損～後來轉正，或是途中大賺後，突然急速下殺賠錢。都是比較不理想的狀況。子標題顯示的「Missed win-profits pct」為「獲利交易位於橘線上的數量/獲利交易數」，數值越高代表潛在錯失獲利的機會較高，數值越高代表越需要設定移動停利去保護獲利。</p>
<p>橘線以下為MDD &lt; GMFE，代表獲利的交易達到價格高點後，即使後來回檔，因回檔不會吃掉全部GMFE，所以不會轉為虧損。若是虧損的部位位於橘線以下，由於MAE &lt;= MDD &lt; GMFE、MAE &lt;= Return，可以推導出即使虧損，MAE也會比GMFE小，比較高的機會是小虧出場。子標題顯示的「Breakeven safe pct」 為「橘線下的比例/全部交易數」，也就是越不容易輸的比例。</p>
<h3 id="maeＭfe-密度分佈圖"><a class="header" href="#maeＭfe-密度分佈圖">MAE、ＭFE 密度分佈圖</a></h3>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8B%E5%8D%8812.40.53-1536x414.png" alt="" /></p>
<p>子圖3-1、3-2、3-3。由 <a href="https://plotly.com/python/distplot/">plotly-distplot</a> 繪製而成，看指標的比例分佈曲線。
子圖3-1為 MAE 密度分佈圖，通常策略體質若較優，勝敗手的高峰會有明顯分群，贏錢的MAE通常較小、輸錢的MAE通常較大，向右過了藍紅曲線的交叉點後，虧損的交易會變得比獲利的交易多，可以視為比較緊的停損點或是開始分批停損的參考。勝敗手Q3(第75分位數)的應用可參考MAE/Return 分佈圖的說明，勝手Q3為積極者加碼點，敗手Q3為絕對停損點，再不跑就容易大賠啦！</p>
<p>子圖 3-2、3-3 為 MFE 密度分佈圖，應用概念與子圖3-1類似。
多數的敗手不會超過敗手MFE Q3 的位置 (圖中的5.16)，換句話說，漲過這個點後，多數交易最終會是獲利的，既然最終會是獲利的，那就會是一個不錯的突破加碼點位，若想要更高的機率確保加碼點安全性，可以用敗手MFE 大於Q3 的位置，例如藍紅曲線的交叉點。
勝手MFE Q3 則可視為分批停利減碼點參考位置。</p>
<h2 id="indices-stats"><a class="header" href="#indices-stats">Indices Stats</a></h2>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8B%E5%8D%8812.42.21-1536x431.png" alt="" /></p>
<p>group模式</p>
<p><img src="strategy/images/%E6%88%AA%E5%9C%96-2022-07-25-%E4%B8%8B%E5%8D%881.41.57-1536x425.png" alt="" /></p>
<p>overlay模式</p>
<p>子圖4-1，將各種數據用<a href="https://plotly.com/python/violin/">提琴圖</a>呈現統計結果，可藉由<code>display_mae_mfe_analysis</code> 中的 violinmode 參數控制顯示模式，預設為group模式，將勝敗手分群統計，overlay模式為全數統計。提琴圖hover過後能顯示數據的<strong>分位數</strong>資料，可快速觀察所有數據的統計分佈，方便設定停損停利點能參考分位數的數值。
除了先前介紹的mae_mfe，其他還有統計數值:</p>
<ul>
<li>pdays_ratio:獲利交易日數/交易持有日數，中位數數值若大於0.5，代表多數交易持有期間都是獲利，操作起來更有彈性。若mfe高，但pdays_ratio低，代表若沒把握到衝高的少數時期，則會錯過理想報酬。</li>
</ul>
<h2 id="結論-1"><a class="header" href="#結論-1">結論</a></h2>
<p>是不是對波動分析更加瞭解了呢？一張圖表包山包海，完整分析出策略細節。</p>
<p>若想更深入瞭解MAE/MFE最大幅度分析法。除了國外資源，中文內容推薦<a href="https://www.maemfe.org/search/label/%E4%BA%A4%E6%98%93-MAE%2FMFE%E6%9C%80%E5%A4%A7%E5%B9%85%E5%BA%A6%E5%88%86%E6%9E%90%5B%E5%BD%B1%E7%89%87%5D">藍月記事</a>，其對這方面的策略體質觀察、優化有全方位的影片教學內容，作者對量化分析與交易心理有獨道見解，推薦大家前往學習。</p>
<hr />
<h2 id="為什麼策略優化容易讓-sltp-往-maemfe-分佈圖左上移動"><a class="header" href="#為什麼策略優化容易讓-sltp-往-maemfe-分佈圖左上移動">為什麼策略優化容易讓 SL/TP 往 MAE/MFE 分佈圖左上移動</a></h2>
<p>出處: https://www.maemfe.org/2020/05/why-the-sltp-moving-to-the-top-left-corner-of-MAEMFE-plot.html</p>
<p>今天來談一個在策略優化過程中，可能會遇到的一種情況</p>
<p>當我們在優化交易策略的參數的時候，有些人會把 Stoploss 和 Takeprofit 放進去一起優化。</p>
<p>這不是不行，如果你已經有一套方法去同時優化模型參數、SL/TP 那很好，但是如果你優化完，你發現每次到樣本外常常都掛掉的話，我會猜測可能 <strong>錯誤以為 MDD 變小是模型優化的「因」。</strong></p>
<p>通常來說，許多人會使用「<strong>粒度大</strong>」、「<strong>交易間</strong>」的評估指標，例如最大連續虧損（MDD）做為策略優化的參考 ，希望盡量找到一個 MDD 小的參數。</p>
<p>如果此時伴隨著 SL 和 TP 下去優化，有時候會得到 <strong>SL 開始變小</strong>、<strong>TP 開始變大</strong>，然後 <strong>MDD 變小</strong>的情況，很多人認為，這樣的情況代表「<strong>好</strong>」，因為每一筆交易的潛在虧損更小、潛在獲利更大，整體的 MDD 更小，感覺應該是更穩健。</p>
<p>在一些條件考量之下，這樣的想法是對的，但如果你如果經常使用這方式，還是無法在外樣本得到好的結果的話，你要謹慎考慮其實你落入一個優化的陷阱。</p>
<p>當你使用粒度大的評估指標，什麼是粒度大呢？也就是可能因為越少的交易，就使得這個評估指標急遽的變差的，我們就叫做粒度大的評估指標。</p>
<p>最大連續虧損就可能因為少數幾個交易連續大幅度的損失，就造成 MDD 非常高，所以 MDD 某種程度可以看成是粒度較大的評估指標；其次是夏普率，夏普率可能會因為少數一些交易帶來大幅度的報酬／虧損，使得淨值曲線的標準差急遽升高，這也是一個粒度大的評估指標。</p>
<p>這些粒度大的評估指標，因為容易受到少數的交易影響，所以你在優化過程中，很難在一開始就針對這些少數交易對陣下藥，所以如果你能讓 MDD 持續的下降，通常伴隨的是一種「<strong>全局</strong>」調整。</p>
<p>你認為可能因為些微修改模型參數，就能突然改善那些影響 MDD 的少數交易嗎？其實很難，大多數時候，你會發現都是因為 SL/TP 的調整，讓 MDD 變小、讓夏普遍高。</p>
<p>所以，這個錯誤的以 MDD 為因的情況，可能是以這樣的一種情況在優化：</p>
<p><strong>調整模型參數、訊號濾網 → 降低SL/提高TP → MDD變小</strong></p>
<p>所以你以為你在優化參數、調整濾網，讓 MDD 變小，但其實你是在讓模型參數能讓你更加的能降低 SL 提高 TP，這樣才能「<strong>對全部交易有直接影響</strong>」而間接降低 MDD，所以 MDD 變小隻是一個結果。</p>
<p>這會有什麼問題呢？</p>
<p>當持續性的降低 SL 和提高 TP，你其實對於波動的忍耐度就更低，所以你如果參數還能賺錢，通常來說你只是在不斷地讓模型參數、訊號濾網維持一個程度的勝率，使得這個勝率下的 SL 能繼續縮小、TP 繼續提高。</p>
<p>通常維持勝率比較依賴進場的時機，當勝率無法維持，通常下一步就是調整出場時機，讓某一些少數交易能帶來大幅度的獲利，所以接下來會看見勝率衰減、平均報酬增加、平均虧損降低，然後繼續縮小 SL，提高 TP。</p>
<p>在這過程中，你的進場和出場已經被特別優化了，這時候你如果還是使用「交易間」的評估方式，你就根本看不到買賣訊號裡面到底有沒有配合波動進出。</p>
<p>到最後，就是過擬合。</p>
<p>很多人發現，**在這樣的優化過程中只要稍微考慮一下加減碼，就會讓優化變得順利一點，為什麼？**因為你等於把 SL/TP 過度優化的負擔分攤出去，然後你的加減碼某種程度其實反應的就是在不同市場波動水準下的調整，當然你在樣本外就會看到好像和樣本內有一咪咪相似的感覺。</p>
<p>但是這樣模型還是不能用，你還是會掛掉，<strong>如果可以用，你就會發現你要經常性的重新訓練和優化你的策略參數，然後還有一些人以為，這樣代表我在「適應」市場</strong>，其實他只是在脫褲子放屁的「適應波動」而已。</p>
<h2 id="maximum-favorable-excursion-and-maximum-adverse-excursion-calculation-toolkit"><a class="header" href="#maximum-favorable-excursion-and-maximum-adverse-excursion-calculation-toolkit">Maximum favorable excursion and Maximum adverse excursion calculation Toolkit</a></h2>
<p>出處 :  https://github.com/RainBoltz/pymfae</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
import pandas as pd
import datetime as dt
import numpy as np
import plotly.graph_objs as go
import plotly.io as pio
import json


def get_mae(
    order_type: str,
    entry_time: dt.datetime or int,
    exit_time: dt.datetime or int,
    price_data: pd.DataFrame or pd.Series or np.array or list,
):
    &quot;&quot;&quot;
    parameters:
        order_type: str, 做多或做空 ('long' 或 'short')
        entry_time: dt.datetime 或 int, 進場時間 (若有OHLC資料，則視為open進場)
        exit_time: dt.datetime 或 int, 出場時間 (若有OHLC資料，則視為close出場)
        price_data: pd.DataFrame 或 pd.Series, 以datetime為index的價格資料
                    np.array 或 list, 以陣列紀錄的價格資料
                    (DataFrame為OHLC資料；Series、Array或List則為Tick或Close資料)

    return:
        mae: float, 交易期間最大回徹
        mae_time: dt.datetime 或 int, MAE發生時間
    &quot;&quot;&quot;
    mae = 0.0
    mae_time = None

    if type(price_data) == pd.DataFrame:
        data = price_data.loc[entry_time:exit_time]
        entry_price = data[&quot;open&quot;].loc[entry_time]
        for index, values in data.iterrows():
            if order_type == &quot;long&quot;:
                drawdown = values[&quot;low&quot;] - entry_price
            elif order_type == &quot;short&quot;:
                drawdown = entry_price - values[&quot;high&quot;]
            if mae &gt; drawdown:
                mae = drawdown
                mae_time = index

    elif type(price_data) == pd.Series:
        data = price_data.loc[entry_time:exit_time]
        entry_price = data.loc[entry_time]
        for index, values in enumerate(data):
            if order_type == &quot;long&quot;:
                drawdown = values - entry_price
            elif order_type == &quot;short&quot;:
                drawdown = entry_price - values
            if mae &gt; drawdown:
                mae = drawdown
                mae_time = index

    elif type(price_data) == np.array or type(price_data) == list:
        entry_price = price_data[entry_time]
        for index, values in enumerate(price_data[entry_time : exit_time + 1]):
            if order_type == &quot;long&quot;:
                drawdown = values - entry_price
            elif order_type == &quot;short&quot;:
                drawdown = entry_price - values
            if mae &gt; drawdown:
                mae = drawdown
                mae_time = entry_time + index

    return mae, mae_time


def get_mfe(
    order_type: str,
    entry_time: dt.datetime or int,
    exit_time: dt.datetime or int,
    price_data: pd.DataFrame or pd.Series or np.array or list,
):
    &quot;&quot;&quot;
    parameters:
        order_type: str, 做多或做空 ('long' 或 'short')
        entry_time: dt.datetime 或 int, 進場時間 (若有OHLC資料，則視為open進場)
        exit_time: dt.datetime 或 int, 出場時間 (若有OHLC資料，則視為close出場)
        price_data: pd.DataFrame 或 pd.Series, 以datetime為index的價格資料
                    np.array 或 list, 以陣列紀錄的價格資料
                    (DataFrame為OHLC資料；Series、Array或List則為Tick或Close資料)

    return:
        mfe: float, 交易期間最大回徹
        mfe_time: dt.datetime 或 int, MAE發生時間
    &quot;&quot;&quot;
    mfe = 0.0
    mfe_time = None

    if type(price_data) == pd.DataFrame:
        data = price_data.loc[entry_time:exit_time]
        entry_price = data[&quot;open&quot;].loc[entry_time]
        for index, values in data.iterrows():
            if order_type == &quot;long&quot;:
                profit = values[&quot;high&quot;] - entry_price
            elif order_type == &quot;short&quot;:
                profit = entry_price - values[&quot;low&quot;]
            if mfe &lt; profit:
                mfe = profit
                mfe_time = index

    elif type(price_data) == pd.Series:
        data = price_data.loc[entry_time:exit_time]
        entry_price = data.loc[entry_time]
        for index, values in enumerate(data):
            if order_type == &quot;long&quot;:
                profit = values - entry_price
            elif order_type == &quot;short&quot;:
                profit = entry_price - values
            if mfe &lt; profit:
                mfe = profit
                mfe_time = index

    elif type(price_data) == np.array or type(price_data) == list:
        entry_price = price_data[entry_time]
        for index, values in enumerate(price_data[entry_time : exit_time + 1]):
            if order_type == &quot;long&quot;:
                profit = values - entry_price
            elif order_type == &quot;short&quot;:
                profit = entry_price - values
            if mfe &lt; profit:
                mfe = profit
                mfe_time = entry_time + index

    return mfe, mfe_time


def mae_mfe_pair(
    order: list,
    price_data: pd.DataFrame or pd.Series or np.array or list,
    mae_first: bool = True,
):
    &quot;&quot;&quot;
    parameters:
        order: list, 所有交易紀錄，交易紀錄為dict
                交易紀錄格式:
                {
                    'order_type': str,
                    'entry_time': dt.datetime 或 int,
                    'exit_time': dt.datetime 或 int
                }
        price_data: pd.DataFrame 或 pd.Series, 以datetime為index的價格資料
                    np.array 或 list, 以陣列紀錄的價格資料
                    (DataFrame為OHLC資料；Series、Array或List則為Tick或Close資料)
        mae_first: bool (預設為True), MFE是否出現在MAE之前

    return:
        results: list, 所有交易紀錄結果，交易紀錄結果為dict
                交易紀錄結果格式:
                {
                    'mae': float,
                    'mfe': float,
                    'mae_time': dt.datetime 或 int,
                    'mfe_time': dt.datetime 或 int
                }
    &quot;&quot;&quot;
    results = []
    for this_order in order:
        mae, mae_time = get_mae(
            this_order[&quot;order_type&quot;],
            this_order[&quot;entry_time&quot;],
            this_order[&quot;exit_time&quot;],
            price_data,
        )

        if mae_first:
            mfe, mfe_time = get_mfe(
                this_order[&quot;order_type&quot;], this_order[&quot;entry_time&quot;], mae_time, price_data
            )
        else:
            mfe, mfe_time = get_mfe(
                this_order[&quot;order_type&quot;],
                this_order[&quot;entry_time&quot;],
                this_order[&quot;exit_time&quot;],
                price_data,
            )

        results.append(
            {&quot;mae&quot;: mae, &quot;mfe&quot;: mfe, &quot;mae_time&quot;: mae_time, &quot;mfe_time&quot;: mfe_time}
        )

    return results


def mae_mfe(orders, x_y_line=True, return_fig_ax=False):
    &quot;&quot;&quot;
    parameters:
        orders: list, 所有交易的mae和mfe資料，資料必須放在dict裡面
            資料格式:
            {
                'mae': float,
                'mfe': float,
                ...
                (可以包含其他資料)
            }
        
        x_y_line: bool (預設為True), 是否繪製x=y的虛線
        return_fig_ax: bool (預設為False), 是否回傳matplotlib的繪圖元件

    return:
        (optional)
        fig: plotly的基本繪圖元件
    &quot;&quot;&quot;
    fig = go.Figure()

    mae = []
    mfe = []
    for order in orders:
        mae.append(abs(order[&quot;mae&quot;]))
        mfe.append(order[&quot;mfe&quot;])
    fig.add_trace(
        go.Scatter(
            x=mae, y=mfe, mode=&quot;markers&quot;, name=&quot;Orders&quot;, marker=dict(color=&quot;red&quot;)
        )
    )

    if x_y_line:
        x_y_line_x = [0, max(max(mae), max(mfe))]
        x_y_line_y = [0, max(max(mae), max(mfe))]
        fig.add_trace(
            go.Scatter(
                x=x_y_line_x,
                y=x_y_line_y,
                mode=&quot;lines&quot;,
                name=&quot;x=y&quot;,
                line=dict(dash=&quot;dash&quot;, color=&quot;black&quot;, width=1),
            )
        )

    fig.update_layout(
        xaxis_title=&quot;MAE&quot;, yaxis_title=&quot;MFE&quot;, title=&quot;MAE vs MFE&quot;, legend=dict(title=&quot;&quot;)
    )

    if return_fig_ax:
        return fig
    else:
        pio.show(fig)


if __name__ == &quot;__main__&quot;:

    # Define your price data as a pandas DataFrame or Series, or as a numpy array or list
    price_data = pd.DataFrame(
        {
            &quot;open&quot;: [10, 12, 15, 13, 14],
            &quot;high&quot;: [13, 15, 17, 16, 16],
            &quot;low&quot;: [9, 11, 14, 12, 12],
            &quot;close&quot;: [12, 14, 16, 14, 15],
        },
        index=[
            dt.datetime(2021, 1, 1, 9, 0),
            dt.datetime(2021, 1, 2, 9, 0),
            dt.datetime(2021, 1, 3, 9, 0),
            dt.datetime(2021, 1, 4, 9, 0),
            dt.datetime(2021, 1, 5, 9, 0),
        ],
    )

    # Define your orders as a list of dictionaries, with each dictionary representing an order
    orders = [
        {
            &quot;order_type&quot;: &quot;long&quot;,
            &quot;entry_time&quot;: dt.datetime(2021, 1, 1, 9, 0),
            &quot;exit_time&quot;: dt.datetime(2021, 1, 2, 9, 0),
        },
        {
            &quot;order_type&quot;: &quot;short&quot;,
            &quot;entry_time&quot;: dt.datetime(2021, 1, 2, 9, 0),
            &quot;exit_time&quot;: dt.datetime(2021, 1, 3, 9, 0),
        },
        {
            &quot;order_type&quot;: &quot;long&quot;,
            &quot;entry_time&quot;: dt.datetime(2021, 1, 3, 9, 0),
            &quot;exit_time&quot;: dt.datetime(2021, 1, 4, 9, 0),
        },
        {
            &quot;order_type&quot;: &quot;short&quot;,
            &quot;entry_time&quot;: dt.datetime(2021, 1, 4, 9, 0),
            &quot;exit_time&quot;: dt.datetime(2021, 1, 5, 9, 0),
        },
    ]

    print(price_data.to_markdown(), &quot;\n&quot;)
    print(json.dumps(orders, indent=4, default=str))

    # Call the mae_mfe_pair function with your orders and price data
    results = mae_mfe_pair(orders, price_data)

    # The results will be a list of dictionaries, with each dictionary representing the MAE/MFE for an order
    print(json.dumps(results, indent=4, default=str))

    # mae_mfe(results)
</code></pre>
<pre><code class="language-sh">|                     |   open |   high |   low |   close |
|:--------------------|-------:|-------:|------:|--------:|
| 2021-01-01 09:00:00 |     10 |     13 |     9 |      12 |
| 2021-01-02 09:00:00 |     12 |     15 |    11 |      14 |
| 2021-01-03 09:00:00 |     15 |     17 |    14 |      16 |
| 2021-01-04 09:00:00 |     13 |     16 |    12 |      14 |
| 2021-01-05 09:00:00 |     14 |     16 |    12 |      15 | 

[
    {
        &quot;order_type&quot;: &quot;long&quot;,
        &quot;entry_time&quot;: &quot;2021-01-01 09:00:00&quot;,
        &quot;exit_time&quot;: &quot;2021-01-02 09:00:00&quot;
    },
    {
        &quot;order_type&quot;: &quot;short&quot;,
        &quot;entry_time&quot;: &quot;2021-01-02 09:00:00&quot;,
        &quot;exit_time&quot;: &quot;2021-01-03 09:00:00&quot;
    },
    {
        &quot;order_type&quot;: &quot;long&quot;,
        &quot;entry_time&quot;: &quot;2021-01-03 09:00:00&quot;,
        &quot;exit_time&quot;: &quot;2021-01-04 09:00:00&quot;
    },
    {
        &quot;order_type&quot;: &quot;short&quot;,
        &quot;entry_time&quot;: &quot;2021-01-04 09:00:00&quot;,
        &quot;exit_time&quot;: &quot;2021-01-05 09:00:00&quot;
    }
]
[
    {
        &quot;mae&quot;: &quot;-1&quot;,    
        &quot;mfe&quot;: &quot;3&quot;,
        &quot;mae_time&quot;: &quot;2021-01-01 09:00:00&quot;,
        &quot;mfe_time&quot;: &quot;2021-01-01 09:00:00&quot;
    },
    {
        &quot;mae&quot;: &quot;-5&quot;,
        &quot;mfe&quot;: &quot;1&quot;,
        &quot;mae_time&quot;: &quot;2021-01-03 09:00:00&quot;,
        &quot;mfe_time&quot;: &quot;2021-01-02 09:00:00&quot;
    },
    {
        &quot;mae&quot;: &quot;-3&quot;,
        &quot;mfe&quot;: &quot;2&quot;,
        &quot;mae_time&quot;: &quot;2021-01-04 09:00:00&quot;,
        &quot;mfe_time&quot;: &quot;2021-01-03 09:00:00&quot;
    },
    {
        &quot;mae&quot;: &quot;-3&quot;,
        &quot;mfe&quot;: &quot;1&quot;,
        &quot;mae_time&quot;: &quot;2021-01-04 09:00:00&quot;,
        &quot;mfe_time&quot;: &quot;2021-01-04 09:00:00&quot;
    }
]

# 解說: &quot;order_type&quot;: &quot;long&quot;, &quot;entry_time&quot;: &quot;2021-01-01 09:00:00&quot;, &quot;exit_time&quot;: &quot;2021-01-02 09:00:00&quot; 
# 2021-1-1 以open價為基準是10, 2021-1-1 low:9 所以mae: -1, 2021-1-1 high:13 所以  
&quot;mae&quot;: &quot;-1&quot;,    
&quot;mfe&quot;: &quot;3&quot;,
&quot;mae_time&quot;: &quot;2021-01-01 09:00:00&quot;,
&quot;mfe_time&quot;: &quot;2021-01-01 09:00:00&quot;
</code></pre>
<ul>
<li>策策略裡停損的標準是採用mdd還是mae?
<ul>
<li>mae, mdd跟移動出場比較有關</li>
</ul>
</li>
<li>B_mfe
<ul>
<li>B_mfe是mae之前的mfe，做多的話，也就是你吃到最大下跌前的漲幅，一般會用mae決定停損位置，mfe決定停利，若你的B_mfe蠻高的，有比較高的機率在停損前停利，這是理想的狀況。</li>
</ul>
</li>
<li>G_mfe
<ul>
<li>G_mfe是全域的mfe，最大漲幅可能出現在mae之後，若你的策略B_mfe很小，G_mfe較大，代表你的策略容易先吃跌再上衝，停損不能設太緊，不然會被洗掉，通常這是波動大策略會有的現象，應對策略可以考慮延遲進場，降低成本，這會延伸到edge ratio對mfe/mae的時序分析，看哪時候進場的mfe/mae最大。</li>
</ul>
</li>
<li>策略若個股勝率低於40%，建議別再自選，整個策略買，自己再選容易買到跌的，但策略整體卻是漲。 
<ul>
<li>我是習慣加條件把策略縮到5-10檔，集火拚高報酬，偏愛動能與高成長。每個月換股一次讓他去跑。 進出場點優化用海龜法則的優勢比率分析、停損停利用mae mfe分析。</li>
</ul>
</li>
</ul>
<h2 id="計算出--mae-bmfe-gmfe"><a class="header" href="#計算出--mae-bmfe-gmfe">計算出  mae bmfe gmfe</a></h2>
<pre><code class="language-python">import pandas as pd


def get_metrics(prices):
    base_price = prices[0]
    min_price = min(prices)
    max_price = max(prices[1:])

    max_price_before_min = (
        max(prices[: prices.index(min_price)])
        if min_price is not None and prices[: prices.index(min_price)] != []
        else None
    )

    bmfe = (
        ((max_price_before_min - base_price) / base_price) * 100
        if max_price_before_min is not None and base_price &lt; max_price_before_min
        else 0
    )

    gmfe = (
        ((max_price - base_price) / base_price) * 100
        if max_price is not None and max_price &gt; base_price
        else 0
    )

    mae = (
        (min_price - base_price) / base_price * 100
        if min_price is not None and min_price &lt; base_price
        else 0
    )

    return mae, bmfe, gmfe


def get_max_drawdown(prices):
    df = pd.DataFrame(prices, columns=[&quot;Close&quot;])
    df[&quot;Max&quot;] = df[&quot;Close&quot;].cummax()
    df[&quot;Drawdown&quot;] = df[&quot;Close&quot;] / df[&quot;Max&quot;] - 1
    df[&quot;Max Drawdown&quot;] = df[&quot;Drawdown&quot;].cummin()
    mdd = df[&quot;Max Drawdown&quot;].min()
    return mdd * 100


if __name__ == &quot;__main__&quot;:
    prices = [
        12.65,
        12.8,
        12.6,
        12.6,
        12.6,
        12.6,
        12.85,
        14.55,
        15.0,
        13.65,
        14.0,
        13.8,
        13.85,
        14.3,
        14.2,
        14.9,
        15.7,
        15.8,
        15.4,
        15.5,
        15.25,
        15.15,
        15.0,
        15.9,
    ]

    mae, bmfe, gmfe = get_metrics(prices)
    print(f&quot;MAE: {mae:.5f}%&quot;)
    print(f&quot;BMFE: {bmfe:.5f}%&quot;)
    print(f&quot;GMFE: {gmfe:.5f}%&quot;)
    print(f&quot;MDD: {get_max_drawdown(prices):.5f}%&quot;)
</code></pre>
<pre><code class="language-python">import pandas as pd

class PriceMetrics:
    def __init__(self, prices):
        self.prices = prices
        self.base_price = prices[0]
        self.min_price = min(prices)
        self.max_price = max(prices[1:])
        self.max_price_before_min = self._get_max_price_before_min()
        self.mae = self._calculate_mae()
        self.bmfe = self._calculate_bmfe()
        self.gmfe = self._calculate_gmfe()
        self.edge_ratio = self._calculate_edge_ratio()

    def _get_max_price_before_min(self):
        if self.min_price is None or self.prices[:self.prices.index(self.min_price)] == []:
            return None
        return max(self.prices[:self.prices.index(self.min_price)])

    def _calculate_mae(self):
        if self.min_price is None or self.min_price &gt;= self.base_price:
            return 0
        return (self.min_price - self.base_price) / self.base_price * 100

    def _calculate_bmfe(self):
        if self.max_price_before_min is None or self.base_price &gt;= self.max_price_before_min:
            return 0
        return ((self.max_price_before_min - self.base_price) / self.base_price) * 100

    def _calculate_gmfe(self):
        if self.max_price is None or self.max_price &lt;= self.base_price:
            return 0
        return ((self.max_price - self.base_price) / self.base_price) * 100

    def _calculate_edge_ratio(self):
        if self.mae == 0:
            return 0
        return ((self.gmfe - self.mae) / abs(self.mae)) * 100

    def get_max_drawdown(self):
        df = pd.DataFrame(self.prices, columns=[&quot;Close&quot;])
        df[&quot;Max&quot;] = df[&quot;Close&quot;].cummax()
        df[&quot;Drawdown&quot;] = df[&quot;Close&quot;] / df[&quot;Max&quot;] - 1
        df[&quot;Max Drawdown&quot;] = df[&quot;Drawdown&quot;].cummin()
        mdd = df[&quot;Max Drawdown&quot;].min()
        return mdd * 100

if __name__ == &quot;__main__&quot;:
    #prices = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]
    prices = [10, 20, 15, 25, 18, 30, 12]
    metrics = PriceMetrics(prices)
    print(metrics.mae)
    print(metrics.bmfe)
    print(metrics.gmfe)
    print(metrics.edge_ratio)
    print(metrics.get_max_drawdown())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="我談的-maemfe-與海龜投資法則的差異"><a class="header" href="#我談的-maemfe-與海龜投資法則的差異">我談的 MAE/MFE 與〈海龜投資法則〉的差異</a></h1>
<p>出處：https://www.maemfe.org/2020/01/analyzing-mae-mfe-from-the-time-axis.html</p>
<h3 id="我談的-maemfe-與海龜投資法則的差異-1"><a class="header" href="#我談的-maemfe-與海龜投資法則的差異-1">我談的 MAE/MFE 與〈海龜投資法則〉的差異</a></h3>
<p>我在 PTT 和人分享 MAE/MFE 的概念的時候，一位網友就和我發想：</p>
<p><img src="strategy/images/ask-q.png" alt="" /></p>
<p>我其實非常高興，他在看完我的影片之後，就自發性地想到這個點</p>
<p>也就是說不從價格面（Y 軸）分析 MAE, MFE ，而是從（X 軸）時間面來分析</p>
<p>沒錯，從時間面來分析，正巧就是**《<a href="https://www.books.com.tw/products/0010384228">海龜投資法則</a>》**一書中</p>
<p>談到的 <strong>優勢比率（Edge Ratio）</strong>！ </p>
<p>也有人稱呼 Edge Ratio 叫做 e-ratio 或 E 比率</p>
<p><strong>優勢比率</strong></p>
<p>在書中作者提出一種評估策略好壞的參考，就是從進場之後 t 個時間單位後的 MAE, MFE</p>
<p>透過計算 MFE 除以 MAE 的值，可以得到 e-ratio</p>
<p>](https://imgur.com/APLnQoJ.png)</p>
<p><img src="strategy/images/APLnQoJ.png" alt="img" /></p>
<p>除此之外，我們還可以計算進場之後不同時間點的 e-ratio ，簡寫成 <strong>e(時間)</strong> 的形式</p>
<p><img src="strategy/images/GDOYvzS.png" alt="" /></p>
<p>你會發現，在我錄的許多影片中，我幾乎沒有提到這個時間面的處理方式</p>
<p>原因是時間面的處理方式，是比較進階的主題，外匯市場的波動在一個小尺度比較固定，但交易成本高</p>
<p>但是如果你想要更仔細去挖掘你的策略是否真的給你帶來良好的體質，或是你的交易策略本身交易次數不夠多</p>
<p>尤其是在更高的時間尺度（例如 H12, Daily）使用時間面的分析是很重要的</p>
<p>除此之外，容易受到時間點的影響的標的（例如股票、原物料）</p>
<p>進場時間與進場的時機，為你後續帶來的時間面的 MAE, MFE 就相對比較重要</p>
<p><strong>最後的碎碎唸</strong></p>
<p>最後我想講的事情是，我的影片的目的很大程度就是這樣</p>
<p>我要啟發你思考，你其實見解不會輸那些大師，你看在 PTT 很隨意</p>
<p>就有人能從 MAE, MFE 基本觀念，想到海龜投資法則大師的分析想法</p>
<p>所以說，我今天不是在給你一個確定的結論，我是要你更多的去思考</p>
<p>你得到的結論可能會對你有無比的幫助，甚至不輸許多高手</p>
<p>很多時候就是欠缺自信，大家要多加相信自己！努力去研究！不要鑽漏洞！</p>
<p>腳踏實地的修改交易策略和努力分析，我在這和你討論，不是很好嗎～</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="彈性進出場的判斷--優勢比率應用"><a class="header" href="#彈性進出場的判斷--優勢比率應用">彈性進出場的判斷 ｜ 優勢比率應用</a></h1>
<p>出處: https://www.finlab.tw/edge-ratio-follow-application/</p>
<p>當你開發完策略，也跑完統計清單，有沒有碰過一種狀況是策略換股週期在月初每月換股，但現在已經月中，你在猶豫適不適閤中途進場？
你一定想過若點位和日期不同，雖然是同一檔標的，但不同價位所面臨的風險完全不一樣，可能策略回測賺錢，但你中途進價太高，導致最後是虧損的局面。</p>
<p>或是你害怕中途進場買高，結果策略一路走高，你只能看著他一路飆，錯過補票機會。
雖然保守一點來看，其實這也沒什麼不好，少賺總比賠錢好，想貼合回測曲線，下次換股日再注意也是選項，但有沒有辦法讓我們判斷策略的進出場彈性，做更積極的決策？</p>
<h2 id="優勢比率定義"><a class="header" href="#優勢比率定義">優勢比率定義</a></h2>
<p>要如何判斷策略適不適合補票(中途進場或加碼)？可以藉由海龜交易法則的 Edge Ratio (優勢比率來判斷)。
優勢比率為平均 GMFE (策略每筆交易紀錄的最大有利幅度) 除以平均 MAE (策略每筆交易紀錄的最大不利幅度)。這可以藉此評估進場優勢，一個隨機性的訊號大致上會帶來相等的 MFE 與 MAE。</p>
<p>若大於1，代表存在正優勢，潛在最大獲利空間比最大虧損多，在持有過程中保有優勢可以中途停利或做其他操作，也就是策略的容錯率較高。反之則為劣勢，可能要抗衡較多的虧損狀態。</p>
<h2 id="優勢比率時序分析"><a class="header" href="#優勢比率時序分析">優勢比率時序分析</a></h2>
<p>我們加上時序分析，判斷策略每筆歷史交易持有過程 n 天內的優勢比率變化，看看隨著持有時間變長，優勢比率是不是會走高？通常一個好的趨勢策略，都會逐步拉開優勢空間。</p>
<h3 id="如何使用-finlab-package-顯示策略的優勢比率"><a class="header" href="#如何使用-finlab-package-顯示策略的優勢比率">如何使用 FinLab Package 顯示策略的優勢比率?</a></h3>
<p>回測函數<a href="https://doc.finlab.tw/reference/backtest/#finlab.backtest.sim">sim </a>裡面的參數「mae_mfe_window」控制「優勢比率時序圖」的時間長度，設定40就是看40天的變化，為了加快回測運算，此參數預設為None，如果要顯示優勢比率，且既一定要自己設定「mae_mfe_window」數值。
一般來說若是月週期 (20交易日) 的策略，我都會拉長一點到40，看策略有沒有可能20天後的edge_ratio持續走升，若是此情況，可以著墨策略延後出場，獲取更多報酬的可能性。
sim會回傳<a href="https://doc.finlab.tw/reference/analysis/#finlab.analysis.Report.display_mae_mfe_analysis">report物件</a>，使用report物件內的<code>display_mae_mfe_analysis()</code>方法即可顯示「波動分析圖」。想知道「波動分析圖」更多應用可參考此篇<a href="https://www.finlab.tw/display_mae_mfe_analysis/">文章</a>。</p>
<pre><code class="language-python">from finlab.backtest import sim

report=sim(position=position, mae_mfe_window=40)
report.display_mae_mfe_analysis()
</code></pre>
<p>回傳圖表的最上排第二張子圖即是「優勢比率時序圖」。</p>
<p><img src="strategy/images/newplot-1-1.png" alt="newplot 1 1" />「波動分析圖</p>
<h2 id="分析案例"><a class="header" href="#分析案例">分析案例</a></h2>
<p>舉幾個FinLab策略的時序圖來示範「優勢比率時序圖」如何分析 ?</p>
<h3 id="營收動能瘋狗策略"><a class="header" href="#營收動能瘋狗策略">營收動能瘋狗策略</a></h3>
<p><img src="strategy/images/edge_ratio_1.png" alt="edge ratio 1" /></p>
<p>優勢比率開高一路走升，優勢空間隨著時間放大，擁有不錯的趨勢策略特質，有較高的近場彈性，但接近第20天左右(下次營收截止日換股)有高峰，這時就不建議中途進場，容易在高點套住，應等下期緩股訊號出現。
<a href="https://ai.finlab.tw/strategyview/?uid=TJN4FDuqrwU8DML7DAjUYFIMutp2&amp;sid=%E7%87%9F%E6%94%B6%E5%BC%B7%E5%8B%A2%E5%8B%95%E8%83%BD%E7%98%8B%E7%8B%97">策略連結</a>。</p>
<h3 id="投信大哥跟屁蟲策略"><a class="header" href="#投信大哥跟屁蟲策略">投信大哥跟屁蟲策略</a></h3>
<p><img src="strategy/images/edge_ratio_2.png" alt="edge ratio 2" /></p>
<p>三天決勝負的短線策略。
優勢開高後一路走跌，優勢空間隨著時間快速縮小，越慢進場的局面越不利。
極度不適合延遲進場，沒跟到第一天就別跟了。
投信買賣超這個因子對短線較有影響力，過去市場應有不少人在投信短期大買後跟單，導致此現象，但這項催化劑也退的很快，長期走勢的影響力就不大，容易被其他變數幹擾，較不適合當中長期因子。
<a href="https://ai.finlab.tw/strategyview/?uid=TJN4FDuqrwU8DML7DAjUYFIMutp2&amp;sid=%E6%8A%95%E4%BF%A1%E5%A4%A7%E5%93%A5%E8%B7%9F%E5%B1%81%E8%9F%B2">策略連結</a>。</p>
<h3 id="藏獒策略"><a class="header" href="#藏獒策略">藏獒策略</a></h3>
<p><img src="strategy/images/edge_ratio_3.png" alt="edge ratio 3" /></p>
<p>類似營收動能瘋狗策略，但不強調營收創新高，比較多轉機股條件。
優勢比率在第五天創出小高峰後，會有一段明顯回撤，也就是延遲第8天進場的話，甚至有機會買的比第一天成本比，過了這個小低谷後，優勢空間開始走出大波段。
<a href="https://ai.finlab.tw/strategyview/?uid=TJN4FDuqrwU8DML7DAjUYFIMutp2&amp;sid=%E8%97%8F%E7%8D%92">策略連結</a>。</p>
<h2 id="結論-2"><a class="header" href="#結論-2">結論</a></h2>
<p>你的策略有什麼樣子的「優勢比率時序圖」呢？趕緊用FinLab Package 來實做看看，會夠瞭解你策略的細節喔！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="低波動-飆股長相"><a class="header" href="#低波動-飆股長相">低波動 飆股長相</a></h2>
<pre><code class="language-python">def compute_candle_volatility(timeperiod=20):
    close = data.get(&quot;price:收盤價&quot;)
    high = data.get(&quot;price:最高價&quot;)
    low = data.get(&quot;price:最低價&quot;)
    open_ = data.get(&quot;price:開盤價&quot;)

    bullish_candle = close &gt;= open_
    bullish_volatility = (
        abs(close.shift() - open_)
        + abs(open_ - low)
        + abs(low - high)
        + abs(high - close)
    )
    bearish_volatility = (
        abs(close.shift() - open_)
        + abs(open_ - high)
        + abs(high - low)
        + abs(low - close)
    )
    candle_volatility = FinlabDataFrame(
        np.nan, index=close.index, columns=close.columns
    )
    candle_volatility[bullish_candle] = bullish_volatility
    candle_volatility[~bullish_candle] = bearish_volatility
    volatility = (
        candle_volatility.average(timeperiod) / close.average(timeperiod) * 100
    )
    return volatility
</code></pre>
<h2 id="收盤價跟月營收合併"><a class="header" href="#收盤價跟月營收合併">收盤價跟月營收合併</a></h2>
<pre><code class="language-python">import finlab
import pandas as pd
from finlab import data

pd.options.display.float_format = lambda x: &quot;%.2f&quot; % x


if __name__ == &quot;__main__&quot;:
    close = data.get(&quot;price:收盤價&quot;)
    rev = data.get(&quot;monthly_revenue:當月營收&quot;)
    print(close)
    print(rev)

    merged_df = close.merge(rev, on='date', how='left', suffixes=('_close', '_rev'))
    merged_df.fillna(method='bfill', inplace=True)
    print(merged_df, merged_df.columns)
    print(merged_df['2330_close'], merged_df['2330_rev'])
</code></pre>
<h2 id="臺股漲跌與市值板塊圖"><a class="header" href="#臺股漲跌與市值板塊圖">臺股漲跌與市值板塊圖</a></h2>
<p>出處: https://www.finlab.tw/dashboard2-plotly-treemap/</p>
<pre><code class="language-python">import pandas as pd
import numpy as np
import finlab
from finlab import data
import plotly.express as px


&quot;&quot;&quot;
https://www.finlab.tw/dashboard2-plotly-treemap/
Treemap
&quot;&quot;&quot;


def df_date_filter(df, start=None, end=None):
    if start:
        df = df[df.index &gt;= start]
    if end:
        df = df[df.index &lt;= end]
    return df


def create_treemap_data(start, end, item, clip=None):
    close = data.get(&quot;price:收盤價&quot;)
    basic_info = data.get(&quot;company_basic_info&quot;)
    turnover = data.get(&quot;price:成交金額&quot;)
    close_data = df_date_filter(close, start, end)
    turnover_data = df_date_filter(turnover, start, end).iloc[1:].sum() / 100000000
    return_ratio = (
        (close_data.iloc[-1] / close_data.iloc[-2]).dropna().replace(np.inf, 0)
    )
    return_ratio = round((return_ratio - 1) * 100, 2)

    concat_list = [close_data.iloc[-1], turnover_data, return_ratio]
    col_names = [&quot;stock_id&quot;, &quot;close&quot;, &quot;turnover&quot;, &quot;return_ratio&quot;]
    if item not in [&quot;return_ratio&quot;, &quot;turnover_ratio&quot;]:
        try:
            custom_item = df_date_filter(data.get(item), start, end).iloc[-1].fillna(0)
        except Exception as e:
            logger.error(&quot;data error, check the data is existed between start and end.&quot;)
            logger.error(e)
            return None
        if clip:
            custom_item = custom_item.clip(*clip)
        concat_list.append(custom_item)
        col_names.append(item)

    df = pd.concat(concat_list, axis=1).dropna()
    df = df.reset_index()
    df.columns = col_names

    basic_info_df = basic_info.copy()
    basic_info_df[&quot;stock_id_name&quot;] = basic_info_df[&quot;stock_id&quot;] + basic_info_df[&quot;公司簡稱&quot;]

    df = df.merge(
        basic_info_df[[&quot;stock_id&quot;, &quot;stock_id_name&quot;, &quot;產業類別&quot;, &quot;市場別&quot;, &quot;實收資本額(元)&quot;]],
        how=&quot;left&quot;,
        on=&quot;stock_id&quot;,
    )
    df = df.rename(columns={&quot;產業類別&quot;: &quot;category&quot;, &quot;市場別&quot;: &quot;market&quot;, &quot;實收資本額(元)&quot;: &quot;base&quot;})
    df = df.dropna(thresh=5)
    df[&quot;market_value&quot;] = round(df[&quot;base&quot;] / 10 * df[&quot;close&quot;] / 100000000, 2)
    df[&quot;turnover_ratio&quot;] = df[&quot;turnover&quot;] / (df[&quot;turnover&quot;].sum()) * 100
    df[&quot;country&quot;] = &quot;TW-Stock&quot;
    return df


def plot_tw_stock_treemap(
    start=None,
    end=None,
    area_ind=&quot;market_value&quot;,
    item=&quot;return_ratio&quot;,
    clip=None,
    color_scales=&quot;Temps&quot;,
):
    &quot;&quot;&quot;Plot treemap chart for tw_stock

    Treemap charts visualize hierarchical data using nested rectangles,
    it is good for judging the overall market dynamics.

    Args:
      start(str): The date of data start point.ex:2021-01-02
      end(str):The date of data end point.ex:2021-01-05
      area_ind(str):The indicator to control treemap area size .
                    Select range is in [&quot;market_value&quot;,&quot;turnover&quot;,&quot;turnover_ratio&quot;]
      item(str): The indicator to control treemap area color .
                 Select range is in [&quot;return_ratio&quot;, &quot;turnover_ratio&quot;]
                 or use the other customized data which you could find from finlab database page,
                 ex:'price_earning_ratio:本益比'
      clip(tuple):lower and upper pd.clip() setting for item values to make distinct colors.ex:(0,100)
      color_scales(str):Used for the built-in named continuous
                        (sequential, diverging and cyclical) color scales in Plotly
                        Ref:https://plotly.com/python/builtin-colorscales/
    Returns:
        figure
    &quot;&quot;&quot;
    df = create_treemap_data(start, end, item, clip)
    if df is None:
        return None
    df[&quot;custom_item_label&quot;] = round(df[item], 2).astype(str)

    if area_ind not in [&quot;market_value&quot;, &quot;turnover&quot;, &quot;turnover_ratio&quot;]:
        return None

    if item in [&quot;return_ratio&quot;]:
        color_continuous_midpoint = 0
    else:
        color_continuous_midpoint = np.average(df[item], weights=df[area_ind])

    fig = px.treemap(
        df,
        path=[&quot;country&quot;, &quot;market&quot;, &quot;category&quot;, &quot;stock_id_name&quot;],
        values=area_ind,
        color=item,
        color_continuous_scale=color_scales,
        color_continuous_midpoint=color_continuous_midpoint,
        custom_data=[&quot;custom_item_label&quot;, &quot;close&quot;, &quot;turnover&quot;],
        title=f&quot;TW-Stock Market TreeMap({start}~{end})&quot;
        f&quot;---area_ind:{area_ind}---item:{item}&quot;,
        width=1600,
        height=800,
    )

    fig.update_traces(
        textposition=&quot;middle center&quot;,
        textfont_size=24,
        texttemplate=&quot;%{label}(%{customdata[1]})&lt;br&gt;%{customdata[0]}&quot;,
    )
    return fig


if __name__ == &quot;__main__&quot;:
    # @title 臺股漲跌與市值板塊圖
    start = &quot;2021-07-01&quot;  # @param {type:&quot;date&quot;}
    end = &quot;2021-07-02&quot;  # @param {type:&quot;date&quot;}
    area_ind = &quot;turnover_ratio&quot;  # @param [&quot;market_value&quot;,&quot;turnover&quot;,&quot;turnover_ratio&quot;] {allow-input: true}
    item = (
        &quot;return_ratio&quot;  # @param [&quot;return_ratio&quot;, &quot;turnover_ratio&quot;] {allow-input: true}
    )
    clip = 1000  # @param {type:&quot;number&quot;}

    plot_tw_stock_treemap(start, end, area_ind, item, clip)

</code></pre>
<h2 id="finlab--的-mae--gmfe--bmfe"><a class="header" href="#finlab--的-mae--gmfe--bmfe">finlab  的 mae  gmfe  bmfe</a></h2>
<p>以 2063 世鎧 mae 是  0 代表  2023-01-03 進場～ 2023-02-01 出場 的所有日K open 價都高過 進場當天開盤價 </p>
<p>是以進場價格做基準點～ 藏獒策略以開盤價進場  開盤價出場</p>
<table><thead><tr><th style="text-align: right">trade_index</th><th style="text-align: left">stock_id</th><th style="text-align: left">entry_date</th><th style="text-align: left">exit_date</th><th style="text-align: left">entry_sig_date</th><th style="text-align: left">exit_sig_date</th><th style="text-align: right">return</th><th style="text-align: right">trade_price@entry_date</th><th style="text-align: right">trade_price@exit_date</th><th style="text-align: right">mae</th><th style="text-align: right">gmfe</th><th style="text-align: right">bmfe</th><th style="text-align: right">mdd</th><th style="text-align: right">return_include_fee</th></tr></thead><tbody>
<tr><td style="text-align: right">630</td><td style="text-align: left">2063 世鎧</td><td style="text-align: left">2023-01-03</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2022-12-30</td><td style="text-align: left">2023-01-31</td><td style="text-align: right">0.0159</td><td style="text-align: right">43.9000</td><td style="text-align: right">44.6000</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.0342</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0287</td><td style="text-align: right">1.0000</td></tr>
<tr><td style="text-align: right">631</td><td style="text-align: left">3498 陽程</td><td style="text-align: left">2023-01-03</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2022-12-30</td><td style="text-align: left">2023-01-31</td><td style="text-align: right">-0.0225</td><td style="text-align: right">37.8000</td><td style="text-align: right">36.9500</td><td style="text-align: right">-0.0542</td><td style="text-align: right">0.0582</td><td style="text-align: right">0.0582</td><td style="text-align: right">-0.1062</td><td style="text-align: right">-2.8200</td></tr>
<tr><td style="text-align: right">632</td><td style="text-align: left">8996 高力</td><td style="text-align: left">2023-01-03</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2022-12-30</td><td style="text-align: left">2023-01-31</td><td style="text-align: right">0.1568</td><td style="text-align: right">185.0000</td><td style="text-align: right">214.0000</td><td style="text-align: right">-0.0270</td><td style="text-align: right">0.1568</td><td style="text-align: right">0.0270</td><td style="text-align: right">-0.0526</td><td style="text-align: right">15.0000</td></tr>
<tr><td style="text-align: right">633</td><td style="text-align: left">1104 環泥</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-01-31</td><td style="text-align: left">2023-02-24</td><td style="text-align: right">0.0253</td><td style="text-align: right">23.7000</td><td style="text-align: right">24.3000</td><td style="text-align: right">-0.0042</td><td style="text-align: right">0.0316</td><td style="text-align: right">0.0274</td><td style="text-align: right">-0.0308</td><td style="text-align: right">1.9300</td></tr>
<tr><td style="text-align: right">634</td><td style="text-align: left">1707 葡萄王</td><td style="text-align: left">2023-01-03</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2022-12-30</td><td style="text-align: left">2023-02-24</td><td style="text-align: right">0.0737</td><td style="text-align: right">169.5000</td><td style="text-align: right">182.0000</td><td style="text-align: right">-0.0619</td><td style="text-align: right">0.0737</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0619</td><td style="text-align: right">6.7500</td></tr>
<tr><td style="text-align: right">635</td><td style="text-align: left">2727 王品</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-01-31</td><td style="text-align: left">2023-02-24</td><td style="text-align: right">0.4865</td><td style="text-align: right">185.0000</td><td style="text-align: right">275.0000</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.4865</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0455</td><td style="text-align: right">47.7800</td></tr>
<tr><td style="text-align: right">636</td><td style="text-align: left">6612 奈米醫材</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-01-31</td><td style="text-align: left">2023-02-24</td><td style="text-align: right">0.2284</td><td style="text-align: right">116.0000</td><td style="text-align: right">142.5000</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.3405</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0870</td><td style="text-align: right">22.1300</td></tr>
<tr><td style="text-align: right">637</td><td style="text-align: left">2916 滿心</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">2023-02-24</td><td style="text-align: left">2023-03-31</td><td style="text-align: right">-0.0046</td><td style="text-align: right">32.8000</td><td style="text-align: right">32.6500</td><td style="text-align: right">-0.0244</td><td style="text-align: right">0.0549</td><td style="text-align: right">0.0549</td><td style="text-align: right">-0.0751</td><td style="text-align: right">-1.0400</td></tr>
<tr><td style="text-align: right">638</td><td style="text-align: left">3004 豐達科</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">2023-02-24</td><td style="text-align: left">2023-03-31</td><td style="text-align: right">0.0650</td><td style="text-align: right">89.2000</td><td style="text-align: right">93.9000</td><td style="text-align: right">-0.0695</td><td style="text-align: right">0.0650</td><td style="text-align: right">0.0381</td><td style="text-align: right">-0.1037</td><td style="text-align: right">4.6500</td></tr>
<tr><td style="text-align: right">639</td><td style="text-align: left">3052 夆典</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">2023-02-24</td><td style="text-align: left">2023-03-31</td><td style="text-align: right">-0.0560</td><td style="text-align: right">11.6000</td><td style="text-align: right">10.9500</td><td style="text-align: right">-0.0560</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0560</td><td style="text-align: right">-6.1500</td></tr>
<tr><td style="text-align: right">640</td><td style="text-align: left">6664 群翊</td><td style="text-align: left">2023-03-01</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">2023-02-24</td><td style="text-align: left">2023-03-31</td><td style="text-align: right">0.0648</td><td style="text-align: right">108.0000</td><td style="text-align: right">115.0000</td><td style="text-align: right">-0.0648</td><td style="text-align: right">0.0648</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0648</td><td style="text-align: right">5.8600</td></tr>
<tr><td style="text-align: right">641</td><td style="text-align: left">8931 大汽電</td><td style="text-align: left">2023-02-01</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">2023-01-31</td><td style="text-align: left">2023-03-31</td><td style="text-align: right">0.6282</td><td style="text-align: right">46.8000</td><td style="text-align: right">76.2000</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.7286</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0581</td><td style="text-align: right">61.8700</td></tr>
<tr><td style="text-align: right">642</td><td style="text-align: left">3078 僑威</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">nan</td><td style="text-align: left">2023-03-31</td><td style="text-align: left">2023-04-30</td><td style="text-align: right">0.2362</td><td style="text-align: right">44.2500</td><td style="text-align: right">54.7000</td><td style="text-align: right">-0.0147</td><td style="text-align: right">0.3107</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0569</td><td style="text-align: right">22.8900</td></tr>
<tr><td style="text-align: right">643</td><td style="text-align: left">3540 曜越</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">nan</td><td style="text-align: left">2023-03-31</td><td style="text-align: left">2023-04-30</td><td style="text-align: right">0.0773</td><td style="text-align: right">38.8000</td><td style="text-align: right">41.8000</td><td style="text-align: right">-0.0052</td><td style="text-align: right">0.1521</td><td style="text-align: right">0.0013</td><td style="text-align: right">-0.0649</td><td style="text-align: right">7.1000</td></tr>
<tr><td style="text-align: right">644</td><td style="text-align: left">4119 旭富</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">nan</td><td style="text-align: left">2023-03-31</td><td style="text-align: left">2023-04-30</td><td style="text-align: right">0.0496</td><td style="text-align: right">121.0000</td><td style="text-align: right">127.0000</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.0992</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0451</td><td style="text-align: right">4.3500</td></tr>
<tr><td style="text-align: right">645</td><td style="text-align: left">4153 鈺緯</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">nan</td><td style="text-align: left">2023-03-31</td><td style="text-align: left">2023-04-30</td><td style="text-align: right">0.1000</td><td style="text-align: right">48.0000</td><td style="text-align: right">52.8000</td><td style="text-align: right">0.0000</td><td style="text-align: right">0.2625</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.1287</td><td style="text-align: right">9.3600</td></tr>
<tr><td style="text-align: right">646</td><td style="text-align: left">4190 佐登-KY</td><td style="text-align: left">2023-04-06</td><td style="text-align: left">nan</td><td style="text-align: left">2023-03-31</td><td style="text-align: left">2023-04-30</td><td style="text-align: right">0.0741</td><td style="text-align: right">94.5000</td><td style="text-align: right">101.5000</td><td style="text-align: right">-0.0169</td><td style="text-align: right">0.1111</td><td style="text-align: right">0.0000</td><td style="text-align: right">-0.0333</td><td style="text-align: right">6.7800</td></tr>
</tbody></table>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;correlationMatrix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jmq3ycgp65_NURP8cY3vg2SvTDXc5X8n
&quot;&quot;&quot;

#!pip install yfinance &gt; log.txt
#@title 輸入 Yahoo 股票代號(例如: 2330.TW, AAPL, BTC-USD)
stock_ids = &quot;2454.TW,2330.TW, AAPL, BTC-USD&quot; #@param {type:&quot;string&quot;}

import yfinance as yf
import time
import pandas as pd

stocks = stock_ids.replace(' ', '').split(',')
price = {}

for s in stocks:

  print(f'download {s}')

  ss = yf.Ticker(s)

  # get historical market data
  hist = ss.history(period='1y')

  price[s] = hist['Close']
  time.sleep(3)

import seaborn
import matplotlib.pyplot as plt

plt.rcParams['figure.figsize'] = (10, 6)
seaborn.heatmap(pd.DataFrame(price).pct_change().dropna(how='any').corr(), cmap=&quot;YlGnBu&quot;,vmax=1,vmin=-1, annot=True)
</code></pre>
<p><img src="strategy/images/correlationMatrix.png" alt="" /></p>
<h2 id="finlab策略"><a class="header" href="#finlab策略">finlab策略</a></h2>
<pre><code class="language-python">from finlab import data
from finlab.backtest import sim
import pandas as pd
import redis
import finlab

def connect_redis():
    r = None
    pool = redis.ConnectionPool(host=&quot;localhost&quot;, port=6379, db=8)
    try:
        r = redis.Redis(connection_pool=pool, charset=&quot;utf-8&quot;)
    except Exception as err:
        logger.error(err)
    return r

# rs = connect_redis()
# rs.flushdb()

finlab.login(&quot;&quot;)
score = data.get('etl:finlab_tw_stock_market_ind')['score']
close = data.get(&quot;price:收盤價&quot;)
vol = data.get(&quot;price:成交股數&quot;)
vol_ma = vol.average(10)
rev = data.get('monthly_revenue:當月營收')
rev_year_growth = data.get('monthly_revenue:去年同月增減(%)')
rev_month_growth = 	data.get('monthly_revenue:上月比較增減(%)')

# 股價創年新高
cond1 = (close == close.rolling(250).max())

# 排除月營收連3月衰退10%以上
cond2 = ~(rev_year_growth &lt; -10).sustain(3) 

# 排除月營收成長趨勢過老(12個月內有至少8個月單月營收年增率大於60%)
cond3 = ~(rev_year_growth &gt; 60).sustain(12,8) 

# 確認營收底部，近月營收脫離近年穀底(連續3月的&quot;單月營收近12月最小值/近月營收&quot; &lt; 0.8)
cond4 = ((rev.rolling(12).min())/(rev) &lt; 0.8).sustain(3)

# 單月營收月增率連續3月大於-40%
cond5 = (rev_month_growth &gt; -40).sustain(3)

# 流動性條件
cond6 = vol_ma &gt; 200*1000

buy = cond1 &amp; cond2  &amp; cond3 &amp; cond4 &amp; cond5 &amp; cond6

# 買比較冷門的股票
buy = vol_ma*buy
buy = buy[buy&gt;0]
buy = buy.is_smallest(5)
long_position = buy.resample('M').last().reindex(close.index,method='ffill')

score_df = score &gt;= 4
long_position *= score_df

# 做空訊號～多單遇大盤訊號轉空時出場，並反手做空指數避險
short_target = '00632R'
short_position = close[[short_target]].notna() * ~score_df
position = pd.concat([long_position, short_position], axis=1)

report = sim(position, upload=True, position_limit=1/3, fee_ratio=1.425/1000/3, stop_loss=0.08,  trade_at_price='open' ,name='XXXX', live_performance_start='2022-06-01')
print(report.get_trades().to_markdown())

</code></pre>
<pre><code class="language-python">from finlab import data
from finlab.backtest import sim
import finlab

finlab.login(&quot;&quot;)

close = data.get(&quot;price:收盤價&quot;)
vol = data.get(&quot;price:成交股數&quot;)
vol_ma = vol.average(10)
rev = data.get('monthly_revenue:當月營收')
rev_year_growth = data.get('monthly_revenue:去年同月增減(%)')
rev_month_growth = 	data.get('monthly_revenue:上月比較增減(%)')

# 股價創年新高
cond1 = (close == close.rolling(250).max())

# 排除月營收連3月衰退10%以上
cond2 = ~(rev_year_growth &lt; -10).sustain(3) 

# 排除月營收成長趨勢過老(12個月內有至少8個月單月營收年增率大於60%)
cond3 = ~(rev_year_growth &gt; 60).sustain(12,8)

# 確認營收底部(單月營收月增率連續3月大於-40)
cond4 = ((rev.rolling(12).min())/(rev) &lt; 0.8).sustain(3)

# 單月營收月增率連續3月大於-40%
cond5 = (rev_month_growth &gt; -40).sustain(3)

# 流動性條件
cond6 = vol_ma &gt; 200*1000

buy = cond1 &amp; cond2  &amp; cond3 &amp; cond4 &amp; cond5 &amp; cond6

# 買比較冷門的股票
buy = vol_ma*buy
buy = buy[buy&gt;0]
buy = buy.is_smallest(5)

report = sim(buy , resample=&quot;M&quot;, upload=True, position_limit=1/3, fee_ratio=1.425/1000/3, stop_loss=0.08,  trade_at_price='open',name='XXX', live_performance_start='2022-05-01')
print(report.get_trades().to_markdown())

</code></pre>
<pre><code class="language-py">from loguru import logger
from finlab import data
from finlab.backtest import sim
import finlab
import pandas as pd
import pickle
import redis
import zlib


def data_to_redis(r):
    score = data.get(&quot;etl:finlab_tw_stock_market_ind&quot;)[&quot;score&quot;]
    close = data.get(&quot;price:收盤價&quot;)
    vol = data.get(&quot;price:成交股數&quot;)
    vol_ma = vol.average(10)
    rev = data.get(&quot;monthly_revenue:當月營收&quot;)
    rev_year_growth = data.get(&quot;monthly_revenue:去年同月增減(%)&quot;)
    rev_month_growth = data.get(&quot;monthly_revenue:上月比較增減(%)&quot;)
    EXPIRATION_SECONDS = 86400
    # Set
    r.setex(&quot;score&quot;, EXPIRATION_SECONDS, zlib.compress(pickle.dumps(score)))
    r.setex(&quot;close&quot;, EXPIRATION_SECONDS, zlib.compress(pickle.dumps(close)))
    r.setex(&quot;vol&quot;, EXPIRATION_SECONDS, zlib.compress(pickle.dumps(vol)))
    r.setex(&quot;vol_ma&quot;, EXPIRATION_SECONDS, zlib.compress(pickle.dumps(vol_ma)))
    r.setex(&quot;rev&quot;, EXPIRATION_SECONDS, zlib.compress(pickle.dumps(rev)))
    r.setex(
        &quot;rev_year_growth&quot;,
        EXPIRATION_SECONDS,
        zlib.compress(pickle.dumps(rev_year_growth)),
    )
    r.setex(
        &quot;rev_month_growth&quot;,
        EXPIRATION_SECONDS,
        zlib.compress(pickle.dumps(rev_month_growth)),
    )

def backtest(r):
    # Get
    score_df = pickle.loads(zlib.decompress(r.get(&quot;score&quot;)))
    close_df = pickle.loads(zlib.decompress(r.get(&quot;close&quot;)))
    vol_df = pickle.loads(zlib.decompress(r.get(&quot;vol&quot;)))
    vol_ma_df = pickle.loads(zlib.decompress(r.get(&quot;vol_ma&quot;)))
    rev_df = pickle.loads(zlib.decompress(r.get(&quot;rev&quot;)))
    rev_year_growth_df = pickle.loads(zlib.decompress(r.get(&quot;rev_year_growth&quot;)))
    rev_month_growth_df = pickle.loads(zlib.decompress(r.get(&quot;rev_month_growth&quot;)))
    # print(score_df)
    # print(close_df)
    # print(vol_df)
    # print(vol_ma_df)
    # print(rev_df)
    # print(rev_year_growth_df)
    # print(rev_month_growth_df)
    # 股價創年新高
    cond1 = close_df == close_df.rolling(250).max()

    # 排除月營收連3月衰退10%以上
    cond2 = ~(rev_year_growth_df &lt; -10).sustain(3)

    # 排除月營收成長趨勢過老(12個月內有至少8個月單月營收年增率大於60%)
    cond3 = ~(rev_year_growth_df &gt; 60).sustain(12, 8)

    # 確認營收底部，近月營收脫離近年穀底(連續3月的&quot;單月營收近12月最小值/近月營收&quot; &lt; 0.8)
    cond4 = ((rev_df.rolling(12).min()) / (rev_df) &lt; 0.8).sustain(3)

    # 單月營收月增率連續3月大於-40%
    cond5 = (rev_month_growth_df &gt; -40).sustain(3)

    # 流動性條件
    cond6 = vol_ma_df &gt; 200 * 1000
    buy = cond1 &amp; cond2 &amp; cond3 &amp; cond4 &amp; cond5 &amp; cond6

    # 買比較冷門的股票
    buy = vol_ma_df * buy
    buy = buy[buy &gt; 0]
    buy = buy.is_smallest(5)
    long_position = buy.resample(&quot;M&quot;).last().reindex(close_df.index, method=&quot;ffill&quot;)
    score_df = score_df &gt;= 4
    long_position *= score_df

    # 做空訊號～多單遇大盤訊號轉空時出場，並反手做空指數避險
    short_target = &quot;00632R&quot;
    short_position = close_df[[short_target]].notna() * ~score_df
    position = pd.concat([long_position, short_position], axis=1)

    report = sim(
        position,
        upload=True,
        position_limit=1 / 3,
        fee_ratio=1.425 / 1000 / 3,
        stop_loss=0.08,
        trade_at_price=&quot;open&quot;,
        name=&quot;XXXXX&quot;,
        live_performance_start=&quot;2022-06-01&quot;,
    )
    # print(report.get_stats())


def connect_redis():
    pool = redis.ConnectionPool(host=&quot;localhost&quot;, port=6379, db=0)
    try:
        r = redis.Redis(connection_pool=pool, charset=&quot;utf-8&quot;)
    except Exception as err:
        logger.error(err)
    return r


if __name__ == &quot;__main__&quot;:
    finlab.login(
        &quot;&quot;
    )
    r = connect_redis()
    # data_to_redis(r)
    backtest(r)

</code></pre>
<h2 id="highcharts_股價走勢ipynb"><a class="header" href="#highcharts_股價走勢ipynb">highcharts_股價走勢.ipynb</a></h2>
<p>https://colab.research.google.com/drive/1W1kH3cwNUTj7hMMyF8W4wcehiWLSyAUF?usp=sharing#scrollTo=Mij5sRmwbtCP</p>
<pre><code class="language-python">import yfinance as yf

# 取得股價歷史資料(含臺股\美股\加密貨幣)

symbol = '2330.TW' # 臺股上市:TW 臺股上櫃:TWO 
start = '2018-01-01' # 起始時間
end = '2022-12-31' # 結束時間

ohlcv = yf.Ticker(symbol).history('max').loc[start:end]


from highcharts import Highchart
import datetime
from IPython.display import HTML,display
import os

# 客製化調整參數
color = '#4285f4' # 線的顏色 (red/green/blue/purple)
linewidth = 2 # 線的粗細
title = symbol # 標題名稱
width = 800 # 圖的寬度
height = 500 # 圖的高度


# 繪圖設定
H = Highchart(width=width,height=height)

x = ohlcv.index
y = round(ohlcv.Close,2)

data = [[index,s] for index,s in zip(x,y)]
H.add_data_set(data,'line','data',color=color)

H.set_options('xAxis',{'type':'datetime'})
H.set_options('title',{'text':title,'style':{'color':'black'}}) # 設定title
H.set_options('plotOptions',{'line':{'lineWidth':linewidth,'dataLabels':{'enabled': False}}}) # 設定線的粗度
H.set_options('tooltip',{'shared':True,'crosshairs':True}) # 設定為可互動式

# 顯示圖表
H.save_file('chart')
display(HTML('chart.html'))
os.remove('chart.html')
</code></pre>
<h2 id="突破策略豆知識--如何避免假突破"><a class="header" href="#突破策略豆知識--如何避免假突破">突破策略豆知識 | 如何避免假突破?</a></h2>
<p>https://colab.research.google.com/drive/1M0XxnAMZoqoOrJQP9dyJVer5Q7YyRFOA?usp=sharing</p>
<p>https://www.finlab.tw/breakthrough_stock_picking_strategies/</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
&quot;&quot;&quot;股價創新高動能.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M0XxnAMZoqoOrJQP9dyJVer5Q7YyRFOA

## 安裝套件
&quot;&quot;&quot;

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install finlab &gt; log.txt
# !pip install talib-binary &gt; log.txt

&quot;&quot;&quot;## 股價創新高動能&quot;&quot;&quot;

from finlab.backtest import sim
from finlab import data

# 標的範圍為上市櫃普通股
with data.universe(market='TSE_OTC'):
    # 取得收盤價
    close = data.get(&quot;price:收盤價&quot;)
    # 股價創近200日新高
    position = (close == close.rolling(200).max())
    # 每兩週再平衡，單檔最大持股比例限制20%，停損20%
    report = sim(position, resample=&quot;2W&quot;, position_limit=0.2, stop_loss=0.2, name=&quot;股價創新高策略&quot;, upload=False)
    report.display()

&quot;&quot;&quot;## 創新高延續動能策略

&quot;&quot;&quot;

from finlab.backtest import sim
from finlab import data
with data.universe(market='TSE_OTC'):
    close = data.get(&quot;price:收盤價&quot;)
    # 近5日內有3日以上的股價創前200日新高
    position = (close == close.rolling(200).max()).sustain(5,3)
    report = sim(position, resample=&quot;2W&quot;, position_limit=0.2, stop_loss=0.2, name=&quot;創新高延續動能策略&quot;, upload=False)
    report.display()
</code></pre>
<pre><code class="language-python">import yfinance as yf

# 下載臺積電股票資料
df = yf.download(&quot;2317.TW&quot;, start=&quot;2014-01-01&quot;, end=&quot;2023-01-01&quot;)

# 將時間單位轉換為月份，取得每個月份的最後一筆資料，並填補缺失值
df = df.resample(&quot;M&quot;).last().bfill()

# 根據原始資料的時間索引重新排序，並填補缺失值
df = df.reindex(df.index, method=&quot;bfill&quot;)

print(df)
</code></pre>
<ul>
<li>FinlabDataFrame</li>
</ul>
<pre><code class="language-python">from finlab.utils import logger
import datetime
import numpy as np
import pandas as pd
from finlab import data
import functools


class FinlabDataFrame(pd.DataFrame):
    &quot;&quot;&quot;回測語法糖
    除了使用熟悉的 Pandas 語法外，我們也提供很多語法糖，讓大家開發程式時，可以用簡易的語法完成複雜的功能，讓開發策略更簡潔！
    我們將所有的語法糖包裹在 `FinlabDataFrame` 中，用起來跟 `pd.DataFrame` 一樣，但是多了很多功能！
    只要使用 `finlab.data.get()` 所獲得的資料，皆為 `FinlabDataFrame` 格式，
    接下來我們就來看看， `FinlabDataFrame` 有哪些好用的語法糖吧！

    當資料日期沒有對齊（例如: 財報 vs 收盤價 vs 月報）時，在使用以下運算符號：`+`, `-`, `*`, `/`, `&gt;`, `&gt;=`, `==`, `&lt;`, `&lt;=`, `&amp;`, `|`, `~`，不需要先將資料對齊，因為 `FinlabDataFrame` 會自動幫你處理，以下是示意圖。

    &lt;img src=&quot;https://i.ibb.co/pQr5yx5/Screen-Shot-2021-10-26-at-5-32-44-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-5-32-44-AM&quot;&gt;

    以下是範例：`cond1` 與 `cond2` 分別為「每天」，和「每季」的資料，假如要取交集的時間，可以用以下語法：

    ```py
    from finlab import data
    # 取得 FinlabDataFrame
    close = data.get('price:收盤價')
    roa = data.get('fundamental_features:ROA稅後息前')

    # 運算兩個選股條件交集
    cond1 = close &gt; 37
    cond2 = roa &gt; 0
    cond_1_2 = cond1 &amp; cond2
</code></pre>
<pre><code>擷取 1101 臺泥 的訊號如下圖，可以看到 `cond1` 跟 `cond2` 訊號的頻率雖然不相同，但是由於 `cond1` 跟 `cond2` 是 `FinlabDataFrame`，所以可以直接取交集，而不用處理資料頻率對齊的問題。
&lt;br /&gt;
&lt;img src=&quot;https://i.ibb.co/m9chXSQ/imageconds.png&quot; alt=&quot;imageconds&quot;&gt;

總結來說，FinlabDataFrame 與一般 dataframe 唯二不同之處：
1. 多了一些 method，如`df.is_largest()`, `df.sustain()`...等。
2. 在做四則運算、不等式運算前，會將 df1、df2 的 index 取聯集，column 取交集。
&quot;&quot;&quot;

@property
def _constructor(self):
    return FinlabDataFrame

@staticmethod
def reshape(df1, df2):

    isfdf1 = isinstance(df1, FinlabDataFrame)
    isfdf2 = isinstance(df2, FinlabDataFrame)
    isdf1 = isinstance(df1, pd.DataFrame)
    isdf2 = isinstance(df2, pd.DataFrame)

    both_are_dataframe = (isfdf1 + isdf1) * (isfdf2 + isdf2) != 0

    d1_index_freq = df1.get_index_str_frequency() if isfdf1 else None
    d2_index_freq = df2.get_index_str_frequency() if isfdf2 else None

    if ((d1_index_freq or d2_index_freq)
      and (d1_index_freq != d2_index_freq)
      and both_are_dataframe):

        df1 = df1.index_str_to_date() if isfdf1 else df1
        df2 = df2.index_str_to_date() if isfdf2 else df2

    if isinstance(df2, pd.Series):
        df2 = pd.DataFrame({c: df2 for c in df1.columns})

    if both_are_dataframe:
        index = df1.index.union(df2.index)
        columns = df1.columns.intersection(df2.columns)

        if len(df1.index) * len(df2.index) != 0:
          index_start = max(df1.index[0], df2.index[0])
          index = [t for t in index if index_start &lt;= t]

        return df1.reindex(index=index, method='ffill')[columns], \
            df2.reindex(index=index, method='ffill')[columns]
    else:
        return df1, df2

def __lt__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__lt__(df1, df2)

def __gt__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__gt__(df1, df2)

def __le__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__le__(df1, df2)

def __ge__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__ge__(df1, df2)

def __eq__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__eq__(df1, df2)

def __ne__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__ne__(df1, df2)

def __sub__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__sub__(df1, df2)

def __add__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__add__(df1, df2)

def __mul__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__mul__(df1, df2)

def __truediv__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__truediv__(df1, df2)

def __rshift__(self, other):
    return self.shift(-other)

def __lshift__(self, other):
    return self.shift(other)

def __and__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__and__(df1, df2)

def __or__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__or__(df1, df2)

def __getitem__(self, other):
    df1, df2 = self.reshape(self, other)
    return pd.DataFrame.__getitem__(df1, df2)

def index_str_to_date(self):
  &quot;&quot;&quot;財務月季報索引格式轉換

    將以下資料的索引轉換成datetime格式:

    月營收 (ex:2022-M1) 從文字格式轉為公告截止日。

    財務季報 (ex:2022-Q1) 從文字格式轉為財報電子檔資料上傳日。

    通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。

    Returns:
      (pd.DataFrame): data
    Examples:

        ```py
        data.get('monthly_revenue:當月營收').index_str_to_date()
        data.get('financial_statement:現金及約當現金').index_str_to_date()
        ```
  &quot;&quot;&quot;
  if len(self.index) == 0 or not isinstance(self.index[0], str):
    return self

  if self.index[0].find('M') != -1:
    return self._index_str_to_date_month()
  elif self.index[0].find('Q') != -1:
    return self._index_str_to_date_season()

  return self

@staticmethod
def to_business_day(date):

    def skip_weekend(d):
        add_days = {5: 2, 6: 1}
        wd = d.weekday()
        if wd in add_days: d += datetime.timedelta(days=add_days[wd])
        return d

    close = data.get('price:收盤價')
    return pd.Series(date).apply(lambda d: skip_weekend(d) if d in close.index or d &lt; close.index[0] or d &gt; close.index[-1] else close.loc[d:].index[0]).values

def get_index_str_frequency(self):

    if len(self.index) == 0:
      return None

    if not isinstance(self.index[0], str):
      return None

    if (self.index.str.find('M') != -1).all():
      return 'month'

    if (self.index.str.find('Q') != -1).all():
      return 'season'

    return None

def _index_date_to_str_month(self):

    # index is already str
    if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
      return self

    index = (self.index - datetime.timedelta(days=30)).strftime('%Y-M%m')
    return FinlabDataFrame(self.values, index=index, columns=self.columns)

def _index_str_to_date_month(self):

    # index is already timestamps
    if len(self.index) == 0 or not isinstance(self.index[0], str):
      return self

    if not (self.index.str.find('M') != -1).all():
      logger.warning('FinlabDataFrame: invalid index, cannot format index to monthly timestamp.')
      return self

    index = pd.to_datetime(self.index, format='%Y-M%m') + pd.offsets.MonthBegin() + datetime.timedelta(days=9)
    # chinese new year and covid-19 impact monthly revenue deadline
    replacements = {
                    datetime.datetime(2020, 2, 10): datetime.datetime(2020, 2, 15),
                    datetime.datetime(2021, 2, 10): datetime.datetime(2021, 2, 15),
                    datetime.datetime(2022, 2, 10): datetime.datetime(2022, 2, 14),
                    }
    replacer = replacements.get
    index = [replacer(n, n) for n in index]

    index = self.to_business_day(index)

    ret = FinlabDataFrame(self.values, index=index, columns=self.columns)
    ret.index.name = 'date'
 
    return ret
def _index_date_to_str_season(self):

    # index is already str
    if len(self.index) == 0 or not isinstance(self.index[0], pd.Timestamp):
      return self

    q = self.index.strftime('%m').astype(int).map({5:1, 8:2, 9:2, 10:3, 11:3, 3:4, 4:4})
    year = self.index.year.copy()
    year -= (q == 4)
    index = year.astype(str) + '-Q' + q.astype(str)

    return FinlabDataFrame(self.values, index=index, columns=self.columns)

def deadline(self):
    &quot;&quot;&quot;財務季報索引轉換成公告截止日

      將財務季報 (ex:2022Q1) 從文字格式轉為公告截止日的datetime格式，
      通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
      Returns:
        (pd.DataFrame): data
      Examples:
          ```py
          data.get('financial_statement:現金及約當現金').deadline()
          ```
    &quot;&quot;&quot;
    return self._index_str_to_date_season(detail=False)

def _index_str_to_date_season(self, detail=True):

  disclosure_dates = (calc_disclosure_dates(detail)
                      .reindex_like(self)
                      .unstack())

  self.columns.name = 'stock_id'

  unstacked = self.unstack()

  ret = (pd.DataFrame({
      'value': unstacked.values,
      'disclosures': disclosure_dates.values,
    }, unstacked.index)
    .reset_index()
    .drop_duplicates(['disclosures', 'stock_id'])
    .pivot(index='disclosures', columns='stock_id', values='value').ffill()
    .pipe(lambda df: df.loc[df.index.notna()])
    .pipe(lambda df: FinlabDataFrame(df))
    .rename_axis('date')
  )

  if not detail:
      ret.index = self.to_business_day(ret.index)

  return ret

def average(self, n):
    &quot;&quot;&quot;取 n 筆移動平均

    若股票在時間窗格內，有 N/2 筆 NaN，則會產生 NaN。
    Args:
      n (positive-int): 設定移動窗格數。
    Returns:
      (pd.DataFrame): data
    Examples:
        股價在均線之上
        ```py
        from finlab import data
        close = data.get('price:收盤價')
        sma = close.average(10)
        cond = close &gt; sma
        ```
        只需要簡單的語法，就可以將其中一部分的訊號繪製出來檢查：
        ```py
        import matplotlib.pyplot as plt

        close.loc['2021', '2330'].plot()
        sma.loc['2021', '2330'].plot()
        cond.loc['2021', '2330'].mul(20).add(500).plot()

        plt.legend(['close', 'sma', 'cond'])
        ```
        &lt;img src=&quot;https://i.ibb.co/Mg1P85y/sma.png&quot; alt=&quot;sma&quot;&gt;
    &quot;&quot;&quot;
    return self.rolling(n, min_periods=int(n/2)).mean()

def is_largest(self, n):
    &quot;&quot;&quot;取每列前 n 筆大的數值

    若符合 `True` ，反之為 `False` 。用來篩選每天數值最大的股票。

    &lt;img src=&quot;https://i.ibb.co/8rh3tbt/is-largest.png&quot; alt=&quot;is-largest&quot;&gt;
    Args:
      n (positive-int): 設定每列前 n 筆大的數值。
    Returns:
      (pd.DataFrame): data
    Examples:
        每季 ROA 前 10 名的股票
        ```py
        from finlab import data

        roa = data.get('fundamental_features:ROA稅後息前')
        good_stocks = roa.is_largest(10)
        ```
    &quot;&quot;&quot;
    return self.astype(float).apply(lambda s: s.nlargest(n), axis=1).reindex_like(self).notna()

def is_smallest(self, n):
    &quot;&quot;&quot;取每列前 n 筆小的數值

    若符合 `True` ，反之為 `False` 。用來篩選每天數值最小的股票。
    Args:
      n (positive-int): 設定每列前 n 筆小的數值。
    Returns:
      (pd.DataFrame): data
    Examples:
        股價淨值比最小的 10 檔股票
        ```py
        from finlab import data

        pb = data.get('price_earning_ratio:股價淨值比')
        cheap_stocks = pb.is_smallest(10)
        ```
    &quot;&quot;&quot;
    return self.astype(float).apply(lambda s: s.nsmallest(n), axis=1).reindex_like(self).notna()

def is_entry(self):
    &quot;&quot;&quot;進場點

    取進場訊號點，若符合條件的值則為True，反之為False。
    Returns:
      (pd.DataFrame): data
    Examples:
      策略為每日收盤價前10高，取進場點。
        ```py
        from finlab import data
        data.get('price:收盤價').is_largest(10).is_entry()
        ```
    &quot;&quot;&quot;
    return (self &amp; ~self.shift(fill_value=False))

def is_exit(self):
    &quot;&quot;&quot;出場點

    取出場訊號點，若符合條件的值則為 True，反之為 False。
    Returns:
      (pd.DataFrame): data
    Examples:
      策略為每日收盤價前10高，取出場點。
        ```py
        from finlab import data
        data.get('price:收盤價').is_largest(10).is_exit()
        ```
    &quot;&quot;&quot;
    return (~self &amp; self.shift(fill_value=False))

def rise(self, n=1):
    &quot;&quot;&quot;數值上升中

    取是否比前第n筆高，若符合條件的值則為True，反之為False。
    &lt;img src=&quot;https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-6-43-41-AM&quot;&gt;
    Args:
      n (positive-int): 設定比較前第n筆高。
    Returns:
      (pd.DataFrame): data
    Examples:
        收盤價是否高於10日前股價
        ```py
        from finlab import data
        data.get('price:收盤價').rise(10)
        ```
    &quot;&quot;&quot;
    return self &gt; self.shift(n)

def fall(self, n=1):
    &quot;&quot;&quot;數值下降中

    取是否比前第n筆低，若符合條件的值則為True，反之為False。
    &lt;img src=&quot;https://i.ibb.co/Y72bN5v/Screen-Shot-2021-10-26-at-6-43-41-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-6-43-41-AM&quot;&gt;
    Args:
      n (positive-int): 設定比較前第n筆低。
    Returns:
      (pd.DataFrame): data
    Examples:
        收盤價是否低於10日前股價
        ```py
        from finlab import data
        data.get('price:收盤價').fall(10)
        ```
    &quot;&quot;&quot;
    return self &lt; self.shift(n)

def groupby_category(self):
    &quot;&quot;&quot;資料按產業分群

    類似 `pd.DataFrame.groupby()`的處理效果。
    Returns:
      (pd.DataFrame): data
    Examples:
      半導體平均股價淨值比時間序列
        ```py
        from finlab import data
        pe = data.get('price_earning_ratio:股價淨值比')
        pe.groupby_category().mean()['半導體'].plot()
        ```
        &lt;img src=&quot;https://i.ibb.co/Tq2fKBp/pbmean.png&quot; alt=&quot;pbmean&quot;&gt;

        全球 2020 量化寬鬆加上晶片短缺，使得半導體股價淨值比衝高。
    &quot;&quot;&quot;
    categories = data.get('security_categories')
    cat = categories.set_index('stock_id').category.to_dict()
    org_set = set(cat.values())
    set_remove_illegal = set(
        o for o in org_set if isinstance(o, str) and o != 'nan')
    set_remove_illegal

    refine_cat = {}
    for s, c in cat.items():
        if c == None or c == 'nan':
            refine_cat[s] = '其他'
            continue

        if c == '電腦及週邊':
            refine_cat[s] = '電腦及週邊設備業'
            continue

        if c[-1] == '業' and c[:-1] in set_remove_illegal:
            refine_cat[s] = c[:-1]
        else:
            refine_cat[s] = c

    col_categories = pd.Series(self.columns.map(
        lambda s: refine_cat[s] if s in cat else '其他'))

    return self.groupby(col_categories.values, axis=1)

def entry_price(self, trade_at='close'):

    signal = self.is_entry()
    adj = data.get('etl:adj_close') if trade_at == 'close' else data.get(
        'etl:adj_open')
    adj, signal = adj.reshape(
        adj.loc[signal.index[0]: signal.index[-1]], signal)
    return adj.bfill()[signal.shift(fill_value=False)].ffill()

def sustain(self, nwindow, nsatisfy=None):
    &quot;&quot;&quot;持續 N 天滿足條件

    取移動 nwindow 筆加總大於等於nsatisfy，若符合條件的值則為True，反之為False。

    Args:
      nwindow (positive-int): 設定移動窗格。
      nsatisfy (positive-int): 設定移動窗格計算後最低滿足數值。
    Returns:
      (pd.DataFrame): data
    Examples:
        收盤價是否連兩日上漲
        ```py
        from finlab import data
        data.get('price:收盤價').rise().sustain(2)
        ```
    &quot;&quot;&quot;
    nsatisfy = nsatisfy or nwindow
    return self.rolling(nwindow).sum() &gt;= nsatisfy

def industry_rank(self, categories=None):
    &quot;&quot;&quot;計算產業 ranking 排名，0 代表產業內最低，1 代表產業內最高
    Args:
      categories (list of str): 欲考慮的產業，ex: ['貿易百貨', '雲端運算']，預設為全產業，請參考 `data.get('security_industry_themes')` 中的產業項目。
    Examples:
        本意比產業排名分數
        ```py
        from finlab import data

        pe = data.get('price_earning_ratio:本益比')
        pe_rank = pe.industry_rank()
        print(pe_rank)
        ```
    &quot;&quot;&quot;

    themes = (data.get('security_industry_themes')
        .copy() # 複製
        .assign(category=lambda self: self.category
            .apply(lambda s: eval(s))) # 從文字格式轉成陣列格
        .explode('category') # 展開資料
    )

    categories = (categories 
        or set(themes.category[themes.category.str.find(':') == -1]))

    def calc_rank(ind):
        stock_ids = themes.stock_id[themes.category == ind]
        return (self[stock_ids].pipe(lambda self: self.rank(axis=1, pct=True)))

    return (pd.concat([calc_rank(ind) for ind in categories],axis=1)
        .groupby(level=0, axis=1).mean())

def quantile_row(self, c):
    &quot;&quot;&quot;股票當天數值分位數

    取得每列c定分位數的值。
    Args:
      c (positive-int): 設定每列 n 定分位數的值。
    Returns:
      (pd.DataFrame): data
    Examples:
        取每日股價前90％分位數
        ```py
        from finlab import data
        data.get('price:收盤價').quantile_row(0.9)
        ```
    &quot;&quot;&quot;
    s = self.quantile(c, axis=1)
    return s

def exit_when(self, exit):

    df, exit = self.reshape(self, exit)

    df.fillna(False, inplace=True)
    exit.fillna(False, inplace=True)

    entry_signal = df.is_entry()
    exit_signal = df.is_exit()
    exit_signal |= exit

    # build position using entry_signal and exit_signal
    position = pd.DataFrame(np.nan, index=df.index, columns=df.columns)
    position[entry_signal] = 1
    position[exit_signal] = 0

    position.ffill(inplace=True)
    position = position == 1
    position.fillna(False)
    return position

def hold_until(self, exit, nstocks_limit=None, stop_loss=-np.inf, take_profit=np.inf, trade_at='close', rank=None):
    &quot;&quot;&quot;訊號進出場

    這大概是所有策略撰寫中，最重要的語法糖，上述語法中 `entries` 為進場訊號，而 `exits` 是出場訊號。所以 `entries.hold_until(exits)` ，就是進場訊號為 `True` 時，買入並持有該檔股票，直到出場訊號為 `True ` 則賣出。
    &lt;img src=&quot;https://i.ibb.co/PCt4hPd/Screen-Shot-2021-10-26-at-6-35-05-AM.png&quot; alt=&quot;Screen-Shot-2021-10-26-at-6-35-05-AM&quot;&gt;
    此函式有很多細部設定，可以讓你最多選擇 N 檔股票做輪動。另外，當超過 N 檔進場訊號發生，也可以按照客製化的排序，選擇優先選入的股票。最後，可以設定價格波動當輪動訊號，來增加出場的時機點。

    Args:
      exit (pd.Dataframe): 出場訊號。
      nstocks_limit (int)`: 輪動檔數上限，預設為None。
      stop_loss (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價下跌 10% 時產生出場訊號。
      take_profit (float): 價格波動輪動訊號，預設為None，不生成輪動訊號。範例：0.1，代表成本價上漲 10% 時產生出場訊號。
      trade_at (str): 價格波動輪動訊號參考價，預設為'close'。可選 `close` 或 `open`。
      rank (pd.Dataframe): 當天進場訊號數量超過 nstocks_limit 時，以 rank 數值越大的股票優先進場。
    Returns:
      (pd.DataFrame): data
    Examples:
        價格 &gt; 20 日均線入場, 價格 &lt; 60 日均線出場，最多持有10檔，超過 10 個進場訊號，則以股價淨值比小的股票優先選入。

        ```python
        from finlab import data
        from finlab.backtest import sim

        close = data.get('price:收盤價')
        pb = data.get('price_earning_ratio:股價淨值比')

        sma20 = close.average(20)
        sma60 = close.average(60)

        entries = close &gt; sma20
        exits = close &lt; sma60

        ＃pb前10小的標的做輪動
        position = entries.hold_until(exits, nstocks_limit=10, rank=-pb)
        sim(position)
        ```
    &quot;&quot;&quot;
    if nstocks_limit is None:
        nstocks_limit = len(self.columns)

    union_index = self.index.union(exit.index)
    intersect_col = self.columns.intersection(exit.columns)

    if stop_loss != -np.inf or take_profit != np.inf:
        price = data.get(f'etl:adj_{trade_at}')
        union_index = union_index.union(
            price.loc[union_index[0]: union_index[-1]].index)
        intersect_col = intersect_col.intersection(price.columns)
    else:
        price = pd.DataFrame()

    if rank is not None:
        union_index = union_index.union(rank.index)
        intersect_col = intersect_col.intersection(rank.columns)

    entry = self.reindex(union_index, columns=intersect_col,
                         method='ffill').ffill().fillna(False)
    exit = exit.reindex(union_index, columns=intersect_col,
                        method='ffill').ffill().fillna(False)

    if price is not None:
        price = price.reindex(
            union_index, columns=intersect_col, method='ffill')

    if rank is not None:
        rank = rank.reindex(
            union_index, columns=intersect_col, method='ffill')
    else:
        rank = pd.DataFrame(1, index=union_index, columns=intersect_col)

    max_rank = rank.max().max()
    min_rank = rank.min().min()
    rank = (rank - min_rank) / (max_rank - min_rank)
    rank.fillna(0, inplace=True)

    def rotate_stocks(ret, entry, exit, nstocks_limit, stop_loss=-np.inf, take_profit=np.inf, price=None, ranking=None):

        nstocks = 0

        ret[0][np.argsort(entry[0])[-nstocks_limit:]] = 1
        ret[0][exit[0] == 1] = 0
        ret[0][entry[0] == 0] = 0

        entry_price = np.empty(entry.shape[1])
        entry_price[:] = np.nan

        for i in range(1, entry.shape[0]):

            # regitser entry price
            if stop_loss != -np.inf or take_profit != np.inf:
                is_entry = ((ret[i-2] == 0) if i &gt;
                            1 else (ret[i-1] == 1))

                is_waiting_for_entry = np.isnan(entry_price) &amp; (ret[i-1] == 1)

                is_entry |= is_waiting_for_entry

                entry_price[is_entry == 1] = price[i][is_entry == 1]

                # check stop_loss and take_profit
                returns = price[i] / entry_price
                stop = (returns &gt; 1 + abs(take_profit)
                        ) | (returns &lt; 1 - abs(stop_loss))
                exit[i] |= stop

            # run signal
            rank = (entry[i] * ranking[i] + ret[i-1] * 3)
            rank[exit[i] == 1] = -1
            rank[(entry[i] == 0) &amp; (ret[i-1] == 0)] = -1

            ret[i][np.argsort(rank)[-nstocks_limit:]] = 1
            ret[i][rank == -1] = 0

        return ret

    ret = pd.DataFrame(0, index=entry.index, columns=entry.columns)
    ret = rotate_stocks(ret.values,
                        entry.astype(int).values,
                        exit.astype(int).values,
                        nstocks_limit,
                        stop_loss,
                        take_profit,
                        price=price.values,
                        ranking=rank.values)

    return pd.DataFrame(ret, index=entry.index, columns=entry.columns)
</code></pre>
<p>@functools.lru_cache
def calc_disclosure_dates(detail=True):</p>
<p>cinfo = data.get('company_basic_info').copy()
cinfo['id'] = cinfo.stock_id.str.split(' ').str[0]
cinfo = cinfo.set_index('id')
cinfo = cinfo[~cinfo.index.duplicated(keep='last')]</p>
<p>def calc_default_disclosure_dates(s):
sid = s.name
cat = cinfo.loc[sid].產業類別 if sid in cinfo.index else 'etf'
short_name = cinfo.loc[sid].公司簡稱 if sid in cinfo.index else 'etf'</p>
<pre><code>if cat == '金融業':
  calendar = {
    '1': '-05-15',
    '2': '-08-31',
    '3': '-11-14',
    '4': '-03-31',
  }
elif cat == '金融保險業':
  calendar = {
    '1': '-04-30',
    '2': '-08-31',
    '3': '-10-31',
    '4': '-03-31',
  }
elif 'KY' in short_name:
    calendar = {
    'old':{
        '1': '-05-15',
        '2': '-08-14',
        '3': '-11-14',
        '4': '-03-31',
          },
    'new':{
        '1': '-05-15',
        '2': '-08-31',
        '3': '-11-14',
        '4': '-03-31',
          },
    }
else:
  calendar = {
    '1': '-05-15',
    '2': '-08-14',
    '3': '-11-14',
    '4': '-03-31',
  }
get_year = lambda year, season: str(year) if int(season) != 4 else str(int(year) + 1)
ky_policy_check = lambda year: 'new' if year &gt;= '2021' else 'old'
return pd.to_datetime(s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[ky_policy_check(d[:4])][d[-1]]) if 'KY' in short_name else s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[d[-1]]))
</code></pre>
<p>def season_end(s):</p>
<pre><code>calendar = {
  '1': '-3-31',
  '2': '-6-30',
  '3': '-9-30',
  '4': '-12-31',
}
return pd.to_datetime(s.index.map(lambda d: d[:4] + calendar[d[-1]]))
</code></pre>
<p>disclosure_dates = data.get('financial_statements_upload_detail:upload_date')
disclosure_dates = disclosure_dates.apply(pd.to_datetime)</p>
<p>financial_season_end = disclosure_dates.apply(season_end)
default_disclosure_dates = disclosure_dates.apply(calc_default_disclosure_dates)</p>
<p>disclosure_dates[(disclosure_dates &gt; default_disclosure_dates)
| (disclosure_dates &lt; financial_season_end)] = pd.NaT
disclosure_dates[(disclosure_dates.diff() &lt;= datetime.timedelta(days=0))] = pd.NaT
disclosure_dates.loc['2019-Q1', '3167'] = pd.NaT
disclosure_dates.loc['2015-Q1', '5536'] = pd.NaT
disclosure_dates.loc['2018-Q1', '5876'] = pd.NaT</p>
<p>disclosure_dates = disclosure_dates.fillna(default_disclosure_dates)
disclosure_dates.columns.name = 'stock_id'</p>
<p>if detail:
return disclosure_dates
return default_disclosure_dates</p>
<pre><code>
## 本益成長比(月營收截止日換股)

https://doc.finlab.tw/tools/guide_for_beginners/

```python
from finlab import data
from finlab.backtest import sim
import finlab

finlab.login(&quot;cdnE+4n53DXjKkN8J7spHLvPq3xwycL6gfd0PaUL+UDWOAKroWHcXUNsN82ibihU#free&quot;)


rev = data.get('monthly_revenue:當月營收')
rev_ma3 = rev.average(3)
rev_ma12 = rev.average(12)

# 營收趨勢多頭策略
cond1 = rev_ma3/rev_ma12 &gt; 1.1
cond2 = rev/rev.shift(1) &gt; 0.9
cond_all = cond1 &amp; cond2

pe = data.get('price_earning_ratio:本益比')
營業利益成長率 = data.get('fundamental_features:營業利益成長率')

# 本益成長比
peg = (pe/營業利益成長率)

# 本益成長比和原訊號相乘，若不持有則相乘後等於0
position = peg*(cond_all)

# 原訊號為0的不要選，若沒加這行且策略只選到7檔，之後還是會選3檔訊號為0(不持有)的補足10檔，執行這行就會排除訊號為0。
position = position[position&gt;0]

# 選股挑本益成長比前10小的
position = position.is_smallest(10)

print(position)



# 月營收截止日換股
position = position.reindex(rev.index_str_to_date().index, method='ffill')
print(position)
input()
report = sim(position=position, name=&quot;策略教學範例:peg_rev&quot;, stop_loss=0.1, upload=False)
report.display()
</code></pre>
<h2 id="股價淨值比"><a class="header" href="#股價淨值比">股價淨值比</a></h2>
<pre><code class="language-python">from finlab import data
from finlab.backtest import sim

pb = data.get('price_earning_ratio:股價淨值比')
close = data.get('price:收盤價')

position = (1/(pb * close) * (close &gt; close.average(60)) * (close &gt; 5)).is_largest(20)
report = sim(position, resample='Q',mae_mfe_window=30,mae_mfe_window_step=2)
report.display_mae_mfe_analysis()
</code></pre>
<h2 id="is_smallest"><a class="header" href="#is_smallest">is_smallest</a></h2>
<pre><code class="language-python">import pandas as pd

def is_smallest(df, n):
    return df.astype(float).apply(lambda s: s.nsmallest(n), axis=1).reindex_like(df).notna()

df = pd.DataFrame({
    'A': [1.2, 2.5, 3.1],
    'B': [2.2, 1.8, 5.5],
    'C': [3.3, 4.5, 0.7],
    'D': [4.4, 5.5, 2.2],
    'E': [5.5, 3.3, 4.4]
})

print(df)
result = is_smallest(df, 2)
print(result)

#這個 DataFrame 有 5 列 3 行，包含 15 個浮點數值。現在需要按行找到每行最小的 2 個數值所在的列，將其對應的索引置為 True。
#
#使用以下程式碼進行處理：
#
#複製
#n = 2
#result = df.astype(float).apply(lambda s: s.nsmallest(n), axis=1).reindex_like(df).notna()
#這裡的 n 為 2，在上面的程式碼中，先將 df 轉換為浮點格式，然後按行進行遍歷，對每一行調用 s.nsmallest(n) 函數找到最小的 2 個數值所在的列，其它位置置為 NaN，返回一個 Series 對象。接著把這個 Series 對象與原始 DataFrame 進行重索引，並且補缺失值為 False，最終得到一個與原始 DataFrame 一樣大小的布林值 DataFrame。
#
#執行上述程式之後，可以得到以下結果：
#
#複製
#       A      B      C      D      E
#0  False   True  False  False  False
#1   True  False  False  False   True
#2  False   True   True  False  False
#這個結果的含義是：
#
#第一行最小的 2 個數值分別位於 B 列，因此 B 列為 True，其餘為 False；
</code></pre>
<h2 id="夏普值"><a class="header" href="#夏普值">夏普值</a></h2>
<p>出處： https://www.finlab.tw/python%e6%96%b0%e6%89%8b%e6%95%99%e5%ad%b8%ef%bc%9a%e5%a4%8f%e6%99%ae%e6%8c%87%e6%95%b8%e7%ad%96%e7%95%a5/</p>
<pre><code class="language-python">import yfinance as yf
import pandas as pd
import numpy as np

def crawl_price(stock_id):
    stock = yf.Ticker(stock_id)
    df = stock.history(period=&quot;max&quot;)
    return df


twii = crawl_price(&quot;^TWII&quot;)
print(twii)
mean = twii['Close'].pct_change().rolling(252).mean()
std = twii['Close'].pct_change().rolling(252).std()

sharpe = mean / std

# sharpe ratio 平滑
sr = sharpe
srsma = sr.rolling(60).mean()

# sharpe ratio 的斜率
srsmadiff = srsma.diff()

# 計算買入賣出點
buy = (srsmadiff &gt; 0) &amp; (srsmadiff.shift() &lt; 0)
sell = (srsmadiff &lt; 0) &amp; (srsmadiff.shift() &gt; 0)

# 計算持有時間
hold = pd.Series(np.nan, index=buy.index)
hold[buy] = 1
hold[sell] = 0
hold.ffill(inplace=True)
hold.plot()

# 持有時候的績效
adj = twii['Close'][buy.index]
(adj.pct_change().shift(-1)+1).fillna(1)[hold == 1].cumprod().plot()


def backtest(a, b, c, d, plot=False):
    sr = sharpe
    srsma = sr.rolling(a).mean()

    srsmadiff = srsma.diff() * 100
    ub = srsmadiff.quantile(b)
    lb = srsmadiff.quantile(c)
    
    buy = ((srsmadiff.shift(d) &lt; lb) &amp; (srsmadiff &gt; ub))
    sell = ((srsmadiff.shift(d) &gt; ub) &amp; (srsmadiff &lt; lb))

    hold = pd.Series(np.nan, index=buy.index)
    hold[buy] = 1
    hold[sell] = 0

    hold.ffill(inplace=True)
    
    adj = twii['Close'][buy.index]

    if plot:
        (adj.pct_change().shift(-1)+1).fillna(1)[hold == 1].cumprod().plot()
        hold.plot()

    eq = (adj.pct_change().shift(-1)+1).fillna(1)[hold == 1].cumprod()
    if len(eq) &gt; 0:
        return eq.iloc[-1]
    else:
        return 1


maxeq = 0
for a in range(100,200,20):
    for b in np.arange(0.3, 0.9, 0.03):
        for c in np.arange(0.3, 0.6, 0.03):
            for d in range(60, 180, 10):
                
                eq = backtest(a,b,c,d)
                
                if maxeq &lt; eq:
                    maxeq = eq
                    print(eq, a,b,c,d)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backtrader交易基礎"><a class="header" href="#backtrader交易基礎">Backtrader交易基礎</a></h1>
<p>查看帳戶情況：</p>
<pre><code class="language-python">class TestStrategy(bt.Strategy):
    def next(self):
        print('當前可用資金', self.broker.getcash())
        print('當前總資產', self.broker.getvalue())
        print('當前持倉量', self.broker.getposition(self.data).size)
        print('當前持倉成本', self.broker.getposition(self.data).price)
        # 也可以直接獲取持倉
        print('當前持倉量', self.getposition(self.data).size)
        print('當前持倉成本', self.getposition(self.data).price)
        # 註：getposition() 需要指定具體的標的資料集
</code></pre>
<p>滑點設定：</p>
<pre><code class="language-python"># 方式1：通過 BackBroker 類中的 slip_perc 參數設定百分比滑點
cerebro.broker = bt.brokers.BackBroker(slip_perc=0.0001)
# 方式2：通過呼叫 brokers 的 set_slippage_perc 方法設定百分比滑點
cerebro.broker.set_slippage_perc(perc=0.0001)

# 方式1：通過 BackBroker 類中的 slip_fixed 參數設定固定滑點
cerebro.broker = bt.brokers.BackBroker(slip_fixed=0.001)
# 方式2：通過呼叫 brokers 的 set_slippage_fixed 方法設定固定滑點
cerebro.broker = cerebro.broker.set_slippage_fixed(fixed=0.001)
</code></pre>
<p>參數說明：</p>
<p>有關滑點的其他設定
slip_open：是否對開盤價做滑點處理，該參數在 BackBroker() 類中默認為 False，在 set_slippage_perc 和set_slippage_fixed 方法中默認為 True；
slip_match：是否將滑點處理後的新成交價與成交當天的價格區間 low ~ high 做匹配，如果為 True，則根據新成交價重新匹配調整價格區間，確保訂單能被執行；如果為 False，則不會與價格區間做匹配，訂單不會執行，但會在下一日執行一個空訂單；默認取值為 True；
slip_out：如果新成交價高於最高價或低於最高價，是否以超出的價格成交，如果為 True，則允許以超出的價格成交；如果為 False，實際成交價將被限制在價格區間內  low ~ high；默認取值為 False；
slip_limit：是否對限價單執行滑點，如果為 True，即使 slip_match 為Fasle，也會對價格做匹配，確保訂單被執行；如果為 False，則不做價格匹配；默認取值為 True。</p>
<pre><code class="language-python"># 情況1：
set_slippage_fixed(fixed=0.35,
                   slip_open=False,
                   slip_match=True,
                   slip_out=False)
# 由於 slip_open=False ，不會對開盤價做滑點處理，所以仍然以原始開盤價 32.63307367 成交

# 情況2：
set_slippage_fixed(fixed=0.35,
                   slip_open=True,
                   slip_match=True,
                   slip_out=False)

# 情況3：
set_slippage_fixed(fixed=0.35,
                   slip_open=True,
                   slip_match=True,
                   slip_out=True)
# 滑點調整的新成交價為 32.63307367+0.35 = 32.98307367，超出了當天最高價 32.94151482
# 允許做價格匹配 slip_match=True, 而且運行以超出價格區間的新成交價執行 slip_out=True
# 最終以新成交價 32.98307367 成交

# 情況4：
set_slippage_fixed(fixed=0.35,
                   slip_open=True,
                   slip_match=False,
                   slip_out=True)
# 滑點調整的新成交價為 32.63307367+0.35 = 32.98307367，超出了當天最高價 32.94151482
# 由於不進行價格匹配 slip_match=False，新成交價超出價格區間無法成交
# 2019-01-17 這一天訂單不會執行，但會在下一日 2019-01-18 執行一個空訂單
# 再往後的 2019-07-02，也未執行訂單，下一日 2019-07-03 執行空訂單
# 即使 2019-07-03的 open 39.96627412+0.35 &lt; high 42.0866713 滿足成交條件，也不會補充成交
</code></pre>
<p>交易稅費管理</p>
<p>股票：目前 A 股的交易費用分為 2 部分：佣金和印花稅，
其中佣金雙邊徵收，不同證券公司收取的佣金各不相同，一般在 0.02%-0.03% 左右，單筆佣金不少於 5 元；
印花稅只在賣出時收取，稅率為 0.1%。</p>
<p>期貨：期貨交易費用包括交易所收取手續費和期貨公司收取佣金 2 部分，交易所手續費較為固定，
不同期貨公司佣金不一致，而且不同期貨品種的收取方式不相同，有的按照固定費用收取，有的按成交金額的固定百分比收取：
合約現價<em>合約乘數</em>手續費費率。除了交易費用外，期貨交易時還需上交一定比例的保證金 。</p>
<p>Backtrader 也提供了多種交易費設定方式，既可以簡單的通過參數進行設定，也可以結合交易條件自訂費用函數：</p>
<p>根據交易品種的不同，Backtrader 將交易費用分為 股票 Stock-like 模式和期貨 Futures-like 種模式；
根據計算方式的不同，Backtrader 將交易費用分為 PERC 百分比費用模式 和 FIXED 固定費用模式 ；</p>
<p>Stock-like 模式與 PERC 百分比費用模式對應，期貨 Futures-like 與 FIXED 固定費用模式對應；</p>
<p>在設定交易費用時，最常涉及如下 3 個參數：</p>
<p>commission：手續費 / 佣金；</p>
<p>mult：乘數；</p>
<p>margin：保證金 / 保證金比率 。</p>
<p>雙邊徵收：買入和賣出操作都要收取相同的交易費用 。</p>
<pre><code class="language-python">cerebro.broker.setcommission(
    # 交易手續費，根據margin取值情況區分是百分比手續費還是固定手續費
    commission=0.0,
    # 期貨保證金，決定著交易費用的類型,只有在stocklike=False時起作用
    margin=None,
    # 乘數，盈虧會按該乘數進行放大
    mult=1.0,
    # 交易費用計算方式，取值有：
    # 1.CommInfoBase.COMM_PERC 百分比費用
    # 2.CommInfoBase.COMM_FIXED 固定費用
    # 3.None 根據 margin 取值來確定類型
    commtype=None,
    # 當交易費用處於百分比模式下時，commission 是否為 % 形式
    # True，表示不以 % 為單位，0.XX 形式；False，表示以 % 為單位，XX% 形式
    percabs=True,
    # 是否為股票模式，該模式通常由margin和commtype參數決定
    # margin=None或COMM_PERC模式時，就會stocklike=True，對應股票手續費；
    # margin設定了取值或COMM_FIXED模式時,就會stocklike=False，對應期貨手續費
    stocklike=False,
    # 計算持有的空頭頭寸的年化利息
    # days * price * abs(size) * (interest / 365)
    interest=0.0,
    # 計算持有的多頭頭寸的年化利息
    interest_long=False,
    # 槓桿比率，交易時按該槓桿調整所需現金
    leverage=1.0,
    # 自動計算保證金
    # 如果False,則通過margin參數確定保證金
    # 如果automargin&lt;0,通過mult*price確定保證金
    # 如果automargin&gt;0,如果automargin*price確定保證金
    automargin=False,
    # 交易費用設定作用的資料集(也就是作用的標的)
    # 如果取值為None，則默認作用於所有資料集(也就是作用於所有assets)
    name=None)
</code></pre>
<p>從上述各參數的含義和作用可知，margin 、commtype、stocklike 存在 2 種默認的組態規則：股票百分比費用、期貨固定費用，具體如下：
第 1 條規則：未設定 margin（即 margin 為 0 / None / False）→ commtype 會指向 COMM_PERC 百分比費用 → 底層的 _stocklike 屬性會設定為 True → 對應的是“股票百分比費用”。
所以如果想為股票設定交易費用，就令 margin = 0 / None / False，或者令 stocklike=True；</p>
<p>第 2 條規則：為 margin 設定了取值 →  commtype 會指向 COMM_FIXED 固定費用 → 底層的 _stocklike 屬性會設定為 False → 對應的是“期貨固定費用”，因為只有期貨才會涉及保證金。
所以如果想為期貨設定交易費用，就需要設定 margin，此外還需令 stocklike=True，margin 參數才會起作用 。</p>
<p>自訂交易費用的例子</p>
<pre><code class="language-python"># 自訂期貨百分比費用
class CommInfo_Fut_Perc_Mult(bt.CommInfoBase):
    params = (
      ('stocklike', False), # 指定為期貨模式
      ('commtype', bt.CommInfoBase.COMM_PERC), # 使用百分比費用
      ('percabs', False), # commission 以 % 為單位
    )

    def _getcommission(self, size, price, pseudoexec):
        # 計算交易費用
        return (abs(size) * price) * (self.p.commission/100) * self.p.mult
    # pseudoexec 用於提示當前是否在真實統計交易費用
    # 如果只是試算費用，pseudoexec=False
    # 如果是真實的統計費用，pseudoexec=True

comminfo = CommInfo_Fut_Perc_Mult(
    commission=0.1, # 0.1%
    mult=10,
    margin=2000) # 實例化
cerebro.broker.addcommissioninfo(comminfo)

# 上述自訂函數，也可以通過 setcommission 來實現
cerebro.broker.setcommission(commission=0.1, #0.1%
                             mult=10,
                             margin=2000,
                             percabs=False,
                             commtype=bt.CommInfoBase.COMM_PERC,
                             stocklike=False)
</code></pre>
<p>下面是考慮佣金和印花稅的股票百分比費用：</p>
<pre><code class="language-python">class StockCommission(bt.CommInfoBase):
    params = (
      ('stocklike', True), # 指定為期貨模式
      ('commtype', bt.CommInfoBase.COMM_PERC), # 使用百分比費用模式
      ('percabs', True), # commission 不以 % 為單位
      ('stamp_duty', 0.001),) # 印花稅默認為 0.1%
    
    # 自訂費用計算公式
      def _getcommission(self, size, price, pseudoexec):
            if size &gt; 0: # 買入時，只考慮佣金
                return abs(size) * price * self.p.commission
            elif size &lt; 0: # 賣出時，同時考慮佣金和印花稅
        return abs(size) * price * (self.p.commission + self.p.stamp_duty)
            else:
                return 0
</code></pre>
<p>成交量限制管理</p>
<p>形式1：bt.broker.fillers.FixedSize(size) </p>
<p>通過 FixedSize() 方法設定最大的固定成交量：size，該種模式下的成交量限制規則如下：</p>
<p>訂單實際成交量的確定規則：取（size、訂單執行那天的 volume 、訂單中要求的成交數量）中的最小者；</p>
<p>訂單執行那天，如果訂單中要求的成交數量無法全部滿足，則只成交部分數量。第二天不會補單。</p>
<pre><code class="language-python"># 通過 BackBroker() 類直接設定
cerebro = Cerebro()
filler = bt.broker.fillers.FixedSize(size=xxx)
newbroker = bt.broker.BrokerBack(filler=filler)
cerebro.broker = newbroker

# 通過 set_filler 方法設定
cerebro = Cerebro()
cerebro.broker.set_filler(bt.broker.fillers.FixedSize(size=xxx))

# self.order = self.buy(size=2000) # 每次買入 2000 股
# cerebro.broker.set_filler(bt.broker.fillers.FixedSize(size=3000)) # 固定最大成交量
</code></pre>
<p>形式2：bt.broker.fillers.FixedBarPerc(perc)</p>
<p>通過 FixedBarPerc(perc) 將 訂單執行當天 bar 的總成交量 volume 的 perc % 設定為最大的固定成交量，該模式的成交量限制規則如下：</p>
<p>訂單實際成交量的確定規則：取 （volume * perc /100、訂單中要求的成交數量） 的 最小者；
訂單執行那天，如果訂單中要求的成交數量無法全部滿足，則只成交部分數量。</p>
<pre><code class="language-python"># 通過 BackBroker() 類直接設定
cerebro = Cerebro()
filler = bt.broker.fillers.FixedBarPerc(perc=xxx)
newbroker = bt.broker.BrokerBack(filler=filler)
cerebro.broker = newbroker

# 通過 set_filler 方法設定
cerebro = Cerebro()
cerebro.broker.set_filler(bt.broker.fillers.FixedBarPerc(perc=xxx))
# perc 以 % 為單位，取值範圍為[0.0,100.0]

# self.order = self.buy(size=2000) # 以下一日開盤價買入2000股
# cerebro.broker.set_filler(bt.broker.fillers.FixedBarPerc(perc=50))
</code></pre>
<p>形式3：bt.broker.fillers.BarPointPerc(minmov=0.01，perc=100.0)</p>
<p>BarPointPerc() 在考慮了價格區間的基礎上確定成交量，在訂單執行當天，成交量確定規則為：</p>
<p>通過 minmov 將 當天 bar 的價格區間 low ~ high 進行均勻劃分，得到劃分的份數：</p>
<p>part =  (high -low +minmov)  // minmov  （向下取整）</p>
<p>再對當天 bar 的總成交量 volume 也劃分成相同的份數 part ，這樣就能得到每份的平均成交量：</p>
<p>volume_per = volume // part </p>
<p>最終，volume_per * （perc / 100）就是允許的最大成交量，實際成交時，對比訂單中要求的成交量，就可以得到最終實際成交量</p>
<p>實際成交量 = min ( volume_per * （perc / 100）, 訂單中要求的成交數量 )</p>
<pre><code class="language-python"># 通過 BackBroker() 類直接設定
cerebro = Cerebro()
filler = bt.broker.fillers.BarPointPerc(minmov=0.01，perc=100.0)
newbroker = bt.broker.BrokerBack(filler=filler)
cerebro.broker = newbroker

# 通過 set_filler 方法設定
cerebro = Cerebro()
cerebro.broker.set_filler(bt.broker.fillers.BarPointPerc(minmov=0.01，perc=100.0))
# perc 以 % 為單位，取值範圍為[0.0,100.0]


# self.order = self.buy(size=2000) # 以下一日開盤價買入2000股

# cerebro.broker.set_filler(bt.broker.fillers.BarPointPerc(minmov=0.1, perc=50)) # 表示 50%
</code></pre>
<p>交易時機管理
對於交易訂單生成和執行時間，Backtrader 默認是 “當日收盤後下單，次日以開盤價成交”，這種模式在回測過程中能有效避免使用未來資料。
但對於一些特殊的交易場景，比如“all_in”情況下，當日所下訂單中的數量是用當日收盤價計算的（總資金 / 當日收盤價），次日以開盤價執行訂單時，
如果開盤價比昨天的收盤價提高了，就會出現可用資金不足的情況。
為了應對一些特殊交易場景，Backtrader 還提供了一些 cheating 式的交易時機模式：Cheat-On-Open 和 Cheat-On-Close。</p>
<p>Cheat-On-Open</p>
<p>Cheat-On-Open 是“當日下單，當日以開盤價成交”模式，在該模式下，Strategy 中的交易邏輯不再寫在 next() 方法裡，而是寫在特定的 next_open()、nextstart_open() 、prenext_open() 函數中，具體設定可參考如下案例：</p>
<p>方式1：bt.Cerebro(cheat_on_open=True)；
方式2：cerebro.broker.set_coo(True)；
方式3：BackBroker(coo=True)。</p>
<p>Cheat-On-Close</p>
<p>Cheat-On-Close 是“當日下單，當日以收盤價成交”模式，在該模式下，Strategy 中的交易邏輯仍寫在 next() 中，具體設定如下：</p>
<p>方式1：cerebro.broker.set_coc(True)；
方式2：BackBroker(coc=True)</p>
<pre><code class="language-python">class TestStrategy(bt.Strategy):
    ......
    def next(self):
        # 取消之前未執行的訂單
        if self.order:
            self.cancel(self.order)
        # 檢查是否有持倉
        if not self.position:
            # 10日均線上穿5日均線，買入
            if self.crossover &gt; 0:
                print('{} Send Buy, open {}'.format(self.data.datetime.date(),self.data.open[0]))
                self.order = self.buy(size=100) # 以下一日開盤價買入100股
        # # 10日均線下穿5日均線，賣出
        elif self.crossover &lt; 0:
            self.order = self.close() # 平倉，以下一日開盤價賣出
    ......

# 實例化大腦
cerebro= bt.Cerebro()
.......
# 當日下單，當日收盤價成交
cerebro.broker.set_coc(True)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python回測框架一backtrader-介紹"><a class="header" href="#python回測框架一backtrader-介紹">Python回測框架（一）Backtrader 介紹</a></h1>
<h3 id="為什麼設計投資策略需要回測"><a class="header" href="#為什麼設計投資策略需要回測"><strong>為什麼設計投資策略需要「回測」？</strong></a></h3>
<p>出處: https://stockbuzzai.wordpress.com/2019/07/08/python%e5%9b%9e%e6%b8%ac%e6%a1%86%e6%9e%b6%ef%bc%88%e4%b8%80%ef%bc%89backtrader-%e4%bb%8b%e7%b4%b9/</p>
<p>因為人都有盲點，在股市暗潮洶湧的環境中，會有我們沒考量到的變因潛伏期中。<strong>透過回測，我們可以找到之前沒發現的暗礁</strong>，<strong>使投資策略更完備</strong>、更安全航行於股海之中。</p>
<p>在這邊介紹一個能簡單操作回測的程式 Backtrader，讓你能輕鬆上手，用電腦幫你運用過去的數據測試選股策略！</p>
<h3 id="backtrader-介紹"><a class="header" href="#backtrader-介紹"><strong>Backtrader 介紹</strong></a></h3>
<p>Backtrader 是一套基於 Python 的策略回測框架，可以讓使用者花更多時間專注於策略上而不需要處理一些交易細節和輸出回測的結果。</p>
<p>這是一個簡單的範例。內容很簡單，我們先放入一筆錢，然後每月買一張微軟 (MSFT) 的股票，最後輸出回測的結果。</p>
<pre><code class="language-python">data = bt.feeds.YahooFinanceData(dataname='MSFT',
                                  fromdate=datetime(2010, 1, 1),
                                  todate=datetime(2018, 12, 31))
  
cerebro.adddata(data) 
</code></pre>
<p>在回測中最重要的，就是需要有數據，Backtrader 提供了從 Yahoo!Finance 直接撈取資料的功能，在這一段程式碼中，我們下載 MSFT 從 2010/1/1 到 2018/12/31 的股價資料，並把資料添加到 cerebro。</p>
<p>Backtrader 除了支援使用 Yahoo!Finance 撈取資料之外，也支援從 csv 載入資料，有興趣的人可以查看 <a href="https://www.backtrader.com/docu/datafeed/">Data Feeds</a>。</p>
<pre><code class="language-python">class TestStrategy(bt.Strategy):
     def __init__(self):
         self._next_buy_date = datetime(2010, 1, 5)
  
     def next(self):
         if self.data.datetime.date() &gt;= self._last_buy_date.date():
             self._last_buy_date += relativedelta(months=1)
             self.buy(size=1)  
</code></pre>
<p>處理完資料的問題，接下來就可以專注於策略的部分。我們的策略是每月 5 日購買 1 股股票。</p>
<pre><code class="language-python">def __init__(self):
         self._next_buy_date = datetime(2010, 1, 5)
</code></pre>
<p>我們的資料設定的時間是 2010/1/1 到 2018/12/31，因此我們設定第一個購買股票的日期為 2010/1/5。</p>
<pre><code class="language-python">def next(self):
         if self.data.datetime.date() &gt;= self._last_buy_date.date():
             self._last_buy_date += relativedelta(months=1)
             self.buy(size=1)  
</code></pre>
<p>next 這個 method 是每一個交易日都會被呼叫一次，我們在這個 method 中比對交易日是否已經到達我們的預期的交易日，當到達的時候就把交易日加上一個月，並購買一股。</p>
<pre><code class="language-python">cerebro.adddata(data) 
cerebro.addstrategy(TestStrategy)
cerebro.broker.set_cash(cash=10000)
cerebro.run()
cerebro.plot()
</code></pre>
<p>我們將策略添加到 cerebro 之中，同時不要忘了把我們的起始資金設定為 10000，然後呼叫 cerebro.run() 來直接交易模擬的工作。最後，我們希望把結果用圖型化的方式輸出，於是呼叫 cerebro.plot() 來展示結果。</p>
<p>以下是我們輸出的結果：</p>
<p><img src="strategy/backtrader/../images/michael_python1_figure.png" alt="img" /></p>
<p>由圖可見， 最上方藍線為淨值曲線，紅線為現金值曲線；最下方為 MSFT 價格走勢圖和我們的買入點，我們的帳戶淨值由原始的 10,000 增長至 16,021.77。在這段期間，我們總共買入 108 股，買入的平均價格為 43.83 元，資產多了 6021.77 元！</p>
<p>下次，我們來回測定期定額買入股票的績效。</p>
<p>＿＿</p>
<h4 id="完整程式碼"><a class="header" href="#完整程式碼"><strong>完整程式碼：</strong></a></h4>
<pre><code class="language-python">from datetime import datetime
import backtrader as bt
from dateutil.relativedelta import relativedelta
  
class TestStrategy(bt.Strategy):
     def __init__(self):
         self._next_buy_date = datetime(2010, 1, 5)
  
     def next(self):
         if self.data.datetime.date() &gt;= self. _next_buy_date.date():
             self. _next_buy_date += relativedelta(months=1)
             self.buy(size=1)
  
cerebro = bt.Cerebro()
data = bt.feeds.YahooFinanceData(dataname='MSFT',
                                  fromdate=datetime(2010, 1, 1),
                                  todate=datetime(2018, 12, 31))
  
cerebro.adddata(data) 
cerebro.addstrategy(TestStrategy)
cerebro.broker.set_cash(cash=10000)
cerebro.run()
cerebro.plot() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-回測框架二定期定額投資"><a class="header" href="#python-回測框架二定期定額投資">Python 回測框架（二）定期定額投資</a></h1>
<p>出處: https://stockbuzzai.wordpress.com/2019/07/09/python-%e5%9b%9e%e6%b8%ac%e6%a1%86%e6%9e%b6-%e4%ba%8c%ef%bc%9a%e5%ae%9a%e6%9c%9f%e5%ae%9a%e9%a1%8d%e6%8a%95%e8%b3%87/</p>
<p>在上一篇 <a href="https://stockbuzzai.wordpress.com/2019/07/08/python%E5%9B%9E%E6%B8%AC%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89backtrader-%E4%BB%8B%E7%B4%B9/">Python回測框架 (一)： Backtrader介紹</a> 中我們介紹如何使用 Backtrader 做定期投資，可是一般我們投資不會一開始準備一大筆錢，然後每期讓它扣款，通常是定期定額的投資。因此在這篇文章中會介紹如何使用 Backtrader 做定期定額的投資。</p>
<pre><code class="language-python">def __init__(self):
         self._last_deposit_date = datetime(2010, 1, 5)
         self._last_buy_date = datetime(2010, 1, 7)
</code></pre>
<p>在初始化的部分，我們一共分成兩個變數，_last_deposit_date 是紀錄本月的入金時間，_last_buy_date 則是記錄實際購買的時間。因為 Backtrader 在增加現金至系統的時候，我有兩天的延遲，所以必須在入金的兩天之後才能進行股票的購買。</p>
<pre><code class="language-python">def next(self):
         current_date = self.data.datetime.date()
         if current_date &gt;= self._last_deposit_date.date():
             self._last_deposit_date += relativedelta(months=1)
             self._last_buy_date = datetime.combine(date=current_date, time=datetime.min.time()) + relativedelta(days=3)
             self.broker.add_cash(cash=300)
</code></pre>
<p>在處理每個交易日的部分，我們程式碼一共分成兩段，這一段程式碼是先判斷今天是不是匯款日，如果是匯款日的話，將 300 美金存入銀行，同時將 _last_deposit_date 設定為下一個月的同一天，並且把交易日設定為三天後。</p>
<pre><code class="language-python">if current_date &gt;= self._last_buy_date.date():
             price = (self.data.high + self.data.low) / 2.0
             volume = math.floor((self.broker.cash) / price)
             self.buy(size=volume)
             self._last_buy_date += relativedelta(months=1)
</code></pre>
<p>這一段程式碼是判斷當今天為交易日的時候，我們使用當日最高價（self.data.high）和最低價（self.data.low）的平均來計算要買的量。把持有的現金（self.broker.cash）除上價格就是我們預計買的量。同時把交易日加上一個月。</p>
<pre><code class="language-python">cerebro.broker.set_cash(cash=1)
</code></pre>
<p>最後，因為我們這次是採取定期定額的投資，所以我們把錢設定為 1 (因為設定為 0 的時候在資產計算會 Crash)。</p>
<p>以下分別是每月用 300 美元購買微軟 (MSFT)、好市多 (COST)、星巴克 (SBUX) 的狀況，購買的時間是 2010/01/01 到 2018/12/31。其中明顯的可以發現微軟的總淨值 94755.7 比好市多的 69478.5 和星巴克的 77851.72 還要好 10% 以上，因此慎選好股票是很重要的一件事情。</p>
<p><img src="strategy/backtrader/../images/michael_python2_msft.png" alt="img" />微軟 (MSFT)</p>
<p><img src="strategy/backtrader/../images/michael_python2_costco.png" alt="img" />好市多 (COST)</p>
<p><img src="strategy/backtrader/../images/michael_python2_starbucks.png" alt="img" />星巴克 (SBUX)</p>
<p>＿＿＿</p>
<h4 id="完整程式碼-1"><a class="header" href="#完整程式碼-1"><strong>完整程式碼：</strong></a></h4>
<pre><code class="language-python">from datetime import datetime
from dateutil.relativedelta import relativedelta
import backtrader
import math
  
class TestStrategy(backtrader.Strategy):
     def __init__(self):
         self._last_deposit_date = datetime(2010, 1, 5)
         self._last_buy_date = datetime(2010, 1, 7)
  
     def next(self):
         current_date = self.data.datetime.date()
         if current_date &gt;= self._last_deposit_date.date():
             self._last_deposit_date += relativedelta(months=1)
             self._last_buy_date = datetime.combine(date=current_date, time=datetime.min.time()) + relativedelta(days=3)
             self.broker.add_cash(cash=300)
  
         if current_date &gt;= self._last_buy_date.date():
             price = (self.data.high + self.data.low) / 2.0
             volume = math.floor((self.broker.cash) / price)
             self.buy(size=volume)
             self._last_buy_date += relativedelta(months=1)
  
cerebro = backtrader.Cerebro()
data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                  fromdate=datetime(2010, 1, 1),
                                  todate=datetime(2018, 12, 31))
  
cerebro.adddata(data) 
cerebro.addstrategy(TestStrategy)
cerebro.broker.set_cash(cash=1)
cerebro.run()
cerebro.plot() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-回測框架三技術指標"><a class="header" href="#python-回測框架三技術指標">Python 回測框架（三）技術指標</a></h1>
<p>出處:https://stockbuzzai.wordpress.com/2019/07/10/python-%e5%9b%9e%e6%b8%ac%e6%a1%86%e6%9e%b6%ef%bc%88%e4%b8%89%ef%bc%89%e6%8a%80%e8%a1%93%e6%8c%87%e6%a8%99/</p>
<p>延續之前的內容，這次要利用最頻繁被使用的技術指標之一 – 日均線 (Moving Average) 作為我們策略的篩選條件。</p>
<p>在投資策略上，技術指標是一個很常被用到的工具。透過技術指標，我們可以比較容易地分析商品或是大盤的趨勢。在這個範例之中，我們將使用 20 日均線和 60 日均線做為我們買賣的參考。當商品 (MSFT) 的開盤價低於 60 日均線同時 20 均線又呈現上漲趨勢的時候，我們才買入商品。</p>
<pre><code class="language-python">data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                  fromdate=datetime(2009, 1, 1),
                                  todate=datetime(2018, 12, 31)) 
</code></pre>
<p>雖然我們是從 2010 年才開始交易，但是因為我們有需要 60 天均線和 20 天均線的資料，因此我們必須至少多載入 60 個交易日以上的資料來提供系統計算均線。</p>
<pre><code class="language-python">def __init__(self):
         self.next_buy_date = datetime(2010, 1, 1)
         self.sma60 = backtrader.ind.SMA(period=60)
         self.sma20 = backtrader.ind.SMA(period=20)
         self.total_cash = 0 
</code></pre>
<p>在初始化的過程中，我們產生了兩個均線變數，sma20 和 sma60。同時我們產生一個變數 total_cash 來統計我們到底投入的多少資金。next_buy_day則是控制不要短期內連續買入。</p>
<pre><code class="language-python">current_date = self.data.datetime.date()
         if current_date &gt;= self.next_buy_date.date():
             if self.data.close &lt; self.sma60[0] and self.sma20[0] &gt; self.sma20[-1]:
                 price = (self.data.high + self.data.low) / 2.0
                 volume = math.floor((self.broker.cash) / price)
                 self.buy(size=volume)
                 self.broker.add_cash(cash=300)
                 self.total_cash += 300
                 self.next_buy_date = datetime.combine(current_date, datetime.min.time()) + relativedelta(months=1)  
</code></pre>
<p>首先，if current_date &gt;= self.next_buy_date.date(): 這一行判斷了是否今天是可以交易的日子。self.data.close &lt; self.sma60[0] 則判斷了今日的開盤價是否高於 60 日均線。self.sma20[0] &gt; self.sma20[-1] 這一行則判斷今日的 20 日均線值是否比昨天高，用來判斷20 天均線是否在上升的狀態。</p>
<p>當這兩個條件都成立，則買入。</p>
<p>根據程式回測的結果，我們只需要投入 7800 元，9 年後微軟的淨值就會成為 25474，大約賺了250% 以上。</p>
<p><img src="strategy/backtrader/../images/michael_python3_msft_sma.png" alt="img" />微軟 (MSFT)</p>
<p>＿＿＿</p>
<h4 id="完整程式碼-2"><a class="header" href="#完整程式碼-2"><strong>完整程式碼</strong></a></h4>
<pre><code class="language-python">from datetime import datetime
from dateutil.relativedelta import relativedelta
import backtrader
import math
  
class TestStrategy(backtrader.Strategy):
     def __init__(self):
         self.next_buy_date = datetime(2010, 1, 1)
         self.sma60 = backtrader.ind.SMA(period=60)
         self.sma20 = backtrader.ind.SMA(period=20)
         self.total_cash = 0
  
     def next(self):
         current_date = self.data.datetime.date()
         if current_date &gt;= self.next_buy_date.date():
             if self.data.close &lt; self.sma60[0] and self.sma20[0] &gt; self.sma20[-1]:
                 price = (self.data.high + self.data.low) / 2.0
                 volume = math.floor((self.broker.cash) / price)
                 self.buy(size=volume)
                 self.broker.add_cash(cash=300)
                 self.total_cash += 300
                 self.next_buy_date = datetime.combine(current_date, datetime.min.time()) + relativedelta(months=1)
  
     def stop(self):
         print(self.total_cash)
  
 cerebro = backtrader.Cerebro()
 data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                  fromdate=datetime(2009, 1, 1),
                                  todate=datetime(2018, 12, 31))
  
 cerebro.adddata(data) 
 cerebro.addstrategy(TestStrategy)
 cerebro.broker.set_cash(cash=300)
 cerebro.run()
 cerebro.plot() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-回測框架四crossover-和-signal"><a class="header" href="#python-回測框架四crossover-和-signal">Python 回測框架（四）CrossOver 和 Signal</a></h1>
<p>出處：https://stockbuzzai.wordpress.com/2019/07/15/python-%e5%9b%9e%e6%b8%ac%e6%a1%86%e6%9e%b6%ef%bc%88%e5%9b%9b%ef%bc%89crossover-%e5%92%8c-signal/</p>
<h3 id="crossover"><a class="header" href="#crossover"><strong>CrossOver</strong></a></h3>
<p>什麼是 CrossOver 呢？CrossOver 是一個判斷輸入的價格或是技術指標狀態的工具。</p>
<p>首先我們先來看下面這一段程式碼：</p>
<pre><code class="language-python">def __init__(self):
     sma10 = backtrader.ind.SMA(period=10)
     sma30 = backtrader.ind.SMA(period=30)
     self.crossover = backtrader.ind.CrossOver(sma10, sma30)  
</code></pre>
<p>在這段程式碼之中，我們建立了一條 10 日的短均線 (sma10) 和一條 30 日的長均線 (sma30)。接著，我們利用了 sma10 和 sma30 建立了一個 CrossOver。</p>
<p>當短均線向上穿越長均線時，sma10 的數值變得比 sma30 大，此時 CrossOver 會回傳一個大於 0 的數值，做為買進訊號。反之，當短均線向下穿越長均線時，sma10 的數值變得小於 sma30 ，CrossOver 會回傳一個小於 0 的數值，為賣出訊號。</p>
<p>以下我們利用 CrossOver 來做買賣：</p>
<pre><code class="language-python">def next(self):
     if not self.position:
         if self.crossover &gt; 0:
             self.buy()
  
     elif self.crossover &lt; 0:
         self.close() 
</code></pre>
<p>這段程式碼中，當我們沒有持倉，且 crossover 大於 0，我們買進股票 1 股 (一樣是以微軟股票為例)，當 crossover 小於 0，我們平倉。</p>
<h4 id="crossover-完整程式碼"><a class="header" href="#crossover-完整程式碼"><strong>CROSSOVER 完整程式碼</strong></a></h4>
<pre><code class="language-python">from datetime import datetime
import backtrader
  
  
class SmaCross(backtrader.Strategy):
     def __init__(self):
         sma10 = backtrader.ind.SMA(period=10)
         sma30 = backtrader.ind.SMA(period=30)
         self.crossover = backtrader.ind.CrossOver(sma10, sma30)
  
     def next(self):
         if not self.position:
             if self.crossover &gt; 0:
                 self.buy()
  
         elif self.crossover &lt; 0:
             self.close()
  
  
cerebro = backtrader.Cerebro()
data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                          fromdate=datetime(2011, 1, 1),
                                          todate=datetime(2012, 12, 31))
  
cerebro.adddata(data)
cerebro.addstrategy(SmaCross)
cerebro.run()
cerebro.plot() 
</code></pre>
<p>根據這個程式碼，以下是我們的回測結果。我們可以清楚地看當 sma10 和 sma30 發生交叉之後，我們就買進和賣出對應的股票。</p>
<p><img src="strategy/backtrader/../images/michael_4-1.png" alt="img" />微軟 (MSFT)</p>
<h3 id="signal"><a class="header" href="#signal"><strong>Signal</strong></a></h3>
<p>很多人可能覺得 CrossOver 可能沒什麼用處，因為我們直接比較 sma10 和 sma30 的數值也可以得到相同的結果，不需要用到這個工具。其實這個工具的主要用途是配合我們現在要介紹的另外一個工具 Signal 來使用。</p>
<p>以下我們先來看一段程式碼：</p>
<pre><code class="language-python">class SmaCross(backtrader.SignalStrategy):
     def __init__(self):
         sma10 = backtrader.ind.SMA(period=10)
         sma30 = backtrader.ind.SMA(period=30)
         crossover = backtrader.ind.CrossOver(sma10, sma30)
         self.signal_add(backtrader.SIGNAL_LONG, crossover) 
</code></pre>
<p>我們把 SmaCross 這個策略跟之前的比較，我們把 Strategy 換成了 SignalStrategy。在初始化的部分，我們的前三步驟跟之前一樣，分別建立了一個 10 日、30 日均線和一個 CrossOver，最大的不同是我們把這個 CrossOver 添加進了一個 Signal 之中。</p>
<p>Signal 會根據傳入資料的狀態變化時來進行動作。當傳入資料的變成正的，則發出 long 的信號，當傳入資料變為負的，則發出 short 的信號。當傳入資料變為 0，則不發出信號。至於 long 和 short 的行為則根據第一個參數來定義。目前這個參數一共有五種選擇分別是：</p>
<h4 id="main-group"><a class="header" href="#main-group"><strong>MAIN GROUP:</strong></a></h4>
<ul>
<li>
<p>LONGSHORT：long 和 short 的信號都接收</p>
</li>
<li>
<p>LONG：</p>
<ul>
<li>
<p>收到 long 的信號時會買入</p>
</li>
<li>
<p>收到 short 的信號時會平倉，但是</p>
<ul>
<li>
<p>如果系統中有 LONGEXIT 的信號，會先離場</p>
</li>
<li>
<p>如果系統中有 SHORT 的信號而且沒有 LONGEXIT 的信號，會先離場再賣出。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SHORT：</p>
<ul>
<li>
<p>收到 short 的信號時會賣出</p>
</li>
<li>
<p>收到 long 的信號時會平倉，但是</p>
<ul>
<li>
<p>如果系統中有 SHORTEXIT 的信號，會先離場。</p>
</li>
<li>
<p>如果有 LONG 的信號而且沒有 SHORTEXIT 的信號，會先離場再買入。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="exit-group"><a class="header" href="#exit-group"><strong>EXIT GROUP:</strong></a></h4>
<ul>
<li>LONGEXIT：收到 short 會離場</li>
<li>SHORTEXIT：收到 long 會離場</li>
</ul>
<p>當使用 LONG 的時候，我們可以看到跟之前相同的的結果：</p>
<p><img src="strategy/backtrader/../images/michael_4-1-1.png" alt="img" />LONG</p>
<p>如果將 LONG 改為 LONGSHORT，我們將得到另外一個結果：</p>
<p><img src="strategy/backtrader/../images/michael_4-2.png" alt="img" />LONGSHORT</p>
<h4 id="完整的程式碼"><a class="header" href="#完整的程式碼"><strong>完整的程式碼</strong></a></h4>
<pre><code class="language-python">from datetime import datetime
import backtrader
  
  
class SmaCross(backtrader.SignalStrategy):
     def __init__(self):
         sma10 = backtrader.ind.SMA(period=10)
         sma30 = backtrader.ind.SMA(period=30)
         crossover = backtrader.ind.CrossOver(sma10, sma30)
         self.signal_add(backtrader.SIGNAL_LONG, crossover)
  
  
cerebro = backtrader.Cerebro()
data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                          fromdate=datetime(2011, 1, 1),
                                          todate=datetime(2012, 12, 31))
  
cerebro.adddata(data)
cerebro.addstrategy(SmaCross)
cerebro.run()
cerebro.plot() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-回測框架五sizer"><a class="header" href="#python-回測框架五sizer">Python 回測框架（五）Sizer</a></h1>
<p>出處：https://stockbuzzai.wordpress.com/2019/07/23/python-%e5%9b%9e%e6%b8%ac%e6%a1%86%e6%9e%b6%ef%bc%88%e4%ba%94%ef%bc%89sizer/</p>
<p>在上一篇 <a href="https://stockbuzzai.wordpress.com/2019/07/15/python-%E5%9B%9E%E6%B8%AC%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89crossover-%E5%92%8C-signal/"><strong>Python 回測框架（四）CrossOver 和 Signal</strong></a> 中，我們談到了如何使用CrossOver 和 Signal 來買賣商品。但是我們又遇到了一個問題，我們無法控制買賣的商品數量。在一般交易中，我們可能會根據當前的狀況來買賣不同的數量的商品，因此我們在這一篇文章要介紹的就是 Backtrader 中負責控制買賣商品數量的工具 Sizer。</p>
<p>首先我們先回看下面這段程式碼：</p>
<pre><code class="language-python">from datetime import datetime
import backtrader
  
class SmaCross(backtrader.SignalStrategy):
    def __init__(self):
        sma10 = backtrader.ind.SMA(period=10)
        sma30 = backtrader.ind.SMA(period=30)
        crossover = backtrader.ind.CrossOver(sma10, sma30)
        self.signal_add(backtrader.SIGNAL_LONG, crossover)
  
cerebro = backtrader.Cerebro()
data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                         fromdate=datetime(2011, 1, 1),
                                         todate=datetime(2012, 12, 31))
  
cerebro.adddata(data)
cerebro.addstrategy(SmaCross)
cerebro.addsizer(backtrader.sizers.SizerFix, stake=10)
cerebro.run()
cerebro.plot() 
</code></pre>
<p>這一段程式碼幾乎跟 <a href="https://stockbuzzai.wordpress.com/2019/07/15/python-%E5%9B%9E%E6%B8%AC%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89crossover-%E5%92%8C-signal/"><strong>Python 回測框架（四）CrossOver 和 Signal</strong></a> 中的程式碼一樣，但是我們多了一行程式碼：</p>
<pre><code class="language-python">cerebro.addsizer(backtrader.sizers.SizerFix, stake=10) 
</code></pre>
<p>這裡我們設定了一個 Sizer，這個 Sizer 每次買賣固定的數量，一次是 10 股。下列是設定不同的 stake 的值的時候所產生的結果。</p>
<p><img src="strategy/backtrader/../images/michael_5-1.png" alt="img" />stake = 1</p>
<p>stake=1 的時候，產生的結果跟 <a href="https://stockbuzzai.wordpress.com/2019/07/15/python-%E5%9B%9E%E6%B8%AC%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89crossover-%E5%92%8C-signal/"><strong>Python 回測框架（四）CrossOver 和 Signal</strong></a> 中是相同的。</p>
<p><img src="strategy/backtrader/../images/michael_5-2.png" alt="img" />stake = 10</p>
<p>stake=10 的時候，我們發現每次購買股票資金明顯花費的比較多。</p>
<p><img src="strategy/backtrader/../images/michael_5-3.png" alt="img" />stake = 100</p>
<p>stake=100 的時候，我們發現每次購買的的數量確實更多了，所花費的資金也更多。</p>
<p>另外，在 Backtrader 之中，主要分成兩種 sizer。一種 sizer 屬於預設的 sizer，在系統中如果沒有其他的 sizer，就使用這個 sizer。在之前的程式碼就是使用預設 sizer 的範例。</p>
<p>另一種 sizer 是跟隨著 strategy 的，這種 sizer 只處理對應的 strategy 的買賣。設定strategy 的 sizer 有二種方法，一種是透過 cerebro 的 addsizer_byidx 來設定，如以下範例：</p>
<pre><code class="language-python">idx = cerebro.addstrategy(SmaCross)
cerebro.addsizer_byidx(idx, backtrader.sizers.SizerFix, stake=100) 
</code></pre>
<p>其中 idx 是 cerebro 在新增 strategy 的時候所回傳 idx 值，以此當參數來新增 sizer。</p>
<p>第二種方式是透過 strategy 的 setsizer 來設定 sizer，程式碼如下：</p>
<pre><code class="language-python">self.setsizer(backtrader.sizers.SizerFix(stake=100))
</code></pre>
<h3 id="如何自訂-sizer"><a class="header" href="#如何自訂-sizer"><strong>如何自訂 sizer</strong></a></h3>
<p>要撰寫自訂的 sizer，需要繼承 backtrader.Sizer 這個物件，然後覆寫 _getsizing 這個函式，以下是範例：</p>
<pre><code class="language-python">class AllSizer(backtrader.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash/data.high)
        else:
            return self.broker.getposition(data) 
</code></pre>
<p>AllSizer 是一個直接將資金買入商品的 sizer，其中 comminfo 代表手續費的相關資訊，cash 代表目前持有的現金，data 代表目前這檔商品，isbuy 代表這是買入還是賣出的請求。在買入的部分，我們利用持有現金除上當天最高價計算買入的股票數。賣出的時候則是把所有持倉都賣出。</p>
<p>以下是完整的程式碼和執行的結果：</p>
<pre><code class="language-python">from datetime import datetime
import yfinance as yf
import backtrader
import math


class AllSizer(backtrader.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash / data.high)
        else:
            return self.broker.getposition(data)


class SmaCross(backtrader.SignalStrategy):
    def __init__(self):
        sma10 = backtrader.ind.SMA(period=10)
        sma30 = backtrader.ind.SMA(period=30)
        crossover = backtrader.ind.CrossOver(sma10, sma30)
        self.signal_add(backtrader.SIGNAL_LONG, crossover)

        self.setsizer(AllSizer())


cerebro = backtrader.Cerebro()
# data = backtrader.feeds.PandasData(dataname=yf.download('TSLA', '2018-01-01', '2023-01-01'))
data = backtrader.feeds.PandasData(
    dataname=yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;)
)

# data = backtrader.feeds.YahooFinanceData(
#    dataname=&quot;MSFT&quot;, fromdate=datetime(2011, 1, 1), todate=datetime(2012, 12, 31)
# )

cerebro.adddata(data)
idx = cerebro.addstrategy(SmaCross)
cerebro.run()
# pip install matplotlib==3.2.2
cerebro.plot()
</code></pre>
<p><img src="strategy/backtrader/../images/michael_5-4.png" alt="img" /></p>
<p>有了 sizer，我們就可以把計算買賣商品數量的邏輯獨立，讓我們在撰寫回測程式的時候更方便且更有彈性。</p>
<h2 id="backtrader---sizer"><a class="header" href="#backtrader---sizer">Backtrader - sizer</a></h2>
<p>出處：https://ithelp.ithome.com.tw/articles/10279754</p>
<p>之前有介紹過，如果我們下單除了股價以外，還有一個很重要的因素就是要買幾股，有些時候，我們的策略可能會需要不同的買入數量，Backtrader 也有一個物件 sizer 可以提供相關的彈性，如果預設的沒有合適的，也可以自訂義一個，以下先介紹內建的一些 sizer</p>
<h3 id="fixedsize"><a class="header" href="#fixedsize">FixedSize</a></h3>
<p>顧名思義就是固定的數量
參數：</p>
<ul>
<li>stake { default 1 }: 固定數量的股數</li>
<li>tranches { default 1 }: 只執行 stake 的幾分之一
<em>最後的數量 = stake / tranches</em></li>
</ul>
<pre><code class="language-python">cerebro.addsizer(bt.sizers.SizerFix, stake = 1000)
</code></pre>
<h3 id="fixedreverser"><a class="header" href="#fixedreverser">FixedReverser</a></h3>
<p>一樣是固定數量，只是在賣的時候，會賣出 2 倍的庫存，也就是把正的庫存賣成負的庫存
參數：</p>
<ul>
<li>stake { default 1 } 固定的股數</li>
</ul>
<pre><code class="language-python">cerebro.addsizer(bt.sizers.FixedRevert, stake = 1000)
</code></pre>
<h3 id="percentsizer"><a class="header" href="#percentsizer">PercentSizer</a></h3>
<p>使用一定比例的帳戶餘額去買進
參數：</p>
<ul>
<li>percents { default 20 }: 20%</li>
</ul>
<pre><code class="language-python">cerebro.addsizer(bt.sizers.PercentSizer, percents = 80)
</code></pre>
<h3 id="allinsizer"><a class="header" href="#allinsizer">AllInSizer</a></h3>
<p>基本上和 PercentSizer 一樣，只是預設是 100% 的帳戶餘額去買進股票，另一個差別就是 All in 聽起來比較霸氣。
<em>這裡有一個要注意的是，AllIn 是以當天的收盤價去算要買的股數，可是在執行買入的時候，是隔天的開盤價，所以隔天是漲的話，就會造成餘額不足，買入失敗喔</em></p>
<pre><code class="language-python">cerebro.addsizer(bt.sizers.AllInSizer)
</code></pre>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<p>PercentSizerInt, AllInSizerInt，這兩個看說明是說在回傳數量的時候會轉成整數，不過我真正去執行的結果，兩個都是一樣的，所以暫時看不出差別</p>
<h3 id="自訂義-sizer"><a class="header" href="#自訂義-sizer">自訂義 sizer</a></h3>
<p>要自訂義 sizer 也很簡單</p>
<ul>
<li>訂義一個 sizer 的 class 繼承 backtrader.Sizer
繼承後可以使用 self.strategy 和 self.broker 來取得相關資料
<ul>
<li>取得庫存 self.strategy.getposition(data)</li>
<li>取得目前淨值 self.broker.getvalue() (或是 self.stratgy.broker.getvalue())</li>
</ul>
</li>
<li>覆寫 _getsizing(self, comminfo, cash, data, isbuy)
<ul>
<li>comminfo: 手續費相關資訊</li>
<li>cash：目前帳戶餘額</li>
<li>data: 目前的操作(買入/賣出)資料</li>
<li>isbuy: 是否為買入(True)</li>
</ul>
</li>
</ul>
<p>例如：改寫 percent 變成可以買的最大的張數 ( 1000 股 )</p>
<pre><code class="language-python">import backtrader as bt
import math
class PercentBoardSizer(bt.Sizer):
    params = (
        ('percents', 20),
    )

    def _getsizing(self, comminfo, cash, data, isbuy):
        position = self.broker.getposition(data)
        if not position:
            size = cash / data.close[0] * (self.p.percents / 100)
            
            if size &lt; 1000:
                # 小於 1000 股，就不買
                size = 0
            else:
                size = math.floor(size / 1000) * 1000
        else:
            size = position.size

        size = int(size)
        
        return size

class AllInBoardSizer(PercentBoardSizer):
    params = (
        ('percents', 100),
    )
</code></pre>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<ul>
<li>
<p>在 strategy 中：</p>
<ul>
<li>def setsizer(self, sizer): 可以取得已經初始化的 sizer</li>
<li>def getsizer(self): 回傳目前使用的 sizer</li>
<li>sizer 屬性可以直接進行 get/set (前幾天的範例就是使用這個)</li>
</ul>
</li>
<li>
<p>使用 cerebro：
<em>目前看來，如果 strategy 和 cerebro 都有設定的話，會以 cerebro 為主</em>，cerebro 有兩個方法可以設定</p>
<ul>
<li>addsizer(sizerClass, *args, **kwargs): 指定所有的 strategy 使用的 sizer</li>
<li>addsizer_byidx(idx, sizerClass, *args, **kwargs): 根據不同的 strategy inx 來使用不同的 sizer
ex:</li>
</ul>
<pre><code class="language-python">cerebro = bt.Cerebro()
# 預設的 sizer
cerebro.addsizer(bt.sizers.SizerFix, stake = 1000)

# 這樣就可以針對不同的 strategy 來設定不同的 sizer
idx = cerebro.addstrategy(TestStrategy)
cerebro.addsizer_byidx(idx, bt.sizers.SizerFix, stake = 5)
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-回測框架六analyzers"><a class="header" href="#python-回測框架六analyzers">Python 回測框架（六）Analyzers</a></h1>
<p>出處：https://stockbuzzai.wordpress.com/2019/07/29/python-%e5%9b%9e%e6%b8%ac%e6%a1%86%e6%9e%b6%ef%bc%88%e5%85%ad%ef%bc%89analyzers/</p>
<p>在跑完策略回測之後，只看淨值曲線圖通常是很難確實分析策略的優劣以及缺失之處。因此 Backtrader 提供了 Analyzers 這組工具來產生一些分析的數據，協助使用者來優化他們的策略。我們先來看下面這段程式碼：</p>
<pre><code class="language-python">from datetime import datetime
import backtrader
import math
 
 
class AllSizer(backtrader.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash/data.high)
        else:
            return self.broker.getposition(data)
 
 
class SmaCross(backtrader.SignalStrategy):
    def __init__(self):
        sma10 = backtrader.ind.SMA(period=10)
        sma30 = backtrader.ind.SMA(period=30)
        crossover = backtrader.ind.CrossOver(sma10, sma30)
        self.signal_add(backtrader.SIGNAL_LONG, crossover)
 
        self.setsizer(AllSizer())
 
 
cerebro = backtrader.Cerebro()
data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                         fromdate=datetime(2011, 1, 1),
                                         todate=datetime(2012, 12, 31))
  
cerebro.adddata(data)
cerebro.addstrategy(SmaCross)
cerebro.addanalyzer(backtrader.analyzers.SharpeRatio, _name = 'SR', timeframe=backtrader.TimeFrame.Years)
results = cerebro.run()
print('Sharpe Ratio:', results[0].analyzers.SR.get_analysis()) 
</code></pre>
<h3 id="分析工具sharperatio-drawdown-timereturn"><a class="header" href="#分析工具sharperatio-drawdown-timereturn"><strong>分析工具：SharpeRatio, DrawDown, TimeReturn</strong></a></h3>
<p>這是一個簡單策略，我們根據 10 日均線和 30 日均線的狀態來決定買賣。在這裡我們想要關注夏普比率的資訊，因此我們添加了下列的程式碼：</p>
<pre><code class="language-python">cerebro.addanalyzer(backtrader.analyzers.SharpeRatio, _name = 'SR', timeframe=backtrader.TimeFrame.Years)
results = cerebro.run()
print('Sharpe Ratio:', results[0].analyzers.SR.get_analysis()) 
</code></pre>
<p>我們新增了一個 Sharpe Ratio 的 Analyzer，名字為 <strong>SR</strong>。同時我們利用 timeframe=backtrader.TimeFrame.Years 把分析的時間單位設定為年。</p>
<p>接著利用 cerebro.run() 來執行模擬，並用 results 來接 cerebro 回傳的結果。因為我們這邊只有一個 Strategy，所以直接使用 results[0] 的結果就可以了。比較特別是 results[0].analyzers.SR.get_analysis() 中是使用前面設定的 <strong>SR</strong> 當呼叫的名稱，這裡要特別注意。</p>
<p>執行之後我們會得到這個結果：</p>
<pre><code class="language-python">Sharpe Ratio: OrderedDict([('sharperatio', -0.5071606143998728)])
</code></pre>
<p>於是我們就得到 Sharpe Ratio 的值了。另外將 timeframe 的參數改為 backtrader.TimeFrame.Months，我們就會得到以月為單位計算的結果。</p>
<pre><code class="language-python">Sharpe Ratio: OrderedDict([('sharperatio', -0.06338628736023329)])
</code></pre>
<p>另外 Analyzer 其實不是一次只能只用一個，也能一次使用多個，如下面的程式碼，我們同時使用了 DrawDown、TimeReturn 和 SharpeRatio 三種 Analyzers：</p>
<pre><code class="language-python">from datetime import datetime
import backtrader
import math
 
 
class AllSizer(backtrader.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash/data.high)
        else:
            return self.broker.getposition(data)
 
 
class SmaCross(backtrader.SignalStrategy):
    def __init__(self):
        sma10 = backtrader.ind.SMA(period=10)
        sma30 = backtrader.ind.SMA(period=30)
        crossover = backtrader.ind.CrossOver(sma10, sma30)
        self.signal_add(backtrader.SIGNAL_LONG, crossover)
 
        self.setsizer(AllSizer())
 
 
cerebro = backtrader.Cerebro()
data = backtrader.feeds.YahooFinanceData(dataname='MSFT',
                                         fromdate=datetime(2011, 1, 1),
                                         todate=datetime(2012, 12, 31))
 
cerebro.adddata(data)
cerebro.addstrategy(SmaCross)
cerebro.addanalyzer(backtrader.analyzers.SharpeRatio, _name = 'SR', timeframe=backtrader.TimeFrame.Years)
cerebro.addanalyzer(backtrader.analyzers.DrawDown, _name = 'DW')
cerebro.addanalyzer(backtrader.analyzers.TimeReturn, _name = 'TR', timeframe=backtrader.TimeFrame.Months)
results = cerebro.run()
print('Sharpe Ratio:', results[0].analyzers.SR.get_analysis())
print('Max DrawDown:', results[0].analyzers.DW.get_analysis().max)
for date, value in  results[0].analyzers.TR.get_analysis().items():
     print(date, value)  
</code></pre>
<p>DrawDown 是計算回撤率的工具，回傳結果中的 max 則是記錄最大回撤率，結果如下：</p>
<pre><code class="language-python">Max DrawDown: AutoOrderedDict([('len', 198), ('drawdown', 17.71801465164528), ('moneydown', 1976.4599999999991)]) 
</code></pre>
<p>這裡我們可以看到，最大回撤總共持續了 198 天，下跌了 19.71%，損失了 1976.46 美元。這可以提供我們在設計停損時的一些依據。</p>
<p>而 TimeReturn 則是計算收益的工具，回傳的結果是一個排序好的 Dict，所以我們把它依序列印出來，結果如下：</p>
<pre><code class="language-python">2011-01-31 00:00:00 0.0
2011-02-28 00:00:00 0.0
2011-03-31 00:00:00 0.0
2011-04-30 00:00:00 -0.010273999999999783
2011-05-31 00:00:00 -0.024536083724182478
2011-06-30 00:00:00 0.027335665943681864
2011-07-31 00:00:00 0.05368343259399522
2011-08-31 00:00:00 -0.08904885568349952
2011-09-30 00:00:00 -0.042906886971318725
2011-10-31 00:00:00 -0.023389784748569564
2011-11-30 00:00:00 0.0
2011-12-31 00:00:00 -0.0018429968927521356
2012-01-31 00:00:00 0.13663358533688363
2012-02-29 00:00:00 0.0816284079934626
2012-03-31 00:00:00 0.016520373448353
2012-04-30 00:00:00 -0.03730546609310592
2012-05-31 00:00:00 -0.03724447064658454
2012-06-30 00:00:00 -0.011841779134246666
2012-07-31 00:00:00 -0.032471926911606275
2012-08-31 00:00:00 0.017043167076716603
2012-09-30 00:00:00 -0.034276837694325546
2012-10-31 00:00:00 -0.0023662293731249173
2012-11-30 00:00:00 0.0
2012-12-31 00:00:00 -0.03251581227796396 
</code></pre>
<p>由此我們可以分析每個月的報酬狀況。</p>
<p>除了這些工具之外，Backtrader 其實還有提供很多其他的分析工具，因為分析工具眾多，這裡就不一一介紹，有興趣的朋友可以去 Backtrader 的網頁上看看：
https://www.backtrader.com/docu/analyzers-reference/</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="多股組合操作"><a class="header" href="#多股組合操作">多股組合操作</a></h2>
<p>多股組合操作，是一種高級的操作模式。多股組合操作通常有兩種模式，<strong>一種是定期調倉</strong>，即定期再平衡，比如每週1調倉，或每月1號調倉等。<strong>另一種是非定期調倉</strong>，比如每日判斷，進行調倉，或者每隔n天進行調倉。</p>
<p>定期調倉（再平衡）通常通過定時器timer來進入調倉邏輯，而非定期調倉通常通過傳統的策略next方法進入調倉邏輯。當然，這並非絕對。</p>
<p>這兩種多股調倉操作，都不能用backtrader內建的自動確定最小期的方法來做（比如為了求20日均線，自動跳過前20個bar），因為有些股票有交易的日期很靠後，它的最小期很大，其他股票也會採用這個最小期，這會導致其他股票浪費最小期前的資料，因此，必須自己控制最小期，也就是prenext方法裡必須寫上self.next()直接跳轉到next。然後如果用到了比如5日均線這樣的指標，你要自己判斷資料對象線長度是否夠長。</p>
<p>儘管網上有一個用backtrader執行多股組合回測的案例，但並未很好地處理好多股回測中的一些問題。本文將給出完善的處理方案。</p>
<p><strong>(基於next的非定期再平衡的策略實現請參考我們編寫的<a href="https://zhuanlan.zhihu.com/p/560885290">教學和視訊課程</a>)</strong></p>
<p><strong>本文介紹基於定時器timer的多股定期再平衡策略的實現.</strong></p>
<p>本案例的目的是介紹使用backtrader進行組合管理時，要注意的一些技術要點，策略本身僅供參考。策略的大致邏輯如下：每年5月1日，9月1日，11月1日進行組合再平衡操作（若該日休市，則順延到開市日進行再平衡操作）。</p>
<p>首先載入一組股票（股票池），在再平衡日，從股票池挑出至少上市3年，且淨資產收益率roe&gt;0.1,市盈率 pe在0到100間的股票，這組選出的股票再按成交量從大到小排序，選出前100隻股票（如果選出的股票少於100隻，則按實際來），將全部帳戶價值按等比例分配買入這些股票。</p>
<p>該策略反應瞭如下幾個技術要點，把這些要點整明白，基本上就可用於實戰了，程式碼更詳細的解讀特別是定時器timer的用法參考我們編寫的<a href="https://zhuanlan.zhihu.com/p/273377912">教學和視訊課程</a>：</p>
<p>1 擴展PandasData類</p>
<p>2 第一個資料應該對應指數，作為時間基準</p>
<p>3 資料預處理：刪除原始資料中無交易的及缺指標的記錄</p>
<p>4 先平倉再執行後續買賣</p>
<p>5 下單量的計算方法</p>
<p>6 如何保證先賣後買以空出資金</p>
<p>7 怎樣按明日開盤價計算下單數量</p>
<p>8 為行情資料對象提供名字</p>
<p>9 買賣數量如何設為100的整數倍</p>
<p>10 設定符合中國股市的佣金模式，考慮印花稅</p>
<p>11 漲跌停板的處理</p>
<pre><code class="language-python"># 考慮中國佣金，下單量100的整數倍,漲跌停板，滑點
# 考慮一個技術指標，展示怎樣處理最小期問題

from datetime import datetime, time
from datetime import timedelta
import pandas as pd
import numpy as np
import backtrader as bt
import os.path  # 管理路徑
import sys  # 發現指令碼名字(in argv[0])
import glob
from backtrader.feeds import PandasData  # 用於擴展DataFeed

# 建立新的data feed類


class PandasDataExtend(PandasData):
    # 增加線
    lines = (&quot;pe&quot;, &quot;roe&quot;, &quot;marketdays&quot;)
    params = (
        (&quot;pe&quot;, 15),
        (&quot;roe&quot;, 16),
        (&quot;marketdays&quot;, 17),
    )  # 上市天數


class stampDutyCommissionScheme(bt.CommInfoBase):
    &quot;&quot;&quot;
    本佣金模式下，買入股票僅支付佣金，賣出股票支付佣金和印花稅.    
    &quot;&quot;&quot;

    params = (
        (&quot;stamp_duty&quot;, 0.005),  # 印花稅率
        (&quot;commission&quot;, 0.001),  # 佣金率
        (&quot;stocklike&quot;, True),
        (&quot;commtype&quot;, bt.CommInfoBase.COMM_PERC),
    )

    def _getcommission(self, size, price, pseudoexec):
        &quot;&quot;&quot;
        If size is greater than 0, this indicates a long / buying of shares.
        If size is less than 0, it idicates a short / selling of shares.
        &quot;&quot;&quot;

        if size &gt; 0:  # 買入，不考慮印花稅
            return size * price * self.p.commission
        elif size &lt; 0:  # 賣出，考慮印花稅
            return -size * price * (self.p.stamp_duty + self.p.commission)
        else:
            return 0  # just in case for some reason the size is 0.


class Strategy(bt.Strategy):
    params = dict(
        rebal_monthday=[1], num_volume=100, period=5,  # 每月1日執行再平衡  # 成交量取前100名
    )

    # 日誌函數
    def log(self, txt, dt=None):
        # 以第一個資料data0，即指數作為時間基準
        dt = dt or self.data0.datetime.date(0)
        print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    def __init__(self):

        self.lastRanks = []  # 上次交易股票的列表
        # 0號是指數，不進入選股池，從1號往後進入股票池
        self.stocks = self.datas[1:]
        # 記錄以往訂單，在再平衡日要全部取消未成交的訂單
        self.order_list = []

        # 移動平均線指標
        self.sma = {d: bt.ind.SMA(d, period=self.p.period) for d in self.stocks}

        # 定時器
        self.add_timer(
            when=bt.Timer.SESSION_START,
            monthdays=self.p.rebal_monthday,  # 每月1號觸發再平衡
            monthcarry=True,  # 若再平衡日不是交易日，則順延觸發notify_timer
        )

    def notify_timer(self, timer, when, *args, **kwargs):

        # 只在5，9，11月的1號執行再平衡
        if self.data0.datetime.date(0).month in [5, 9, 11]:
            self.rebalance_portfolio()  # 執行再平衡

    # def next(self):

    #     print('next 帳戶總值', self.data0.datetime.datetime(0), self.broker.getvalue())
    #     for d in self.stocks:
    #         if(self.getposition(d).size!=0):
    #             print(d._name, '持倉' ,self.getposition(d).size)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 訂單狀態 submitted/accepted，無動作
            return

        # 訂單完成
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;買單執行,%s, %.2f, %i&quot;
                    % (order.data._name, order.executed.price, order.executed.size)
                )

            elif order.issell():
                self.log(
                    &quot;賣單執行, %s, %.2f, %i&quot;
                    % (order.data._name, order.executed.price, order.executed.size)
                )

        else:
            self.log(
                &quot;訂單作廢 %s, %s, isbuy=%i, size %i, open price %.2f&quot;
                % (
                    order.data._name,
                    order.getstatusname(),
                    order.isbuy(),
                    order.created.size,
                    order.data.open[0],
                )
            )

    # 記錄交易收益情況
    def notify_trade(self, trade):
        if trade.isclosed:
            print(
                &quot;毛收益 %0.2f, 扣傭後收益 % 0.2f, 佣金 %.2f, 市值 %.2f, 現金 %.2f&quot;
                % (
                    trade.pnl,
                    trade.pnlcomm,
                    trade.commission,
                    self.broker.getvalue(),
                    self.broker.getcash(),
                )
            )

    def rebalance_portfolio(self):
        # 從指數取得當前日期
        self.currDate = self.data0.datetime.date(0)
        print(&quot;rebalance_portfolio currDate&quot;, self.currDate, len(self.stocks))

        # 如果是指數的最後一本bar，則退出，防止取下一日開盤價越界錯
        if len(self.datas[0]) == self.data0.buflen():
            return

        # 取消以往所下訂單（已成交的不會起作用）
        for o in self.order_list:
            self.cancel(o)
        self.order_list = []  # 重設訂單列表

        # for d in self.stocks:
        #     print('sma', d._name, self.sma[d][0],self.sma[d][1], d.marketdays[0])

        # 最終標的選取過程
        # 1 先做排除篩選過程
        self.ranks = [
            d
            for d in self.stocks
            if len(d) &gt; 0 and d.marketdays &gt; 3 * 365  # 重要，到今日至少要有一根實際bar  # 到今天至少上市
            # 今日未停牌 (若去掉此句，則今日停牌的也可能進入，並下訂單，次日若復牌，則次日可能成交）（假設原始資料中已刪除無交易的記錄)
            and d.datetime.date(0) == self.currDate
            and d.roe &gt;= 0.1
            and d.pe &lt; 100
            and d.pe &gt; 0
            and len(d) &gt;= self.p.period  # 最小期，至少需要5根bar
            and d.close[0] &gt; self.sma[d][1]
        ]

        # 2 再做排序挑選過程
        self.ranks.sort(key=lambda d: d.volume, reverse=True)  # 按成交量從大到小排序
        self.ranks = self.ranks[0 : self.p.num_volume]  # 取前num_volume名

        if len(self.ranks) == 0:  # 無股票選中，則返回
            return

        # 3 以往買入的標的，本次不在標的中，則先平倉
        data_toclose = set(self.lastRanks) - set(self.ranks)
        for d in data_toclose:
            print(&quot;sell 平倉&quot;, d._name, self.getposition(d).size)
            o = self.close(data=d)
            self.order_list.append(o)  # 記錄訂單

        # 4 本次標的下單
        # 每隻股票買入資金百分比，預留2%的資金以應付佣金和計算誤差
        buypercentage = (1 - 0.02) / len(self.ranks)

        # 得到目標市值
        targetvalue = buypercentage * self.broker.getvalue()
        # 為保證先賣後買，股票要按持倉市值從大到小排序
        self.ranks.sort(key=lambda d: self.broker.getvalue([d]), reverse=True)
        self.log(
            &quot;下單, 標的個數 %i, targetvalue %.2f, 當前總市值 %.2f&quot;
            % (len(self.ranks), targetvalue, self.broker.getvalue())
        )

        for d in self.ranks:
            # 按次日開盤價計算下單量，下單量是100的整數倍
            size = int(
                abs((self.broker.getvalue([d]) - targetvalue) / d.open[1] // 100 * 100)
            )
            validday = d.datetime.datetime(1)  # 該股下一實際交易日
            if self.broker.getvalue([d]) &gt; targetvalue:  # 持倉過多，要賣
                # 次日跌停價近似值
                lowerprice = d.close[0] * 0.9 + 0.02

                o = self.sell(
                    data=d,
                    size=size,
                    exectype=bt.Order.Limit,
                    price=lowerprice,
                    valid=validday,
                )
            else:  # 持倉過少，要買
                # 次日漲停價近似值
                upperprice = d.close[0] * 1.1 - 0.02
                o = self.buy(
                    data=d,
                    size=size,
                    exectype=bt.Order.Limit,
                    price=upperprice,
                    valid=validday,
                )

            self.order_list.append(o)  # 記錄訂單

        self.lastRanks = self.ranks  # 跟蹤上次買入的標的


##########################
# 主程序開始
#########################
cerebro = bt.Cerebro(stdstats=False)
cerebro.addobserver(bt.observers.Broker)
cerebro.addobserver(bt.observers.Trades)
# cerebro.broker.set_coc(True)  # 以訂單建立日的收盤價成交
# cerebro.broker.set_coo(True) # 以次日開盤價成交


datadir = &quot;./dataswind&quot;  # 資料檔案位於本指令碼所在目錄的data子目錄中
datafilelist = glob.glob(os.path.join(datadir, &quot;*&quot;))  # 資料檔案路徑列表

maxstocknum = 20  # 股票池最大股票數目
# 注意，排序第一個檔案必須是指數資料，作為時間基準
datafilelist = datafilelist[0:maxstocknum]  # 擷取指定數量的股票池
print(datafilelist)
# 將目錄datadir中的資料檔案載入進系統


for fname in datafilelist:

    df = pd.read_csv(fname, skiprows=0, header=0,)  # 不忽略行  # 列頭在0行
    # df = df[~df['交易狀態'].isin(['停牌一天'])]  # 去掉停牌日記錄
    df[&quot;date&quot;] = pd.to_datetime(df[&quot;date&quot;])  # 轉成日期類型
    df = df.dropna()

    # print(df.info())
    # print(df.head())

    data = PandasDataExtend(
        dataname=df,
        datetime=0,  # 日期列
        open=2,  # 開盤價所在列
        high=3,  # 最高價所在列
        low=4,  # 最低價所在列
        close=5,  # 收盤價價所在列
        volume=6,  # 成交量所在列
        pe=7,
        roe=8,
        marketdays=9,
        openinterest=-1,  # 無未平倉量列
        fromdate=datetime(2002, 4, 1),  # 起始日2002, 4, 1
        todate=datetime(2015, 12, 31),  # 結束日 2015, 12, 31
        plot=False,
    )
    ticker = fname[-13:-4]  # 從檔案路徑名取得股票程式碼

    cerebro.adddata(data, name=ticker)


cerebro.addstrategy(Strategy)
startcash = 10000000
cerebro.broker.setcash(startcash)
# 防止下單時現金不夠被拒絕。只在執行時檢查現金夠不夠。
cerebro.broker.set_checksubmit(False)
comminfo = stampDutyCommissionScheme(stamp_duty=0.001, commission=0.001)
cerebro.broker.addcommissioninfo(comminfo)
results = cerebro.run()
print(&quot;最終市值: %.2f&quot; % cerebro.broker.getvalue())
# cerebro.plot()
</code></pre>
<p>以上這個策略，其實也可以通過next方法進入策略邏輯，具體程式碼和詳情請參考我們的教學：</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="均線交叉策略"><a class="header" href="#均線交叉策略">均線交叉策略</a></h2>
<p>出處：https://ithelp.ithome.com.tw/articles/10242427</p>
<p>前面幾個策略的回測方式，是自己刻一個回測函數，其實是挺麻煩的，還好因為做量化的大家都有回測的需求，所以早就有人開發回測框架拉，就跟網頁開發使用的前端框架或後端框架類似，已經把常用到的功能都寫成模組囉，非常好用。</p>
<p>以Python為基礎的回測框架，包含vnpy、zipline、backtrader...等等，這次先來介紹一下backtrader，因為它用起來蠻直覺的，一些函數也都蠻口語化的，都是很容易懂的英文命名。</p>
<h3 id="backtrader做回測會用到的元素"><a class="header" href="#backtrader做回測會用到的元素">Backtrader做回測會用到的元素</a></h3>
<p>就跟一般做回測，通常會需要：OHLC資料、交易策略、回測模組、分析工具。下面就用前一篇寫的均線交叉策略來說明，怎麼使用backtrader做回測：</p>
<h4 id="1-餵資料data-feeds"><a class="header" href="#1-餵資料data-feeds">1. 餵資料(Data Feeds)</a></h4>
<p>關於data feeds的用法，官網的document有列出蠻多種取得資料的方式，這邊就先用常用的Yahoo Finance的資料。</p>
<pre><code class="language-python"># data feeds
import math
import yfinance as yf
import datetime
import backtrader as bt
import backtrader.feeds as btfeeds


# 從Yahoo Finance取得資料
data = bt.feeds.PandasData(
    dataname=yf.download(&quot;SPY&quot;, &quot;2015-07-06&quot;, &quot;2023-01-01&quot;, auto_adjust=True)
)
</code></pre>
<h4 id="2-撰寫策略"><a class="header" href="#2-撰寫策略">2. 撰寫策略</a></h4>
<pre><code class="language-python"># sma cross strategy
class SmaCross(bt.Strategy):
    # 交易紀錄
    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))
    
    # 設定交易參數
    params = dict(
        ma_period_short=5,
        ma_period_long=10
    )

    def __init__(self):
        # 均線交叉策略
        sma1 = bt.ind.SMA(period=self.p.ma_period_short)
        sma2 = bt.ind.SMA(period=self.p.ma_period_long)
        self.crossover = bt.ind.CrossOver(sma1, sma2)
        
        # 使用自訂的sizer函數，將帳上的錢all-in
        self.setsizer(sizer())
        
        # 用開盤價做交易
        self.dataopen = self.datas[0].open

    def next(self):
        # 帳戶沒有部位
        if not self.position:
            # 5ma往上穿越20ma
            if self.crossover &gt; 0:
                # 印出買賣日期與價位
                self.log('BUY ' + ', Price: ' + str(self.dataopen[0]))
                # 使用開盤價買入標的
                self.buy(price=self.dataopen[0])
        # 5ma往下穿越20ma
        elif self.crossover &lt; 0:
            # 印出買賣日期與價位
            self.log('SELL ' + ', Price: ' + str(self.dataopen[0]))
            # 使用開盤價賣出標的
            self.close(price=self.dataopen[0])

# 計算交易部位
class sizer(bt.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash/data[1])
        else:
            return self.broker.getposition(data)
</code></pre>
<h4 id="3-執行回測-and-顯示分析圖表"><a class="header" href="#3-執行回測-and-顯示分析圖表">3. 執行回測 and 顯示分析圖表</a></h4>
<p>cerebro是backtrader回測模組的名稱，將資料、策略丟給cerebro之後，就可以執行回測並作圖了。</p>
<pre><code class="language-python"># 初始化cerebro
cerebro = bt.Cerebro()
# feed data
cerebro.adddata(data)
# add strategy
cerebro.addstrategy(SmaCross)
# run backtest
cerebro.run()
# plot diagram
cerebro.plot()
</code></pre>
<pre><code class="language-python"># data feeds
import math
import yfinance as yf
import datetime
import backtrader as bt
import backtrader.feeds as btfeeds


# sma cross strategy
class SmaCross(bt.Strategy):
    # 交易紀錄
    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    # 設定交易參數
    params = dict(ma_period_short=5, ma_period_long=10)

    def __init__(self):
        # 均線交叉策略
        sma1 = bt.ind.SMA(period=self.p.ma_period_short)
        sma2 = bt.ind.SMA(period=self.p.ma_period_long)
        self.crossover = bt.ind.CrossOver(sma1, sma2)

        # 使用自訂的sizer函數，將帳上的錢all-in
        self.setsizer(sizer())

        # 用開盤價做交易
        self.dataopen = self.datas[0].open

    def next(self):
        # 帳戶沒有部位
        if not self.position:
            # 5ma往上穿越20ma
            if self.crossover &gt; 0:
                # 印出買賣日期與價位
                self.log(&quot;BUY &quot; + &quot;, Price: &quot; + str(self.dataopen[0]))
                # 使用開盤價買入標的
                self.buy(price=self.dataopen[0])
        # 5ma往下穿越20ma
        elif self.crossover &lt; 0:
            # 印出買賣日期與價位
            self.log(&quot;SELL &quot; + &quot;, Price: &quot; + str(self.dataopen[0]))
            # 使用開盤價賣出標的
            self.close(price=self.dataopen[0])


# 計算交易部位
class sizer(bt.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash / data[1])
        else:
            return self.broker.getposition(data)


# 從Yahoo Finance取得資料
data = bt.feeds.PandasData(
    dataname=yf.download(&quot;SPY&quot;, &quot;2015-07-06&quot;, &quot;2023-01-01&quot;, auto_adjust=True)
)


## 執行回測 and 顯示分析圖表

# 初始化cerebro
cerebro = bt.Cerebro()
# feed data
cerebro.adddata(data)
# add strategy
cerebro.addstrategy(SmaCross)
# run backtest
cerebro.run()
# plot diagram
cerebro.plot()
</code></pre>
<p>執行程式後，會顯示下面的資料及圖表：</p>
<ul>
<li>分析圖表
如下圖，預設的起始資金是10000元，期末資產淨值是11238，所以報酬率大概是12.38%，這張圖有四個區塊可以解釋一下，分別從上到下說明：</li>
</ul>
<p><img src="strategy/backtrader/../images/9rtWHCZ.png" alt="img" /></p>
<ol>
<li>第1區塊：藍色代表資產淨值，紅色代表帳戶現金，所以當紅色線突然掉下去的時候，就代表買入股票，上升就代表賣出股票。</li>
<li>第2區塊：代表每次賣出的獲利情況，藍色點點表示賺錢，紅色點點表示虧錢。</li>
<li>第3區塊：顯示長短均線、買賣點、股價走勢、交易量，從這張圖可以大概看出來買賣的時間點與走勢的相對關係。</li>
<li>第4區塊：cross over訊號出現的點，可以仔細看到，第一個訊號是賣出訊號(線圖向下凸)，但是因為帳上沒有部位，所以沒有賣出動作。</li>
</ol>
<p><strong>本篇總結</strong>
這篇就大概寫了一下backtrader怎麼使用，當然它的功能是非常強大的，還有許多功能是我沒接觸過的，大家都可以google或看document去把玩把玩，蠻有趣的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="唐奇安通道策略"><a class="header" href="#唐奇安通道策略">唐奇安通道策略</a></h2>
<h2 id="通道策略"><a class="header" href="#通道策略">通道策略</a></h2>
<p>要講通道策略，直接看圖最快，下面是維基百科裡面的圖：
<img src="https://i.imgur.com/hR3RTEI.png" alt="img" /></p>
<p>從上圖可以看到，白色的線是股價走勢，上下有兩條黃色的線包覆中間的白色線，包圍的區間看起來就像是一個通道，所以叫做通道策略，上下兩條黃線則是稱為上下軌。</p>
<p>計算這兩條黃色線的方式有很多不同的方式，本篇介紹其中一種叫做唐奇安通道(Donchian Channel)，唐奇安通道的上下軌計算方式為，上軌為過去一段時間內的最高價，下軌為過去一段時間內的最低價。</p>
<p>若股價超過上軌，可能表示多頭較強勢，所以產生買進訊號，若股價低於下軌，可能表示空頭較強勢，所以產生賣出訊號。至於這過去一段時間要採用多長的時間，會跟商品性質或是交易頻率比較有相關。</p>
<h2 id="開始寫策略吧"><a class="header" href="#開始寫策略吧">開始寫策略吧</a></h2>
<p>寫唐奇安通道策略大概需要三個步驟：</p>
<ul>
<li>計算通道上下軌</li>
<li>撰寫交易策略</li>
<li>執行回測</li>
</ul>
<h3 id="計算通道上下軌"><a class="header" href="#計算通道上下軌">計算通道上下軌</a></h3>
<p>因為上下軌是用來買進賣出的指標，因此可以使用backtrader的<a href="https://www.backtrader.com/docu/induse/">Indicators</a>，官網文件有非常詳細的介紹。下面程式碼是官網的範例，由於實在蠻複雜的，就一行一行來解釋：</p>
<pre><code class="language-python">from datetime import datetime
import yfinance as yf
import backtrader as bt


# 定義一個Indicator物件
class DonchianChannels(bt.Indicator):
    # 這個物件的別名，所以後面我們可以用DCH/DonchianChannel來呼叫這個指標
    alias = ('DCH', 'DonchianChannel',)
    
    # 三條線分別代表唐奇安通道中的 中軌(上軌加下軌再除以2)、上軌、下軌
    lines = ('dcm', 'dch', 'dcl',)  # dc middle, dc high, dc low
    
    # 軌道的計算方式：用過去20天的資料來計算，所以period是20，lookback的意思是要不要將今天的資料納入計算，由於唐奇安通道是取過去20天的最高或最低，所以一定不能涵蓋今天，不然永遠不會有訊號出現，所以要填-1(從前一天開始算20天)
    params = dict(
        period=20,
        lookback=-1,  # consider current bar or not
    )
    
    # 是否要將Indicators另外畫一張圖，然而通道線通常都是跟股價圖畫在同一張，才能看得出相對關係，所以這裡就填subplot=False
    plotinfo = dict(subplot=False)  # plot along with data
    
    # 繪圖設定，ls是line style，'--'代表虛線
    plotlines = dict(
        dcm=dict(ls='--'),  # dashed line
        dch=dict(_samecolor=True),  # use same color as prev line (dcm)
        dcl=dict(_samecolor=True),  # use same color as prev line (dch)
    )
    
    def __init__(self):
        # hi與lo是指每日股價的最高與最低價格
        hi, lo = self.data.high, self.data.low
        
        # 視需求決定是否要從前一天開始讀資料，上面已經定義lookback存在，所以這邊會直接從前一天的資料開始跑
        if self.p.lookback:  # move backwards as needed
            hi, lo = hi(self.p.lookback), lo(self.p.lookback)
        
        # 定義三條線的計算方式
        self.l.dch = bt.ind.Highest(hi, period=self.p.period)
        self.l.dcl = bt.ind.Lowest(lo, period=self.p.period)
        self.l.dcm = (self.l.dch + self.l.dcl) / 2.0  # avg of the above
</code></pre>
<h3 id="撰寫交易策略"><a class="header" href="#撰寫交易策略">撰寫交易策略</a></h3>
<p>寫策略的部份就相對簡單很多，第一步把指標帶入，再來就產出訊號拉。</p>
<pre><code class="language-python"># 撰寫交易策略
class MyStrategy(bt.Strategy):
    def __init__(self):
        # DCH就是上面定義的 DonchianChannels的alias
        self.myind = DCH()

    def next(self):
        if self.data[0] &gt; self.myind.dch[0]:
            self.buy()
        elif self.data[0] &lt; self.myind.dcl[0]:
            self.sell()
</code></pre>
<h3 id="執行回測"><a class="header" href="#執行回測">執行回測</a></h3>
<pre><code class="language-python">cerebro = bt.Cerebro()
cerebro.addstrategy(MyStrategy)
cerebro.broker.setcash(1000)
cerebro.broker.setcommission(commission=0.001)

data = bt.feeds.PandasData(
    dataname=yf.download(&quot;AAPL&quot;, &quot;2019-01-01&quot;, &quot;2019-12-31&quot;, auto_adjust=True)
)

cerebro.adddata(data)
print('Starting Value: %.2f' % cerebro.broker.getvalue())
cerebro.run()
print('Ending Value: %.2f' % cerebro.broker.getvalue())
cerebro.plot()
</code></pre>
<pre><code class="language-python">from datetime import datetime
import yfinance as yf
import backtrader as bt

# 定義一個Indicator物件
class DonchianChannels(bt.Indicator):
    # 這個物件的別名，所以後面我們可以用DCH/DonchianChannel來呼叫這個指標
    alias = (
        &quot;DCH&quot;,
        &quot;DonchianChannel&quot;,
    )

    # 三條線分別代表唐奇安通道中的 中軌(上軌加下軌再除以2)、上軌、下軌
    lines = (
        &quot;dcm&quot;,
        &quot;dch&quot;,
        &quot;dcl&quot;,
    )  # dc middle, dc high, dc low

    # 軌道的計算方式：用過去20天的資料來計算，所以period是20，lookback的意思是要不要將今天的資料納入計算，由於唐奇安通道是取過去20天的最高或最低，所以一定不能涵蓋今天，不然永遠不會有訊號出現，所以要填-1(從前一天開始算20天)
    params = dict(period=20, lookback=-1,)  # consider current bar or not

    # 是否要將Indicators另外畫一張圖，然而通道線通常都是跟股價圖畫在同一張，才能看得出相對關係，所以這裡就填subplot=False
    plotinfo = dict(subplot=False)  # plot along with data

    # 繪圖設定，ls是line style，'--'代表虛線
    plotlines = dict(
        dcm=dict(ls=&quot;--&quot;),  # dashed line
        dch=dict(_samecolor=True),  # use same color as prev line (dcm)
        dcl=dict(_samecolor=True),  # use same color as prev line (dch)
    )

    def __init__(self):
        # hi與lo是指每日股價的最高與最低價格
        hi, lo = self.data.high, self.data.low

        # 視需求決定是否要從前一天開始讀資料，上面已經定義lookback存在，所以這邊會直接從前一天的資料開始跑
        if self.p.lookback:  # move backwards as needed
            hi, lo = hi(self.p.lookback), lo(self.p.lookback)

        # 定義三條線的計算方式
        self.l.dch = bt.ind.Highest(hi, period=self.p.period)
        self.l.dcl = bt.ind.Lowest(lo, period=self.p.period)
        self.l.dcm = (self.l.dch + self.l.dcl) / 2.0  # avg of the above


# 撰寫交易策略
class MyStrategy(bt.Strategy):
    def __init__(self):
        # DCH就是上面定義的 DonchianChannels的alias
        self.myind = DCH()

    def next(self):
        if self.data[0] &gt; self.myind.dch[0]:
            self.buy()
        elif self.data[0] &lt; self.myind.dcl[0]:
            self.sell()


# 執行回測
cerebro = bt.Cerebro()
cerebro.addstrategy(MyStrategy)
cerebro.broker.setcash(1000)
cerebro.broker.setcommission(commission=0.001)

data = bt.feeds.PandasData(
    dataname=yf.download(&quot;AAPL&quot;, &quot;2019-01-01&quot;, &quot;2019-12-31&quot;, auto_adjust=True)
)

cerebro.adddata(data)
print(&quot;Starting Value: %.2f&quot; % cerebro.broker.getvalue())
cerebro.run()
print(&quot;Ending Value: %.2f&quot; % cerebro.broker.getvalue())
cerebro.plot()

</code></pre>
<p>回測2019年的結果(過去績效僅供參考，不保證未來能夠持續獲利)：
Starting Value: 1000.00
Ending Value: 1400.97
<img src="strategy/backtrader/../images/PiBgdeg.png" alt="img" /></p>
<p>從上圖可以看得出來，因為2019年AAPL股價一直上漲的關係，很容易突破前20日的高點，導致綠色的三角形比紅色三角形多。</p>
<p><strong>本篇總結</strong>
這篇就簡單的寫了一下用Backtrader回測唐奇安通道策略，又對這個框架多瞭解一些，覺得bt的功能真的超多，好用好用！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sizers模組"><a class="header" href="#sizers模組">Sizers模組</a></h2>
<p>出處：https://ithelp.ithome.com.tw/articles/10243685</p>
<h3 id="前言-5"><a class="header" href="#前言-5">前言</a></h3>
<p>前面在使用backtrader的時候，沒有特別針對交易部位的計算作介紹。主要是因為想先簡化實作過程，快速寫完幾個簡單的策略。這篇就要來深入研究，當交易訊號產生的時候，怎麼樣使用backtrader的Sizers模組，撰寫我們要買賣多少部位，不管是all-in、每次買進固定股數...等等，都可以化成一行一行的程式碼，真的是非常神奇呢！</p>
<h3 id="首先看看document"><a class="header" href="#首先看看document">首先，看看document</a></h3>
<p>之前看過很多人寫的Sizers範例，用法真的是千變萬化，所以我覺得要理解他到底有哪些用法，最快速的方式就是去看<a href="https://www.backtrader.com/docu/sizers/sizers/">document</a>。</p>
<h4 id="回顧一下-day10---backtrader回測框架實作一均線交叉策略"><a class="header" href="#回顧一下-day10---backtrader回測框架實作一均線交叉策略">回顧一下 Day10 - backtrader回測框架實作(一)均線交叉策略</a></h4>
<pre><code class="language-python">def next(self):
        # 帳戶沒有部位
        if not self.position:
            # 5ma往上穿越20ma
            if self.crossover &gt; 0:
                # 印出買賣日期與價位
                self.log('BUY ' + ', Price: ' + str(self.dataopen[0]))
                # 使用開盤價買入標的
                self.buy(price=self.dataopen[0])
        # 5ma往下穿越20ma
        elif self.crossover &lt; 0:
            # 印出買賣日期與價位
            self.log('SELL ' + ', Price: ' + str(self.dataopen[0]))
            # 使用開盤價賣出標的
            self.close(price=self.dataopen[0])
</code></pre>
<p>上面這段程式碼中，self.buy的參數只有指定price，其他都是使用預設參數，那麼預設的交易量是多少呢？得要看一下說明書：</p>
<pre><code class="language-python">class SizerFix(SizerBase):
    params = (('stake', 1),)
</code></pre>
<p>上面表示：如果buy跟sell沒有指定size是多少，那就會是1單位。但是我們通常不會只有買賣1單位，所以就需要寫sizer。</p>
<h3 id="如何使用sizer"><a class="header" href="#如何使用sizer">如何使用Sizer</a></h3>
<p>這邊就介紹兩個Sizer用法，一種是寫在回測函數內，另一個則是寫在策略函數內：</p>
<ul>
<li><strong>寫在回測函數(cerebro)內</strong></li>
</ul>
<pre><code class="language-python">cerebro = bt.Cerebro()
cerebro.addsizer(bt.sizers.SizerFix, stake=20)
</code></pre>
<p>這邊addsizer裡面就是指定買賣的size是固定的，每次交易都是20單位</p>
<ul>
<li><strong>寫在策略函數內</strong></li>
</ul>
<blockquote>
<p>The Strategy class offers an API: setsizer and getsizer (and a property sizer) to manage the Sizer</p>
</blockquote>
<p>上面這句話表示可以在Strategy裡面，用setsizer或getsizer來管理交易量，下面就以之前寫的sma cross解釋setsizer的方式：</p>
<pre><code class="language-python"># sma cross strategy
class SmaCross(bt.Strategy):
    ...

    def __init__(self):
        # 均線交叉策略
        sma1 = bt.ind.SMA(period=self.p.ma_period_short)
        sma2 = bt.ind.SMA(period=self.p.ma_period_long)
        self.crossover = bt.ind.CrossOver(sma1, sma2)
        
        # 使用自訂的sizer函數，將帳上的錢all-in
        self.setsizer(sizer())
        
    ...
</code></pre>
<p>方法相當簡單，就是在init裡面寫setsizer，再定義一個sizer class就完成了。詳細的文件可以看官網的Size Development的部份，這邊就先用all-in法做解說，所謂all-in就是帳上有多少錢就買多少：</p>
<pre><code class="language-python"># 計算交易部位
class sizer(bt.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            return math.floor(cash/data.open)
        else:
            return self.broker.getposition(data)
</code></pre>
<blockquote>
<p>Override the method _getsizing(self, comminfo, cash, data, isbuy)
意思就是可以用自己定義的交易量去覆蓋掉原本的method，而上面寫的cash / data.open，就是指用開盤價來計算帳上的cash可以買多少的量，再四捨五入後就是真正交易的量了。</p>
</blockquote>
<p><strong>本篇總結</strong>
那麼以上就是sizers的介紹，有了sizer，就可以寫各式各樣的交易量配置，資金運用會再更靈活一些，下一篇將介紹Observers，就是回測成果的觀測工具，請繼續收看囉！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="observers模組"><a class="header" href="#observers模組">Observers模組</a></h2>
<p>還記得在Day10均線交叉策略看到的這張圖嗎？從上到下分成4個區塊(Cash and Value/Trade/BuySell/CrossOver)，之前有分別講一下這4個區塊的功能，這篇則是說明這些區塊是怎麼呼叫出來的，以及這些區塊是否可以增加更多資訊或是刪減一些區塊。
<img src="strategy/backtrader/../images/IHr9no1.png" alt="img" /></p>
<p>先來看一下<a href="https://www.backtrader.com/docu/observers-and-statistics/observers-and-statistics/">document</a>：</p>
<blockquote>
<p>All backtrader sample charts have so far had 3 things plotted which seem to be taken for granted because they are not declared anywhere:</p>
<ul>
<li>Cash and Value (what’s happening with the money in the broker)</li>
<li>Trades (aka Operations)</li>
<li>Buy/Sell Orders</li>
</ul>
<p>They are Observers and exist within the submodule backtrader.observers. They are there because Cerebro supports a parameter to automatically add (or not) them to the Strategy:</p>
<ul>
<li><code>stdstats (default: True)</code></li>
</ul>
</blockquote>
<p>所以如果要把Cash &amp; Value/Trades/BuySell的內容刪除，只要在cerebro的部份修改成下面這行就好：</p>
<pre><code class="language-python">cerebro = bt.Cerebro(stdstats=False)
</code></pre>
<p>就會得到下面這張圖，只剩下股價走勢、長短均線、均線交叉訊號。
<img src="strategy/backtrader/../images/9AuiuJv.png" alt="img" /></p>
<p>那如果想要把Cash &amp; Value的部份也納入觀察，可以單獨增加這個區塊，只要在cerebro的部份改成：</p>
<pre><code class="language-python">import math
cerebro = bt.Cerebro(stdstats=False)
# 加上下面這一行
cerebro.addobserver(bt.observers.Broker)
cerebro.adddata(data)
cerebro.addstrategy(SmaCross)
cerebro.run()
cerebro.plot()
</code></pre>
<p>或是再加上DrawDown圖(每日損失)：</p>
<pre><code class="language-python">...
cerebro.addobserver(bt.observers.Broker)
# 加上下面這行
cerebro.addobserver(bt.observers.DrawDown)
...
</code></pre>
<p><img src="strategy/backtrader/../images/ass58Jt.png" alt="img" /></p>
<p>如果想把Drawdown的部份，用文字印出來，則可以在strategy的部份，加上兩行code：</p>
<pre><code class="language-python">class SmaCross(bt.Strategy):
    ...
    def next(self):
        ...
        # 加上下面這兩行
        self.log('DrawDown: %.2f' % self.stats.drawdown.drawdown[-1])
        self.log('MaxDrawDown: %.2f' % self.stats.drawdown.maxdrawdown[-1])
        ...
</code></pre>
<p>執行回測時就會印出每日DrawDon及MaxDrawDown，如下</p>
<pre><code>2019-01-16, DrawDown: 0.00
2019-01-16, MaxDrawDown: 0.00
2019-01-17, DrawDown: 0.00
2019-01-17, MaxDrawDown: 0.00
...
2019-03-29, DrawDown: 1.26
2019-03-29, MaxDrawDown: 1.97
2019-04-01, DrawDown: 1.26
2019-04-01, MaxDrawDown: 1.97
...
2019-12-27, DrawDown: 0.00
2019-12-27, MaxDrawDown: 4.60
2019-12-30, DrawDown: 0.00
2019-12-30, MaxDrawDown: 4.60
</code></pre>
<p>從上面幾個例子來看，backtrader可以根據個人需求去調整觀測數據的模板，算是蠻彈性的機制，因為不同策略要看的指標往往會有些不同。</p>
<p><strong>本篇總結</strong>
那這篇就先寫到這，backtrader這幾篇寫了交易策略、下單部位控制、數據觀測模板，接下來就可以來介紹python串接券商API下單，因為我自己是用IB(Interactive Brokers)交易，所以會以IB的API作為範例，請繼續收看囉。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整合pyfolio了"><a class="header" href="#整合pyfolio了">整合pyfolio了</a></h1>
<p>出處:https://codeantenna.com/a/n8rxd9EgKz</p>
<p>下面介紹如何在backtrader裡使用pyfolio。</p>
<p>1 安裝pyfolio</p>
<p>必須使用如下命令安裝pyfolio，這樣安裝的是最新版：</p>
<p>pip install git+https://github.com/quantopian/pyfolio
不能使用pip install pyfolio來安裝。很多人整合不了pyfolio，就是因為安裝方式不對。</p>
<p>2 在backtrader中使用pyfolio</p>
<p>樣本程式碼test.ipynb如下</p>
<pre><code class="language-python">from datetime import datetime
import pandas as pd
import backtrader as bt
import yfinance as yf

# 匯入pyfolio 包
import pyfolio as pf


# 建立策略類
class SmaCross(bt.Strategy):
    # 定義參數
    params = dict(period=5)  # 移動平均期數

    # 日誌函數
    def log(self, txt, dt=None):
        &quot;&quot;&quot;日誌函數&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 訂單狀態 submitted/accepted，無動作
            return
        # 訂單完成
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(&quot;買單執行, %.2f&quot; % order.executed.price)
            elif order.issell():
                self.log(&quot;賣單執行, %.2f&quot; % order.executed.price)
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;訂單 Canceled/Margin/Rejected&quot;)

    # 記錄交易收益情況（可省略，默認不輸出結果）
    def notify_trade(self, trade):
        if trade.isclosed:
            print(
                &quot;毛收益 %0.2f, 扣傭後收益 % 0.2f, 佣金 %.2f&quot;
                % (trade.pnl, trade.pnlcomm, trade.commission)
            )

    def __init__(self):
        # 移動平均線指標
        self.move_average = bt.ind.MovingAverageSimple(
            self.data, period=self.params.period
        )
        # 交叉訊號指標
        self.crossover = bt.ind.CrossOver(self.data, self.move_average)

        # sma10 = backtrader.ind.SMA(period=10)
        # sma30 = backtrader.ind.SMA(period=30)
        # crossover = backtrader.ind.CrossOver(sma10, sma30)

    def __bt_to_pandas__(self, btdata, len):
        get = lambda mydata: mydata.get(ago=0, size=len)

        fields = {
            &quot;open&quot;: get(btdata.open),
            &quot;high&quot;: get(btdata.high),
            &quot;low&quot;: get(btdata.low),
            &quot;close&quot;: get(btdata.close),
            &quot;volume&quot;: get(btdata.volume),
        }
        time = [btdata.num2date(x) for x in get(btdata.datetime)]
        return pd.DataFrame(data=fields, index=time)

    def next(self):
        data = self.__bt_to_pandas__(self.datas[1], len(self.datas[1]))
        print(data)
        if not self.position:  # 還沒有倉位
            # 當日收盤價上穿5日均線，建立買單，買入100股
            if self.crossover &gt; 0:
                self.log(&quot;建立買單&quot;)
                self.buy(size=100)
        # 有倉位，並且當日收盤價下破5日均線，建立賣單，賣出100股
        elif self.crossover &lt; 0:
            self.log(&quot;建立賣單&quot;)
            self.sell(size=100)


##########################
# 主程序開始
#########################

# 建立大腦引擎對象
cerebro = bt.Cerebro()


# 建立行情資料對象，載入資料
data = bt.feeds.PandasData(dataname=yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))
# self.datas[0] 日K數據, self.datas[1] 月K數據
data = cerebro.resampledata(data, timeframe=bt.TimeFrame.Months, compression=1)
cerebro.adddata(data)  # 將行情資料對象注入引擎

cerebro.addstrategy(SmaCross)  # 將策略注入引擎

cerebro.broker.setcash(10000.0)  # 設定初始資金

# 加入pyfolio分析者
cerebro.addanalyzer(bt.analyzers.PyFolio, _name=&quot;pyfolio&quot;)

results = cerebro.run()  # 運行
strat = results[0]
pyfoliozer = strat.analyzers.getbyname(&quot;pyfolio&quot;)
returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()
pf.create_full_tear_sheet(returns)
</code></pre>
<p>這裡pf.create_full_tear_sheet(returns)中pyfolio需要的收益率returns是日收益率。</p>
<p>如果backtrader原始資料不是日線資料，我估計returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()中，backtrader返回的returns應該是已經轉換成日收益率了，讀者可以驗證一下告訴我哈。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="backtrader-resample過程"><a class="header" href="#backtrader-resample過程">backtrader resample過程</a></h2>
<p>如何將一個小週期的data 轉換成一個大週期的data？具體如何操作，這個在BT裡面使用resample 完成的。例如days轉換成weeks?</p>
<pre><code class="language-python">data = btfeeds.BacktraderCSVData(dataname=datapath)
cerebro.adddata(data)  # First add the original data - smaller timeframe
cerebro.resampledata(data, timeframe=tframes[args.timeframe],
                     compression=args.compression)
</code></pre>
<p>會<code>自動</code>在datas裡面新增這2個data，第二個data在第一個data的基礎上，進行資料的resample.</p>
<p>這裡需要注意：</p>
<p>timeframe：壓縮的週期，只能比被壓縮的資料週期大，當前資料週期是days,那麼timeframe可以是weeks,M，year等。</p>
<p>compression：一個timeframe壓縮成多少個bar，一般是1。當前是5個days bar壓縮成一個week bar.</p>
<p>資料壓縮的過程：</p>
<p>當前的data無法進行一次性的preload，linebuffer 每次向前移動一個單位長度，即每次讀取data的一個資料，然後每次checkover一下是否集齊5根bar：</p>
<pre><code class="language-python">def _checkbarover(self, data, fromcheck=False, forcedata=None):

    chkdata = DTFaker(data, forcedata) if fromcheck else data

    isover = False
    if not self.componly and not self._barover(chkdata):
        return isover

    if self.subdays and self.p.bar2edge:
        isover = True
    elif not fromcheck:  # fromcheck doesn't increase compcount
        self.compcount += 1
        if not (self.compcount % self.p.compression):
            # boundary crossed and enough bars for compression ... proceed
            isover = True

    return isover
</code></pre>
<p>當完成一個週期的壓縮後，isover是true。</p>
<p>資料的壓縮演算法_bar 裡面的：</p>
<pre><code class="language-python">def bupdate(self, data, reopen=False):
    '''Updates a bar with the values from data

    Returns True if the update was the 1st on a bar (just opened)

    Returns False otherwise
    '''
    if reopen:
        self.bstart()

    self.datetime = data.datetime[0]

    self.high = max(self.high, data.high[0])
    self.low = min(self.low, data.low[0])
    self.close = data.close[0]

    self.volume += data.volume[0]
    self.openinterest = data.openinterest[0]

    o = self.open
    if reopen or not o == o:
        self.open = data.open[0]
        return True  # just opened the bar

    return False
</code></pre>
<p>壓縮完成的資料存放在：</p>
<pre><code class="language-python">for i, dti in enumerate(dts):
    if dti is not None:
        di = datas[i]
        rpi = False and di.replaying   # to check behavior
        if dti &gt; dt0:
            if not rpi:  # must see all ticks ...
                di.rewind()  # cannot deliver yet
            # self._plotfillers[i].append(slen)
        elif not di.replaying:
            # Replay forces tick fill, else force here
            di._tick_fill(force=True)
</code></pre>
<p>di._tick_fill：完成對一個bar的填充。</p>
<h2 id="量化交易回測框架backtrader使用optstrategy最佳化"><a class="header" href="#量化交易回測框架backtrader使用optstrategy最佳化">量化交易回測框架Backtrader使用optstrategy最佳化</a></h2>
<p>給策略增加指標後，需要給你指標設定參數，比如SMA設定幾天合適呢，每個股票的週期又都不一樣。總不能一個一個的自己嘗試。Backtrader提供了一個參數最佳化的方法，可以按照給出的範圍來運行，大家可以根據結果尋找最優的均線天數。具體可以參看Backtrader官方文件<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.backtrader.com%2Fdocu%2Fquickstart%2Fquickstart%2F">quickstart</a></p>
<ol>
<li>通過給策略一個範圍值，根據運行結果，找出某適合一隻股票的盤整週期。</li>
</ol>
<p>通過optstrategy方法，給策略設定範圍值，讓策略逐個執行，對比結果。</p>
<pre><code class="language-python">&quot;&quot;&quot;
Created on Sun Mar 29 12:18:17 2020

@author: horace pei
&quot;&quot;&quot;
#############################################################
# import
#############################################################
from __future__ import absolute_import, division, print_function, unicode_literals
import os, sys
import pandas as pd
import backtrader as bt

#############################################################
# global const values
#############################################################
#############################################################
# static function
#############################################################
#############################################################
# class
#############################################################
# Create a Stratey
class TestStrategy(bt.Strategy):
    # 自訂均線的實踐間隔，默認是5天
    params = (
        (&quot;maperiod&quot;, 5),
        (&quot;printlog&quot;, False),
    )

    def log(self, txt, dt=None, doprint=False):
        &quot;&quot;&quot; Logging function for this strategy&quot;&quot;&quot;
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close
        # To keep track of pending orders
        self.order = None
        # buy price
        self.buyprice = None
        # buy commission
        self.buycomm = None
        # 增加均線，簡單移動平均線（SMA）又稱“算術移動平均線”，是指對特定期間的收盤價進行簡單平均化
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod
        )

    # 訂單狀態改變回呼方法 be notified through notify_order(order) of any status change in an order
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return
        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            elif order.issell():
                self.log(
                    &quot;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
            self.bar_executed = len(self)
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;Order Canceled/Margin/Rejected&quot;)
        # Write down: no pending order
        self.order = None

    # 交易狀態改變回呼方法 be notified through notify_trade(trade) of any opening/updating/closing trade
    def notify_trade(self, trade):
        if not trade.isclosed:
            return
        # 每筆交易收益 毛利和淨利
        self.log(&quot;OPERATION PROFIT, GROSS %.2f, NET %.2f&quot; % (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log(&quot;Close, %.2f&quot; % self.dataclose[0])
        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return
        # Check if we are in the market(當前帳戶持股情況，size，price等等)
        if not self.position:
            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] &gt;= self.sma[0]:
                # 當收盤價，大於等於均線的價格
                # BUY, BUY, BUY!!! (with all possible default parameters)
                self.log(&quot;BUY CREATE, %.2f&quot; % self.dataclose[0])
                # Keep track of the created order to avoid a 2nd order
                self.order = self.buy()
        else:
            # Already in the market ... we might sell
            if self.dataclose[0] &lt; self.sma[0]:
                # 當收盤價，小於均線價格
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log(&quot;SELL CREATE, %.2f&quot; % self.dataclose[0])
                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

    def stop(self):
        self.log(
            &quot;(MA Period %2d) Ending Value %.2f&quot;
            % (self.params.maperiod, self.broker.getvalue()),
            doprint=True,
        )


#############################################################
# global values
#############################################################
#############################################################
# global function
#############################################################
def get_dataframe():
    # Get a pandas dataframe
    datapath = &quot;./data/stockinfo.csv&quot;
    tmpdatapath = &quot;./data/stockinfo_tmp.csv&quot;
    print(&quot;-----------------------read csv---------------------------&quot;)
    dataframe = pd.read_csv(
        datapath, skiprows=0, header=0, parse_dates=True, index_col=0
    )
    dataframe.trade_date = pd.to_datetime(dataframe.trade_date, format=&quot;%Y%m%d&quot;)
    dataframe[&quot;openinterest&quot;] = &quot;0&quot;
    feedsdf = dataframe[
        [&quot;trade_date&quot;, &quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;vol&quot;, &quot;openinterest&quot;]
    ]
    feedsdf.columns = [
        &quot;datetime&quot;,
        &quot;open&quot;,
        &quot;high&quot;,
        &quot;low&quot;,
        &quot;close&quot;,
        &quot;volume&quot;,
        &quot;openinterest&quot;,
    ]
    feedsdf.set_index(keys=&quot;datetime&quot;, inplace=True)
    feedsdf.iloc[::-1].to_csv(tmpdatapath)
    feedsdf = pd.read_csv(
        tmpdatapath, skiprows=0, header=0, parse_dates=True, index_col=0
    )
    if os.path.isfile(tmpdatapath):
        os.remove(tmpdatapath)
        print(tmpdatapath + &quot; removed!&quot;)
    return feedsdf


########################################################################
# main
########################################################################
if __name__ == &quot;__main__&quot;:
    # Create a cerebro entity(建立cerebro)
    cerebro = bt.Cerebro()
    # Add a strategy(加入自訂策略,可以設定自訂參數，方便調節)
    cerebro.optstrategy(TestStrategy, maperiod=range(3, 15))
    # Get a pandas dataframe(獲取dataframe格式股票資料)
    feedsdf = get_dataframe()
    # Pass it to the backtrader datafeed and add it to the cerebro(加入資料)
    data = bt.feeds.PandasData(dataname=feedsdf)
    cerebro.adddata(data)
    # Add a FixedSize sizer according to the stake(國內1手是100股，最小的交易單位)
    cerebro.addsizer(bt.sizers.FixedSize, stake=100)
    # Set our desired cash start(給經紀人，可以理解為交易所股票帳戶充錢)
    cerebro.broker.setcash(10000.0)
    # Set the commission - 0.1%(設定交易手續費，雙向收取)
    cerebro.broker.setcommission(commission=0.001)
    # Print out the starting conditions(輸出帳戶金額)
    print(&quot;Starting Portfolio Value: %.2f&quot; % cerebro.broker.getvalue())
    # Run over everything(執行回測)
    cerebro.run()
    # Print out the final result(輸出帳戶金額)
    print(&quot;Final Portfolio Value: %.2f&quot; % cerebro.broker.getvalue())
</code></pre>
<p>分析和說明</p>
<p>通過： cerebro.optstrategy(TestStrategy, maperiod=range(3,15))，來設定3到15天的均線，看看均線時間那個收益最好。</p>
<p><img src="strategy/backtrader/../images/16939854-19727fb596ab167f.png" alt="" /></p>
<h2 id="追高進場與加碼固定停損停利計算固定資金的數量"><a class="header" href="#追高進場與加碼固定停損停利計算固定資金的數量">追高進場與加碼，固定停損停利，計算固定資金的數量</a></h2>
<pre><code class="language-python">from __future__ import absolute_import, division, print_function, unicode_literals

from math import e
import yfinance as yf
import pyfolio
import backtrader as bt
import numpy as np
import warnings
import pandas as pd

warnings.filterwarnings(&quot;ignore&quot;)

# 計算固定資金的數量
class FixedCash(bt.Sizer):
    def __init__(self, cash=10000):
        self.cash = cash

    def _getsizing(self, comminfo, cash, data, isbuy):
        print(self.cash // data.close[0], data.close[0])
        if isbuy:
            return self.cash // data.close[0]  # 向下取整得到可買入的數量
        else:
            return self.broker.getposition(data).size  # 返回持倉數量


# 固定數量
class FixedSize(bt.Sizer):
    def __init__(self, stake=10000):
        self.stake = stake

    def _getsizing(self, comminfo, cash, data, isbuy):
        return self.stake


# 買總總金%數量
class DynamicRiskSizer(bt.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        # 查詢當前交易賬戶的總價值
        total_value = self.broker.get_value()

        # 計算每個交易的交易量
        trade_value = total_value * 0.01  # 每個交易的風險百分比為1%
        risk = (
            data.close[0] - data.close[-1] if isbuy else data.close[-1] - data.close[0]
        )
        trade_size = trade_value / abs(risk)

        return int(trade_size)


# 建立一個backtrader回測框架
class Highest_high(bt.Strategy):
    # 設置sma的參數，根據官方照此設置可進行暴力演算，得知何種參數最佳
    params = (
        (&quot;highest&quot;, 6),
        (&quot;in_amount&quot;, 4),
        (&quot;stoploss&quot;, 0.1),
        (&quot;takeprofit&quot;, 0.2),
    )

    # 這裡是log，當交易發生時呼叫log函數可以將交易print出來
    def log(self, txt, dt=None):
        &quot;&quot;&quot; Logging function fot this strategy&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        # print('%s, %s' % (dt.isoformat(), txt))

    # init定義你會用到的數據
    def __init__(self):
        # 呼叫high序列備用
        self.datahigh = self.datas[0].high
        # 呼叫close序列備用
        self.dataclose = self.datas[0].close
        # 追蹤order、buyprice跟buycomm使用，可用可不用
        self.order = None
        self.buyprice = None
        self.buycomm = None
        # 使用指標套件給的最高價判斷函數Highest
        self.the_highest_high = bt.ind.Highest(
            self.datahigh, period=self.params.highest
        )

    # notify_order當每次有訂單由next偵測出來的條件送出時，會觸發notify_order，好處是顯示出訂單執行的狀況以及偵測是否有資金不足的情況
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 當訂單為提交狀態時則不做任何事
            return

        # 當訂單完成時，若為Buy則print出買入狀況；反之亦然
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:
                self.log(
                    &quot;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )

        # 當因策略取消或是現今不足訂單被拒絕等狀況則print出訂單取消
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;Order Canceled/Margin/Rejected&quot;)

        # 完成該有的提醒之後則將oder設置回None
        self.order = None

    # notify_trade交易通知，預設如果有倉在手就不做事，如果執行賣出則print出獲利
    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log(&quot;OPERATION PROFIT, GROSS %.2f, NET %.2f&quot; % (trade.pnl, trade.pnlcomm))

    # next可以把它想像成一個內建的for loop，他把數據打包好供我們使用
    def next(self):
        # 獲取當前日期和股票的收盤價格
        date = self.datas[0].datetime.date(0).isoformat()
        close = self.datas[0].close[0]

        # 檢查有無pending的訂單
        if self.order:
            return
        # self.position.size獲得目前倉位資訊，當size&lt;指定進場次數時則允許買入
        if self.position.size &lt; self.params.in_amount * 1000:
            # 當現在的高大於前面n根的最高價時準備執行買入
            if self.datahigh &gt; self.the_highest_high[-1]:
                # 紀錄買單提交
                self.log(&quot;BUY CREATE, %.2f&quot; % self.dataclose[0])
                # 買進
                self.order = self.buy()
        # 當庫存部位不為0但表有庫存
        if self.position.size != 0:
            # 獲取庫存成本
            costs = self.position.price
            # 當收盤價大於平均成本的10%停利賣出
            if self.dataclose[0] &gt; costs + (costs * self.params.takeprofit):
                self.close()
                self.log(&quot;Take Profit, %.2f&quot; % self.dataclose[0])
            # 當收盤價小於平均成本
            elif self.dataclose[0] &lt; costs - (costs * self.params.stoploss):
                self.close()
                self.log(&quot;Stop Loss, %.2f&quot; % self.dataclose[0])
        print(
            f&quot;Date: {date}, Closing:{close}, holding of shares:{self.position.size}, total captial:{self.broker.get_value()}&quot;
        )
        input()

    # #回測終止時print出結果
    # def stop(self):
    #     print(f'Fast MA: {self.params.fast_period} | Slow MA: {self.params.slow_period} | End Value: {self.broker.getvalue()}')


if __name__ == &quot;__main__&quot;:
    # 創建框架
    cerebro = bt.Cerebro()
    # # 放入策略
    # cerebro.addstrategy(Highest_high)
    # # 放入策略
    cerebro.optstrategy(
        Highest_high,
        highest=range(5, 9),
        in_amount=range(1, 5),
        stoploss=np.arange(0.1, 0.5, 0.1),
        takeprofit=np.arange(0.1, 0.5, 0.1),
    )

    # 使用框架的資料取得函數
    data = bt.feeds.PandasData(
        dataname=yf.download(&quot;2317.TW&quot;, &quot;2014-01-01&quot;, &quot;2023-01-01&quot;)
    )
    # 將datafeed餵入框架
    cerebro.adddata(data)
    # 設置起始金額
    cerebro.broker.setcash(1000000.0)
    # 設置一次購買的股數，臺股以1000股為主
    # cerebro.addsizer(bt.sizers.SizerFix, stake=1000)

    cerebro.addsizer(FixedCash)

    # 設置傭金，稍微設置高一點作為滑價付出成本
    cerebro.broker.setcommission(commission=0.0015)

    # ===================Pyfolio===================
    # cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')

    # 在設置完傭金、起始金額以及買入股數之後，我們加入三種分析
    cerebro.addanalyzer(bt.analyzers.SharpeRatio)
    cerebro.addanalyzer(bt.analyzers.Returns)
    cerebro.addanalyzer(bt.analyzers.DrawDown)
    results = cerebro.run(maxcpus=1)
    # 準備list存放每一個參數及結果
    par1, par2, par3, par4, ret, down, sharpe_r = [], [], [], [], [], [], []
    # 迴圈每一個結果
    for strat in results:
        # 因為結果是用list包起來(範例在下註解)，所以我們要[0]取值
        # [&lt;backtrader.cerebro.OptReturn object at 0x0000024FF9717CC8&gt;]
        strat = strat[0]
        # get_analysis()獲得值
        a_return = strat.analyzers.returns.get_analysis()
        drawDown = strat.analyzers.drawdown.get_analysis()
        sharpe = strat.analyzers.sharperatio.get_analysis()
        # 依序裝入資料，可用strat.params.xx獲取參數
        par1.append(strat.params.highest)
        par2.append(strat.params.in_amount)
        par3.append(strat.params.stoploss)
        par4.append(strat.params.takeprofit)
        # rtot代表總回報，獲取總回報
        ret.append(a_return[&quot;rtot&quot;])
        # 我們關注最大的drawdown，因此如下取值
        down.append(drawDown[&quot;max&quot;][&quot;drawdown&quot;])
        # 獲取sharpe ratio
        sharpe_r.append(sharpe[&quot;sharperatio&quot;])
    # 組裝成dataframe
    result_df = pd.DataFrame()
    result_df[&quot;Highest&quot;] = par1
    result_df[&quot;in_amount&quot;] = par2
    result_df[&quot;stoploss&quot;] = par3
    result_df[&quot;takeprofit&quot;] = par4
    result_df[&quot;total profit&quot;] = ret
    result_df[&quot;Max Drawdown&quot;] = down
    result_df[&quot;Sharpe Ratio&quot;] = sharpe_r
    # 根據總報酬來排列
    result_df = result_df.sort_values(by=[&quot;total profit&quot;], ascending=False)
    print(result_df)

    # 畫Kbars
    # cerebro.plot(style='candlestick', barup='red', bardown='green')

    # ===================Pyfolio===================
    # strat = results[0]
    # pyfoliozer = strat.analyzers.getbyname('pyfolio')
    # returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()

    # # # pyfolio showtime
    # import pyfolio as pf
    # pf.create_full_tear_sheet(
    # returns,
    # positions=positions,
    # transactions=transactions,
    # live_start_date='2018-01-01')  # This date is sample specific)
</code></pre>
<h2 id="追高進場與加碼固定停損停利"><a class="header" href="#追高進場與加碼固定停損停利">追高進場與加碼，固定停損停利</a></h2>
<pre><code class="language-python">from __future__ import absolute_import, division, print_function, unicode_literals

import datetime
from math import e
import yfinance as yf
import os.path
import sys
import pyfolio
import backtrader as bt
import numpy as np
import warnings
import pandas as pd

warnings.filterwarnings(&quot;ignore&quot;)
# 建立一個backtrader回測框架
class Highest_high(bt.Strategy):
    # 設置sma的參數，根據官方照此設置可進行暴力演算，得知何種參數最佳
    params = (
        (&quot;highest&quot;, 6),
        (&quot;in_amount&quot;, 4),
        (&quot;stoploss&quot;, 0.1),
        (&quot;takeprofit&quot;, 0.2),
    )

    # 這裡是log，當交易發生時呼叫log函數可以將交易print出來
    def log(self, txt, dt=None):
        &quot;&quot;&quot; Logging function fot this strategy&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        # print('%s, %s' % (dt.isoformat(), txt))

    # init定義你會用到的數據
    def __init__(self):
        # 呼叫high序列備用
        self.datahigh = self.datas[0].high
        # 呼叫close序列備用
        self.dataclose = self.datas[0].close
        # 追蹤order、buyprice跟buycomm使用，可用可不用
        self.order = None
        self.buyprice = None
        self.buycomm = None
        # 使用指標套件給的最高價判斷函數Highest
        self.the_highest_high = bt.ind.Highest(
            self.datahigh, period=self.params.highest
        )

    # notify_order當每次有訂單由next偵測出來的條件送出時，會觸發notify_order，好處是顯示出訂單執行的狀況以及偵測是否有資金不足的情況
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 當訂單為提交狀態時則不做任何事
            return

        # 當訂單完成時，若為Buy則print出買入狀況；反之亦然
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:
                self.log(
                    &quot;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )

        # 當因策略取消或是現今不足訂單被拒絕等狀況則print出訂單取消
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;Order Canceled/Margin/Rejected&quot;)

        # 完成該有的提醒之後則將oder設置回None
        self.order = None

    # notify_trade交易通知，預設如果有倉在手就不做事，如果執行賣出則print出獲利
    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log(&quot;OPERATION PROFIT, GROSS %.2f, NET %.2f&quot; % (trade.pnl, trade.pnlcomm))

    # next可以把它想像成一個內建的for loop，他把數據打包好供我們使用
    def next(self):
        # 檢查有無pending的訂單
        print(
            f&quot;holding of shares:{self.position.size}, total captial:{self.broker.get_value()}&quot;
        )
        if self.order:
            return
        # self.position.size獲得目前倉位資訊，當size&lt;指定進場次數時則允許買入
        if self.position.size &lt; self.params.in_amount * 1000:
            # 當現在的高大於前面n根的最高價時準備執行買入
            if self.datahigh &gt; self.the_highest_high[-1]:
                # 紀錄買單提交
                self.log(&quot;BUY CREATE, %.2f&quot; % self.dataclose[0])
                # 買進
                self.order = self.buy()
        # 當庫存部位不為0但表有庫存
        if self.position.size != 0:
            # 獲取庫存成本
            costs = self.position.price
            # 當收盤價大於平均成本的10%停利賣出
            if self.dataclose[0] &gt; costs + (costs * self.params.takeprofit):
                self.close()
                self.log(&quot;Take Profit, %.2f&quot; % self.dataclose[0])
            # 當收盤價小於平均成本
            elif self.dataclose[0] &lt; costs - (costs * self.params.stoploss):
                self.close()
                self.log(&quot;Stop Loss, %.2f&quot; % self.dataclose[0])

    # #回測終止時print出結果
    # def stop(self):
    #     print(f'Fast MA: {self.params.fast_period} | Slow MA: {self.params.slow_period} | End Value: {self.broker.getvalue()}')


if __name__ == &quot;__main__&quot;:
    # 創建框架
    cerebro = bt.Cerebro()
    # # 放入策略
    # cerebro.addstrategy(Highest_high)
    # # 放入策略
    cerebro.optstrategy(
        Highest_high,
        highest=range(5, 9),
        in_amount=range(1, 5),
        stoploss=np.arange(0.1, 0.5, 0.1),
        takeprofit=np.arange(0.1, 0.5, 0.1),
    )

    # 使用框架的資料取得函數
    data = bt.feeds.PandasData(
        dataname=yf.download(&quot;2317.TW&quot;, &quot;2014-01-01&quot;, &quot;2023-01-01&quot;)
    )
    # 將datafeed餵入框架
    cerebro.adddata(data)
    # 設置起始金額
    cerebro.broker.setcash(1000000.0)
    # 設置一次購買的股數，臺股以1000股為主
    cerebro.addsizer(bt.sizers.SizerFix, stake=1000)
    # 設置傭金，稍微設置高一點作為滑價付出成本
    cerebro.broker.setcommission(commission=0.0015)

    # ===================Pyfolio===================
    # cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')

    # 在設置完傭金、起始金額以及買入股數之後，我們加入三種分析
    cerebro.addanalyzer(bt.analyzers.SharpeRatio)
    cerebro.addanalyzer(bt.analyzers.Returns)
    cerebro.addanalyzer(bt.analyzers.DrawDown)
    results = cerebro.run(maxcpus=1)
    # 準備list存放每一個參數及結果
    par1, par2, par3, par4, ret, down, sharpe_r = [], [], [], [], [], [], []
    # 迴圈每一個結果
    for strat in results:
        # 因為結果是用list包起來(範例在下註解)，所以我們要[0]取值
        # [&lt;backtrader.cerebro.OptReturn object at 0x0000024FF9717CC8&gt;]
        strat = strat[0]
        # get_analysis()獲得值
        a_return = strat.analyzers.returns.get_analysis()
        drawDown = strat.analyzers.drawdown.get_analysis()
        sharpe = strat.analyzers.sharperatio.get_analysis()
        # 依序裝入資料，可用strat.params.xx獲取參數
        par1.append(strat.params.highest)
        par2.append(strat.params.in_amount)
        par3.append(strat.params.stoploss)
        par4.append(strat.params.takeprofit)
        # rtot代表總回報，獲取總回報
        ret.append(a_return[&quot;rtot&quot;])
        # 我們關注最大的drawdown，因此如下取值
        down.append(drawDown[&quot;max&quot;][&quot;drawdown&quot;])
        # 獲取sharpe ratio
        sharpe_r.append(sharpe[&quot;sharperatio&quot;])
    # 組裝成dataframe
    result_df = pd.DataFrame()
    result_df[&quot;Highest&quot;] = par1
    result_df[&quot;in_amount&quot;] = par2
    result_df[&quot;stoploss&quot;] = par3
    result_df[&quot;takeprofit&quot;] = par4
    result_df[&quot;total profit&quot;] = ret
    result_df[&quot;Max Drawdown&quot;] = down
    result_df[&quot;Sharpe Ratio&quot;] = sharpe_r
    # 根據總報酬來排列
    result_df = result_df.sort_values(by=[&quot;total profit&quot;], ascending=False)
    print(result_df)

    # 畫Kbars
    # cerebro.plot(style='candlestick', barup='red', bardown='green')

    # ===================Pyfolio===================
    # strat = results[0]
    # pyfoliozer = strat.analyzers.getbyname('pyfolio')
    # returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()

    # # # pyfolio showtime
    # import pyfolio as pf
    # pf.create_full_tear_sheet(
    # returns,
    # positions=positions,
    # transactions=transactions,
    # live_start_date='2018-01-01')  # This date is sample specific)
</code></pre>
<pre><code class="language-python">import backtrader as bt
import yfinance as yf

class MyStrategy(bt.Strategy):
    
    # 設定MA均線的週期
    params = (
        ('ma10', 10),
        ('ma20', 20),
        ('ma40', 40),
        ('take_profit', 0.2), # 設定獲利目標為20%
    )

    def __init__(self):
        self.ma10 = bt.indicators.MovingAverageSimple(self.data.close, period=self.params.ma10)
        self.ma20 = bt.indicators.MovingAverageSimple(self.data.close, period=self.params.ma20)
        self.ma40 = bt.indicators.MovingAverageSimple(self.data.close, period=self.params.ma40)
        
    def next(self):
        # 如果當前價格低於MA10，就買入一次
        if self.data.close[0] &lt; self.ma10[0]:
            self.buy(size=1)
            
        # 如果當前價格低於MA20，再買入一次
        if self.data.close[0] &lt; self.ma20[0]:
            self.buy(size=1)
            
        # 如果當前價格低於MA40，就停止交易並止損
        if self.data.close[0] &lt; self.ma40[0]:
            self.close()
            
        # 如果當前有持倉，計算當前持倉的盈利百分比
        if self.position:
            profit = (self.data.close[0] - self.position.price) / self.position.price

            # 如果當前持倉的盈利達到設定的獲利目標，就賣出並止盈
            if profit &gt;= self.params.take_profit:
                self.close()
            
cerebro = bt.Cerebro()

# 設定初始資金為10000美元
cerebro.broker.setcash(10000)

data = bt.feeds.PandasData(dataname=yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))

# 將數據傳入Cerebro中
cerebro.adddata(data)

# 將策略傳入Cerebro中
cerebro.addstrategy(MyStrategy)

# 運行回測
cerebro.run()

# 打印最終資金餘額
print('Final Balance: %.2f' % cerebro.broker.getvalue())

</code></pre>
<pre><code class="language-python">from datetime import datetime
import pandas as pd
import backtrader as bt
import yfinance as yf

# 匯入pyfolio 包
import pyfolio as pf


# 建立策略類
class SmaCross(bt.Strategy):
    # 定義參數
    params = (
        (&quot;ma10&quot;, 10),
        (&quot;ma20&quot;, 20),
        (&quot;ma40&quot;, 40),
        (&quot;take_profit&quot;, 0.2),  # 設定獲利目標為20%
    )

    # 日誌函數
    def log(self, txt, dt=None):
        &quot;&quot;&quot;日誌函數&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 訂單狀態 submitted/accepted，無動作
            return
        # 訂單完成
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(&quot;買單執行, %.2f&quot; % order.executed.price)
            elif order.issell():
                self.log(&quot;賣單執行, %.2f&quot; % order.executed.price)
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;訂單 Canceled/Margin/Rejected&quot;)

    # 記錄交易收益情況（可省略，默認不輸出結果）
    def notify_trade(self, trade):
        if trade.isclosed:
            print(
                &quot;毛收益 %0.2f, 扣傭後收益 % 0.2f, 佣金 %.2f&quot;
                % (trade.pnl, trade.pnlcomm, trade.commission)
            )

    def __init__(self):
        self.ma10 = bt.indicators.MovingAverageSimple(
            self.data.close, period=self.params.ma10
        )
        self.ma20 = bt.indicators.MovingAverageSimple(
            self.data.close, period=self.params.ma20
        )
        self.ma40 = bt.indicators.MovingAverageSimple(
            self.data.close, period=self.params.ma40
        )

    def __bt_to_pandas__(self, btdata, len):
        get = lambda mydata: mydata.get(ago=0, size=len)

        fields = {
            &quot;open&quot;: get(btdata.open),
            &quot;high&quot;: get(btdata.high),
            &quot;low&quot;: get(btdata.low),
            &quot;close&quot;: get(btdata.close),
            &quot;volume&quot;: get(btdata.volume),
        }
        time = [btdata.num2date(x) for x in get(btdata.datetime)]
        return pd.DataFrame(data=fields, index=time)

    def next(self):
        data = self.__bt_to_pandas__(self.datas[1], len(self.datas[1]))
        cash = self.broker.cash
        # print('剩餘現金:', cash)
        # print(data)
        # Get the current position
        pos = self.getposition()
        # Get the position size, 股數
        size = pos.size
        print(
            f&quot;size:{size}, close:{self.data.close[0]}, ma10:{self.ma10[0]}, ma20:{self.ma20[0]}, ma40:{self.ma40[0]}, cash:{cash}&quot;
        )

        # 如果當前價格低於MA10，就買入一次
        if self.data.close[0] &lt; self.ma10[0] and size &lt; 200:
            self.buy(size=10)
            print(&quot;close &lt; ma10&quot;)

        # 如果當前價格低於MA20，再買入一次
        if self.data.close[0] &lt; self.ma20[0] and size &lt; 200:
            self.buy(size=10)
            print(&quot;close &lt; ma20&quot;)

        # 如果當前有持倉，計算當前持倉的盈利百分比
        if self.position:
            # 如果當前價格低於MA40，就停止交易並止損
            if self.data.close[0] &lt; self.ma40[0]:
                self.close()

            profit = (self.data.close[0] - self.position.price) / self.position.price

            # 如果當前持倉的盈利達到設定的獲利目標，就賣出並止盈
            if profit &gt;= self.params.take_profit:
                self.close()


##########################
# 主程序開始
#########################

# 建立大腦引擎對象
cerebro = bt.Cerebro()


# 建立行情資料對象，載入資料
# data = bt.feeds.PandasData(dataname=yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))
data = bt.feeds.PandasData(dataname=yf.download(&quot;2330.TW&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))
# print(yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;), type(yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;)))
# input()

# self.datas[0] 日K數據, self.datas[1] 月K數據
data = cerebro.resampledata(data, timeframe=bt.TimeFrame.Months, compression=1)
cerebro.adddata(data)  # 將行情資料對象注入引擎

cerebro.addstrategy(SmaCross)  # 將策略注入引擎

cerebro.broker.setcash(10000.0)  # 設定初始資金

# 加入pyfolio分析者
cerebro.addanalyzer(bt.analyzers.PyFolio, _name=&quot;pyfolio&quot;)

results = cerebro.run()  # 運行
strat = results[0]
pyfoliozer = strat.analyzers.getbyname(&quot;pyfolio&quot;)
returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()
pf.create_full_tear_sheet(returns)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="如何提高backtrader回測性能1倍以上且最佳化記憶體"><a class="header" href="#如何提高backtrader回測性能1倍以上且最佳化記憶體">如何提高BACKTRADER回測性能1倍以上且最佳化記憶體</a></h2>
<p>出處：https://www.itbook5.com/12372/</p>
<h3 id="使用200萬條k線的資料測試backtrader的回測性能如何"><a class="header" href="#使用200萬條k線的資料測試backtrader的回測性能如何">使用200萬條K線的資料，測試backtrader的回測性能如何？</a></h3>
<p>為了做到這一點，第一件事就是產生的足夠的K線。所以，我們會做以下動作：</p>
<ul>
<li>產生100支股票</li>
<li>每支股票 20000條K線資料</li>
</ul>
<p>100個股票資料檔案總計200萬 根K線資料.</p>
<p>程式碼：</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

COLUMNS = ['open', 'high', 'low', 'close', 'volume', 'openinterest']
CANDLES = 20000
STOCKS

dateindex = pd.date_range(start='2010-01-01', periods=CANDLES, freq='15min')

for i in range(STOCKS):

    data = np.random.randint(10, 20, size=(CANDLES, len(COLUMNS)))
    df = pd.DataFrame(data * 1.01, dateindex, columns=COLUMNS)
    df = df.rename_axis('datetime')
    df.to_csv('candles{:02d}.csv'.format(i))
</code></pre>
<p>這會生成 100 個檔案，從<code>candles00.csv到``candles99.csv</code>. 其中實際值並不重要。擁有標準 <code>datetime</code>、<code>OHLCV</code>（和<code>OpenInterest</code>）才是最重要的。</p>
<h2 id="測試系統"><a class="header" href="#測試系統">測試系統</a></h2>
<ul>
<li><em>硬體/作業系統</em>：將使用配備 Intel i7 和 32 GB 記憶體的<em>Windows 10的 15.6″筆記型電腦。</em></li>
<li><em>Python</em> : CPython<code>3.6.1</code>和<code>pypy3 6.0.0</code></li>
<li><em>其他</em>：持續運行並佔用大約 20% 的 CPU 的應用程式。正在運行著Chrome（102 個處理程序）、Edge、Word、Powerpoint、Excel 和一些小型應用程式等通常的程序。</li>
</ul>
<h2 id="默認組態"><a class="header" href="#默認組態">默認組態</a></h2>
<p>讓我們回顧一下<em>backtrader</em>的默認執行階段組態是什麼：</p>
<ul>
<li>如果可能，預載入所有資料饋送</li>
<li>如果可以預載入所有資料饋送，則以批處理模式運行（命名為<code>runonce</code>）</li>
<li>首先預先計算所有指標</li>
<li>逐步瞭解策略邏輯和經紀人</li>
</ul>
<h2 id="runonce在默認批處理模式下執行"><a class="header" href="#runonce在默認批處理模式下執行"><code>runonce</code>在默認批處理模式下執行</a></h2>
<p>我們的測試指令碼（完整原始碼見底部）將打開這 100 個檔案並使用backtrader默認的組態運行。</p>
<pre><code class="language-sh">$ ./two-million-candles.py
Cerebro Start Time:          2019-10-26 08:33:15.563088
Strat Init Time:             2019-10-26 08:34:31.845349
Time Loading Data Feeds:     76.28
Number of data feeds:        100
Strat Start Time:            2019-10-26 08:34:31.864349
Pre-Next Start Time:         2019-10-26 08:34:32.670352
Time Calculating Indicators: 0.81
Next Start Time:             2019-10-26 08:34:32.671351
Strat warm-up period Time:   0.00
Time to Strat Next Logic:    77.11
End Time:                    2019-10-26 08:35:31.493349
Time in Strategy Next Logic: 58.82
Total Time in Strategy:      58.82
Total Time:                  135.93
Length of data feeds:        20000
</code></pre>
<p><strong>記憶體使用</strong>：觀察到 348 MB 的峰值</p>
<p>大部分時間實際上都花在預載入資料（<code>98.63</code>秒）上，其餘時間花在策略上，包括在每次迭代中通過代理（<code>73.63</code>秒）。總時間為<code>173.26</code>秒。</p>
<p>根據您想要計算它的方式，性能是：</p>
<ul>
<li>考慮到整個執行階段間:<code>14,713</code>根K線/秒</li>
</ul>
<p>說明以這樣的資料量backtrader處理起來，基本沒有壓力，記憶體的處理上，還可以通過參數的設定進行最佳化。將在後面做更多的探索。</p>
<h3 id="比較使用pypy的方案"><a class="header" href="#比較使用pypy的方案"><code>比較使用pypy的方案</code></a></h3>
<p>使用pypy的情況下，運行結果如下：</p>
<pre><code class="language-sh">$ ./two-million-candles.py
Cerebro Start Time:          2019-10-26 08:39:42.958689
Strat Init Time:             2019-10-26 08:40:31.260691
Time Loading Data Feeds:     48.30
Number of data feeds:        100
Strat Start Time:            2019-10-26 08:40:31.338692
Pre-Next Start Time:         2019-10-26 08:40:31.612688
Time Calculating Indicators: 0.27
Next Start Time:             2019-10-26 08:40:31.612688
Strat warm-up period Time:   0.00
Time to Strat Next Logic:    48.65
End Time:                    2019-10-26 08:40:40.150689
Time in Strategy Next Logic: 8.54
Total Time in Strategy:      8.54
Total Time:                  57.19
Length of data feeds:        20000
</code></pre>
<p>總時間已經從 <code>135.93</code>秒減少到<code>57.19</code>秒。性能提高了<strong>一倍多</strong>。</p>
<p>性能：<code>34,971</code>根K線/秒</p>
<p><strong>記憶體使用</strong>：觀察到 269 MB 的峰值。</p>
<p>這也是對標準 CPython 直譯器的重要改進。</p>
<h2 id="handling-2m的蠟燭出核心memory"><a class="header" href="#handling-2m的蠟燭出核心memory">Handling 2M的蠟燭出核心<a href="https://www.itbook5.com/tag/memory/">memory</a></a></h2>
<p>如果考慮到<em>backtrader</em>有多個用於執行回測會話的組態選項，所有這些都可以得到改進，包括最佳化緩衝區和僅使用所需的最少資料集（理想情況下僅使用 size 的緩衝區，這只會發生在理想場景）</p>
<pre><code class="language-python">class backtrader.Cerebro()
參數：

preload（默認True：）
是否預加載data feeds傳遞給 cerebro

runonce（默認：True）
以矢量化模式運行Indicators以加速整個系統。策略和觀察者將始終基於事件運行

live（默認：False）
默認是回測數據。

當使用實時數據時設置成True（或通過數據的islive 方法）

這將同時停用preload和runonce。它對內存節省方案沒有影響。

以矢量化模式運行Indicators以加速整個系統。策略和觀察者將始終基於事件運行

maxcpus（默認值：None -&gt; 所有可用內核）
同時使用多少個內核進行優化

stdstats（默認：True）
默認將添加真正的默認觀察員：經紀人（現金和價值）、交易和買入賣出

oldbuysell（默認：False）（與畫圖相關）
如果stdstatsis：True 時觀察者自動添加，則此開關使用BuySell

False：其中買入/賣出信號分別繪製在低/高價下方/上方，以避免混亂

True：在該行為中繪製買入/賣出信號在給定時間的訂單執行的平均價格。這當然會在 OHLC 條的頂部或在 Close 的 Line 上，從而難以識別。

oldtrades（默認：False）（與畫圖相關）
如果stdstatsis：True時觀察者自動添加，則此開關控制Trades 

False：其中所有數據的交易都用不同的標記繪製

True：同一方向的交易用相同的標記繪製交易，僅區分它們是正數還是負數

exactbars（默認：False）
使用默認值，存儲在一行中的每個值都保存在內存中

`True` 或 `1`：所有“行”對象將內存使用量減少到自動計算的最小週期。

  如果簡單移動平均線的週期為 30，則基礎數據將始終具有 30 個柱的運行緩衝區，以允許計算簡單移動平均線

  * 此設置將停用 `preload` 和 `runonce` 

  * 使用此設置也會停用**繪圖** 

objcache (default: False)
如果為True實現line對象的緩存。

writer（默認: False）
如果設置為True時 它將標準信息的輸出生成一個默認文件

tradehistory（默認: False）
如果設置為True，它將在所有策略的每筆交易中激活更新事件記錄log。這也可以在每個策略的上使用set_tradehistory來實現

optdatas（默認：True）
如果True優化（並且preload和runonce也是True），數據預加載將在主進程中只進行一次，以節省時間和資源。

optreturn（默認：True）
如果True優化結果只有params屬性和analyzers指標，而不是完整Strategy 對象（以及所有數據、指標、觀察者……），這樣可以優化速度，測試顯示改善13% - 15%的執行時間

oldsync（默認False：）
從版本 1.9.0.99 開始，多個數據（相同或不同時間範圍）的同步已更改為允許不同長度的數據。

如果希望使用 data0 作為系統主控的舊行為，請將此參數設置為 true

tz（默認：None）
為策略添加全球時區。論據tz可以是

* `None`：在這種情況下，策略顯示的日期時間將採用UTC，這是標準行為

* `pytz` 實例。它將用於將 UTC 時間轉換為所選時區

* `string`。將嘗試實例化 `pytz` 實例。

* `整數`。
  對於策略，使用與 `self.datas` 迭代中相應的 `data`相同的時區（`0` 將使用來自 `data0` 的時區）

cheat_on_open（默認：False）
當為True時next_open調用發生在next方法調用之前。此時指標尚未重新計算。這允許發佈一個考慮前一天指標但使用open價格計算的訂單

對於 cheat_on_open 訂單執行，還需要調用cerebro.broker.set_coo(True)或實例化一個經紀人 BackBroker(coo=True)（其中coo代表 cheat-on-open）或將broker_coo參數設置為True. 除非在下面禁用，否則 Cerebro 會自動執行此操作。

broker_coo（默認：True）
這將自動調用set_coo代理的方法True來激活cheat_on_open執行。cheat_on_open要同時為True

quicknotify（默認：False）
經紀人通知在下一個價格交付之前交付 。對於回溯測試，這沒有任何影響，但是對於實時經紀人，可以在柱線交付之前很久就發出通知。設置為True通知將盡快發送（請參閱qcheck實時提要）

設置False為兼容性。可以改為True
</code></pre>
<p>要使用的選項是<code>exactbars=True</code>. 從文件中 <code>exactbars</code>（這是<code>Cerebro</code>在實例化或呼叫時給出的參數<code>run</code>）</p>
<p>為了最大程度的最佳化並且停用繪圖，也將使用<code>stdstats=False</code>，停用現金、價值和交易的標準觀察者</p>
<pre><code class="language-sh">$ ./two-million-candles.py --cerebro exactbars=False,stdstats=False
Cerebro Start Time:          2019-10-26 08:37:08.014348
Strat Init Time:             2019-10-26 08:38:21.850392
Time Loading Data Feeds:     73.84
Number of data feeds:        100
Strat Start Time:            2019-10-26 08:38:21.851394
Pre-Next Start Time:         2019-10-26 08:38:21.857393
Time Calculating Indicators: 0.01
Next Start Time:             2019-10-26 08:38:21.857393
Strat warm-up period Time:   0.00
Time to Strat Next Logic:    73.84
End Time:                    2019-10-26 08:39:02.334936
Time in Strategy Next Logic: 40.48
Total Time in Strategy:      40.48
Total Time:                  114.32
Length of data feeds:        20000
</code></pre>
<p>性能：<code>17,494</code>根K線/秒</p>
<p><strong>記憶體使用</strong>：75M位元組（從開始回測開始到結束，穩定在這個數值）</p>
<p>讓我們與之前的非最佳化運行進行比較</p>
<ul>
<li>無需花費<code>76</code>秒鐘預載入資料，而是立即開始回測。</li>
<li>總時間是<code>114.32</code>秒 比 <code>135.93秒</code>改進<code>15.90%</code>。</li>
<li>使用記憶體改進了<code>68.5%</code>。</li>
</ul>
<h3 id="再次pypy"><a class="header" href="#再次pypy">再次<code>pypy</code></a></h3>
<p>既然我們知道如何最佳化，讓我們照著做一次<code>pypy</code>。</p>
<pre><code class="language-sh">$ ./two-million-candles.py --cerebro exactbars=True,stdstats=False 
Cerebro Start Time: 2019-10-26 08:44:32.309689 
Strat Init Time: 2019-10-26 08:44:32.406689
時間加載數據饋送：0.10
數據饋送數量：100 
Strat 開始時間：2019-10-26 08:44:32.409689 
Pre-Next Start Time：2019-10-26 08:44:32.451689
時間計算指標：0.04 
Next Start Time：2019 -10-26 08:44:32.451689 戰略
預熱期時間：0.00戰略下一個邏輯時間
：0.14
結束時間：2019-10-26 08:45:38.918693
戰略下一個邏輯時間：66.47
戰略總時間：66.47
總時間：66.61
數據饋送長度：20000
</code></pre>
<p>性能：<code>30,025</code>根K線/秒</p>
<p><strong>記憶體使用</strong>：恆定在<code>49 M位元組</code></p>
<p>將其與之前運行進行比較：</p>
<ul>
<li><code>66.61</code>秒 比<code>114.32t秒，在執行階段間上有``41.73%</code>的改進。</li>
<li><code>49 M位元組比``75 M位元組</code>，在記憶體上有<code>34.6%</code>的改進。</li>
</ul>
<p>在這種情況下，與批處理模式<code>pypy</code>相比，它無法擊敗自己的時間。這是意料之中的，因為在預載入時，計算器指示是在<strong>向量化</strong>模式下完成的。</p>
<p>無論如何，它仍然做得非常好，並且記憶體消耗有了重要的<strong>改善</strong></p>
<h2 id="完整的交易運行"><a class="header" href="#完整的交易運行">完整的交易運行</a></h2>
<p>該指令碼可以建立指標（移動平均線）並使用移動平均線的交叉<em>短期/長期策略</em>對 100 個股票執行回測*。*讓我們用<code>pypy</code>來做，並且知道使用批處理模式會更好，就這樣吧。</p>
<pre><code class="language-sh">$ ./two-million-candles.py --strat indicators=True,trade=True
Cerebro Start Time:          2019-10-26 08:57:36.114415
Strat Init Time:             2019-10-26 08:58:25.569448
Time Loading Data Feeds:     49.46
Number of data feeds:        100
Total indicators:            300
Moving Average to be used:   SMA
Indicators period 1:         10
Indicators period 2:         50
Strat Start Time:            2019-10-26 08:58:26.230445
Pre-Next Start Time:         2019-10-26 08:58:40.850447
Time Calculating Indicators: 14.62
Next Start Time:             2019-10-26 08:58:41.005446
Strat warm-up period Time:   0.15
Time to Strat Next Logic:    64.89
End Time:                    2019-10-26 09:00:13.057955
Time in Strategy Next Logic: 92.05
Total Time in Strategy:      92.21
Total Time:                  156.94
Length of data feeds:        20000
</code></pre>
<p>性能：<code>12,743</code>根K線/秒</p>
<p><strong>記憶體使用</strong>：<code>1300 M位元組</code>觀察到一個峰值。</p>
<p>由於增加了指標和交易，執行時間明顯增加了，但是為什麼記憶體使用也增加了？</p>
<p>在得出任何結論之前，讓我們嘗試建立指標但不進行交易</p>
<pre><code class="language-sh">$ ./two-million-candles.py --strat indicators=True
Cerebro Start Time:          2019-10-26 09:05:55.967969
Strat Init Time:             2019-10-26 09:06:44.072969
Time Loading Data Feeds:     48.10
Number of data feeds:        100
Total indicators:            300
Moving Average to be used:   SMA
Indicators period 1:         10
Indicators period 2:         50
Strat Start Time:            2019-10-26 09:06:44.779971
Pre-Next Start Time:         2019-10-26 09:06:59.208969
Time Calculating Indicators: 14.43
Next Start Time:             2019-10-26 09:06:59.360969
Strat warm-up period Time:   0.15
Time to Strat Next Logic:    63.39
End Time:                    2019-10-26 09:07:09.151838
Time in Strategy Next Logic: 9.79
Total Time in Strategy:      9.94
Total Time:                  73.18
Length of data feeds:        20000
</code></pre>
<p>性能：<code>27,329</code> 根K線/秒</p>
<p><strong>記憶體使用</strong>：（<code>600 M位元組</code>在最佳化<code>exactbars</code>模式下做同樣的事情只會消耗<code>60 M位元組</code>，但會增加執行時間，因為 <code>pypy</code>它本身不能最佳化這麼多）</p>
<p>有了<strong>交易，記憶體使用量確實增加</strong>了。原因是對像是由代理建立、傳遞和保存的<code>Order和``Trade。</code></p>
<p>還有該資料集包含隨機值，其產生數量龐大交叉的，因此有大量的訂單和交易。對於常規資料集，不會有類似的行為。</p>
<h2 id="結論-3"><a class="header" href="#結論-3">結論</a></h2>
<ol>
<li>
<ol>
<li><em>backtrader</em>可以使用默認組態輕鬆處理<code>2M</code>蠟燭圖（預載入記憶體資料）</li>
<li><em>backtrader</em>可以在非預載入最佳化模式下運行，將緩衝區減少到最小，以進行減少記憶體使用進行回測</li>
<li>在<em>最佳化</em>的非預載入模式下進行回測時，記憶體消耗的增加來自於代理產生的管理開銷。</li>
<li>即使交易、使用指標和經紀人不斷阻礙，表現也是<code>12,473</code>根K線/秒</li>
<li>儘可能使用<code>pypy</code>（如果您不需要繪圖的時候）</li>
</ol>
</li>
</ol>
<h2 id="測試指令碼"><a class="header" href="#測試指令碼">測試指令碼</a></h2>
<p>這裡是原始碼</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
import argparse
import datetime

import backtrader as bt


class St(bt.Strategy):
    params = dict(
        indicators=False,
        indperiod1=10,
        indperiod2=50,
        indicator=bt.ind.SMA,
        trade=False,
    )

    def __init__(self):
        self.dtinit = datetime.datetime.now()
        print('Strat Init Time:             {}'.format(self.dtinit))
        loaddata = (self.dtinit - self.env.dtcerebro).total_seconds()
        print('Time Loading Data Feeds:     {:.2f}'.format(loaddata))

        print('Number of data feeds:        {}'.format(len(self.datas)))
        if self.p.indicators:
            total_ind = self.p.indicators * 3 * len(self.datas)
            print('Total indicators:            {}'.format(total_ind))
            indname = self.p.indicator.__name__
            print('Moving Average to be used:   {}'.format(indname))
            print('Indicators period 1:         {}'.format(self.p.indperiod1))
            print('Indicators period 2:         {}'.format(self.p.indperiod2))

            self.macross = {}
            for d in self.datas:
                ma1 = self.p.indicator(d, period=self.p.indperiod1)
                ma2 = self.p.indicator(d, period=self.p.indperiod2)
                self.macross[d] = bt.ind.CrossOver(ma1, ma2)

    def start(self):
        self.dtstart = datetime.datetime.now()
        print('Strat Start Time:            {}'.format(self.dtstart))

    def prenext(self):
        if len(self.data0) == 1:  # only 1st time
            self.dtprenext = datetime.datetime.now()
            print('Pre-Next Start Time:         {}'.format(self.dtprenext))
            indcalc = (self.dtprenext - self.dtstart).total_seconds()
            print('Time Calculating Indicators: {:.2f}'.format(indcalc))

    def nextstart(self):
        if len(self.data0) == 1:  # there was no prenext
            self.dtprenext = datetime.datetime.now()
            print('Pre-Next Start Time:         {}'.format(self.dtprenext))
            indcalc = (self.dtprenext - self.dtstart).total_seconds()
            print('Time Calculating Indicators: {:.2f}'.format(indcalc))

        self.dtnextstart = datetime.datetime.now()
        print('Next Start Time:             {}'.format(self.dtnextstart))
        warmup = (self.dtnextstart - self.dtprenext).total_seconds()
        print('Strat warm-up period Time:   {:.2f}'.format(warmup))
        nextstart = (self.dtnextstart - self.env.dtcerebro).total_seconds()
        print('Time to Strat Next Logic:    {:.2f}'.format(nextstart))
        self.next()

    def next(self):
        if not self.p.trade:
            return

        for d, macross in self.macross.items():
            if macross &gt; 0:
                self.order_target_size(data=d, target=1)
            elif macross &lt; 0:
                self.order_target_size(data=d, target=-1)

    def stop(self):
        dtstop = datetime.datetime.now()
        print('End Time:                    {}'.format(dtstop))
        nexttime = (dtstop - self.dtnextstart).total_seconds()
        print('Time in Strategy Next Logic: {:.2f}'.format(nexttime))
        strattime = (dtstop - self.dtprenext).total_seconds()
        print('Total Time in Strategy:      {:.2f}'.format(strattime))
        totaltime = (dtstop - self.env.dtcerebro).total_seconds()
        print('Total Time:                  {:.2f}'.format(totaltime))
        print('Length of data feeds:        {}'.format(len(self.data)))


def run(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()

    datakwargs = dict(timeframe=bt.TimeFrame.Minutes, compression=15)
    for i in range(args.numfiles):
        dataname = 'candles{:02d}.csv'.format(i)
        data = bt.feeds.GenericCSVData(dataname=dataname, **datakwargs)
        cerebro.adddata(data)

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))
    cerebro.dtcerebro = dt0 = datetime.datetime.now()
    print('Cerebro Start Time:          {}'.format(dt0))
    cerebro.run(**eval('dict(' + args.cerebro + ')'))


def parse_args(pargs=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=(
            'Backtrader Basic Script'
        )
    )

    parser.add_argument('--numfiles', required=False, default=100, type=int,
                        help='Number of files to rea')

    parser.add_argument('--cerebro', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--strat', '--strategy', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')


    return parser.parse_args(pargs)


if __name__ == '__main__':
    run()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用python連線kafka介紹"><a class="header" href="#使用python連線kafka介紹">使用python連線kafka介紹</a></h1>
<p>整體架構調整如下圖：</p>
<p><img src="mq/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzcjQw,size_16,color_FFFFFF,t_70" alt="img" /></p>
<h3 id="歡看文字描述的朋友可以看看如下解釋"><a class="header" href="#歡看文字描述的朋友可以看看如下解釋"><strong>歡看文字描述的朋友可以看看如下解釋</strong>：</a></h3>
<p>在叢集外的一臺機器上啟動一個python指令碼，該指令碼從資料庫讀出資料，然後將這些資料分發給多個執行緒，每個執行緒各自訪問url，解析正文，建立一個kafka的生產者往kafka中傳送資料（有多少條執行緒，就有多少個kafka資訊），接著在內網環境中，啟動一個kafka消費者，將所有生產者傳遞過來的資料解析，並批量插入資料庫。</p>
<h3 id="然後我再說幾個點"><a class="header" href="#然後我再說幾個點">然後我再說幾個點：</a></h3>
<p>1、我試過，如果每個kafka生產者獲取到個url的正文，就往kafka傳送訊息，這樣相對來說可以更加保證資料不丟失，但是消費者會消費來不及，也就是說會有資料延遲，而且把生產者關了一段時間，消費者還消費不完（延遲挺嚴重），所以還是得通過拼接字串的方式，使得一條kafka訊息中，有幾十（甚至可以更多）條資料，然後消費端再解析這個資料，批量插入資料庫（<strong>詳細看程式碼</strong>），節省時間和資源。</p>
<p>2、資料是否會出現問題，會的，我來列舉下會丟或者重複資料的幾個地方。</p>
<ul>
<li>
<p>丟失資料：</p>
<ul>
<li>urllib獲取頁面資訊的時候，有可能超時，所以那個頁面就跳過去了</li>
<li>生產者傳送資料的時候，有可能因為網路或者其他原因沒傳送成功（大部分是因為網路）</li>
</ul>
</li>
<li>
<p>資料重複：</p>
<ul>
<li>消費者消費完資料之後，由於消費者的程式掛了，沒能將偏移量提交到zookeeper上，導致下次再開啟消費者的時候，重複消費資料，但是因為我的消費者壓力不大，所以沒有出現主動掛掉的情況</li>
</ul>
</li>
</ul>
<p>總結：我會通過sql的join方式，每次都從資料庫中拿出那些未被處理的資料，也就是說丟資料也無所謂，資料重複的問題，可以用主鍵（一張表內不會出現兩條相同主鍵的資料），或者最後用sql來對錶進行去重的方式來解決。</p>
<p><strong>3、python連線kafka有兩個包：pykafka和kafka-python</strong></p>
<p>具體他們之間孰好孰壞，可以看下pykafka開發者在自己的GitHub給別人的回答：https://github.com/Parsely/pykafka/issues/334，當然是全英文的。不過（作者：高爾夫golf，標明轉載）https://blog.csdn.net/konglongaa/article/details/81206889有對於這個issue的中文翻譯和總結，如果大家有興趣可以去看下，當然，這個issue的回答有些年代了，所以也不一定完全正確，比如裡面說pykafka只支援0.8.2版本的kafka，但是我使用了kafka_2.11-1.0.1版本，完全沒有版本不相容的問題。</p>
<h3 id="程式碼如下"><a class="header" href="#程式碼如下">程式碼如下：</a></h3>
<h2 id="生產者"><a class="header" href="#生產者">生產者：</a></h2>
<pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor
import time
import urllib.request
import  psycopg2
from lxml import etree
from pykafka import KafkaClient


def insertManyRow(strings):
    print('insertManyRow:',strings)
    # 多條資料間使用 =.= 來做分隔符
    b=&quot;=.=&quot;.join(strings)
    try:
        print('進入到生產者程式碼！')

        client = KafkaClient(hosts=&quot;broker1:埠1,broker2:埠2,broker3:埠3&quot;)
        # 檢視所有topic
        print(client.topics)
        topic = client.topics['指定傳送的topic名稱']  # 選擇一個topic
		# 同步傳送資料
        with topic.get_sync_producer() as producer:
			# 資料轉換成byte才可以傳送
            producer.produce(bytes(b, encoding=&quot;utf8&quot;))

    except Exception as e:
        print(&quot;傳送失敗%s&quot; % (e))
      

def productList(rows):
    string=''
    # 將多條資料放入list中
    strings=[]
    count = 0
    for row in rows:
        file = urllib.request.urlopen(row[2],timeout=5)

        try: 
            data = file.read()
            #是否被封號，從偏移量3000的位置往下找
            isBan=str(data).find('被封號的字串', 3000)
            if(isBan!=-1):
                string='ip被封'
            else:
                selector = etree.HTML(data)
                data = selector.xpath('//*[@id=&quot;zhengwen&quot;]/p/span/text()')
                # 將獲取到的多個正文內容拼接成一條字串
                for i in data:
                    if (i != None):
                        string = string + i  

            # 列印檢視
            print('正文：', string)
            # 將資料庫中一條資料的多個欄位通過 -.- 拼接到一起
            content=row[0]+'-.-'+row[1]+'-.-'+string+'-.-'+row[3]+'-.-'+row[4]
            # 放入list中
            strings.append(content)
            # 清空字串
            string = ''
            print(&quot;集合：&quot;, strings)
            print(&quot;集合長度：&quot;,len(strings))
            count = count + 1
            # 每十條資料就呼叫一次kafka生產者的程式碼
            if (count &gt;= 10):
                print('進入到insertManyRow')
                insertManyRow(strings)
                strings = []
                count = 0
        except Exception as e:
            print(&quot;執行緒出錯：%s&quot; % (e))

if __name__ == '__main__':
    conn = psycopg2.connect(database=&quot;資料庫&quot;, user=&quot;使用者名稱&quot;, password=&quot;密碼&quot;,
                                   host=&quot;ip&quot;,
                                   port=&quot;埠&quot;)
    cur = conn.cursor()
    
    sql = &quot;查詢的sql，查出未處理的url&quot;
    cur.execute(sql1)
    rows = cur.fetchall()
    print('拉取到資料')
    start=time.time()
    # 開啟10個執行緒，每個執行緒每次拉取10條url
    with ThreadPoolExecutor(10) as executor:
        for i in range(0, len(rows)//10, 1):
            executor.submit(productList, rows[i*10:(i+1)*10])
    end = time.time()
    print(&quot;time: &quot; + str(end - start))
    conn.close()
</code></pre>
<h2 id="消費者"><a class="header" href="#消費者">消費者：</a></h2>
<pre><code class="language-python">from pykafka import KafkaClient
import psycopg2

client = KafkaClient(hosts=&quot;broker1:埠1,broker2:埠2,broker3:埠3&quot;)
# 檢視所有topic
print(client.topics)
topic = client.topics['指定傳送的topic名稱']  # 選擇一個topic

#獲得一個均衡的消費者
balanced_consumer = topic.get_balanced_consumer(
consumer_group=bytes('消費者組名',encoding='utf-8'),
auto_commit_enable=True,# 設定為False的時候不需要新增consumer_group,直接連線topic即可取到訊息
#kafka在zk上的路徑，這個路徑應該和kafka的broker配置的zk路徑一樣（不然zk上會放得亂七八糟的。。。）
zookeeper_connect='zk1:埠1,zk2:埠1,zk3:埠3/kafka在zk上的路徑'
)


# arrs=[]
insertarr=[]

for message in balanced_consumer:
    print(message)
    if message is not None:
        #print(message.offset, message.value, type(message.value), str(message.value, encoding=&quot;utf8&quot;))
		#將接受到的資料轉換成executemany能接受的資料格式
        arrs=str(message.value, encoding=&quot;utf8&quot;).split('=.=')
        for arr in arrs:
            a=arr.split('-.-')
            insertarr.append(a)
    try:
		conn = psycopg2.connect(database=&quot;資料庫&quot;, user=&quot;使用者名稱&quot;, password=&quot;密碼&quot;,
                                   host=&quot;ip&quot;,
                                   port=&quot;埠&quot;)
		cur = conn.cursor()
        sql = &quot;INSERT INTO 資料庫.表名(欄位1,欄位2,欄位3,欄位4,欄位5) VALUES(%s,%s,%s,%s,%s)&quot;
        print(insertarr)
        cur.executemany(sql, insertarr)
        conn.commit()
        insertarr = []
        conn.close()
    except Exception as e:
        print(&quot;插入錯誤：%s&quot; % (e))
        insertarr=[]
        conn.close()
</code></pre>
<p>所以，到這裡，這個爬蟲系列的文章就更新到這裡了！因為我使用到了<strong>kafka</strong>框架，下一篇文章，應該會說下kafka生產者，消費者的一些東西，比如，我使用的<strong>get_balanced_consumer</strong>這個api，然後還有第一篇文章說的分類的東西，我也會開部落格來記錄！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python操作kafka的通俗總結"><a class="header" href="#python操作kafka的通俗總結">Python操作Kafka的通俗總結</a></h1>
<p>kafka-python文檔：<a href="https://link.zhihu.com/?target=https%3A//kafka-python.readthedocs.io/en/master/apidoc/KafkaConsumer.html">KafkaConsumer - kafka-python 2.0.2-dev documentation</a></p>
<h2 id="一基本概念"><a class="header" href="#一基本概念">一、基本概念</a></h2>
<ul>
<li>Topic：一組消息數據的標記符；</li>
<li>Producer：生產者，用於生產數據，可將生產後的消息送入指定的Topic；</li>
<li>Consumer：消費者，獲取數據，可消費指定的Topic；</li>
<li>Group：消費者組，同一個group可以有多個消費者，一條消息在一個group中，只會被一個消費者獲取；</li>
<li>Partition：分區，為了保證kafka的吞吐量，一個Topic可以設置多個分區。同一分區只能被一個消費者訂閱。</li>
</ul>
<h2 id="二本地安裝與啟動基於docker"><a class="header" href="#二本地安裝與啟動基於docker">二、本地安裝與啟動（基於Docker）</a></h2>
<ol>
<li>下載zookeeper鏡像與kafka鏡像：</li>
</ol>
<pre><code class="language-text">docker pull wurstmeister/zookeeper
docker pull wurstmeister/kafka
</code></pre>
<ol start="2">
<li>本地啟動zookeeper</li>
</ol>
<pre><code class="language-text">docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper  
</code></pre>
<ol start="3">
<li>本地啟動kafka</li>
</ol>
<pre><code class="language-python3">docker run -d --name kafka --publish 9092:9092 --link zookeeper \
--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \
--env KAFKA_ADVERTISED_HOST_NAME=localhost \
--env KAFKA_ADVERTISED_PORT=9092 \
wurstmeister/kafka:latest 
</code></pre>
<p>注意：上述代碼，將kafka啟動在9092端口</p>
<ol start="4">
<li>進入kafka bash</li>
</ol>
<pre><code class="language-text">docker exec -it kafka bash
cd /opt/kafka/bin
</code></pre>
<ol start="5">
<li>創建Topic，分區為2，Topic name為'kafkademo'</li>
</ol>
<pre><code class="language-text">kafka-topics.sh --create --zookeeper zookeeper:2181 \
--replication-factor 1 --partitions 2 --topic kafkademo
</code></pre>
<ol start="6">
<li>查看當前所有topic</li>
</ol>
<pre><code class="language-text">kafka-topics.sh --zookeeper zookeeper:2181 --list
</code></pre>
<ol start="7">
<li>安裝kafka-python</li>
</ol>
<pre><code class="language-text">pip install kafka-python
</code></pre>
<h2 id="三生產者producer與消費者consumer"><a class="header" href="#三生產者producer與消費者consumer">三、生產者（Producer）與消費者（Consumer）</a></h2>
<p>生產者和消費者的簡易Demo，這裡一起演示：</p>
<pre><code class="language-python">from kafka import KafkaConsumer
import json


def consumer_demo():
    consumer = KafkaConsumer(
        &quot;kafkademo&quot;,
        bootstrap_servers=[&quot;localhost:9092&quot;],
        group_id=&quot;test&quot;,
        # api_version='2.0.2'
        api_version=(0, 10),
    )

    print(consumer.bootstrap_connected())
    print(consumer.topics())
    for message in consumer:
        print(consumer.bootstrap_connected())
        print(
            &quot;receive, key: {}, value: {}&quot;.format(
                json.loads(message.key.decode()), json.loads(message.value.decode())
            )
        )


if __name__ == &quot;__main__&quot;:
    consumer_demo()
</code></pre>
<pre><code class="language-python">from kafka import KafkaProducer
from kafka.errors import kafka_errors
import traceback
import json


def producer_demo():
    # 假設生產的消息為鍵值對（不是一定要鍵值對），且序列化方式為json
    producer = KafkaProducer(
        bootstrap_servers=[&quot;localhost:9092&quot;],
        key_serializer=lambda k: json.dumps(k).encode(),
        value_serializer=lambda v: json.dumps(v).encode(),
    )
    # 發送三條消息
    for i in range(0, 3):
        future = producer.send(
            &quot;kafkademo&quot;, key=&quot;count_num&quot;, value=str(i), partition=1  # 同一個key值，會被送至同一個分區
        )  # 向分區1發送消息
        print(&quot;send {}&quot;.format(str(i)))
        try:
            future.get(timeout=10)  # 監控是否發送成功
        except kafka_errors:  # 發送失敗拋出kafka_errors
            traceback.format_exc()


if __name__ == &quot;__main__&quot;:
    producer_demo()
</code></pre>
<p>這裡建議起兩個terminal，或者兩個jupyter notebook頁面來驗證。</p>
<p>先執行消費者：</p>
<pre><code class="language-text">consumer_demo()
</code></pre>
<p>再執行生產者：</p>
<pre><code class="language-text">producer_demo()
</code></pre>
<p>會看到如下輸出：</p>
<pre><code class="language-text">&gt;&gt;&gt; producer_demo()
send 0
send 1
send 2
</code></pre>
<pre><code class="language-text">&gt;&gt;&gt; consumer_demo()
receive, key: count_num, value: 0
receive, key: count_num, value: 1
receive, key: count_num, value: 2
</code></pre>
<h2 id="四消費者進階操作"><a class="header" href="#四消費者進階操作">四、消費者進階操作</a></h2>
<p>（1）初始化參數：</p>
<p>列舉一些KafkaConsumer初始化時的重要參數：</p>
<ul>
<li>group_id</li>
</ul>
<p>高並發量，則需要有多個消費者協作，消費進度，則由group_id統一。例如消費者A與消費者B，在初始化時使用同一個group_id。在進行消費時，一條消息被消費者A消費後，在kafka中會被標記，這條消息不會再被B消費（前提是A消費後正確commit）。</p>
<ul>
<li>key_deserializer， value_deserializer</li>
</ul>
<p>與生產者中的參數一致，自動解析。</p>
<ul>
<li>auto_offset_reset</li>
</ul>
<p>消費者啟動的時刻，消息隊列中或許已經有堆積的未消費消息，有時候需求是從上一次未消費的位置開始讀（則該參數設置為earliest），有時候的需求為從當前時刻開始讀之後產生的，之前產生的數據不再消費（則該參數設置為latest）。</p>
<ul>
<li>enable_auto_commit， auto_commit_interval_ms</li>
</ul>
<p>是否自動commit，當前消費者消費完該數據後，需要commit，才可以將消費完的信息傳回消息隊列的控制中心。enable_auto_commit設置為True後，消費者將自動commit，並且兩次commit的時間間隔為auto_commit_interval_ms。</p>
<p>（2）手動commit</p>
<pre><code class="language-text">def consumer_demo():
    consumer = KafkaConsumer(
        'kafkademo', 
        bootstrap_servers=':9092',
        group_id='test',
        enable_auto_commit=False
    )
    for message in consumer:
        print(&quot;receive, key: {}, value: {}&quot;.format(
            json.loads(message.key.decode()),
            json.loads(message.value.decode())
            )
        )
        consumer.commit()
</code></pre>
<p>（3）查看kafka堆積剩餘量</p>
<p>在線環境中，需要保證消費者的消費速度大於生產者的生產速度，所以需要檢測kafka中的剩餘堆積量是在增加還是減小。可以用如下代碼，觀測隊列消息剩餘量：</p>
<pre><code class="language-text">consumer = KafkaConsumer(topic, **kwargs)
partitions = [TopicPartition(topic, p) for p in consumer.partitions_for_topic(topic)]

print(&quot;start to cal offset:&quot;)

# total
toff = consumer.end_offsets(partitions)
toff = [(key.partition, toff[key]) for key in toff.keys()]
toff.sort()
print(&quot;total offset: {}&quot;.format(str(toff)))
    
# current
coff = [(x.partition, consumer.committed(x)) for x in partitions]
coff.sort()
print(&quot;current offset: {}&quot;.format(str(coff)))

# cal sum and left
toff_sum = sum([x[1] for x in toff])
cur_sum = sum([x[1] for x in coff if x[1] is not None])
left_sum = toff_sum - cur_sum
print(&quot;kafka left: {}&quot;.format(left_sum))
</code></pre>
<h2 id="check-if-kafka-broker-is-up-and-running-in-python"><a class="header" href="#check-if-kafka-broker-is-up-and-running-in-python">Check if Kafka Broker is up and running in Python</a></h2>
<p><strong>Using <a href="https://github.com/confluentinc/confluent-kafka-python"><code>confluent-kafka-python</code></a> and <a href="https://docs.confluent.io/current/clients/confluent-kafka-python/#pythonclient-adminclient"><code>AdminClient</code></a></strong></p>
<p>https://stackoverflow.com/questions/61226910/how-to-programmatically-check-if-kafka-broker-is-up-and-running-in-python</p>
<pre><code class="language-py"># Example using confuent_kafka
from confluent_kafka.admin import AdminClient

kafka_broker = {'bootstrap.servers': 'localhost:9092'}
admin_client = AdminClient(kafka_broker)
topics = admin_client.list_topics().topics

if not topics: 
    raise RuntimeError()
</code></pre>
<p><strong>Using <a href="https://github.com/dpkp/kafka-python"><code>kafka-python</code></a> and <a href="https://kafka-python.readthedocs.io/en/1.0.2/#kafkaconsumer"><code>KafkaConsumer</code></a></strong></p>
<pre><code class="language-py"># example using kafka-python
import kafka


consumer = kafka.KafkaConsumer(group_id='test', bootstrap_servers=['localhost:9092'])
topics = consumer.topics()

if not topics: 
    raise RuntimeError()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安裝-redis"><a class="header" href="#安裝-redis">安裝 Redis</a></h1>
<pre><code class="language-shell">sudo apt install redis-server
sudo systemctl status redis-server
</code></pre>
<pre><code class="language-python">import redis

def delete_all_keys():
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=8)
    redis_conn.flushdb()

if __name__ == &quot;__main__&quot;:
    delete_all_keys()
</code></pre>
<pre><code class="language-python">import redis
r = redis.StrictRedis(host='localhost', port=6379, db=0)
r.set('foo', 'bar')
print(r.get('foo'))
</code></pre>
<h2 id="備份還原"><a class="header" href="#備份還原">備份＆還原</a></h2>
<pre><code class="language-python">from github import Github
from finlab import data
from os.path import getsize
import finlab
import pickle
import redis
import zlib
import time


def update_github(git_file):
    token = &quot;&quot;
    # Step 1: Create a Github instance:
    g = Github(token)
    repo = g.get_user().get_repo(&quot;stockinfo&quot;)

    all_files = []
    contents = repo.get_contents(&quot;&quot;)
    while contents:
        file_content = contents.pop(0)
        if file_content.type == &quot;dir&quot;:
            contents.extend(repo.get_contents(file_content.path))
        else:
            file = file_content
            all_files.append(
                str(file).replace('ContentFile(path=&quot;', &quot;&quot;).replace('&quot;)', &quot;&quot;)
            )

    print(all_files)
    with open(git_file, &quot;rb&quot;) as file:
        content = file.read()

    if git_file in all_files:
        contents = repo.get_contents(&quot;/&quot;)
        for item in contents:
            if item.path == git_file:
                contents = item
                break
        print(contents)

        while True:
            try:
                repo.update_file(
                    contents.path, &quot;committing files&quot;, content, contents.sha
                )
                break
            except Exception as e:
                print(e)
                time.sleep(10)
                continue

        print(git_file + &quot; UPDATED&quot;)
    else:
        while True:
            try:
                repo.create_file(git_file, &quot;committing files&quot;, content)
                break
            except Exception as e:
                print(e)
                time.sleep(10)
                continue
        print(git_file + &quot; CREATED&quot;)


def dump():
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=8)
    data_keys = redis_conn.keys()
    for key in data_keys:
        with open(f'{key.decode(&quot;utf-8&quot;)}.bin', &quot;wb&quot;) as f:
            f.write(redis_conn.get(key))
        print(
            key.decode(&quot;utf-8&quot;),
            &quot;==========================================================================================&quot;,
        )
        # github 單一檔案無法上傳超過50mb
        if getsize(f'{key.decode(&quot;utf-8&quot;)}.bin') &lt; 52428800:
            update_github(f'{key.decode(&quot;utf-8&quot;)}.bin')
    redis_conn.close()


def restore(dataset):
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=9)
    with open(f&quot;{dataset}.bin&quot;, &quot;rb&quot;) as f:
        redis_conn.set(dataset.encode(&quot;utf-8&quot;), f.read())
    redis_conn.close()


def get_data():
    data_list = [
        &quot;benchmark_return:發行量加權股價報酬指數&quot;,
        &quot;etl:adj_close&quot;,
        &quot;etl:finlab_tw_stock_market_ind&quot;,
        &quot;financial_statement:合約負債_流動&quot;,
        &quot;financial_statement:投資活動之淨現金流入_流出&quot;,
        &quot;financial_statement:營業收入淨額&quot;,
        &quot;financial_statement:營業活動之淨現金流入_流出&quot;,
        &quot;financial_statement:研究發展費&quot;,
        &quot;financial_statement:籌資活動之淨現金流入_流出&quot;,
        &quot;financial_statement:股本&quot;,
        &quot;financial_statement:股東權益總額&quot;,
        &quot;fundamental_features:ROE稅後&quot;,
        &quot;fundamental_features:業外收支營收率&quot;,
        &quot;fundamental_features:營收成長率&quot;,
        &quot;fundamental_features:營業利益成長率&quot;,
        &quot;fundamental_features:營業利益率&quot;,
        &quot;fundamental_features:經常稅後淨利&quot;,
        &quot;institutional_investors_trading_summary:投信買賣超股數&quot;,
        &quot;inventory&quot;,
        &quot;margin_balance:融資券總餘額&quot;,
        &quot;margin_transactions:融資今日餘額&quot;,
        &quot;margin_transactions:融資使用率&quot;,
        &quot;monthly_revenue:上月比較增減(%)&quot;,
        &quot;monthly_revenue:去年同月增減(%)&quot;,
        &quot;monthly_revenue:當月營收&quot;,
        &quot;par_value_change_otc:otc_par_value_change_divide_ratio&quot;,
        &quot;par_value_change_tse:twse_par_value_change_divide_ratio&quot;,
        &quot;price_earning_ratio:本益比&quot;,
        &quot;price_earning_ratio:殖利率(%)&quot;,
        &quot;price_earning_ratio:股價淨值比&quot;,
        &quot;price:成交股數&quot;,
        &quot;price:收盤價&quot;,
        &quot;price:收盤價&quot;,
        &quot;security_industry_themes&quot;,
        &quot;tw_business_indicators:景氣對策信號(分)&quot;,
        &quot;tw_total_nmi:臺灣非製造業NMI&quot;,
        &quot;tw_total_pmi:未來六個月展望&quot;,
        &quot;tw_total_pmi:製造業PMI&quot;,
    ]
    for dataset in data_list:
        data.get(dataset)


if __name__ == &quot;__main__&quot;:
    finlab.login(
        &quot;&quot;
    )
    get_data()
    dump()
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=8)
    data_keys = redis_conn.keys()
    redis_conn.close()

    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=9)
    for key in data_keys:
        k = key.decode(&quot;utf-8&quot;)
        restore(k)
        print(k)
        print(pickle.loads(zlib.decompress(redis_conn.get(k))))
    redis_conn.close()
</code></pre>
<h2 id="以字典形式寫入數據到-redis"><a class="header" href="#以字典形式寫入數據到-redis">以字典形式寫入數據到 Redis</a></h2>
<pre><code class="language-python">import redis

# 建立 Redis 連線
r = redis.Redis(host=&quot;localhost&quot;, port=6379, db=0)

if True:
    # 使用多次 hset 方法設置多個鍵值對
    r.hset(&quot;my_dict&quot;, &quot;key1&quot;, &quot;value1&quot;)
    r.hset(&quot;my_dict&quot;, &quot;key2&quot;, &quot;value2&quot;)
else:
    # 使用字典一次性設置多個鍵值對
    data = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}
    r.hmset(&quot;my_dict&quot;, data)  # 此行仍可以正常運作，但會出現 DeprecationWarning 警告


# 從 Redis 讀取字典
my_dict = r.hgetall(&quot;my_dict&quot;)
my_dict = {key.decode(&quot;utf-8&quot;): val.decode(&quot;utf-8&quot;) for key, val in my_dict.items()}
print(my_dict)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安裝-redis-1"><a class="header" href="#安裝-redis-1">安裝 Redis</a></h1>
<pre><code class="language-shell">sudo apt install redis-server
sudo systemctl status redis-server
</code></pre>
<pre><code class="language-python">import redis

def delete_all_keys():
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=8)
    redis_conn.flushdb()

if __name__ == &quot;__main__&quot;:
    delete_all_keys()
</code></pre>
<pre><code class="language-python">import redis
r = redis.StrictRedis(host='localhost', port=6379, db=0)
r.set('foo', 'bar')
print(r.get('foo'))
</code></pre>
<h2 id="備份還原-1"><a class="header" href="#備份還原-1">備份＆還原</a></h2>
<pre><code class="language-python">from github import Github
from finlab import data
from os.path import getsize
import finlab
import pickle
import redis
import zlib
import time


def update_github(git_file):
    token = &quot;&quot;
    # Step 1: Create a Github instance:
    g = Github(token)
    repo = g.get_user().get_repo(&quot;stockinfo&quot;)

    all_files = []
    contents = repo.get_contents(&quot;&quot;)
    while contents:
        file_content = contents.pop(0)
        if file_content.type == &quot;dir&quot;:
            contents.extend(repo.get_contents(file_content.path))
        else:
            file = file_content
            all_files.append(
                str(file).replace('ContentFile(path=&quot;', &quot;&quot;).replace('&quot;)', &quot;&quot;)
            )

    print(all_files)
    with open(git_file, &quot;rb&quot;) as file:
        content = file.read()

    if git_file in all_files:
        contents = repo.get_contents(&quot;/&quot;)
        for item in contents:
            if item.path == git_file:
                contents = item
                break
        print(contents)

        while True:
            try:
                repo.update_file(
                    contents.path, &quot;committing files&quot;, content, contents.sha
                )
                break
            except Exception as e:
                print(e)
                time.sleep(10)
                continue

        print(git_file + &quot; UPDATED&quot;)
    else:
        while True:
            try:
                repo.create_file(git_file, &quot;committing files&quot;, content)
                break
            except Exception as e:
                print(e)
                time.sleep(10)
                continue
        print(git_file + &quot; CREATED&quot;)


def dump():
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=8)
    data_keys = redis_conn.keys()
    for key in data_keys:
        with open(f'{key.decode(&quot;utf-8&quot;)}.bin', &quot;wb&quot;) as f:
            f.write(redis_conn.get(key))
        print(
            key.decode(&quot;utf-8&quot;),
            &quot;==========================================================================================&quot;,
        )
        # github 單一檔案無法上傳超過50mb
        if getsize(f'{key.decode(&quot;utf-8&quot;)}.bin') &lt; 52428800:
            update_github(f'{key.decode(&quot;utf-8&quot;)}.bin')
    redis_conn.close()


def restore(dataset):
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=9)
    with open(f&quot;{dataset}.bin&quot;, &quot;rb&quot;) as f:
        redis_conn.set(dataset.encode(&quot;utf-8&quot;), f.read())
    redis_conn.close()


def get_data():
    data_list = [
        &quot;benchmark_return:發行量加權股價報酬指數&quot;,
        &quot;etl:adj_close&quot;,
        &quot;etl:finlab_tw_stock_market_ind&quot;,
        &quot;financial_statement:合約負債_流動&quot;,
        &quot;financial_statement:投資活動之淨現金流入_流出&quot;,
        &quot;financial_statement:營業收入淨額&quot;,
        &quot;financial_statement:營業活動之淨現金流入_流出&quot;,
        &quot;financial_statement:研究發展費&quot;,
        &quot;financial_statement:籌資活動之淨現金流入_流出&quot;,
        &quot;financial_statement:股本&quot;,
        &quot;financial_statement:股東權益總額&quot;,
        &quot;fundamental_features:ROE稅後&quot;,
        &quot;fundamental_features:業外收支營收率&quot;,
        &quot;fundamental_features:營收成長率&quot;,
        &quot;fundamental_features:營業利益成長率&quot;,
        &quot;fundamental_features:營業利益率&quot;,
        &quot;fundamental_features:經常稅後淨利&quot;,
        &quot;institutional_investors_trading_summary:投信買賣超股數&quot;,
        &quot;inventory&quot;,
        &quot;margin_balance:融資券總餘額&quot;,
        &quot;margin_transactions:融資今日餘額&quot;,
        &quot;margin_transactions:融資使用率&quot;,
        &quot;monthly_revenue:上月比較增減(%)&quot;,
        &quot;monthly_revenue:去年同月增減(%)&quot;,
        &quot;monthly_revenue:當月營收&quot;,
        &quot;par_value_change_otc:otc_par_value_change_divide_ratio&quot;,
        &quot;par_value_change_tse:twse_par_value_change_divide_ratio&quot;,
        &quot;price_earning_ratio:本益比&quot;,
        &quot;price_earning_ratio:殖利率(%)&quot;,
        &quot;price_earning_ratio:股價淨值比&quot;,
        &quot;price:成交股數&quot;,
        &quot;price:收盤價&quot;,
        &quot;price:收盤價&quot;,
        &quot;security_industry_themes&quot;,
        &quot;tw_business_indicators:景氣對策信號(分)&quot;,
        &quot;tw_total_nmi:臺灣非製造業NMI&quot;,
        &quot;tw_total_pmi:未來六個月展望&quot;,
        &quot;tw_total_pmi:製造業PMI&quot;,
    ]
    for dataset in data_list:
        data.get(dataset)


if __name__ == &quot;__main__&quot;:
    finlab.login(
        &quot;&quot;
    )
    get_data()
    dump()
    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=8)
    data_keys = redis_conn.keys()
    redis_conn.close()

    redis_conn = redis.Redis(host=&quot;127.0.0.1&quot;, port=6379, db=9)
    for key in data_keys:
        k = key.decode(&quot;utf-8&quot;)
        restore(k)
        print(k)
        print(pickle.loads(zlib.decompress(redis_conn.get(k))))
    redis_conn.close()
</code></pre>
<h2 id="以字典形式寫入數據到-redis-1"><a class="header" href="#以字典形式寫入數據到-redis-1">以字典形式寫入數據到 Redis</a></h2>
<pre><code class="language-python">import redis

# 建立 Redis 連線
r = redis.Redis(host=&quot;localhost&quot;, port=6379, db=0)

if True:
    # 使用多次 hset 方法設置多個鍵值對
    r.hset(&quot;my_dict&quot;, &quot;key1&quot;, &quot;value1&quot;)
    r.hset(&quot;my_dict&quot;, &quot;key2&quot;, &quot;value2&quot;)
else:
    # 使用字典一次性設置多個鍵值對
    data = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}
    r.hmset(&quot;my_dict&quot;, data)  # 此行仍可以正常運作，但會出現 DeprecationWarning 警告


# 從 Redis 讀取字典
my_dict = r.hgetall(&quot;my_dict&quot;)
my_dict = {key.decode(&quot;utf-8&quot;): val.decode(&quot;utf-8&quot;) for key, val in my_dict.items()}
print(my_dict)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis-hash操作"><a class="header" href="#redis-hash操作">Redis Hash操作]</a></h1>
<p>Redis 數據庫hash數據類型是一個string類型的key和value的映射表，適用於存儲對象。Redis 中每個 hash 可以存儲 232 - 1 鍵值對（40多億）。 hash表現形式上有些像pyhton中的dict,可以存儲一組關聯性較強的數據 ， redis中Hash在內存中的存儲格式如下圖：</p>
<p><img src="database/images/821560-20180115135035506-1067480309.png" alt="img" /></p>
<pre><code class="language-python"># 連接redis
 
import redis
 
host = '172.16.200.49'
port = 6379
 
pool = redis.ConnectionPool(host=host, port=port)
 
r = redis.Redis(connection_pool=pool)
</code></pre>
<p><strong>hset(name, key, value)</strong></p>
<pre><code class="language-python"># name對應的hash中設置一個鍵值對（不存在，則創建；否則，修改）
  
# 參數：
    # name，redis的name
    # key，name對應的hash中的key
    # value，name對應的hash中的value
  
# 註：
    # hsetnx(name, key, value),當name對應的hash中不存在當前key時則創建（相當於添加）
 
 
r.hset('p_info', 'name', 'bigberg')
r.hset('p_info', 'age', '22')
r.hset('p_info', 'gender', 'M')
 
# 設置了姓名、年齡和性別
</code></pre>
<p><strong>hmset(name, mapping)</strong></p>
<pre><code class="language-python"># 在name對應的hash中批量設置鍵值對
  
# 參數：
    # name，redis的name
    # mapping，字典，如：{'k1':'v1', 'k2': 'v2'}
  
# 如：
    # r.hmset('xx', {'k1':'v1', 'k2': 'v2'})
 
 
r.hmset('info_2', {'name': 'Jerry', 'species': 'mouse'})
</code></pre>
<p><strong>hget(name, key)</strong></p>
<pre><code class="language-python"># 在name對應的hash中獲取根據key獲取value
 
# 獲取的bytes 類型
print(r.hget('p_info', 'name').decode())
 
# 輸出
bigberg
</code></pre>
<p><strong>hmget(name, key, *args)</strong></p>
<pre><code class="language-python"># 在name對應的hash中獲取多個key的值
  
# 參數：
    # name，reids對應的name
    # keys，要獲取key集合，如：['k1', 'k2', 'k3']
    # *args，要獲取的key，如：k1,k2,k3
  
# 如：
print(r.hmget('p_info', ['name', 'age', 'gender']))
</code></pre>
<p><strong>hgetall(name)</strong></p>
<pre><code class="language-python">獲取name對應hash的所有鍵值
 
print(r.hgetall('p_info'))
 
#輸出是一個字典
 
{b'name': b'bigberg', b'gender': b'M', b'age': b'22'}
</code></pre>
<p><strong>hlen(name)</strong></p>
<pre><code class="language-python"># 獲取name對應的hash中鍵值對的個數
 
print(r.hlen('p_info'))
 
#輸出
3
</code></pre>
<p><strong>hkeys(name)</strong></p>
<pre><code class="language-python"># 獲取name對應的hash中所有的key的值
 
print(r.hkeys('p_info'))
 
#輸出
[b'name', b'age', b'gender']
</code></pre>
<p><strong>hvals(name)</strong></p>
<pre><code class="language-python"># 獲取name對應的hash中所有的value的值
 
print(r.hvals('p_info'))
 
#輸出
 [b'bigberg', b'22', b'M']
</code></pre>
<p><strong>hexists(name, key)</strong></p>
<pre><code class="language-python"># 檢查name對應的hash是否存在當前傳入的key
 
print(r.hexists('p_info', 'name'))
print(r.hexists('p_info', 'job'))
 
#輸出
True
False
</code></pre>
<p><strong>hdel(name,*keys)</strong></p>
<pre><code class="language-python"># 將name對應的hash中指定key的鍵值對刪除
 
r.hdel('p_info', 'gender')
print(r.hgetall('p_info'))
 
# 刪除了性別
#輸出
{b'name': b'bigberg', b'age': b'22'
</code></pre>
<p><strong>hincrby(name, key, amount=1)</strong></p>
<pre><code class="language-python"># 自增name對應的hash中的指定key的值，不存在則創建key=amount
# 參數：
    # name，redis中的name
    # key， hash對應的key
    # amount，自增數（整數）
 
r.hincrby('p_info', 'age', 1)
print(r.hget('p_info', 'age'))
 
#輸出，年齡增加1
b'23'
</code></pre>
<p><strong>hincrbyfloat(name, key, amount=1.0)</strong></p>
<pre><code class="language-python"># 自增name對應的hash中的指定key的值，不存在則創建key=amount
  
# 參數：
    # name，redis中的name
    # key， hash對應的key
    # amount，自增數（浮點數）
  
# 自增name對應的hash中的指定key的值，不存在則創建key=amount
</code></pre>
<p><strong>hscan(name, cursor=0, match=None, count=None)</strong></p>
<pre><code class="language-python"># 增量式迭代獲取，對於數據大的數據非常有用，hscan可以實現分片的獲取數據，並非一次性將數據全部獲取完，從而放置內存被撐爆
  
# 參數：
    # name，redis的name
    # cursor，遊標（基於遊標分批取獲取數據）
    # match，匹配指定key，默認None 表示所有的key
    # count，每次分片最少獲取個數，默認None表示採用Redis的默認分片個數
 
 
print(r.hscan('p_info', cursor=0))
print(r.hscan('p_info', cursor=0, match='n*'))
 
#輸出
 
(0, {b'age': b'23', b'address': b'hz', b'name': b'bigberg'})
(0, {b'name': b'bigberg'})
</code></pre>
<p><strong>hscan_iter(name, match=None, count=None)</strong></p>
<pre><code class="language-python"># 利用yield封裝hscan創建生成器，實現分批去redis中獲取數據
   
# 參數：
    # match，匹配指定key，默認None 表示所有的key
    # count，每次分片最少獲取個數，默認None表示採用Redis的默認分片個數
   
# 如：
    # for item in r.hscan_iter('xx'):
    #     print(item)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">clickhouse</a></h1>
<p>https://phoenixnap.com/kb/install-clickhouse-on-ubuntu-20-04</p>
<h2 id="installing-clickhouse-on-ubuntu-2004"><a class="header" href="#installing-clickhouse-on-ubuntu-2004">Installing ClickHouse on Ubuntu 20.04</a></h2>
<pre><code class="language-sh">sudo apt-get install -y apt-transport-https ca-certificates dirmngr
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 8919F6BD2B48D754

echo &quot;deb https://packages.clickhouse.com/deb stable main&quot; | sudo tee \
    /etc/apt/sources.list.d/clickhouse.list
    
sudo apt-get update

sudo apt-get install -y clickhouse-server clickhouse-client

sudo service clickhouse-server start
clickhouse-client # or &quot;clickhouse-client --password&quot; if you've set up a password.
</code></pre>
<h2 id="getting-started-with-clickhouse"><a class="header" href="#getting-started-with-clickhouse">Getting Started With ClickHouse</a></h2>
<pre><code class="language-sh">sudo systemctl start clickhouse-server
sudo systemctl status clickhouse-server
</code></pre>
<pre><code>● clickhouse-server.service - ClickHouse Server (analytic DBMS for big data)
     Loaded: loaded (/lib/systemd/system/clickhouse-server.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2022-09-12 16:07:10 CST; 5s ago
   Main PID: 429578 (clckhouse-watch)
      Tasks: 205 (limit: 18726)
     Memory: 73.7M
     CGroup: /system.slice/clickhouse-server.service
             ├─429578 clickhouse-watchdog        --config=/etc/clickhouse-server/config.xml --pid-file=/run/clickhouse-server/clickhouse-server.pid
             └─429596 /usr/bin/clickhouse-server --config=/etc/clickhouse-server/config.xml --pid-file=/run/clickhouse-server/clickhouse-server.pid

 9月 12 16:07:10 nb-jasonyao systemd[1]: Started ClickHouse Server (analytic DBMS for big data).
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429578]: Processing configuration file '/etc/clickhouse-server/config.xml'.
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429578]: Logging trace to /var/log/clickhouse-server/clickhouse-server.log
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429578]: Logging errors to /var/log/clickhouse-server/clickhouse-server.err.log
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429596]: Processing configuration file '/etc/clickhouse-server/config.xml'.
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429596]: Saved preprocessed configuration to '/var/lib/clickhouse/preprocessed_configs/config.xml'.
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429596]: Processing configuration file '/etc/clickhouse-server/users.xml'.
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429596]: Merging configuration file '/etc/clickhouse-server/users.d/default-password.xml'.
 9月 12 16:07:10 nb-jasonyao clickhouse-server[429596]: Saved preprocessed configuration to '/var/lib/clickhouse/preprocessed_configs/users.xml'.
</code></pre>
<pre><code class="language-sh">clickhouse-client --password f0409 --user default
</code></pre>
<h1 id="python-clickhouse-driver"><a class="header" href="#python-clickhouse-driver">python clickhouse-driver</a></h1>
<pre><code class="language-sh">pip install clickhouse-driver
</code></pre>
<pre><code class="language-py">from clickhouse_driver import Client
from io import StringIO
import requests
import pandas as pd

client = Client(host=&quot;localhost&quot;, port=&quot;9000&quot;, user=&quot;default&quot;, password=&quot;f0409&quot;)

def get_wespai_data(url):
    headers = {
        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&quot;
    }
    TAIGU1 = requests.get(url, headers=headers)
    TAIGU1.encoding = &quot;utf-8&quot;
    raw_data = pd.read_html(StringIO(TAIGU1.text))[0]
    #raw_data.to_csv(FILE_name, header=True, index=False, encoding=&quot;utf-8&quot;)
    return raw_data

df = get_wespai_data(&quot;https://stock.wespai.com/p/48812&quot;)


def read_sql(sql):
    data, columns = client.execute(sql, columnar=True, with_column_types=True)
    df = pd.DataFrame({re.sub(r&quot;\W&quot;, &quot;_&quot;, col[0]): d for d, col in zip(data, columns)})
    return df


def get_type_dict(tb_name):
    sql = f&quot;select name, type from system.columns where table='{tb_name}';&quot;
    df = read_sql(sql)
    df = df.set_index(&quot;name&quot;)
    type_dict = df.to_dict(&quot;dict&quot;)[&quot;type&quot;]
    return type_dict


def to_sql(df, tb_name):
    type_dict = get_type_dict(tb_name)
    columns = list(type_dict.keys())
    # 類型處理
    for i in range(len(columns)):
        col_name = columns[i]
        col_type = type_dict[col_name]
        if &quot;Date&quot; in col_type:
            df[col_name] = pd.to_datetime(df[col_name])
        elif &quot;Int&quot; in col_type:
            df[col_name] = df[col_name].astype(&quot;int&quot;)
        elif &quot;Float&quot; in col_type:
            df[col_name] = df[col_name].astype(&quot;float&quot;)
        elif col_type == &quot;String&quot;:
            df[col_name] = df[col_name].astype(&quot;str&quot;).fillna(&quot;&quot;)
    # df數據存入clickhouse
    cols = &quot;,&quot;.join(columns)
    data = df.to_dict(&quot;records&quot;)
    client.execute(f&quot;INSERT INTO {tb_name} ({cols}) VALUES&quot;, data, types_check=True)


if __name__ == '__main__':
    print(client.execute(&quot;SHOW DATABASES&quot;))
    client.execute(&quot;DROP TABLE IF EXISTS test&quot;)
    print(client.execute(&quot;SHOW TABLES&quot;))
    client.execute(&quot;CREATE TABLE test (x Int32) ENGINE = Memory&quot;)
    print(client.execute(&quot;SHOW TABLES&quot;))

    client.execute(&quot;INSERT INTO test (x) VALUES&quot;, [{&quot;x&quot;: 100}])
    client.execute(&quot;INSERT INTO test (x) VALUES&quot;, [[200]])
    client.execute(
        &quot;INSERT INTO test (x) &quot; &quot;SELECT * FROM system.numbers LIMIT %(limit)s&quot;, {&quot;limit&quot;: 3}
    )
    df = get_wespai_data(&quot;https://stock.wespai.com/p/48812&quot;)
    print(df.to_markdown())

</code></pre>
<h2 id="gui-tool"><a class="header" href="#gui-tool">GUI TOOL</a></h2>
<p>https://dbeaver.io/download/</p>
<p>https://dbeaver.io/files/dbeaver-ce-latest-linux.gtk.x86_64.tar.gz</p>
<h2 id="使用-pandas-讀寫-clickhouse"><a class="header" href="#使用-pandas-讀寫-clickhouse">使用 Pandas 讀寫 ClickHouse</a></h2>
<p>Pandas 本身不支援 ClickHouse 相關操作, 本篇部落格主要是記錄一下自己封裝的一些讀寫操作, 所以嚴格來說標題應該是: 如何從 ClickHouse 讀取資料到 DataFrame 及將 DataFrame 寫入 ClickHouse.</p>
<h3 id="一-pandas-讀取-clickhouse"><a class="header" href="#一-pandas-讀取-clickhouse">一. Pandas 讀取 ClickHouse</a></h3>
<p>GitHub 上面有幾個 Python 操作 ClickHouse 的開放原始碼專案, 不過收藏數量都不多(幾百個 star), 經過試用, 發現 clickhouse_driver 這個項目相對靠譜一點, 先使用 pip 安裝 clickhouse_driver, 讀取資料的程式碼如下:</p>
<pre><code class="language-py">from clickhouse_driver import Client
import pandas as pd
import re

client = Client(host=&quot;xxx&quot;, database=&quot;xxx&quot;, user=&quot;xxx&quot;, password=&quot;xxx&quot;)

def read_sql(sql):
    data, columns = client.execute(sql, columnar=True, with_column_types=True)
    df = pd.DataFrame({re.sub(r&quot;\W&quot;, &quot;_&quot;, col[0]): d for d, col in zip(data, columns)})
    return df
</code></pre>
<p>使用 ClickHouse 的查詢命令也可以將資料讀出, 而且速度特別快, 但是得到的資料是一個超長的字串, 想要轉成 DataFrame 的話需要自己做切分和轉換, 操作比較麻煩, 以後有時間再嘗試, 查詢資料的程式碼如下:</p>
<pre><code class="language-python">import subprocess

def read_sql(sql):
    cmd = f'clickhouse-client -t --query &quot;{sql}&quot;'
    data = subprocess.getoutput(cmd)
    return data
</code></pre>
<h3 id="二-pandas-寫入-clickhouse"><a class="header" href="#二-pandas-寫入-clickhouse">二. Pandas 寫入 ClickHouse</a></h3>
<p>由於 Pandas 的資料類型跟 ClickHouse 不同, 所以有些資料類型需要做一些處理, 大概的思路是</p>
<ul>
<li>
<p>獲取 ClickHouse 中指定表的各個欄位的資料類型</p>
</li>
<li>
<p>修改將要寫入 ClickHouse 的 DataFrame 的資料類型</p>
</li>
<li>
<p>將 DataFrame 裝換為字典形式</p>
</li>
<li>
<p>呼叫 ClickHouse 的 insert 命令將字典資料匯入庫中*</p>
</li>
</ul>
<p>程式碼實現如下:</p>
<pre><code class="language-py">from clickhouse_driver import Client
import pandas as pd
import re

client = Client(host=&quot;xxx&quot;, database=&quot;xxx&quot;, user=&quot;xxx&quot;, password=&quot;xxx&quot;)


def read_sql(sql):
    data, columns = client.execute(sql, columnar=True, with_column_types=True)
    df = pd.DataFrame({re.sub(r&quot;\W&quot;, &quot;_&quot;, col[0]): d for d, col in zip(data, columns)})
    return df


def get_type_dict(tb_name):
    sql = f&quot;select name, type from system.columns where table='{tb_name}';&quot;
    df = read_sql(sql)
    df = df.set_index(&quot;name&quot;)
    type_dict = df.to_dict(&quot;dict&quot;)[&quot;type&quot;]
    return type_dict


def to_sql(df, tb_name):
    type_dict = get_type_dict(tb_name)
    columns = list(type_dict.keys())
    # 類型處理
    for i in range(len(columns)):
        col_name = columns[i]
        col_type = type_dict[col_name]
        if &quot;Date&quot; in col_type:
            df[col_name] = pd.to_datetime(df[col_name])
        elif &quot;Int&quot; in col_type:
            df[col_name] = df[col_name].astype(&quot;int&quot;)
        elif &quot;Float&quot; in col_type:
            df[col_name] = df[col_name].astype(&quot;float&quot;)
        elif col_type == &quot;String&quot;:
            df[col_name] = df[col_name].astype(&quot;str&quot;).fillna(&quot;&quot;)
    # df數據存入clickhouse
    cols = &quot;,&quot;.join(columns)
    data = df.to_dict(&quot;records&quot;)
    client.execute(f&quot;INSERT INTO {tb_name} ({cols}) VALUES&quot;, data, types_check=True)

</code></pre>
<hr />
<h2 id="pandas-寫入-clickhouse"><a class="header" href="#pandas-寫入-clickhouse">Pandas 寫入 clickhouse</a></h2>
<pre><code class="language-py">from clickhouse_driver import Client
from io import StringIO
import numpy as np
import pandahouse as ph
import requests
import pandas as pd


def get_wespai_data(url):
    headers = {
        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&quot;
    }
    TAIGU1 = requests.get(url, headers=headers)
    TAIGU1.encoding = &quot;utf-8&quot;
    raw_data = pd.read_html(StringIO(TAIGU1.text))[0]
    return raw_data


def insert_df_to_ch(df, str_database, str_table, bool_drop=True):
    dtypes_dict = dict(df.dtypes)
    dict_dtype = {}
    ch_type_convert_dict = {
        np.dtype(&quot;datetime64[ns]&quot;): &quot;Datetime64&quot;,
        np.dtype(&quot;int64&quot;): &quot;Int64&quot;,
        np.dtype(&quot;float64&quot;): &quot;Float64&quot;,
        np.dtype(&quot;object&quot;): &quot;String&quot;,
        np.dtype(&quot;bool&quot;): &quot;Bool&quot;,
    }

    create_table_cmd_str = &quot;&quot;
    for x in dtypes_dict:
        type_str = ch_type_convert_dict.get(dtypes_dict[x], None)
        if type_str is None:
            print(f&quot;Undefined type {dtypes_dict[x]}&quot;)
        create_table_cmd_str = create_table_cmd_str + f&quot;`{x}` {type_str} DEFAULT 0, &quot;

    create_table_cmd_str = f&quot;CREATE TABLE IF NOT EXISTS {str_database}.{str_table} ( {create_table_cmd_str[:-2]}) ENGINE = Log&quot;
    # print(create_table_cmd_str)

    client = Client(host=&quot;localhost&quot;, port=&quot;9000&quot;, user=&quot;default&quot;, password=&quot;f0409&quot;)
    client.execute(f'CREATE DATABASE IF NOT EXISTS {str_database};')
    if bool_drop:
        client.execute(f'DROP TABLE IF EXISTS {str_database}.{str_table};')
    client.execute(create_table_cmd_str)

    connection = dict(
        database=str_database, host=&quot;http://127.0.0.1:8123/&quot;, user=&quot;default&quot;, password=&quot;f0409&quot;
    )

    ph.to_clickhouse(df, str_table, index=False, chunksize=100000, connection=connection)


if __name__ == '__main__':
    df = get_wespai_data(&quot;https://stock.wespai.com/p/48812&quot;)
    #print(df)
    insert_df_to_ch(df, &quot;CRYPTO&quot;, &quot;TEST11&quot; + &quot;_MM_TEST&quot;, True)

</code></pre>
<hr />
<pre><code class="language-sh">組態檔案路徑：/etc/clickhouse-server/，默認的組態檔案為config.xml，但是建議將更新的組態放入config.d資料夾下，以防版本更新導致修改檔案被覆蓋。

默認資料保存路徑：/var/lib/clickhouse/

如果改路徑下的儲存空間比較小，建議將其該為大儲存空間下的目錄，例如：/app/clickhouse

注意：請注意/app/clickhouse的存取權，需要賦予clickhouse使用者的存取權，也可以直接使用chmod 775 /app/clickhouse為其設定寫存取權。


mkdir clickhouse_data/ 
sudo chown -R clickhouse:clickhouse clickhouse_data/
vim /etc/clickhouse-server/config.xml
&lt;path&gt;/home/shihyu/clickhouse_data/&lt;/path&gt;
systemctl stop clickhouse-server
systemctl restart clickhouse-server
sudo systemctl status clickhouse-server
</code></pre>
<h2 id="刪除xx日期之前的數據"><a class="header" href="#刪除xx日期之前的數據">刪除XX日期之前的數據</a></h2>
<pre><code class="language-python">from clickhouse_driver import Client
from datetime import datetime, timedelta

client = Client(
    host=&quot;localhost&quot;,
    port=&quot;9000&quot;,
    user=&quot;default&quot;,
    password=&quot;f0409&quot;,
    settings={&quot;allow_experimental_lightweight_delete&quot;: True},
)
str_database = &quot;CRYPTO&quot;
str_table = &quot;Bitopro_Orderbook_Partition&quot;

# 計算三個月前的日期
three_months_ago = datetime.now() - timedelta(days=90)
print(three_months_ago.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))

# 構建 SQL 語句
# sql = f&quot;DELETE FROM {str_database}.{str_table} WHERE date &lt; toYYYYMMDD('{three_months_ago.strftime('%Y-%m-%d %H:%M:%S')}');&quot;
# sql = &quot;DELETE FROM CRYPTO.Binance_Orderbook_Partition WHERE date &lt; '2023-01-27 10:24:30' &quot;
sql = f&quot;DELETE FROM CRYPTO.Binance_Orderbook_Partition WHERE date &lt; '{three_months_ago.strftime('%Y-%m-%d %H:%M:%S')}' &quot;
print(sql)

# 執行 SQL 語句
client.execute(sql)
</code></pre>
<h2 id="clickhouse--partition"><a class="header" href="#clickhouse--partition">ClickHouse  Partition</a></h2>
<p>在 ClickHouse 中，Partition 是一種將表格分割成小塊的技術。可以在表格中設置一個或多個 Partition，這樣它們就可以存儲在不同的位置中。當查詢表格時，ClickHouse 能夠根據分區策略只查詢所需的分區，這樣就能夠提高查詢效率、降低維護成本。</p>
<p>在 ClickHouse 中，支持以下多種 Partition：</p>
<ol>
<li>Range Partition: 根據特定的欄位和一個或多個範圍，將表格分割成多個 Partition，並將每個 Partition 存儲在一個獨立的目錄中。</li>
<li>List Partition: 根據特定的欄位和一個或多個值的列表，將表格分割成多個 Partition，並將每個 Partition 存儲在一個獨立的目錄中。</li>
<li>Hash Partition: 將表格分割成多個 Partition，並根據 Hash 函數將每個 Partition 存儲在不同的磁盤上。</li>
<li>Unpartitioned Table: 不對表格進行分區。</li>
</ol>
<p>分區可以幫助 ClickHouse 實現更精確的查詢，因為可以通過分區信息更快地定位查找對象。例如，當表格被分成多個 Partition 時，ClickHouse 可以只查詢特定的 Partition，而非查詢整個表格，從而提高查詢效率。此外，當需要刪除 Partition 時，也不需要刪除整個表格。</p>
<p>總結來說，ClickHouse 中的 Partition 可以幫助你提高查詢效率、降低維護成本、以及增強表格的可用性和可擴展性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-install-dolphin-on-ubuntu-2004"><a class="header" href="#how-to-install-dolphin-on-ubuntu-2004">How To Install dolphin on Ubuntu 20.04</a></h1>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get -y install dolphin
sudo apt -y install dolphin
</code></pre>
<p>https://github.com/dolphindb/api_python3</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="把sqlite當嵌入式kv資料庫用"><a class="header" href="#把sqlite當嵌入式kv資料庫用">把Sqlite當嵌入式KV資料庫用</a></h2>
<p>https://zhuanlan.zhihu.com/p/93969678</p>
<p>市面上已經有很優秀的嵌入式KV資料庫了，如Berkeley DB。為什麼還需要把Sqlite當KV資料庫用呢？原因若干。</p>
<p>1，可能是為了好玩或者純屬無聊</p>
<p>2，可結合關係型資料庫與KV資料庫的優點</p>
<p>3，可利用一些sqlite特性做其他KV資料庫不好做的事情</p>
<p>4，事務管理更方便</p>
<p>5，sqlite更可靠，更流行</p>
<p><strong>實現思路</strong></p>
<p>使用json（或pickle）dump資料，並將資料寫入有KEY（主鍵）和VALUE兩個欄位的SQLITE庫表中。參照kv資料庫呼叫辦法實現外部介面。</p>
<p><strong>主要功能</strong></p>
<p>1，put：寫入key/value資料</p>
<p>2，get：獲取某個key的value</p>
<p>3，put_many：批次寫入key/value資料</p>
<p>4，keys：獲取所有key的列表</p>
<p>5，value：獲取所有value的列表</p>
<p>6，limit：利用SQL語句中limit關鍵字，獲取資料庫中“前”N條KV資料</p>
<p>7，random：利用SQL語句中random關鍵字，從資料庫中隨即獲取N條KV資料</p>
<p>8，has_key：某個key是否存在</p>
<p>9，cursor_execute：執行sql自訂語句</p>
<p>10，其他：items，pop，filter，count等</p>
<pre><code class="language-py">import os
import json
import sqlite3
import sys
from threading import Lock

PY3 = sys.version_info &gt;= (3,)
if PY3:
    ifilter = filter
else:
    from itertools import ifilter

DUMPS = lambda d: json.dumps(d)
LOADS = lambda d: json.loads(d)


class SDB(object):
    _DEFAULT_TABLE = &quot;__KVS_DEFAULT_TABLE__&quot;
    _MEMORY_DB = &quot;:memory:&quot;

    def __init__(self, filename):
        if filename is None or len(filename) &lt; 1 or filename.lower() == self._MEMORY_DB:
            self.filename = self._MEMORY_DB
        else:
            self.filename = filename
        self._lock = Lock()
        self._db_init()

    def _row_factory(self, cursor, row):
        result = []
        for idx, col in enumerate(cursor.description):
            if col[0].lower() in (&quot;k&quot;, &quot;v&quot;):
                result.append(LOADS(row[idx]))
            else:
                result.append(row[idx])
        return result

    def _db_init(self):
        _new_table = &quot;CREATE TABLE IF NOT EXISTS {0} ( k PRIMARY KEY,v)&quot;.format(
            self._DEFAULT_TABLE
        )
        db = sqlite3.connect(self.filename, timeout=60, check_same_thread=False)
        db.row_factory = self._row_factory
        db.execute(_new_table)
        self._cursor = db.cursor()
        self._db = db

    def _statement_init(self):
        table = self._DEFAULT_TABLE
        return dict(
            insert=&quot;insert or replace into {0}(k,v) values(:1,:2)&quot;.format(table),
            delete=&quot;delete from {0} where k=:1&quot;.format(table),
            update=&quot;update {0} set v=:1 where k=:2&quot;.format(table),
            clear=&quot;delete from {0}&quot;.format(table),
            get=&quot;select v from {0} where k=:1&quot;.format(table),
            has_key=&quot;select count(1) from {0} where k=:1&quot;.format(table),
            keys=&quot;select k from {0}&quot;.format(table),
            values=&quot;select v from {0}&quot;.format(table),
            items=&quot;select k,v from {0}&quot;.format(table),
            count=&quot;select count(*) from {0}&quot;.format(table),
            random=&quot;select * from {0} order BY RANDOM() limit :1&quot;.format(table),
            limit=&quot;select * from {0} limit :1 offset :2&quot;.format(table),
        )

    _statements = property(_statement_init)
    del _statement_init

    def _commit(self):
        self._db.commit()

    def _rollback(self):
        self._db.rollback()

    def _insert(self, key, value):
        try:
            self._lock.acquire(True)
            self._cursor.execute(
                self._statements.get(&quot;insert&quot;), (DUMPS(key), DUMPS(value))
            )
        finally:
            self._lock.release()

    def _update(self, key, value):
        try:
            self._lock.acquire(True)
            self._cursor.execute(
                self._statements.get(&quot;update&quot;), (DUMPS(value), DUMPS(key))
            )
        finally:
            self._lock.release()

    def _delete(self, key):
        try:
            self._lock.acquire(True)
            self._cursor.execute(self._statements.get(&quot;delete&quot;), (DUMPS(key),))
        finally:
            self._lock.release()

    def _query(self, method, *args):
        try:
            self._lock.acquire(True)
            return self._cursor.execute(self._statements.get(method), args)
        finally:
            self._lock.release()

    def _clear(self):
        &quot;&quot;&quot;
        刪除所有數據,需要調用_commit方法確認刪除
        :return:
        &quot;&quot;&quot;
        try:
            self._lock.acquire(True)
            self._cursor.execute(self._statements.get(&quot;clear&quot;))
        except Exception as e:
            self._rollback()
            raise e
        finally:
            self._lock.release()

    def keys(self, sort=False, sort_key=None, reverse=False):
        if sort:
            return sorted(self.iterkeys(), key=sort_key, reverse=reverse)
        return list(self.iterkeys())

    def values(self, sort=False, sort_key=None, reverse=False):
        if sort:
            return sorted(self.itervalues(), key=sort_key, reverse=reverse)
        return list(self.itervalues())

    def iterkeys(self):
        for k in self._query(&quot;keys&quot;):
            yield k[0]

    def itervalues(self):
        for k in self._query(&quot;values&quot;):
            yield k[0]

    def items(self, sort=False, key=None, reverse=False):
        if sort:
            return sorted(self.iteritems(), key=key, reverse=reverse)
        return list(self.iteritems())

    def iteritems(self):
        for k, v in self._query(&quot;items&quot;):
            yield k, v

    def count(self):
        return self._query(&quot;count&quot;).fetchone()[0]

    def has_key(self, key):
        return self._query(&quot;has_key&quot;, DUMPS(key)).fetchone()[0] &gt; 0

    def get(self, key):
        data = self._query(&quot;get&quot;, DUMPS(key)).fetchone()
        if data:
            return data[0]

    def put(self, key, value):
        try:
            self._insert(key, value)
            self._commit()
        except Exception as e:
            self._rollback()
            raise e

    def pop(self, key):
        try:
            value = self.get(key)
            self._delete(key)
            self._commit()
            return value
        except Exception as e:
            self._rollback()
            raise e

    def put_many(self, rows):
        try:
            self._lock.acquire(True)
            if rows and len(rows) &gt; 0:
                self._cursor.executemany(
                    self._statements.get(&quot;insert&quot;),
                    [(DUMPS(k), DUMPS(v)) for k, v in rows],
                )
                self._commit()
        except Exception as e:
            self._rollback()
            raise e
        finally:
            if self._lock.locked():
                self._lock.release()

    def limit(self, limit=1, offset=0):
        rows = self._query(&quot;limit&quot;, limit, offset)
        if limit == 1:
            return rows.fetchone()
        return rows.fetchall()

    def random(self, limit=1):
        rows = self._query(&quot;random&quot;, limit)
        if limit == 1:
            return rows.fetchone()
        return rows.fetchall()

    def filter(self, func):
        return list(ifilter(func, self.items()))

    def ifilter(self, func):
        return ifilter(func, self.iteritems())

    def cursor_execute(self, sql, parameters=None):
        &quot;&quot;&quot;
        執行SQL語句，如:SELECT K,V FROM __KVS_DEFAULT_TABLE__ WHERE K LIKE 'ABC%'
        &quot;&quot;&quot;
        try:
            self._lock.acquire(True)
            return self._cursor.execute(sql=sql, parameters=parameters)
        finally:
            self._lock.release()

    def close(self):
        try:
            self._rollback()
            self._cursor.close()
            self._db.close()
        except:
            pass


if __name__ == &quot;__main__&quot;:
    # 打開資料庫
    db = SDB(&quot;test.sqlite&quot;)
    # 寫入單條資料
    db.put(&quot;first&quot;, &quot;第一條資料&quot;)
    db.put(&quot;second&quot;, dict(a=1, b=2, c=[2, 3, 4]))
    # 獲取資料
    db.get(&quot;first&quot;)
    # 寫入多條資料
    db.put_many([[1, 2], [3, 4], [&quot;A&quot;, &quot;abc&quot;]])
    # 獲取key的列表
    db.keys()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptotrade"><a class="header" href="#cryptotrade">CryptoTrade</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-binance-api-教學"><a class="header" href="#python-binance-api-教學">Python Binance API 教學</a></h1>
<h2 id="幣安帳務下單-websocket"><a class="header" href="#幣安帳務下單-websocket">幣安帳務下單＆ websocket</a></h2>
<pre><code class="language-python">import asyncio
import json
import websockets
from binance.client import Client
from binance.enums import *

class mid_class:
    def __init__(self, api_key, api_secret):
        self.client = Client(api_key, api_secret)
        self.balance = None
        self.ticker = None
        self.depth = None
        self.order = None

    def get_account(self):
        self.balance = self.client.get_asset_balance(asset='USDT')

    def get_ticker(self):
        self.ticker = self.client.get_symbol_ticker(symbol='BTCUSDT')

    def get_depth(self):
        self.depth = self.client.get_order_book(symbol='BTCUSDT')

    def create_order(self):
        self.order = self.client.create_test_order(
            symbol='BTCUSDT',
            side=SIDE_BUY,
            type=ORDER_TYPE_LIMIT,
            timeInForce=TIME_IN_FORCE_GTC,
            quantity=100,
            price='1000')

    def cancel_order(self):
        self.client.cancel_order(
            symbol='BTCUSDT',
            orderId=self.order['orderId'])

async def main():
    api_key = 'your_api_key'
    api_secret = 'your_api_secret'
    mid = mid_class(api_key, api_secret)
    #mid.get_account()
    #mid.get_ticker()
    #mid.get_depth()
    #mid.create_order()
    #mid.cancel_order()
    await fetch_depth(mid)

async def fetch_depth(mid):
    async with websockets.connect('wss://stream.binance.com:9443/ws/btcusdt@depth@100ms') as websocket:
        while True:
            depth_json = await websocket.recv()
            depth_dict = json.loads(depth_json)
            print(depth_dict)

if __name__ == '__main__':
    asyncio.run(main())
</code></pre>
<h2 id="使用websocket-訂閱幣安-orderbook--100ms"><a class="header" href="#使用websocket-訂閱幣安-orderbook--100ms">使用Websocket 訂閱幣安 orderbook  100ms</a></h2>
<pre><code class="language-python">import asyncio
import json
import websockets

async def fetch_depth(symbol):
    while True:
        try:
            async with websockets.connect(f'wss://stream.binance.com:9443/ws/{symbol}@depth@100ms') as websocket:
                while True:
                    depth = await websocket.recv()
                    depth = json.loads(depth)
                    print(depth)
        except websockets.exceptions.ConnectionClosed:
            print(f'Connection to {symbol} WebSocket closed, reconnecting...')

async def main():
    tasks = [
        asyncio.create_task(fetch_depth('btcusdt')),
        asyncio.create_task(fetch_depth('ethusdt'))
    ]
    await asyncio.gather(*tasks)

asyncio.run(main())
</code></pre>
<h2 id="如何獲取-sma-等技術指標"><a class="header" href="#如何獲取-sma-等技術指標">如何獲取 SMA 等技術指標？</a></h2>
<p>我們已經討論瞭如何將 DataFrame 輸出為 CSV 檔。你可以用 Python Pandas 做更多的事情，計算移動平均線就是其中之一。</p>
<p>下面是一個示例：</p>
<pre><code class="language-python">import btalib
import pandas as pd

# load DataFrame
btc_df = pd.read_csv('btc_bars3.csv', index_col=0)
btc_df.set_index('date', inplace=True)
btc_df.index = pd.to_datetime(btc_df.index, unit='ms')

# calculate 20 moving average using Pandas
btc_df['20sma'] = btc_df.close.rolling(20).mean()
print(btc_df.tail(5))
</code></pre>
<p>在上面的代碼中，我們從之前創建的CSV檔載入了數據。然後，我們使用mean（） 函數來計算收盤列上的平均值。</p>
<p>滾動函數允許我們為移動平均線設置一個週期。所有這些內容都將附加到現有的數據幀中。這就是結果的樣子。</p>
<p><img src="cryptotrade/binance/images/20sma_dataframe.jpg" alt="img" /></p>
<p>如您所見，已使用 20 移動平均線創建了一個新列。</p>
<p>假設您只需要知道移動平均線現在的位置。或者從數據幀中的最後一個價位開始。</p>
<p>我們可以使用相同的 mean（） 函數，只需在 DataFrame 的最後 20 行上運行它，如下所示：</p>
<pre><code class="language-python"># calculate just the last value for the 20 moving average
mean = btc_df.close.tail(20).mean()
</code></pre>
<p>熊貓可以做的還有很多。我們可以很容易地抓住今年交易的最高價格比特幣，如下所示 –</p>
<pre><code class="language-python"># get the highest closing price in 2020
max_val = btc_df.close['2020'].max()
</code></pre>
<p>但Pandas無法計算其他技術指標，如RSI或MACD。幣安 API 也不提供此資訊。</p>
<p>TA-LIB一直是一個流行的庫一段時間了。我們最近有機會測試了一個新的庫 – bta-lib。</p>
<p>該庫由Backtrader的作者創建。他在博客上討論TA-LIB有幾個指標實施不當。</p>
<p>此外，TA-LIB不是為Python設計的。有一個可用的包裝器，但是為Python設計的解決方案的開銷要少得多。</p>
<p>可以使用 PIP 安裝 Bta-lib，如下所示。</p>
<pre><code>pip install bta-lib
</code></pre>
<p>讓我們嘗試用庫計算相同的移動平均線作為比較 –</p>
<pre><code class="language-python">sma = btalib.sma(btc_df.close)
print(sma.df)
</code></pre>
<p>現在，我們有一個單獨的數據幀，其中包含移動平均線的值。它看起來像這樣：</p>
<p><img src="cryptotrade/binance/images/btalib_20sma.jpg" alt="img" /></p>
<p>請注意，bta-lib 將返回一個對象到我們的 sma 變數。若要訪問其中包含的數據幀，只需在變數名稱後鍵入即可。<code>.df</code></p>
<p>默認情況下，該庫使用 30 週期移動平均線。</p>
<p>我們可以複製我們之前的相同函數，並計算20條移動平均線，並將其作為列附加到我們原來的DataFrame上，就像這樣。</p>
<pre><code class="language-python"># create sma and attach as column to original df
btc_df['sma'] = btalib.sma(btc_df.close, period=20).df
print(btc_df.tail())
</code></pre>
<p>讓我們再創建幾個指標。以下是我們使用bta-lib庫計算RSI的方法 –</p>
<pre><code class="language-python">rsi = btalib.rsi(btc_df, period=14)
</code></pre>
<p>再次返回包含 df 的物件。我們可以像這樣訪問最後一個值。</p>
<pre><code class="language-python">print(rsi.df.rsi[-1])
</code></pre>
<p>在實時環境中，您可能只需要最後一個值。</p>
<p>以下是我們如何計算bta-lib中比特幣的MACD。</p>
<pre><code class="language-python">macd = btalib.macd(btc_df, pfast=20, pslow=50, psignal=13)
</code></pre>
<p>最後，我們將把RSI和MACD值加入到我們的原始比特幣價格DataFrame中。</p>
<pre><code class="language-python"># join the rsi and macd calculations as columns in original df
btc_df = btc_df.join([rsi.df, macd.df])
print(btc_df.tail())
</code></pre>
<p>現在，我們可以從一個數據幀輕鬆訪問所有計算 –</p>
<p><img src="cryptotrade/binance/images/btc_df_all_indicators-1024x253-1.jpg" alt="img" /></p>
<h2 id="如何使用幣安api觸發乙太坊訂單"><a class="header" href="#如何使用幣安api觸發乙太坊訂單">如何使用幣安API觸發乙太坊訂單？</a></h2>
<p>我們使用的庫具有一個函數，允許我們創建測試訂單。下面是一個示例：</p>
<pre><code class="language-python">buy_order_limit = client.create_test_order(
    symbol='ETHUSDT',
    side='BUY',
    type='LIMIT',
    timeInForce='GTC',
    quantity=100,
    price=200)
</code></pre>
<p>我們可以確保我們的語法是正確的，而不必提交實時訂單。當您瞭解 API 時，這非常有用。</p>
<p>例如，如果我們將上述代碼中的類型更改為”MARKET”，它將引發異常。原因是<strong>timeInForce</strong>和<strong>價格</strong>參數不用於市場訂單。相反，市場訂單將如下所示：</p>
<pre><code class="language-python">buy_order = client.create_test_order(symbol='ETHUSDT', side='BUY', type='MARKET', quantity=100)
</code></pre>
<p>一旦您滿意語法正確，只需將 替換為 .<code>create_test_order function``create_order function</code></p>
<p>注意：如果您按照示例進行操作，則在將上述限價訂單代碼用於ETHUSDT時，如果自編寫本文以來價格已大幅變動，則可能會收到API錯誤。幣安只允許與硬幣當前交易價格相差一定百分比的訂單。</p>
<p>由於可能存在異常，因此我們將代碼包裝在 try/except 塊中，並從庫中導入一些定義的異常。</p>
<pre><code class="language-python">import os

from binance.client import Client
from binance.enums import *
from binance.exceptions import BinanceAPIException, BinanceOrderException

# init
api_key = os.environ.get('binance_api')
api_secret = os.environ.get('binance_secret')

client = Client(api_key, api_secret)
</code></pre>
<p>除了用戶端和自定義異常之外，我們還導入了 binance.enums，我們稍後將對此進行討論。</p>
<p>這是訂單代碼塊。</p>
<pre><code class="language-python"># create a real order if the test orders did not raise an exception

try:
    buy_limit = client.create_order(
        symbol='ETHUSDT',
        side='BUY',
        type='LIMIT',
        timeInForce='GTC',
        quantity=100,
        price=200)

except BinanceAPIException as e:
    # error handling goes here
    print(e)
except BinanceOrderException as e:
    # error handling goes here
    print(e)
</code></pre>
<p>訂單確認將從交易所發回並存儲在我們的buy_limit變數中。這是它的樣子：</p>
<p><img src="cryptotrade/binance/images/buy_eth.jpg" alt="img" /></p>
<p>它是字典格式。請注意，它包含一個 orderId。我們可以使用此ID來取消像這樣的限價訂單 –</p>
<pre><code class="language-python">    # cancel previous orders
    cancel = client.cancel_order(symbol='ETHUSDT', orderId=buy_limit['orderId'])
</code></pre>
<p>我們再次收到確認。我們可以列印出 cancel 變數來查看它。</p>
<p><img src="cryptotrade/binance/images/cancel_eth_buy.jpg" alt="img" /></p>
<p>該函數是下訂單的主要方法。我們可以在這裡傳遞幾個參數。<code>create_order</code></p>
<p>但是有一些常見的順序，並且已經為它們創建了説明器函數。它們縮短了下訂單所需的代碼，使事情變得容易一些。以下是一些範例：</p>
<pre><code class="language-python">    # same order but with helper function
    buy_limit = client.order_limit_buy(symbol='ETHUSDT', quantity=100, price=200)

    # market order using a helper function
    market_order = client.order_market_sell(symbol='ETHUSDT', quantity=100)
</code></pre>
<p>以下是您可能希望使用的一些幫助程式函數：</p>
<ul>
<li><code>order_limit_buy()</code></li>
<li><code>order_limit_sell()</code></li>
<li><code>order_market_buy()</code></li>
<li><code>order_market_sell()</code></li>
<li><code>order_oco_buy()</code></li>
<li><code>order_ocosell()</code></li>
</ul>
<p>最後兩個被視為高級訂單類型。<strong>OCO</strong>代表<strong>O</strong>ne <strong>C</strong>ancels the <strong>O</strong>ther。</p>
<p>一個很好的例子是當您使用止損和止盈目標時。如果其中一個訂單被擊中，您可能希望另一個訂單被取消。</p>
<p>某些訂單類型需要字串常量，例如**「MARKET」<strong>或</strong>「BUY」。。**另一個經紀人可能會使用「<strong>MKT」 所以</strong>關於你應該使用什麼並不總是有一個合乎邏輯的答案。</p>
<p>如果需要，您可以在文檔中查找這些內容。或者，該庫將硬編碼字串轉換為您可以使用的變數。</p>
<p>如果您的編碼編輯器具有自動完成功能，這將特別有用，因為您可以快速確定要使用的參數，而無需拉出文檔。</p>
<p>下面是一個不使用內置變數的訂單示例：</p>
<pre><code class="language-python">buy_order = client.create_test_order(symbol='ETHUSDT', side='BUY', type='MARKET', quantity=100)
</code></pre>
<p>使用內置變數也是一樣的。</p>
<pre><code class="language-python">buy_order = client.create_test_order(symbol='ETHUSDT', side=SIDE_BUY, type=ORDER_TYPE_MARKET, quantity=100)
</code></pre>
<p>如果計劃採用此路由，則需要前面討論的枚舉導入。</p>
<p>所有硬編碼字串的完整清單可以<a href="https://python-binance.readthedocs.io/en/latest/constants.html#">在這裡</a>找到。</p>
<h2 id="如何使用幣安api實現止損或止盈"><a class="header" href="#如何使用幣安api實現止損或止盈">如何使用幣安API實現止損或止盈？</a></h2>
<p>與其他市場（如股票或外匯）相比，加密貨幣的止損或止盈方法不同。</p>
<p>原因是，對於股票，你有一個基礎貨幣。這通常以美元為單位。一旦你買了一隻股票，你就處於”交易”中。在某些時候，您將希望出售該股票並返回到您的基礎美元貨幣。</p>
<p>對於加密貨幣，實際上沒有基礎貨幣的概念。當您進行交易時，您正在將一種貨幣換成另一種貨幣。系統不會將其視為您最終想要擺脫的”交易”。</p>
<p>因此，幣安不允許您將止損和止盈本機附加到主訂單上。</p>
<p>但是我們仍然可以手動實現一個。</p>
<p>為此，我們可以下OCO訂單。這個想法是，如果止損或止盈被擊中，另一個訂單應該被取消。</p>
<p>回到我們的ETH訂單，以下是我們如何實現止損和止盈。</p>
<pre><code class="language-python">try:
    order = client.create_oco_order(
        symbol='ETHUSDT',
        side='SELL',
        quantity=100,
        price=250,
        stopPrice=150,
        stopLimitPrice=150,
        stopLimitTimeInForce='GTC')

except BinanceAPIException as e:
    # error handling goes here
    print(e)
except BinanceOrderException as e:
    # error handling goes here
    print(e)
</code></pre>
<p>請注意，我們正在傳遞<strong>止損價格</strong>和<strong>止損限價</strong>。一旦<strong>達到止損價格</strong>水準，將使用<strong>止損限價</strong>。在大多數情況下，這兩個參數的價格將相同。</p>
<p>雖然大多數資產都接受止損限價單，但並非所有資產都接受止損限價單。在下訂單之前，最好檢查它是否受支援。</p>
<p>為此，可以使用交換信息終結點。</p>
<pre><code class="language-python"># use exchange info to confirm order types
info = client.get_symbol_info('ETHUSDT')
print(info['orderTypes'])
</code></pre>
<p>以下是回應 –</p>
<p><img src="cryptotrade/binance/images/exchange_info-1-719x1024-1.jpg" alt="img" /></p>
<p>在<strong>orderTypes</strong>下，它表明該資產確實接受止損限值。</p>
<p>這裡還有其他有用的資訊，例如資產是否可以以保證金交易，最小數量和價格變動大小。</p>
<h2 id="如何使用幣安幣bnb獲得交易手續費折扣"><a class="header" href="#如何使用幣安幣bnb獲得交易手續費折扣">如何使用幣安幣（BNB）獲得交易手續費折扣？</a></h2>
<p>幸運的是，幣安有一個交易手續費折扣計劃。</p>
<p><img src="cryptotrade/binance/images/fee_schedule-1011x1024-3.jpg" alt="img" /></p>
<p>The image above shows the fee schedule and discounts for trading the spot market. There are discounts for futures trading too. </p>
<p>You can either qualify for a discount depending on your trading volume or the quantity of Binance coin you own.</p>
<p>Binance coin or BNB was created by Binance in 2017. It can be used as a currency although perhaps the more common usage for it is to pay trading fees.</p>
<p>If you’re not keen on owning BNB, it still makes sense to own just a little bit to pay your trading fees with. After all, any amount of BNB will qualify you for the first tier.</p>
<p>Keep in mind, if you’re using BNB to pay for trading fees, your balance will reduce over time.</p>
<p>The function below ensures there is a minimum amount of BNB in your account and tops it up if there isn’t.</p>
<pre><code class="language-python">def topup_bnb(min_balance: float, topup: float):
	''' Top up BNB balance if it drops below minimum specified balance '''
	bnb_balance = client.get_asset_balance(asset='BNB')
	bnb_balance = float(bnb_balance['free'])
	if bnb_balance &lt; min_balance:
		qty = round(topup - bnb_balance, 5)
		print(qty)
		order = client.order_market_buy(symbol='BNBUSDT', quantity=qty)
		return order
	return False
</code></pre>
<p>Trading scripts are usually run in a loop, so periodically calling the above function will ensure there is enough BNB in the account to qualify for the minimum discount.</p>
<p>As an example, we can call the above function like this – </p>
<pre><code class="language-python">min_balance = 1.0
topup = 2.5
order = topup_bnb(min_balance, topup)
</code></pre>
<p>這將檢查至少1 BNB的餘額。如果BNB的金額低於此值，它將使其達到2.5 BNB。</p>
<p>要使用BNB支付交易費用並獲得折扣，需要啟用它。在幣安主頁面中，登錄後按兩下右上角的個人資料圖標。</p>
<p>第一個選項應該是您的電子郵件位址，按下該位址以訪問您的儀錶板。從那裡，將有一個看起來像這樣的部分 –</p>
<p><img src="cryptotrade/binance//home/shihyu/github/jason_note/src/cryptotrade/binance/images/BNB_fees.jpg" alt="img" /></p>
<p>在這裡，您可以啟用和禁用使用BNB支付交易費用的選項。</p>
<h2 id="當btc達到一定價格時如何在eth上執行交易"><a class="header" href="#當btc達到一定價格時如何在eth上執行交易">當BTC達到一定價格時，如何在ETH上執行交易？</a></h2>
<p>在下一個示例中，當比特幣突破10，000美元的價格點時，我們將在乙太坊中下達買入訂單。</p>
<p>我們將使用Binance WebSocket來跟蹤比特幣的價格。</p>
<pre><code class="language-python">import os
from time import sleep

from binance.client import Client
from binance import ThreadedWebsocketManager

# init
api_key = os.environ.get('binance_api')
api_secret = os.environ.get('binance_secret')
client = Client(api_key, api_secret)
price = {'BTCUSDT': None, 'error': False}
</code></pre>
<p>上面的代碼看起來與前面的示例非常相似，我們在前面的例子中展示瞭如何使用 WebSocket。</p>
<pre><code class="language-python">def btc_pairs_trade(msg):
    ''' define how to process incoming WebSocket messages '''
    if msg['e'] != 'error':
        price['BTCUSDT'] = float(msg['c'])
    else:
        price['error'] = True
</code></pre>
<p>接下來，我們有回調函數。這是所有 WebSocket 數據流經的地方。我們也可以在這裡對交易邏輯進行程式設計。</p>
<p>但是，由於我們需要對訂單輸入使用 try/except 塊，因此最好不要這樣做，因為這可能會干擾在庫中的後端進行的錯誤檢查。</p>
<p>我們將啟動 WebSocket 並將其定向到我們剛剛創建的函數。<code>btc_pairs_trade</code></p>
<pre><code class="language-python">bsm = ThreadedWebsocketManager()
bsm.start()
bsm.start_symbol_ticker_socket(symbol='BTCUSDT', callback=btc_pairs_trade)
</code></pre>
<p>在開始之前，請快速檢查以確保我們有數據。</p>
<pre><code class="language-python">while not price['BTCUSDT']:
    # wait for WebSocket to start streaming data
    sleep(0.1)
</code></pre>
<p>一旦WebSocket用新值填充我們的價格字典，上述無限迴圈就會中斷。</p>
<p>關於主要的交易邏輯。</p>
<pre><code class="language-python">while True:
    # error check to make sure WebSocket is working
    if price['error']:
        # stop and restart socket
	bsm.stop()
	sleep(2)
	bsm.start()
        price['error'] = False

    else:
        if price['BTCUSDT'] &gt; 10000:
            try:
                order = client.order_market_buy(symbol='ETHUSDT', quantity=100)
                break
            except Exception as e:
                print(e)

    sleep(0.1)
</code></pre>
<p>在這裡，我們正在檢查價格是否高於我們的參數，在這種情況下為10，000美元。如果是這樣，我們會發送市場訂單以購買ETHUSDT。</p>
<p>在發送買入訂單後，我們打破迴圈，我們的腳本完成。</p>
<p>不要忘記正確終止 WebSocket</p>
<pre><code class="language-python">bsm.stop()
</code></pre>
<h2 id="當btc在過去5分鐘內移動5時如何執行eth交易"><a class="header" href="#當btc在過去5分鐘內移動5時如何執行eth交易">當BTC在過去5分鐘內移動5%時，如何執行ETH交易？</a></h2>
<p>我們將再次做出基於比特幣的乙太坊交易決策。儘管在此示例中，我們正在尋找過去五分鐘內大於5%的價格變動。</p>
<p>因此，如果比特幣漲幅超過5%，我們就會買入乙太坊。如果它下跌超過5%，我們將出售乙太坊。</p>
<p>由於我們可能在這裡持有空頭頭寸，因此我們將交易期貨。在現貨市場上，只有當您已經擁有該加密貨幣時，您才能出售。</p>
<p>我們的導入和腳本的大部分初始部分都沒有改變。這裡的主要區別在於我們使用Pandas，因為我們將從WebSocket的傳入數據存儲到DataFrame中。</p>
<pre><code class="language-python">import os
from time import sleep

import pandas as pd
from binance import ThreadedWebsocketManager
from binance.client import Client

# init
api_key = os.environ.get('binance_api')
api_secret = os.environ.get('binance_secret')
client = Client(api_key, api_secret)
price = {'BTCUSDT': pd.DataFrame(columns=['date', 'price']), 'error': False}
</code></pre>
<p>因此，我們導入了Pandas，並在價格字典中創建了一個空白的數據幀。數據幀有兩列，一列用於日期，或者更確切地說是時間。另一列將持有價格。</p>
<p>回調函數包含用於從 WebSocket 數據填充數據幀的代碼。</p>
<pre><code class="language-python">def btc_pairs_trade(msg):
	''' define how to process incoming WebSocket messages '''
    if msg['e'] != 'error':
        price['BTCUSDT'].loc[len(price['BTCUSDT'])] = [pd.Timestamp.now(), float(msg['c'])]
    else:
        price['error'] = True
</code></pre>
<p>我們使用該函數通過最後一個索引值將數據追加到 DataFrame 中。我們使用數據幀的長度來確定索引值。<code>.loc</code></p>
<p>此時，我們只是插入當前時間（使用 Pandas 中的時間戳函數獲得）和來自套接字流的價格。</p>
<p>現在我們已經創建了回調函數，我們將啟動 WebSocket。</p>
<pre><code class="language-python"># init and start the WebSocket
bsm = ThreadedWebsocketManager()
bsm.start()
bsm.start_symbol_ticker_socket(symbol='BTCUSDT', callback=btc_pairs_trade)
</code></pre>
<p>再一次，我們將進行快速檢查，以確保數據正在流式傳輸。</p>
<pre><code class="language-python">## main
while len(price['BTCUSDT']) == 0:
	# wait for WebSocket to start streaming data
	sleep(0.1)
	
sleep(300)
</code></pre>
<p>在開始主交易邏輯之前，我們將把腳本休眠五分鐘，因為我們至少需要那麼多數據。</p>
<pre><code class="language-python">while True:
	# error check to make sure WebSocket is working
    if price['error']:
        # stop and restart socket
        bsm.stop()
	sleep(2)
        bsm.start()
        price['error'] = False
    else:
		df = price['BTCUSDT']
		start_time = df.date.iloc[-1] - pd.Timedelta(minutes=5)
		df = df.loc[df.date &gt;= start_time]
		max_price = df.price.max()
		min_price = df.price.min()
</code></pre>
<p>在主迴圈中，我們首先從字典檔中獲取DataFrame並將其分配給變數<strong>df</strong>。此步驟不是必需的，但會使我們的示例中的代碼更易於閱讀。</p>
<p>接下來，我們確定五分鐘前的時間。我們可以通過從DataFrame中獲取最後一個日期值並使用Pandas內置的Timedelta函數減去5分鐘來做到這一點。我們將此值分配給變數start_time。</p>
<p>使用<strong>start_time</strong>值，我們可以向下篩選數據幀，使其僅包含最後五分鐘的數據。</p>
<p>從那裡，我們可以使用Pandas的max（）和min（）函數來找到最高和最低的價格。</p>
<p>現在我們需要做的就是確定最後一個價格與最大值或最小值之間的變動是否大於5%。</p>
<pre><code class="language-python">		if df.price.iloc[-1] &lt; max_price * 0.95:
			try:
				order = client.futures_create_order(symbol='ETHUSDT', side='SELL', type='MARKET', quantity=100)
				break
			except Exception as e:
				print(e)

		elif df.price.iloc[-1] &gt; min_price * 1.05:
			try:
				order = client.futures_create_order(symbol='ETHUSDT', side='BUY', type='MARKET', quantity=100)
				break
			except Exception as e:
				print(e)

	sleep(0.1)
</code></pre>
<p>如果最新價格比上一個值大5%，我們知道比特幣正在上漲，我們將做空乙太坊作為我們均值回歸策略的一部分。</p>
<p>如果最後一個價格比數據幀中的最高價格低 5%，那麼我們就會反其道而行之。</p>
<p>請注意，該庫沒有期貨市場訂單的説明器函數，因此我們使用的方法類似於用於現貨市場的create_order函數。</p>
<p>再一次，如果我們的訂單被填滿，我們將打破我們的主循環並正確終止WebSocket。</p>
<pre><code># properly stop and terminate WebSocket
bsm.stop()
</code></pre>
<p>但是，你的策略可能是無限期運行的策略。如果您不打算在下訂單後突破，最好將腳本置於睡眠狀態一段時間。</p>
<p>否則，每逢價格變動時都會發送新訂單，直到 5% 的背離缺口關閉。</p>
<h2 id="出處-3"><a class="header" href="#出處-3">出處</a></h2>
<p>https://www.coreenginepro.com/python/python-binance-api-%e6%95%99%e5%ad%b8-4-%e6%8a%80%e8%a1%93%e6%8c%87%e6%a8%99%e5%88%86%e6%9e%90/</p>
<hr />
<pre><code class="language-python">from binance.client import Client
import pandas as pd
import matplotlib.pyplot as plt
import os
import json


class binanceAPI:
    def __init__(self, configPath):
        with open(configPath, &quot;r&quot;) as f:
            self.kw_login = json.loads(f.read())
        self.api = self.__login(self.kw_login[&quot;PUBLIC&quot;], self.kw_login[&quot;SECRET&quot;])

    def __login(self, PUBLIC, SECRET):
        return Client(api_key=PUBLIC, api_secret=SECRET)


if __name__ == &quot;__main__&quot;:
    cols = [
        &quot;timestamp&quot;,
        &quot;open&quot;,
        &quot;high&quot;,
        &quot;low&quot;,
        &quot;close&quot;,
        &quot;volume&quot;,
        &quot;close_time&quot;,
        &quot;quote_av&quot;,
        &quot;trades&quot;,
        &quot;tb_base_av&quot;,
        &quot;tb_quote_av&quot;,
        &quot;ignore&quot;,
    ]
    &quot;&quot;&quot;
    Jan
    Feb
    Mar
    Apr
    May
    Jun
    Jul
    Aug
    Sep
    Oct
    Nov
    Dec
    &quot;&quot;&quot;
    # client = binanceAPI(os.environ[&quot;HOME&quot;] + f&quot;/.mybin/jason/binance_login.txt&quot;)
    # klines = client.api.get_historical_klines(
    #    &quot;BTCUSDT&quot;, &quot;1m&quot;, &quot;1 JAN, 2022&quot;, &quot;20 JUN, 2023&quot;
    # )
    # df = pd.DataFrame(klines, columns=cols)
    # df[&quot;timestamp&quot;] = pd.to_datetime(df[&quot;timestamp&quot;], unit=&quot;ms&quot;)
    # df[&quot;close&quot;] = df[&quot;close&quot;].astype(float)
    # df[&quot;change&quot;] = round(df[&quot;close&quot;].pct_change() * 100, 4)
    # df = df.set_index(&quot;timestamp&quot;)
    # print(df)
    # df.to_csv(&quot;BTCUSDT_1m.csv&quot;)

    # Load the DataFrame from the CSV file
    df = pd.read_csv(&quot;BTCUSDT_1m.csv&quot;, index_col=&quot;timestamp&quot;)
    df[&quot;change&quot;] = df[&quot;change&quot;].astype(float)

    # Create a line chart for the &quot;change&quot; column
    plt.plot(df[&quot;change&quot;])

    # Add a title and axis labels
    plt.title(&quot;BTCUSDT 1m Change&quot;)
    plt.xlabel(&quot;Time&quot;)
    plt.ylabel(&quot;Change (%)&quot;)

    # Display the chart
    plt.show()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="如何將oco訂單發送到幣安"><a class="header" href="#如何將oco訂單發送到幣安">如何將OCO訂單發送到幣安</a></h2>
<p>我想請你幫忙。我正在嘗試將python代碼從通過api到Binance發送限價/市價訂單更改為OCO訂單。我可以做限價單，市價單，止損限價單。我不知道該如何下OCO訂單...</p>
<p>當我使用限價單時，我發送的是order_type = ORDER_TYPE_LIMIT，然後我使用order = client.create_order（），它可以正常工作。當我想發送市價單時，我使用了order_type = ORDER_TYPE_MARKET，但是當我要進行OCO訂單時，我發現唯一可行的選擇是：order = client.create_oco_order（）而沒有order_type，但是在這裡我遇到了錯誤1013止損不支持此符號...</p>
<p>我檢查了https://api.binance.com/api/v1/exchangeInfo</p>
<p>並有以下“ orderTypes”：[“ LIMIT”，“ LIMIT_MAKER”，“ MARKET”，“ STOP_LOSS_LIMIT”，“ TAKE_PROFIT_LIMIT”]，“ icebergAllowed”：true，“ ocoAllowed”：true，</p>
<p>所以我不能使用order_type。沒有ORDER_TYPE_OCO，ocoAllowed為true，所以我應該能夠發送oco訂單。但是我收到“錯誤1013：此代碼不支持止損定單。定單失敗”。</p>
<p>我想要的是將“價格”設置為限價賣出訂單，以在價格到達那裡時獲得更高的獲利，並在價格下跌時將止損“ stopPrice”設置得更低... 這就是OCO的工作方式。</p>
<p>有人可以給我一個建議怎麼做嗎？我不是python專家，我只是在更改一個發現的代碼，我的理解是，如果允許oco，也應該允許止損。謝謝</p>
<hr />
<p>為了使所有感興趣的人都能找到有關此問題的解決方案的準確答案，我將代碼包含在注釋中。</p>
<p>我將使用<strong>OCO賣單</strong>作為BTCUSDT中的示例。</p>
<p>假設我有1個BTC。當前價格為30157.85，我想在32000.07賣出更高的1個BTC</p>
<p>但是價格沒有上漲並開始下跌，因此我將止損價設置為29283.03，在該價格處以29000.00的價格開立限價賣單。</p>
<p>這意味著我將以32000.07或29000.00 USDT的價格賣出。該命令的編寫方式如下：</p>
<pre><code>order= client.order_oco_sell(
    symbol= 'BTCUSDT',                                            
    quantity= 1.00000,                                            
    price= '32000.07',                                            
    stopPrice= '29283.03',                                            
    stopLimitPrice= '29000.00',                                            
    stopLimitTimeInForce= 'FOK')
</code></pre>
<h2 id="生效時間訂單"><a class="header" href="#生效時間訂單"><strong>生效時間訂單</strong></a></h2>
<p>生效時間指的是您的訂單在被執行或過期之前維持有效的時間。這樣可以讓您更具體的掌握時間參數，您可以在下單時自訂時間。</p>
<p>幣安提供 GTC (有效直到取消)、IOC (立即成交或取消) 或 FOK (全部成交或取消) 等訂單選項：</p>
<ul>
<li><strong>GTC (有效直到取消)</strong>：訂單將維持有效到成交或被您取消。</li>
<li><strong>IOC (立即成交或取消)</strong>：以可用價格及數量立即嘗試成交全部或部分訂單，然後取消剩餘未成交的訂單部分。如果您下單時所選擇的價格沒有可供應的數量，訂單將會立即被取消。請注意，此訂單類型不支持冰山委託。</li>
<li><strong>FOK (全部成交或取消)</strong>：訂單必須立即完全成交 (全部成交)，否則將被取消 (完全取消)。請注意，此訂單類型不支持冰山委託。</li>
</ul>
<p>請注意，OCO訂單需要stopLimitTimeInForce參數。我使用了'FOK'值，但在這裡給您留下了可以使用的不同值的描述：<a href="https://help.bybit.com/hc/en-us/articles/360039749233-What-are-time-in-force-TIF-GTC-IOC-FOK-">https</a> : <a href="https://help.bybit.com/hc/en-us/articles/360039749233-What-are-time-in-force-TIF-GTC-IOC-FOK-">//help.bybit.com/hc/zh-CN/articles/360039749233-What-are-time-有效TIF-GTC-IOC-FOK-</a></p>
<p>請注意，price，stopPrice，stopLimitPrice和stopLimitTimeInForce參數是字符串，而不是浮點數或十進制數。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-git-lfs-上傳大型檔案"><a class="header" href="#使用-git-lfs-上傳大型檔案">使用 Git LFS 上傳大型檔案</a></h1>
<p>https://ithelp.ithome.com.tw/articles/10229654</p>
<p>專案開發過程中，檔案越來越大在所難免，GitHub 限制單一檔案 100 MB 的限制，這時候就需要交由 <strong>LFS</strong> 這個功能，來解決類似以下的錯誤訊息。</p>
<pre><code class="language-bash">remote: warning: Large files detected.
remote: error: File large_file is 123.00 MB; this exceeds GitHub's file size limit of 100 MB
</code></pre>
<h2 id="安裝-git-lfs"><a class="header" href="#安裝-git-lfs">安裝 Git LFS</a></h2>
<h3 id="安裝命令"><a class="header" href="#安裝命令">安裝命令</a></h3>
<ul>
<li>
<p>Linux</p>
<p>依序輸入以下指令</p>
</li>
</ul>
<pre><code class="language-bash">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
sudo apt-get install git-lfs
git lfs install
</code></pre>
<ul>
<li>
<p>MacOS</p>
<p>依序輸入以下指令，如果不能執行 <code>brew</code> 相關指令，參考 <a href="https://brew.sh/index_zh-tw">這裡</a> 安裝 HomeBrew 。</p>
</li>
</ul>
<pre><code class="language-bash">brew install git-lfs
git lfs install
</code></pre>
<ul>
<li>
<p>Windows</p>
<p>下載安裝 <a href="https://git-lfs.github.com/">Git Large File Storage (LFS)</a></p>
</li>
</ul>
<p>執行安裝檔，安裝完畢後，回到專案終端機，輸入</p>
<pre><code class="language-bash">git lfs install
</code></pre>
<h2 id="將檔案交由-lfs-管理"><a class="header" href="#將檔案交由-lfs-管理">將檔案交由 LFS 管理</a></h2>
<p><code>*</code> 表示所有檔案， <code>.psd</code> 表示副檔名為 .psd 的檔案，所以 lfs 會管理所有副檔名為 .psd 的檔案，若有多個附檔名要管理，請一一執行命令，或參考 <a href="https://www.jianshu.com/p/64e3137cbc22">這裡</a> 的第四點。</p>
<pre><code class="language-bash">git lfs track &quot;*.psd&quot;
</code></pre>
<h2 id="接著-push-專案"><a class="header" href="#接著-push-專案">接著 Push 專案</a></h2>
<p>LFS 管理大型檔案後，繼續執行 <code>git add</code> <code>git commit</code> <code>git push</code> 命令即可。</p>
<div style="break-before: page; page-break-before: always;"></div><p>出處： https://magiclen.org/git-remove-commited-files/</p>
<p>在使用Git進行程式專案或是其它任何專案的版本控制時，通常會使用<code>.gitignore</code>檔案來讓Git在使用<code>add</code>將檔案納入Git的版本控制清單的時，過濾掉指定的目錄或檔案。通常這些被過濾的檔案是由專案在進行建置時所產生出來的任何檔案，以及一些使用者需要自行修改或是建立的設定檔(例如存放資料庫登入資訊的設定檔)。但我們都是人，難免會忘記把要過濾掉的檔案加進<code>.gitignore</code>中，而使得該檔案不小心被commit進我們的倉庫之中。有時候不小心commit進去的甚至是大小超過數十MB的檔案，或是一些存放著帳號密碼、金鑰等與安全性直接相關的設定檔，這可就不太妙了。</p>
<p>一旦Git中的大檔愈多，在進行<code>git clone</code>的時候就會變得愈來愈慢，而且GitHub、BitBucket等主流的Git遠端倉庫服務商，通常會限制倉庫中單一檔案的大小與整個倉庫的大小。</p>
<p>您可能會問：難道不小心commit進Git的檔案，不是直接在專案底下刪掉後，再重新commit就好了嗎？……OK，我們來做個小小的實驗吧！</p>
<p>假設有個專案，只有<code>Hello World</code>這個二進制檔，存在於專案的根目錄中。我們先將目前工作目錄移動到這個專案的根目錄，接著使用以下指令來初始化Git。</p>
<blockquote>
<p>git init</p>
</blockquote>
<p>然後使用以下指令，將<code>Hello World</code>檔案加進Git的版本控制清單中。</p>
<blockquote>
<p>git add Hello\ World</p>
</blockquote>
<p>接著使用以下指令來進行commit。</p>
<blockquote>
<p>git commit -m 'Hello!'</p>
</blockquote>
<p><img src="git/images/shot-02.png" alt="" /></p>
<p>然後用以下指令將<code>Hello World</code>檔案從專案中刪除。</p>
<blockquote>
<p>rm Hello\ World</p>
</blockquote>
<p>然後再次使用以下指令，將專案的根目錄加進Git的版本控制清單中。</p>
<blockquote>
<p>git add .</p>
</blockquote>
<p>接著使用以下指令來進行commit。</p>
<blockquote>
<p>git commit -m 'Delete Hello World'</p>
</blockquote>
<p><img src="git/images/shot-03.png" alt="" /></p>
<p>然後執行以下指令，暫時回到前一個commit時的狀態。</p>
<blockquote>
<p>git checkout HEAD~1</p>
</blockquote>
<p>最後執行<code>ls</code>指令，列出目前專案根目錄底下有哪些檔案。</p>
<p><img src="git/images/shot-04.png" alt="" /></p>
<p>如上圖，看到沒？原本被我們的刪除的<code>Hello World</code>檔案又跑出來了！它根本就沒有被刪除嘛！</p>
<h3 id="刪除git中已經被commit的檔案"><a class="header" href="#刪除git中已經被commit的檔案">刪除Git中已經被commit的檔案</a></h3>
<h4 id="顯示目前專案的git倉庫究竟佔用了多少空間"><a class="header" href="#顯示目前專案的git倉庫究竟佔用了多少空間">顯示目前專案的Git倉庫究竟佔用了多少空間</a></h4>
<p>以下指令，可以顯示目前專案的Git倉庫所佔用的檔案空間：</p>
<blockquote>
<p>git count-objects -vH</p>
</blockquote>
<p><code>size</code>欄位加上<code>size-pack</code>欄位所顯示的值就是Git倉庫所佔用的檔案空間。</p>
<p><img src="git/images/shot-05.png" alt="" /></p>
<p>如上圖，可知目前筆者這個Android專案的Git倉庫居然佔用了1.47 GiB的空間。</p>
<h4 id="將git倉庫中的檔案依照大小排序並顯示出來"><a class="header" href="#將git倉庫中的檔案依照大小排序並顯示出來">將Git倉庫中的檔案依照大小排序並顯示出來</a></h4>
<p>以下指令，可以列出目前Git倉庫中的所有檔案，並且按照檔案大小來排序：</p>
<pre><code class="language-bash">git rev-list --objects --all | git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | sed -n 's/^blob //p' | sort --numeric-sort --key=2 | cut -c 1-12,41- | $(command -v gnumfmt || echo numfmt) --field=2 --to=iec-i --suffix=B --padding=7 --round=nearest
</code></pre>
<p><img src="git/images/shot-06.png" alt="" /></p>
<p><a href="https://img.magiclen.org/albums/git-remove-commited-files/shot-07.png"><img src="https://img.magiclen.org/albums/git-remove-commited-files/shot-07.png" alt="git-remove-commited-files" /></a></p>
<p>如上圖，基本上可以看出筆者的這個Git倉庫把Android所建置出來的APK檔也加進來了，所以才會那麼肥大。</p>
<p>這個指令有個要注意的地方是，如果有同樣的檔案但儲存在不同的路徑，只會顯示出其中一個路徑哦！在之後要刪除的時候必須要把每個路徑的該檔案都刪除，該檔案才會真正地從Git倉庫中移除。</p>
<h4 id="確認要排除在git之外的檔案是否已經在gitignore中"><a class="header" href="#確認要排除在git之外的檔案是否已經在gitignore中">確認要排除在Git之外的檔案，是否已經在<code>.gitignore</code>中</a></h4>
<p>以下指令，可以檢查要排除在Git之外的檔案，是否已經在<code>.gitignore</code>中：</p>
<blockquote>
<p>git add . &amp;&amp; git ls-files --error-unmatch 檔案路徑</p>
</blockquote>
<p>這邊的<code>檔案路徑</code>是指檔案在Git倉庫中的路徑。</p>
<p><img src="git/images/shot-12.png" alt="" /></p>
<p>如果在執行指令後，看到螢幕上顯示：</p>
<blockquote>
<p>error: pathspec '檔案路徑' did not match any file(s) known to git.</p>
</blockquote>
<p>表示目前那個檔案已經在<code>.gitignore</code>中了。</p>
<h4 id="將要排除在git之外的檔案加進gitignore中"><a class="header" href="#將要排除在git之外的檔案加進gitignore中">將要排除在Git之外的檔案加進<code>.gitignore</code>中</a></h4>
<p>Git倉庫底下的<code>.gitignore</code>檔案可以設定要排除加入的檔案或是目錄。如果您不知道怎麼設定，可以在以下這個網站搜尋到很多針對不同程式語言和IDE用的<code>.gitignore</code>模板。</p>
<blockquote>
<p>https://www.gitignore.io/</p>
</blockquote>
<p>在修改完<code>.gitignore</code>後，執行以下指令來重新套用：</p>
<blockquote>
<p>git rm -r --cached .</p>
</blockquote>
<p><img src="git/images/shot-08.png" alt="" /></p>
<p>如果有需要的話，可以立刻再重新將專案根目錄加進版本控制清單中，並再commit一次，指令如下：</p>
<blockquote>
<p>git add . &amp;&amp; git commit -m 'update .gitignore'</p>
</blockquote>
<p><img src="git/images/shot-09.png" alt="" /></p>
<h4 id="將已經被commit進git倉庫的檔案刪除"><a class="header" href="#將已經被commit進git倉庫的檔案刪除">將已經被commit進Git倉庫的檔案刪除</a></h4>
<p>以下指令，可以把已經被commit進Git倉庫的檔案或整個目錄給刪除：</p>
<blockquote>
<p>git filter-branch --force --tree-filter 'rm -f -r &quot;檔案路徑&quot;' -- --all</p>
</blockquote>
<p>這邊的<code>檔案路徑</code>是指檔案在Git倉庫中的路徑，不支援wildcard寫法。注意這個指令會直接將有包含指定檔案的commit進行修改，而導致該commit的雜湊值以及這個commit之後的所有commit的雜湊值都會發生變化。</p>
<p><img src="git/images/shot-14.png" alt="" /></p>
<p>另外還一點要注意的是，在執行一次以上指令之後，就算有確實將指定的檔案刪除掉，再次使用這篇文章先前提到的將Git倉庫中的檔案顯示出來的指令，也可能還是會看到那個應該已經要被刪除掉的檔案仍然出現在清單中，它會在這個Git倉庫有其它變動(例如建立新的commit)後，檔案列表才會跟著刷新。</p>
<p>如果要立刻刷新檔案列表，可以執行以下指令：</p>
<blockquote>
<p>git filter-branch --force</p>
</blockquote>
<h4 id="清除git的reflog並手動調用垃圾回收機制"><a class="header" href="#清除git的reflog並手動調用垃圾回收機制">清除Git的Reflog並手動調用垃圾回收機制</a></h4>
<p>以下指令，可以清除Git的Reflog並手動調用垃圾回收機制，來即時讓Git倉庫將可用空間釋放出來。如果並非迫切地需要釋出空間，建議不要執行這個指令。</p>
<blockquote>
<p>git reflog expire --expire=now --expire-unreachable=now --all &amp;&amp; git gc --prune=all --aggressive</p>
</blockquote>
<h4 id="覆蓋遠端的git倉庫"><a class="header" href="#覆蓋遠端的git倉庫">覆蓋遠端的Git倉庫</a></h4>
<p>若您已經不幸地將要排除在Git倉庫之外的檔案給上傳到遠端的Git倉庫，那麼就在處理好本地端的Git倉庫之後，使用以下指令來覆蓋遠端的commit吧！</p>
<blockquote>
<p>git push --force --all</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="常用指令"><a class="header" href="#常用指令">常用指令</a></h2>
<ul>
<li>
<p><code>git init</code></p>
<p>建立新的本地端 Repository。</p>
</li>
<li>
<p><code>git clone [Repository URL]</code></p>
<p>複製遠端的 Repository 檔案到本地端。</p>
</li>
<li>
<p><code>git status</code></p>
<p>檢查本地端檔案異動狀態。</p>
</li>
<li>
<p><code>git add [檔案或資料夾]</code></p>
<p>將指定的檔案（或資料夾）加入版本控制。用 <code>git add .</code> 可加入全部。</p>
</li>
<li>
<p><code>git commit</code></p>
<p>提交（commit）目前的異動。</p>
</li>
<li>
<p><code>git commit -m &quot;提交說明內容&quot;</code></p>
<p>提交（commit）目前的異動並透過 <code>-m</code> 參數設定摘要說明文字。</p>
</li>
<li>
<p><code>git stash</code></p>
<p>獲取目前工作目錄的 dirty state，並保存到一個未完成變更的 stack，以方便隨時回復至當初的 state。</p>
</li>
<li>
<p><code>git log</code></p>
<p>查看先前的 commit 記錄。</p>
</li>
<li>
<p><code>git push</code></p>
<p>將本地端 Repository 的 commit 發佈到遠端。</p>
</li>
<li>
<p><code>git push origin [BRANCH_NAME]</code></p>
<p>發佈至遠端指定的分支（Branch）</p>
</li>
<li>
<p><code>git branch</code></p>
<p>查看分支。</p>
</li>
<li>
<p><code>git branch [BRANCH_NAME]</code></p>
<p>建立分支。</p>
</li>
<li>
<p><code>git checkout [BRANCH_NAME]</code></p>
<p>取出指定的分支。</p>
</li>
<li>
<p><code>git checkout -b [BRANCH_NAME]</code></p>
<p>建立並跳到該分支。</p>
</li>
<li>
<p><code>git branch -D [BRANCH_NAME]</code></p>
<p>強制刪除指定分支（須先切換至其他分支再做刪除）。</p>
</li>
<li>
<p><code>git reset --hard [HASH]</code></p>
<p>強制恢復到指定的 commit（透過 Hash 值）。</p>
</li>
<li>
<p><code>git checkout [HASH]</code></p>
<p>切換到指定的 commit（與 <code>git checkout [BRANCH_NAME]</code> 相同)。</p>
</li>
<li>
<p><code>git branch -m &lt;OLD_BRANCH_NAME&gt; &lt;NEW_BRANCH_NAME&gt;</code></p>
<p>修改分支名稱。</p>
</li>
</ul>
<hr />
<h2 id="git-指令表"><a class="header" href="#git-指令表">Git 指令表</a></h2>
<h3 id="config"><a class="header" href="#config">config</a></h3>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git config --list</code></td><td style="text-align: center"></td><td style="text-align: center">查看設定</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git config --local user.name &quot;(userName)&quot;</code></td><td style="text-align: center"></td><td style="text-align: center">設定帳號</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git config --local user.email &quot;(e-mail)&quot;</code></td><td style="text-align: center"></td><td style="text-align: center">設定E-mail</td><td style="text-align: center">全域</td></tr>
<tr><td style="text-align: left"><code>git config --global user.name &quot;(userName)&quot;</code></td><td style="text-align: center"></td><td style="text-align: center">設定帳號</td><td style="text-align: center">單專案</td></tr>
<tr><td style="text-align: left"><code>git config --global user.email &quot;(e-mail)&quot;</code></td><td style="text-align: center"></td><td style="text-align: center">設定E-mail</td><td style="text-align: center">單專案</td></tr>
</tbody></table>
<h3 id="init--clone"><a class="header" href="#init--clone">init / clone</a></h3>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git clone</code></td><td style="text-align: center"></td><td style="text-align: center">抓遠端儲存庫下來</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git init</code></td><td style="text-align: center"></td><td style="text-align: center">Git 初始化</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>rm -rf .git</code></td><td style="text-align: center"></td><td style="text-align: center">移除 Git</td><td style="text-align: center"></td></tr>
</tbody></table>
<h3 id="remote"><a class="header" href="#remote">remote</a></h3>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git remote add (origin) (git@~.git)</code></td><td style="text-align: center"></td><td style="text-align: center">遠端連結</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git remote set-url (origin) (git@~.git)</code></td><td style="text-align: center">-</td><td style="text-align: center">修改遠端連結</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git remote remove (origin)</code></td><td style="text-align: center">-</td><td style="text-align: center">移除遠端連結</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git remote -v</code></td><td style="text-align: center"></td><td style="text-align: center">查詢遠端連結(URL)</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git push -u (origin) (master)</code></td><td style="text-align: center"></td><td style="text-align: center">推上遠端並綁定</td><td style="text-align: center"></td></tr>
</tbody></table>
<h3 id="基本版更-pull--push--add--commit--status"><a class="header" href="#基本版更-pull--push--add--commit--status">基本版更（ pull / push / add / commit / status）</a></h3>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git status</code></td><td style="text-align: center">gst</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git add (file)</code></td><td style="text-align: center">ga (~)</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git add .</code></td><td style="text-align: center">ga .</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git commit -m'message'</code></td><td style="text-align: center">gcmsg '(~)'</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git pull</code></td><td style="text-align: center">gl</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git push (remote) (branch)</code></td><td style="text-align: center">gp (~) (~)</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git push -u (remote) (branch)</code></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git restore --staged (file)</code></td><td style="text-align: center"></td><td style="text-align: center">取消 git add</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git pull --rebase (remote) (branch)</code></td><td style="text-align: center">gl</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
<h3 id="檔案變更版更操作"><a class="header" href="#檔案變更版更操作">檔案變更版更操作</a></h3>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git clean -fd</code></td><td style="text-align: center">-</td><td style="text-align: center">清除未被追蹤的所有檔案</td><td style="text-align: center">已編輯的會恢復,新增的不會變動</td></tr>
<tr><td style="text-align: left"><code>git checkout (file)</code></td><td style="text-align: center">-</td><td style="text-align: center">當前目錄回復前次存檔</td><td style="text-align: center">(已編輯的會恢復,新增的不會變動)</td></tr>
<tr><td style="text-align: left"><code>git restore (file)</code></td><td style="text-align: center">-</td><td style="text-align: center">當前目錄回復前次存檔</td><td style="text-align: center">(含被刪除的檔)</td></tr>
</tbody></table>
<h3 id="branch-分支應用"><a class="header" href="#branch-分支應用">Branch 分支應用</a></h3>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git branch</code></td><td style="text-align: center">-</td><td style="text-align: center">查詢所有本地分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git branch -a</code></td><td style="text-align: center">-</td><td style="text-align: center">查詢所有遠端分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git branch (newBranch)</code></td><td style="text-align: center">-</td><td style="text-align: center">當前 commit 新建分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git branch (newBranch) (commitID)</code></td><td style="text-align: center">-</td><td style="text-align: center">特定 commit 上新建分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git checkout (branch)</code></td><td style="text-align: center">-</td><td style="text-align: center">切換到某分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git checkout -b (newBranch)</code></td><td style="text-align: center">-</td><td style="text-align: center">新建分支並切換過去</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git branch -d (branch)</code></td><td style="text-align: center">-</td><td style="text-align: center">刪除某分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git branch -D (branch)</code></td><td style="text-align: center">-</td><td style="text-align: center">強制刪除某分支</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git branch -m (branch) (newName)</code></td><td style="text-align: center">-</td><td style="text-align: center">將某 branch 更名</td><td style="text-align: center">必須先切到不同分支</td></tr>
</tbody></table>
<hr />
<h2 id="reset-切到某版本"><a class="header" href="#reset-切到某版本">Reset 切到某版本</a></h2>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git reset (commit)</code></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">預設為'mixed'</td></tr>
<tr><td style="text-align: left"><code>git reset (commit) --mixed</code></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">放回&quot;1-工作目錄&quot;</td></tr>
<tr><td style="text-align: left"><code>git reset (commit) --soft</code></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">放回&quot;2-暫存區&quot;</td></tr>
<tr><td style="text-align: left"><code>git reset (commit) --hard</code></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">都不留(直接被隱藏)</td></tr>
<tr><td style="text-align: left"><code>git reset (commit)^</code></td><td style="text-align: center"></td><td style="text-align: center">退回前1次的commit</td><td style="text-align: center">^^ 退回前2版…</td></tr>
<tr><td style="text-align: left"><code>git reset (commit)~5</code></td><td style="text-align: center"></td><td style="text-align: center">退回前5次的commit</td><td style="text-align: center">~N 退至前N版</td></tr>
</tbody></table>
<ul>
<li>(commit)可以是 branch / commit ID / HEAD</li>
</ul>
<hr />
<h2 id="rebase--merge-合併應用"><a class="header" href="#rebase--merge-合併應用">Rebase &amp; Merge 合併應用</a></h2>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git rebase (branch)</code></td><td style="text-align: center"></td><td style="text-align: center">重接分支基底</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git merge (branch)</code></td><td style="text-align: center"></td><td style="text-align: center">合併分支(平行)</td><td style="text-align: center"></td></tr>
</tbody></table>
<hr />
<h2 id="查詢"><a class="header" href="#查詢">查詢</a></h2>
<table><thead><tr><th style="text-align: left">Git</th><th style="text-align: center">zsh</th><th style="text-align: center">do</th><th style="text-align: center">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>git config --list</code></td><td style="text-align: center"></td><td style="text-align: center">查詢目前設定</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>which git</code></td><td style="text-align: center"></td><td style="text-align: center">查詢 Git 位置</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git --version</code></td><td style="text-align: center"></td><td style="text-align: center">查詢Git版本</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git status</code></td><td style="text-align: center"></td><td style="text-align: center">查詢狀態</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git log</code></td><td style="text-align: center"></td><td style="text-align: center">查詢 Log</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git log --oneline</code></td><td style="text-align: center"></td><td style="text-align: center">查詢 Log(單行顯示)</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git log --oneline --all --graph</code></td><td style="text-align: center"></td><td style="text-align: center">樹狀顯示 Log</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git log -p FileName</code></td><td style="text-align: center"></td><td style="text-align: center">查詢檔案 Log</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git blame FileName</code></td><td style="text-align: center"></td><td style="text-align: center">查詢該檔案每行編輯資訊</td><td style="text-align: center">(上傳者&amp;時間)</td></tr>
<tr><td style="text-align: left"><code>git reflog</code></td><td style="text-align: center"></td><td style="text-align: center">查詢 reflog</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left"><code>git help</code></td><td style="text-align: center"></td><td style="text-align: center">查詢指令</td><td style="text-align: center"></td></tr>
</tbody></table>
<ul>
<li>reflog：reflog　保留HEAD移動的軌跡，可以查詢到commit ID(用於尋找被隱藏的　commit　</li>
</ul>
<hr />
<h3 id="切換到新分支"><a class="header" href="#切換到新分支">切換到新分支</a></h3>
<pre><code>git checkout new_branch
</code></pre>
<h3 id="建立並切換到新分支"><a class="header" href="#建立並切換到新分支">建立並切換到新分支</a></h3>
<pre><code>git checkout -b new_branch
</code></pre>
<h3 id="將本地分支推送到遠端使用-git-push-命令並指定要推送的分支名稱和遠端的分支名稱-git-push--u-origin-branch-name"><a class="header" href="#將本地分支推送到遠端使用-git-push-命令並指定要推送的分支名稱和遠端的分支名稱-git-push--u-origin-branch-name">將本地分支推送到遠端，使用 git push 命令，並指定要推送的分支名稱和遠端的分支名稱 <code>git push -u origin &lt;branch-name&gt;</code></a></h3>
<pre><code>git push -u origin new_branch
</code></pre>
<p>但一般主要的遠端數據庫我們都會把它命名為`` <code>origin</code>，其他特殊作用的遠端數據庫才會刻意命名，後面的操作就都會是以這一個變數名稱為主，接下來執行以下命令：</p>
<p>說明：</p>
<ul>
<li><code>git push</code>：將本地指定分支推送至遠端數據庫</li>
<li><code>-u</code>：同 <code>--set-upstream</code>，設定推送分支的上游</li>
<li><code>origin</code>：要推向哪個遠端數據庫，寫名稱即可 (就是指前面說的 <code>origin</code>)</li>
<li><code>master</code>：指定本地 <code>master</code> 分支進行推送，如果存在 <code>master</code> 分支即合併，不存在即新增</li>
</ul>
<p>這一段可能會比較不好理解，讓我們將上面這段命令完整的寫出來：</p>
<pre><code>git push --set-upstream origin master:master
</code></pre>
<p>複製</p>
<p>首先是 <code>-u</code> 的部分，等同於 <code>--set-upstream</code>，可以使 <code>master</code> 這一個指定的分支開始追蹤遠端的分支，只要做過一次 <code>git push -u origin master</code>，並且成功 Push 出去，本地的 <code>master</code> 分支就會被設定去追蹤遠端的 <code>origin/master</code> 分支，往後再 <code>master</code> 分支直接使用 <code>git push</code> 命令就會推向當時設定的 <code>origin/master</code> 分支，反之，如果沒有設定 <code>-u</code> 就使用 <code>git push</code>，就會導致以下錯誤：</p>
<p><img src="git/images/OUCX1Hl.png" alt="" /></p>
<p>可能有人會想，那我是否可以在不設定 <code>-u</code> 的情況下使用以下指令呢？</p>
<pre><code>git push origin master
</code></pre>
<p>複製</p>
<p>答案是可以的，我們為什麼要設定 <code>-u</code> 就是要方便往後在直接使用 <code>git push</code> 命令時，Git 能夠知道此命令該推向何處，上面這種寫法明確的定義推向何處，結果與 <code>git push -u origin master</code> 一樣，只是我們習慣在第一次推送時，在明確定義該推向何處時，同時也設置往後這個位置就是預設推向的位置，有關 <code>-u</code> 的設定一樣可以到 <code>/.git/config</code> 尋找：</p>
<pre><code>[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master
</code></pre>
<h3 id="刪除的本地分支"><a class="header" href="#刪除的本地分支">刪除的本地分支</a></h3>
<pre><code>git branch -D branch_to_delete
</code></pre>
<h3 id="刪除遠端分支"><a class="header" href="#刪除遠端分支">刪除遠端分支</a></h3>
<pre><code>git push origin --delete branch_to_delete
</code></pre>
<h2 id="git-誤刪分支恢復方法"><a class="header" href="#git-誤刪分支恢復方法">git 誤刪分支恢復方法</a></h2>
<pre><code># 建立分支 abc
git branch abc

# 切換分支
git checkout abc

# 立一個檔案  &amp; commit &amp; push
echo 'abc' &gt; test.txt &amp;&amp;
git add . &amp;&amp;
git commit -m 'add test.txt' &amp;&amp;
git push -u origin abc


# 刪除分支abc
git checkout master
git branch -D abc

# git br查看分支列表，abc分支已不存在
git branch -a

# 使用git log -g 找回之前提交的commit
commit 3eac14d05bc1264cda54a7c21f04c3892f32406a
Reflog: HEAD@{1} (fdipzone &lt;fdipzone@sina.com&gt;)
Reflog message: commit: add test.txt
Author: fdipzone &lt;fdipzone@sina.com&gt;
Date:   Sun Jan 31 22:26:33 2016 +0800

    add test.txt
    
    
# git branch recover_branch[新分支] commit_id命令用這個commit建立一個分支
git branch abc 3eac14d05bc1264cda54a7c21f04c3892f32406a

# 可以見到recover_branch_abc已建立
git branch -a


# 切換到recover_branch_abc分支，檢查檔案是否存在
git checkout recover_branch_abc
</code></pre>

                        <script src="https://utteranc.es/client.js"
                            repo="imxood/imxood.github.io"
                            issue-term="pathname"
                            theme="boxy-light"
                            crossorigin="anonymous"
                            async>
                        </script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom/mermaid.min.js"></script>
        <script type="text/javascript" src="theme/custom/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
