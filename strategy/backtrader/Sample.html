<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sample - Jason Notes</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/custom/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html">Jason Notes</a></li><li class="chapter-item expanded "><a href="../../ubuntu/ubuntu_setup.html">Ubuntu</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ubuntu/command.html">Command</a></li><li class="chapter-item "><a href="../../ubuntu/gcp.html">GCP ssh</a></li></ol></li><li class="chapter-item expanded "><a href="../../android/android.html">Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../android/install_sdk.html">SDK install</a></li></ol></li><li class="chapter-item expanded "><a href="../../tools/tools.html">Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tools/asciinema.html">asciinema 把終端操作錄製成 gif 動畫</a></li><li class="chapter-item "><a href="../../tools/finmind.html">Finmind</a></li><li class="chapter-item "><a href="../../tools/add-enter-and-exit-trace-for-your-function.html">addr2line</a></li><li class="chapter-item "><a href="../../tools/cmake.html">cmake</a></li><li class="chapter-item "><a href="../../tools/network.html">Network</a></li><li class="chapter-item "><a href="../../tools/python-pycryptodome-aes-symmetric-encryption-tutorial-examples.html">實作 AES 對稱式加密</a></li></ol></li><li class="chapter-item expanded "><a href="../../html/html.html">HTML</a></li><li class="chapter-item expanded "><a href="../../vim/vim.html">Vim</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../vim/copilot.html">copilot</a></li><li class="chapter-item "><a href="../../vim/tabnine.html">tabnine</a></li></ol></li><li class="chapter-item expanded "><a href="../../gdb/gdb.html">Gdb</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../gdb/常用指令.html">常用指令</a></li><li class="chapter-item "><a href="../../gdb/jemalloc.html">jemalloc</a></li><li class="chapter-item "><a href="../../gdb/graphs.html">graphs</a></li><li class="chapter-item "><a href="../../gdb/rust-gdb.html">rust gdb</a></li></ol></li><li class="chapter-item expanded "><a href="../../c++/cpp.html">C++</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../c++/benchmark.html">benchmark</a></li><li class="chapter-item "><a href="../../c++/smart_pointer.html">Smart pointer</a></li><li class="chapter-item "><a href="../../c++/l&rvalue.html">L&amp;R value</a></li><li class="chapter-item "><a href="../../c++/move.html">Move</a></li><li class="chapter-item "><a href="../../c++/CAS.html">CAS</a></li><li class="chapter-item "><a href="../../c++/HFT.html">HFT</a></li></ol></li><li class="chapter-item expanded "><a href="../../riscv/riscv.html">RISC-V</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../riscv/qemu_riscv_linux.html">QEMU上運行RISV-V Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../../centos/centos.html">CentOS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../centos/tqdb_setup.html">TQDB 安裝紀錄</a></li></ol></li><li class="chapter-item expanded "><a href="../../ssh/ssh.html">SSH</a></li><li class="chapter-item expanded "><a href="../../network/socket.html">Network</a></li><li class="chapter-item expanded "><a href="../../docker/docker_helloworld.html">Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docker/docker.html">Docker 基本教學</a></li><li class="chapter-item "><a href="../../docker/example.html">簡單範例</a></li><li class="chapter-item "><a href="../../docker/creating-the-perfect-python-dockerfile.html">Perfect python dockerfile</a></li><li class="chapter-item "><a href="../../docker/dockerfile-from-docker-image.html">由 Docker image 反推其 Dockerfile</a></li><li class="chapter-item "><a href="../../docker/python_connect_redis.html">Python連接Redis</a></li><li class="chapter-item "><a href="../../docker/command.html">Command</a></li><li class="chapter-item "><a href="../../docker/docker_compose.html">Docker compose</a></li><li class="chapter-item "><a href="../../docker/docker_compse_example.html">Docker compose example</a></li><li class="chapter-item "><a href="../../docker/python_redis.html">Python-Redis</a></li><li class="chapter-item "><a href="../../docker/redash.html">Redash</a></li><li class="chapter-item "><a href="../../docker/clickhouse.html">ClickHouse</a></li><li class="chapter-item "><a href="../../docker/clickhouse-setup.html">clickhouse-setup</a></li></ol></li><li class="chapter-item expanded "><a href="../../rust/rust.html">Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/note.html">Rust筆記</a></li><li class="chapter-item "><a href="../../rust/basic.html">Rust 基本教學</a></li><li class="chapter-item "><a href="../../rust/ownership.html">Rust 所有權系統</a></li><li class="chapter-item "><a href="../../rust/lifetime.html">Rust 生命週期 (Lifetime)</a></li><li class="chapter-item "><a href="../../rust/type.html">Rust 型別系統</a></li><li class="chapter-item "><a href="../../rust/polars.html">Polars</a></li><li class="chapter-item "><a href="../../rust/rust_call_c.html">Rust call C</a></li><li class="chapter-item "><a href="../../rust/10-rust-an-introduction.html">給 C++ 使用者的 Rust 簡介</a></li><li class="chapter-item "><a href="../../rust/可視化Rust各資料結構的記憶體佈局.html">可視化Rust各資料結構的記憶體佈局</a></li><li class="chapter-item "><a href="../../rust/rust_note.html">學習順序</a></li><li class="chapter-item "><a href="../../rust/overview.html">大局觀</a></li><li class="chapter-item "><a href="../../rust/String.html">理解字串</a></li><li class="chapter-item "><a href="../../rust/easy_rust.html">Easy Rust</a></li><li class="chapter-item "><a href="../../rust/rust_easy.html">Rust 新手</a></li><li class="chapter-item "><a href="../../rust/module.html">Rust 模組結構</a></li><li class="chapter-item "><a href="../../rust/rust_memory.html">Rust與記憶體</a></li><li class="chapter-item "><a href="../../rust/rust_vs_cpp.html">Rust vs C++語法</a></li><li class="chapter-item "><a href="../../rust/rust_file_format.html">Rust 檔案格式</a></li><li class="chapter-item "><a href="../../rust/binary_lib.html">Rust 函數庫/執行檔</a></li><li class="chapter-item "><a href="../../rust/print-function-name-dump-stack.html">印出函數名稱</a></li><li class="chapter-item "><a href="../../rust/note.html">30天深入淺出Rust系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/30天深入淺出Rust系列/rust_30_day.html">Rust 30 Day</a></li><li class="chapter-item "><a href="../../rust/30天深入淺出Rust系列/Move_Borrow_Ownership.html">變數的所有權與借出變數</a></li><li class="chapter-item "><a href="../../rust/30天深入淺出Rust系列/Lifetime.html">Lifetime： Borrow 的存活時間</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../go/go.html">Go</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../go/note.html">Golang  Note</a></li><li class="chapter-item "><a href="../../go/pytago.html">pytago</a></li><li class="chapter-item "><a href="../../go/Go編程實戰派基礎入門.html">Go編程實戰派基礎入門</a></li><li class="chapter-item "><a href="../../go/Go編程實戰派Web開發基礎.html">Go編程實戰派Web開發基礎</a></li><li class="chapter-item "><a href="../../go/golang_debugger.html">Golang Deubgger</a></li><li class="chapter-item "><a href="../../go/golang-go-module-tutorial.html">從一知半解到略懂 Go modules</a></li><li class="chapter-item "><a href="../../go/go_mod.html">Go modules</a></li><li class="chapter-item "><a href="../../go/trace.html">Golang大殺器之跟蹤剖析trace</a></li><li class="chapter-item "><a href="../../go/Coroutine.html">行程、執行緒、協程，傻傻分得清楚！</a></li><li class="chapter-item "><a href="../../go/goroutine-and-channel.html">Go併發</a></li><li class="chapter-item "><a href="../../go/websocket.html">Websocket</a></li><li class="chapter-item "><a href="../../go/returning-pointer-from-a-function-in-go.html">Returning Pointer from a Function in Go</a></li><li class="chapter-item "><a href="../../go/golang-memory-management.html">GC 全面解析</a></li><li class="chapter-item "><a href="../../go/golang-goroutine.html">Goroutine 與 GMP 原理全面分析</a></li><li class="chapter-item "><a href="../../go/oo.html">OO</a></li><li class="chapter-item "><a href="../../go/mutex-rwmutex.html">sync.Mutex 和 sync.RWMutex</a></li><li class="chapter-item "><a href="../../go/interface.html">interface</a></li><li class="chapter-item "><a href="../../go/example.html">Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../ml/ml.html">ML</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/pytorch.html">Pytorch</a></li></ol></li><li class="chapter-item expanded "><a href="../../python/python.html">Python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../python/Poetry完全入門指南.html">Poetry完全入門指南</a></li><li class="chapter-item "><a href="../../python/搭建gRPC服務.html">搭建gRPC服務</a></li><li class="chapter-item "><a href="../../python/python_debugger.html">Python Debugger</a></li><li class="chapter-item "><a href="../../python/decorator.html">Python decorator</a></li><li class="chapter-item "><a href="../../python/python-decorator.html">裝飾器看這一篇就夠了</a></li><li class="chapter-item "><a href="../../python/import-concept.html">import-concept</a></li><li class="chapter-item "><a href="../../python/process_thread.html">Process/Thread優缺點</a></li><li class="chapter-item "><a href="../../python/processing_communcation.html">Processing 通訊</a></li><li class="chapter-item "><a href="../../python/condition.html">Python中的wait和notify</a></li><li class="chapter-item "><a href="../../python/生產者消費者模式.html">生產者消費者模式</a></li><li class="chapter-item "><a href="../../python/Loguru.html">Loguru</a></li><li class="chapter-item "><a href="../../python/WebSocket_reconnect.html">Python WebSocket長連接心跳與短連接</a></li><li class="chapter-item "><a href="../../python/bloomrpc.html">bloomrpc</a></li><li class="chapter-item "><a href="../../python/concurrent.futures.html">Concurrent futures</a></li><li class="chapter-item "><a href="../../python/schedule.html">任務調度</a></li><li class="chapter-item "><a href="../../python/plot/plot.html">Plot</a></li><li class="chapter-item "><a href="../../python/plot/dash.html">Dash</a></li><li class="chapter-item "><a href="../../python/Rust_bindings_for_Python.html">Rust bindings for Python</a></li><li class="chapter-item "><a href="../../python/pandas.html">Pandas</a></li><li class="chapter-item "><a href="../../python/coroutine.html">Coroutine</a></li><li class="chapter-item "><a href="../../python/finmind.html">FinMind</a></li><li class="chapter-item "><a href="../../python/telegram_bot.html">Telegram Bot</a></li><li class="chapter-item "><a href="../../python/websocket_client_server.html">Websocket client/server</a></li><li class="chapter-item "><a href="../../python/poetry.html">從零開始使用 Poetry</a></li><li class="chapter-item "><a href="../../python/fil-memory-usage-profiler.html">Fil-memory-usage-profiler</a></li><li class="chapter-item "><a href="../../python/plot.html">繪圖</a></li><li class="chapter-item "><a href="../../python/shioaji.html">永豐shioaji</a></li><li class="chapter-item "><a href="../../python/other.html">Other</a></li></ol></li><li class="chapter-item expanded "><a href="../../mermaid/mermaid.html">Mermaid</a></li><li class="chapter-item expanded "><a href="../../linux_system/perf.html">Linux System</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../linux_system/1_day_socket.html">Socket</a></li><li class="chapter-item "><a href="../../linux_system/cgroup.html">Cgroup</a></li><li class="chapter-item "><a href="../../linux_system/perf.html">Perf</a></li></ol></li><li class="chapter-item expanded "><a href="../../strategy/bollmaker.html">Strategy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../strategy/造市/market_market.html">造市</a></li><li class="chapter-item "><a href="../../strategy/tw_futures.html">臺指</a></li><li class="chapter-item "><a href="../../strategy/arbitrage.html">套利</a></li><li class="chapter-item "><a href="../../strategy/海龜交易.html">海龜交易</a></li><li class="chapter-item "><a href="../../strategy/如何避免過擬合.html">如何避免過擬合</a></li><li class="chapter-item "><a href="../../strategy/Option/option.html">選擇權</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../strategy/Option/option_note.html">Option note</a></li></ol></li><li class="chapter-item "><a href="../../strategy/vectorbt.html">VectorBT</a></li><li class="chapter-item "><a href="../../strategy/orderbook.html">Orderbook</a></li><li class="chapter-item "><a href="../../strategy/選股條件.html">選股條件</a></li><li class="chapter-item "><a href="../../strategy/如何進場.html">如何進場</a></li><li class="chapter-item "><a href="../../strategy/如何出場.html">如何出場</a></li><li class="chapter-item "><a href="../../strategy/建倉加碼.html">建倉加碼</a></li><li class="chapter-item "><a href="../../strategy/Book/JG.html">JG</a></li><li class="chapter-item "><a href="../../strategy/bnf.html">BNF</a></li><li class="chapter-item "><a href="../../strategy/cis.html">CIS</a></li><li class="chapter-item "><a href="../../strategy/stock.html">Stock</a></li><li class="chapter-item "><a href="../../strategy/note.html">Resource</a></li><li class="chapter-item "><a href="../../strategy/nansen.html">Nansen</a></li><li class="chapter-item "><a href="../../strategy/example.html">Example</a></li><li class="chapter-item "><a href="../../strategy/other.html">Other</a></li><li class="chapter-item "><a href="../../strategy/sample.html">Sample</a></li><li class="chapter-item "><a href="../../strategy/grid.html">Grid</a></li><li class="chapter-item "><a href="../../strategy/pine-script.html">pine-script</a></li><li class="chapter-item "><a href="../../strategy/拾人牙慧.html">拾人牙慧</a></li><li class="chapter-item "><a href="../../strategy/sharpe_ratio.html">夏普值</a></li><li class="chapter-item "><a href="../../strategy/display_mae_mfe_analysis.html">MAE&amp;MFE分析</a></li><li class="chapter-item "><a href="../../strategy/海龜投資法則.html">海龜投資法則</a></li><li class="chapter-item "><a href="../../strategy/edge-ratio-follow-application.html">彈性進出場的判斷</a></li><li class="chapter-item "><a href="../../strategy/finlab.html">Finlab</a></li><li class="chapter-item expanded "><a href="../../strategy/backtrader/basis.html">Backtrader</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../strategy/backtrader/Python回測框架一Backtrader介紹.html">Python回測框架一Backtrader介紹</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Python回測框架二定期定額投資.html">Python 回測框架（二）定期定額投資</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Python回測框架三技術指標.html">Python 回測框架（三）技術指標</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Python回測框架四CrossOver和Signal.html">Python 回測框架（四）CrossOver 和 Signal</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Python回測框架五Sizer.html">Python 回測框架（五）Sizer</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Python回測框架六Analyzers.html">Python 回測框架（六）Analyzers</a></li><li class="chapter-item "><a href="../../strategy/backtrader/多股組合操作策略.html">多股組合操作</a></li><li class="chapter-item "><a href="../../strategy/backtrader/均線交叉策略.html">均線交叉策略</a></li><li class="chapter-item "><a href="../../strategy/backtrader/唐奇安通道策略.html">唐奇安通道策略</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Sizers模組.html">Sizers模組</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Observers模組.html">Observers模組</a></li><li class="chapter-item "><a href="../../strategy/backtrader/Pyfolio.html">Pyfolio</a></li><li class="chapter-item expanded "><a href="../../strategy/backtrader/Sample.html" class="active">Sample</a></li><li class="chapter-item "><a href="../../strategy/backtrader/performance.html">Performance</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../mq/kafka.html">MQ</a></li><li class="chapter-item expanded "><a href="../../mq/kafka-python.html">Kafka的通俗總結</a></li><li class="chapter-item expanded "><a href="../../database/redis.html">Database</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../database/redis.html">Redis</a></li><li class="chapter-item "><a href="../../database/hash.html">Redis Hash</a></li><li class="chapter-item "><a href="../../database/clickhouse.html">ClickHouse</a></li><li class="chapter-item "><a href="../../database/dolphin.html">Dolphin</a></li><li class="chapter-item "><a href="../../database/sqlite.html">Sqlite</a></li></ol></li><li class="chapter-item expanded "><a href="../../cryptotrade/cryptotrade.html">CryptoTrade</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../cryptotrade/binance/binance.html">Binance</a></li><li class="chapter-item "><a href="../../cryptotrade/binance/oco.html">如何將OCO訂單發送到Binance</a></li></ol></li><li class="chapter-item expanded "><a href="../../git/git.html">Git</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../git/git-remove-commited-files.html">git-remove-commited-files</a></li><li class="chapter-item "><a href="../../git/cheat-sheet.html">Git 常用</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jason Notes</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shihyu/jason_note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="backtrader-resample過程"><a class="header" href="#backtrader-resample過程">backtrader resample過程</a></h2>
<p>如何將一個小週期的data 轉換成一個大週期的data？具體如何操作，這個在BT裡面使用resample 完成的。例如days轉換成weeks?</p>
<pre><code class="language-python">data = btfeeds.BacktraderCSVData(dataname=datapath)
cerebro.adddata(data)  # First add the original data - smaller timeframe
cerebro.resampledata(data, timeframe=tframes[args.timeframe],
                     compression=args.compression)
</code></pre>
<p>會<code>自動</code>在datas裡面新增這2個data，第二個data在第一個data的基礎上，進行資料的resample.</p>
<p>這裡需要注意：</p>
<p>timeframe：壓縮的週期，只能比被壓縮的資料週期大，當前資料週期是days,那麼timeframe可以是weeks,M，year等。</p>
<p>compression：一個timeframe壓縮成多少個bar，一般是1。當前是5個days bar壓縮成一個week bar.</p>
<p>資料壓縮的過程：</p>
<p>當前的data無法進行一次性的preload，linebuffer 每次向前移動一個單位長度，即每次讀取data的一個資料，然後每次checkover一下是否集齊5根bar：</p>
<pre><code class="language-python">def _checkbarover(self, data, fromcheck=False, forcedata=None):

    chkdata = DTFaker(data, forcedata) if fromcheck else data

    isover = False
    if not self.componly and not self._barover(chkdata):
        return isover

    if self.subdays and self.p.bar2edge:
        isover = True
    elif not fromcheck:  # fromcheck doesn't increase compcount
        self.compcount += 1
        if not (self.compcount % self.p.compression):
            # boundary crossed and enough bars for compression ... proceed
            isover = True

    return isover
</code></pre>
<p>當完成一個週期的壓縮後，isover是true。</p>
<p>資料的壓縮演算法_bar 裡面的：</p>
<pre><code class="language-python">def bupdate(self, data, reopen=False):
    '''Updates a bar with the values from data

    Returns True if the update was the 1st on a bar (just opened)

    Returns False otherwise
    '''
    if reopen:
        self.bstart()

    self.datetime = data.datetime[0]

    self.high = max(self.high, data.high[0])
    self.low = min(self.low, data.low[0])
    self.close = data.close[0]

    self.volume += data.volume[0]
    self.openinterest = data.openinterest[0]

    o = self.open
    if reopen or not o == o:
        self.open = data.open[0]
        return True  # just opened the bar

    return False
</code></pre>
<p>壓縮完成的資料存放在：</p>
<pre><code class="language-python">for i, dti in enumerate(dts):
    if dti is not None:
        di = datas[i]
        rpi = False and di.replaying   # to check behavior
        if dti &gt; dt0:
            if not rpi:  # must see all ticks ...
                di.rewind()  # cannot deliver yet
            # self._plotfillers[i].append(slen)
        elif not di.replaying:
            # Replay forces tick fill, else force here
            di._tick_fill(force=True)
</code></pre>
<p>di._tick_fill：完成對一個bar的填充。</p>
<h2 id="量化交易回測框架backtrader使用optstrategy最佳化"><a class="header" href="#量化交易回測框架backtrader使用optstrategy最佳化">量化交易回測框架Backtrader使用optstrategy最佳化</a></h2>
<p>給策略增加指標後，需要給你指標設定參數，比如SMA設定幾天合適呢，每個股票的週期又都不一樣。總不能一個一個的自己嘗試。Backtrader提供了一個參數最佳化的方法，可以按照給出的範圍來運行，大家可以根據結果尋找最優的均線天數。具體可以參看Backtrader官方文件<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.backtrader.com%2Fdocu%2Fquickstart%2Fquickstart%2F">quickstart</a></p>
<ol>
<li>通過給策略一個範圍值，根據運行結果，找出某適合一隻股票的盤整週期。</li>
</ol>
<p>通過optstrategy方法，給策略設定範圍值，讓策略逐個執行，對比結果。</p>
<pre><code class="language-python">&quot;&quot;&quot;
Created on Sun Mar 29 12:18:17 2020

@author: horace pei
&quot;&quot;&quot;
#############################################################
# import
#############################################################
from __future__ import absolute_import, division, print_function, unicode_literals
import os, sys
import pandas as pd
import backtrader as bt

#############################################################
# global const values
#############################################################
#############################################################
# static function
#############################################################
#############################################################
# class
#############################################################
# Create a Stratey
class TestStrategy(bt.Strategy):
    # 自訂均線的實踐間隔，默認是5天
    params = (
        (&quot;maperiod&quot;, 5),
        (&quot;printlog&quot;, False),
    )

    def log(self, txt, dt=None, doprint=False):
        &quot;&quot;&quot; Logging function for this strategy&quot;&quot;&quot;
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close
        # To keep track of pending orders
        self.order = None
        # buy price
        self.buyprice = None
        # buy commission
        self.buycomm = None
        # 增加均線，簡單移動平均線（SMA）又稱“算術移動平均線”，是指對特定期間的收盤價進行簡單平均化
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod
        )

    # 訂單狀態改變回呼方法 be notified through notify_order(order) of any status change in an order
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return
        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            elif order.issell():
                self.log(
                    &quot;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
            self.bar_executed = len(self)
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;Order Canceled/Margin/Rejected&quot;)
        # Write down: no pending order
        self.order = None

    # 交易狀態改變回呼方法 be notified through notify_trade(trade) of any opening/updating/closing trade
    def notify_trade(self, trade):
        if not trade.isclosed:
            return
        # 每筆交易收益 毛利和淨利
        self.log(&quot;OPERATION PROFIT, GROSS %.2f, NET %.2f&quot; % (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log(&quot;Close, %.2f&quot; % self.dataclose[0])
        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return
        # Check if we are in the market(當前帳戶持股情況，size，price等等)
        if not self.position:
            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] &gt;= self.sma[0]:
                # 當收盤價，大於等於均線的價格
                # BUY, BUY, BUY!!! (with all possible default parameters)
                self.log(&quot;BUY CREATE, %.2f&quot; % self.dataclose[0])
                # Keep track of the created order to avoid a 2nd order
                self.order = self.buy()
        else:
            # Already in the market ... we might sell
            if self.dataclose[0] &lt; self.sma[0]:
                # 當收盤價，小於均線價格
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log(&quot;SELL CREATE, %.2f&quot; % self.dataclose[0])
                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

    def stop(self):
        self.log(
            &quot;(MA Period %2d) Ending Value %.2f&quot;
            % (self.params.maperiod, self.broker.getvalue()),
            doprint=True,
        )


#############################################################
# global values
#############################################################
#############################################################
# global function
#############################################################
def get_dataframe():
    # Get a pandas dataframe
    datapath = &quot;./data/stockinfo.csv&quot;
    tmpdatapath = &quot;./data/stockinfo_tmp.csv&quot;
    print(&quot;-----------------------read csv---------------------------&quot;)
    dataframe = pd.read_csv(
        datapath, skiprows=0, header=0, parse_dates=True, index_col=0
    )
    dataframe.trade_date = pd.to_datetime(dataframe.trade_date, format=&quot;%Y%m%d&quot;)
    dataframe[&quot;openinterest&quot;] = &quot;0&quot;
    feedsdf = dataframe[
        [&quot;trade_date&quot;, &quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;vol&quot;, &quot;openinterest&quot;]
    ]
    feedsdf.columns = [
        &quot;datetime&quot;,
        &quot;open&quot;,
        &quot;high&quot;,
        &quot;low&quot;,
        &quot;close&quot;,
        &quot;volume&quot;,
        &quot;openinterest&quot;,
    ]
    feedsdf.set_index(keys=&quot;datetime&quot;, inplace=True)
    feedsdf.iloc[::-1].to_csv(tmpdatapath)
    feedsdf = pd.read_csv(
        tmpdatapath, skiprows=0, header=0, parse_dates=True, index_col=0
    )
    if os.path.isfile(tmpdatapath):
        os.remove(tmpdatapath)
        print(tmpdatapath + &quot; removed!&quot;)
    return feedsdf


########################################################################
# main
########################################################################
if __name__ == &quot;__main__&quot;:
    # Create a cerebro entity(建立cerebro)
    cerebro = bt.Cerebro()
    # Add a strategy(加入自訂策略,可以設定自訂參數，方便調節)
    cerebro.optstrategy(TestStrategy, maperiod=range(3, 15))
    # Get a pandas dataframe(獲取dataframe格式股票資料)
    feedsdf = get_dataframe()
    # Pass it to the backtrader datafeed and add it to the cerebro(加入資料)
    data = bt.feeds.PandasData(dataname=feedsdf)
    cerebro.adddata(data)
    # Add a FixedSize sizer according to the stake(國內1手是100股，最小的交易單位)
    cerebro.addsizer(bt.sizers.FixedSize, stake=100)
    # Set our desired cash start(給經紀人，可以理解為交易所股票帳戶充錢)
    cerebro.broker.setcash(10000.0)
    # Set the commission - 0.1%(設定交易手續費，雙向收取)
    cerebro.broker.setcommission(commission=0.001)
    # Print out the starting conditions(輸出帳戶金額)
    print(&quot;Starting Portfolio Value: %.2f&quot; % cerebro.broker.getvalue())
    # Run over everything(執行回測)
    cerebro.run()
    # Print out the final result(輸出帳戶金額)
    print(&quot;Final Portfolio Value: %.2f&quot; % cerebro.broker.getvalue())
</code></pre>
<p>分析和說明</p>
<p>通過： cerebro.optstrategy(TestStrategy, maperiod=range(3,15))，來設定3到15天的均線，看看均線時間那個收益最好。</p>
<p><img src="../images/16939854-19727fb596ab167f.png" alt="" /></p>
<h2 id="追高進場與加碼固定停損停利計算固定資金的數量"><a class="header" href="#追高進場與加碼固定停損停利計算固定資金的數量">追高進場與加碼，固定停損停利，計算固定資金的數量</a></h2>
<pre><code class="language-python">from __future__ import absolute_import, division, print_function, unicode_literals

from math import e
import yfinance as yf
import pyfolio
import backtrader as bt
import numpy as np
import warnings
import pandas as pd

warnings.filterwarnings(&quot;ignore&quot;)

# 計算固定資金的數量
class FixedCash(bt.Sizer):
    def __init__(self, cash=10000):
        self.cash = cash

    def _getsizing(self, comminfo, cash, data, isbuy):
        print(self.cash // data.close[0], data.close[0])
        if isbuy:
            return self.cash // data.close[0]  # 向下取整得到可買入的數量
        else:
            return self.broker.getposition(data).size  # 返回持倉數量


# 固定數量
class FixedSize(bt.Sizer):
    def __init__(self, stake=10000):
        self.stake = stake

    def _getsizing(self, comminfo, cash, data, isbuy):
        return self.stake


# 買總總金%數量
class DynamicRiskSizer(bt.Sizer):
    def _getsizing(self, comminfo, cash, data, isbuy):
        # 查詢當前交易賬戶的總價值
        total_value = self.broker.get_value()

        # 計算每個交易的交易量
        trade_value = total_value * 0.01  # 每個交易的風險百分比為1%
        risk = (
            data.close[0] - data.close[-1] if isbuy else data.close[-1] - data.close[0]
        )
        trade_size = trade_value / abs(risk)

        return int(trade_size)


# 建立一個backtrader回測框架
class Highest_high(bt.Strategy):
    # 設置sma的參數，根據官方照此設置可進行暴力演算，得知何種參數最佳
    params = (
        (&quot;highest&quot;, 6),
        (&quot;in_amount&quot;, 4),
        (&quot;stoploss&quot;, 0.1),
        (&quot;takeprofit&quot;, 0.2),
    )

    # 這裡是log，當交易發生時呼叫log函數可以將交易print出來
    def log(self, txt, dt=None):
        &quot;&quot;&quot; Logging function fot this strategy&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        # print('%s, %s' % (dt.isoformat(), txt))

    # init定義你會用到的數據
    def __init__(self):
        # 呼叫high序列備用
        self.datahigh = self.datas[0].high
        # 呼叫close序列備用
        self.dataclose = self.datas[0].close
        # 追蹤order、buyprice跟buycomm使用，可用可不用
        self.order = None
        self.buyprice = None
        self.buycomm = None
        # 使用指標套件給的最高價判斷函數Highest
        self.the_highest_high = bt.ind.Highest(
            self.datahigh, period=self.params.highest
        )

    # notify_order當每次有訂單由next偵測出來的條件送出時，會觸發notify_order，好處是顯示出訂單執行的狀況以及偵測是否有資金不足的情況
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 當訂單為提交狀態時則不做任何事
            return

        # 當訂單完成時，若為Buy則print出買入狀況；反之亦然
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:
                self.log(
                    &quot;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )

        # 當因策略取消或是現今不足訂單被拒絕等狀況則print出訂單取消
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;Order Canceled/Margin/Rejected&quot;)

        # 完成該有的提醒之後則將oder設置回None
        self.order = None

    # notify_trade交易通知，預設如果有倉在手就不做事，如果執行賣出則print出獲利
    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log(&quot;OPERATION PROFIT, GROSS %.2f, NET %.2f&quot; % (trade.pnl, trade.pnlcomm))

    # next可以把它想像成一個內建的for loop，他把數據打包好供我們使用
    def next(self):
        # 獲取當前日期和股票的收盤價格
        date = self.datas[0].datetime.date(0).isoformat()
        close = self.datas[0].close[0]

        # 檢查有無pending的訂單
        if self.order:
            return
        # self.position.size獲得目前倉位資訊，當size&lt;指定進場次數時則允許買入
        if self.position.size &lt; self.params.in_amount * 1000:
            # 當現在的高大於前面n根的最高價時準備執行買入
            if self.datahigh &gt; self.the_highest_high[-1]:
                # 紀錄買單提交
                self.log(&quot;BUY CREATE, %.2f&quot; % self.dataclose[0])
                # 買進
                self.order = self.buy()
        # 當庫存部位不為0但表有庫存
        if self.position.size != 0:
            # 獲取庫存成本
            costs = self.position.price
            # 當收盤價大於平均成本的10%停利賣出
            if self.dataclose[0] &gt; costs + (costs * self.params.takeprofit):
                self.close()
                self.log(&quot;Take Profit, %.2f&quot; % self.dataclose[0])
            # 當收盤價小於平均成本
            elif self.dataclose[0] &lt; costs - (costs * self.params.stoploss):
                self.close()
                self.log(&quot;Stop Loss, %.2f&quot; % self.dataclose[0])
        print(
            f&quot;Date: {date}, Closing:{close}, holding of shares:{self.position.size}, total captial:{self.broker.get_value()}&quot;
        )
        input()

    # #回測終止時print出結果
    # def stop(self):
    #     print(f'Fast MA: {self.params.fast_period} | Slow MA: {self.params.slow_period} | End Value: {self.broker.getvalue()}')


if __name__ == &quot;__main__&quot;:
    # 創建框架
    cerebro = bt.Cerebro()
    # # 放入策略
    # cerebro.addstrategy(Highest_high)
    # # 放入策略
    cerebro.optstrategy(
        Highest_high,
        highest=range(5, 9),
        in_amount=range(1, 5),
        stoploss=np.arange(0.1, 0.5, 0.1),
        takeprofit=np.arange(0.1, 0.5, 0.1),
    )

    # 使用框架的資料取得函數
    data = bt.feeds.PandasData(
        dataname=yf.download(&quot;2317.TW&quot;, &quot;2014-01-01&quot;, &quot;2023-01-01&quot;)
    )
    # 將datafeed餵入框架
    cerebro.adddata(data)
    # 設置起始金額
    cerebro.broker.setcash(1000000.0)
    # 設置一次購買的股數，臺股以1000股為主
    # cerebro.addsizer(bt.sizers.SizerFix, stake=1000)

    cerebro.addsizer(FixedCash)

    # 設置傭金，稍微設置高一點作為滑價付出成本
    cerebro.broker.setcommission(commission=0.0015)

    # ===================Pyfolio===================
    # cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')

    # 在設置完傭金、起始金額以及買入股數之後，我們加入三種分析
    cerebro.addanalyzer(bt.analyzers.SharpeRatio)
    cerebro.addanalyzer(bt.analyzers.Returns)
    cerebro.addanalyzer(bt.analyzers.DrawDown)
    results = cerebro.run(maxcpus=1)
    # 準備list存放每一個參數及結果
    par1, par2, par3, par4, ret, down, sharpe_r = [], [], [], [], [], [], []
    # 迴圈每一個結果
    for strat in results:
        # 因為結果是用list包起來(範例在下註解)，所以我們要[0]取值
        # [&lt;backtrader.cerebro.OptReturn object at 0x0000024FF9717CC8&gt;]
        strat = strat[0]
        # get_analysis()獲得值
        a_return = strat.analyzers.returns.get_analysis()
        drawDown = strat.analyzers.drawdown.get_analysis()
        sharpe = strat.analyzers.sharperatio.get_analysis()
        # 依序裝入資料，可用strat.params.xx獲取參數
        par1.append(strat.params.highest)
        par2.append(strat.params.in_amount)
        par3.append(strat.params.stoploss)
        par4.append(strat.params.takeprofit)
        # rtot代表總回報，獲取總回報
        ret.append(a_return[&quot;rtot&quot;])
        # 我們關注最大的drawdown，因此如下取值
        down.append(drawDown[&quot;max&quot;][&quot;drawdown&quot;])
        # 獲取sharpe ratio
        sharpe_r.append(sharpe[&quot;sharperatio&quot;])
    # 組裝成dataframe
    result_df = pd.DataFrame()
    result_df[&quot;Highest&quot;] = par1
    result_df[&quot;in_amount&quot;] = par2
    result_df[&quot;stoploss&quot;] = par3
    result_df[&quot;takeprofit&quot;] = par4
    result_df[&quot;total profit&quot;] = ret
    result_df[&quot;Max Drawdown&quot;] = down
    result_df[&quot;Sharpe Ratio&quot;] = sharpe_r
    # 根據總報酬來排列
    result_df = result_df.sort_values(by=[&quot;total profit&quot;], ascending=False)
    print(result_df)

    # 畫Kbars
    # cerebro.plot(style='candlestick', barup='red', bardown='green')

    # ===================Pyfolio===================
    # strat = results[0]
    # pyfoliozer = strat.analyzers.getbyname('pyfolio')
    # returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()

    # # # pyfolio showtime
    # import pyfolio as pf
    # pf.create_full_tear_sheet(
    # returns,
    # positions=positions,
    # transactions=transactions,
    # live_start_date='2018-01-01')  # This date is sample specific)
</code></pre>
<h2 id="追高進場與加碼固定停損停利"><a class="header" href="#追高進場與加碼固定停損停利">追高進場與加碼，固定停損停利</a></h2>
<pre><code class="language-python">from __future__ import absolute_import, division, print_function, unicode_literals

import datetime
from math import e
import yfinance as yf
import os.path
import sys
import pyfolio
import backtrader as bt
import numpy as np
import warnings
import pandas as pd

warnings.filterwarnings(&quot;ignore&quot;)
# 建立一個backtrader回測框架
class Highest_high(bt.Strategy):
    # 設置sma的參數，根據官方照此設置可進行暴力演算，得知何種參數最佳
    params = (
        (&quot;highest&quot;, 6),
        (&quot;in_amount&quot;, 4),
        (&quot;stoploss&quot;, 0.1),
        (&quot;takeprofit&quot;, 0.2),
    )

    # 這裡是log，當交易發生時呼叫log函數可以將交易print出來
    def log(self, txt, dt=None):
        &quot;&quot;&quot; Logging function fot this strategy&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        # print('%s, %s' % (dt.isoformat(), txt))

    # init定義你會用到的數據
    def __init__(self):
        # 呼叫high序列備用
        self.datahigh = self.datas[0].high
        # 呼叫close序列備用
        self.dataclose = self.datas[0].close
        # 追蹤order、buyprice跟buycomm使用，可用可不用
        self.order = None
        self.buyprice = None
        self.buycomm = None
        # 使用指標套件給的最高價判斷函數Highest
        self.the_highest_high = bt.ind.Highest(
            self.datahigh, period=self.params.highest
        )

    # notify_order當每次有訂單由next偵測出來的條件送出時，會觸發notify_order，好處是顯示出訂單執行的狀況以及偵測是否有資金不足的情況
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 當訂單為提交狀態時則不做任何事
            return

        # 當訂單完成時，若為Buy則print出買入狀況；反之亦然
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &quot;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:
                self.log(
                    &quot;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&quot;
                    % (order.executed.price, order.executed.value, order.executed.comm)
                )

        # 當因策略取消或是現今不足訂單被拒絕等狀況則print出訂單取消
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;Order Canceled/Margin/Rejected&quot;)

        # 完成該有的提醒之後則將oder設置回None
        self.order = None

    # notify_trade交易通知，預設如果有倉在手就不做事，如果執行賣出則print出獲利
    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log(&quot;OPERATION PROFIT, GROSS %.2f, NET %.2f&quot; % (trade.pnl, trade.pnlcomm))

    # next可以把它想像成一個內建的for loop，他把數據打包好供我們使用
    def next(self):
        # 檢查有無pending的訂單
        print(
            f&quot;holding of shares:{self.position.size}, total captial:{self.broker.get_value()}&quot;
        )
        if self.order:
            return
        # self.position.size獲得目前倉位資訊，當size&lt;指定進場次數時則允許買入
        if self.position.size &lt; self.params.in_amount * 1000:
            # 當現在的高大於前面n根的最高價時準備執行買入
            if self.datahigh &gt; self.the_highest_high[-1]:
                # 紀錄買單提交
                self.log(&quot;BUY CREATE, %.2f&quot; % self.dataclose[0])
                # 買進
                self.order = self.buy()
        # 當庫存部位不為0但表有庫存
        if self.position.size != 0:
            # 獲取庫存成本
            costs = self.position.price
            # 當收盤價大於平均成本的10%停利賣出
            if self.dataclose[0] &gt; costs + (costs * self.params.takeprofit):
                self.close()
                self.log(&quot;Take Profit, %.2f&quot; % self.dataclose[0])
            # 當收盤價小於平均成本
            elif self.dataclose[0] &lt; costs - (costs * self.params.stoploss):
                self.close()
                self.log(&quot;Stop Loss, %.2f&quot; % self.dataclose[0])

    # #回測終止時print出結果
    # def stop(self):
    #     print(f'Fast MA: {self.params.fast_period} | Slow MA: {self.params.slow_period} | End Value: {self.broker.getvalue()}')


if __name__ == &quot;__main__&quot;:
    # 創建框架
    cerebro = bt.Cerebro()
    # # 放入策略
    # cerebro.addstrategy(Highest_high)
    # # 放入策略
    cerebro.optstrategy(
        Highest_high,
        highest=range(5, 9),
        in_amount=range(1, 5),
        stoploss=np.arange(0.1, 0.5, 0.1),
        takeprofit=np.arange(0.1, 0.5, 0.1),
    )

    # 使用框架的資料取得函數
    data = bt.feeds.PandasData(
        dataname=yf.download(&quot;2317.TW&quot;, &quot;2014-01-01&quot;, &quot;2023-01-01&quot;)
    )
    # 將datafeed餵入框架
    cerebro.adddata(data)
    # 設置起始金額
    cerebro.broker.setcash(1000000.0)
    # 設置一次購買的股數，臺股以1000股為主
    cerebro.addsizer(bt.sizers.SizerFix, stake=1000)
    # 設置傭金，稍微設置高一點作為滑價付出成本
    cerebro.broker.setcommission(commission=0.0015)

    # ===================Pyfolio===================
    # cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')

    # 在設置完傭金、起始金額以及買入股數之後，我們加入三種分析
    cerebro.addanalyzer(bt.analyzers.SharpeRatio)
    cerebro.addanalyzer(bt.analyzers.Returns)
    cerebro.addanalyzer(bt.analyzers.DrawDown)
    results = cerebro.run(maxcpus=1)
    # 準備list存放每一個參數及結果
    par1, par2, par3, par4, ret, down, sharpe_r = [], [], [], [], [], [], []
    # 迴圈每一個結果
    for strat in results:
        # 因為結果是用list包起來(範例在下註解)，所以我們要[0]取值
        # [&lt;backtrader.cerebro.OptReturn object at 0x0000024FF9717CC8&gt;]
        strat = strat[0]
        # get_analysis()獲得值
        a_return = strat.analyzers.returns.get_analysis()
        drawDown = strat.analyzers.drawdown.get_analysis()
        sharpe = strat.analyzers.sharperatio.get_analysis()
        # 依序裝入資料，可用strat.params.xx獲取參數
        par1.append(strat.params.highest)
        par2.append(strat.params.in_amount)
        par3.append(strat.params.stoploss)
        par4.append(strat.params.takeprofit)
        # rtot代表總回報，獲取總回報
        ret.append(a_return[&quot;rtot&quot;])
        # 我們關注最大的drawdown，因此如下取值
        down.append(drawDown[&quot;max&quot;][&quot;drawdown&quot;])
        # 獲取sharpe ratio
        sharpe_r.append(sharpe[&quot;sharperatio&quot;])
    # 組裝成dataframe
    result_df = pd.DataFrame()
    result_df[&quot;Highest&quot;] = par1
    result_df[&quot;in_amount&quot;] = par2
    result_df[&quot;stoploss&quot;] = par3
    result_df[&quot;takeprofit&quot;] = par4
    result_df[&quot;total profit&quot;] = ret
    result_df[&quot;Max Drawdown&quot;] = down
    result_df[&quot;Sharpe Ratio&quot;] = sharpe_r
    # 根據總報酬來排列
    result_df = result_df.sort_values(by=[&quot;total profit&quot;], ascending=False)
    print(result_df)

    # 畫Kbars
    # cerebro.plot(style='candlestick', barup='red', bardown='green')

    # ===================Pyfolio===================
    # strat = results[0]
    # pyfoliozer = strat.analyzers.getbyname('pyfolio')
    # returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()

    # # # pyfolio showtime
    # import pyfolio as pf
    # pf.create_full_tear_sheet(
    # returns,
    # positions=positions,
    # transactions=transactions,
    # live_start_date='2018-01-01')  # This date is sample specific)
</code></pre>
<pre><code class="language-python">import backtrader as bt
import yfinance as yf

class MyStrategy(bt.Strategy):
    
    # 設定MA均線的週期
    params = (
        ('ma10', 10),
        ('ma20', 20),
        ('ma40', 40),
        ('take_profit', 0.2), # 設定獲利目標為20%
    )

    def __init__(self):
        self.ma10 = bt.indicators.MovingAverageSimple(self.data.close, period=self.params.ma10)
        self.ma20 = bt.indicators.MovingAverageSimple(self.data.close, period=self.params.ma20)
        self.ma40 = bt.indicators.MovingAverageSimple(self.data.close, period=self.params.ma40)
        
    def next(self):
        # 如果當前價格低於MA10，就買入一次
        if self.data.close[0] &lt; self.ma10[0]:
            self.buy(size=1)
            
        # 如果當前價格低於MA20，再買入一次
        if self.data.close[0] &lt; self.ma20[0]:
            self.buy(size=1)
            
        # 如果當前價格低於MA40，就停止交易並止損
        if self.data.close[0] &lt; self.ma40[0]:
            self.close()
            
        # 如果當前有持倉，計算當前持倉的盈利百分比
        if self.position:
            profit = (self.data.close[0] - self.position.price) / self.position.price

            # 如果當前持倉的盈利達到設定的獲利目標，就賣出並止盈
            if profit &gt;= self.params.take_profit:
                self.close()
            
cerebro = bt.Cerebro()

# 設定初始資金為10000美元
cerebro.broker.setcash(10000)

data = bt.feeds.PandasData(dataname=yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))

# 將數據傳入Cerebro中
cerebro.adddata(data)

# 將策略傳入Cerebro中
cerebro.addstrategy(MyStrategy)

# 運行回測
cerebro.run()

# 打印最終資金餘額
print('Final Balance: %.2f' % cerebro.broker.getvalue())

</code></pre>
<pre><code class="language-python">from datetime import datetime
import pandas as pd
import backtrader as bt
import yfinance as yf

# 匯入pyfolio 包
import pyfolio as pf


# 建立策略類
class SmaCross(bt.Strategy):
    # 定義參數
    params = (
        (&quot;ma10&quot;, 10),
        (&quot;ma20&quot;, 20),
        (&quot;ma40&quot;, 40),
        (&quot;take_profit&quot;, 0.2),  # 設定獲利目標為20%
    )

    # 日誌函數
    def log(self, txt, dt=None):
        &quot;&quot;&quot;日誌函數&quot;&quot;&quot;
        dt = dt or self.datas[0].datetime.date(0)
        print(&quot;%s, %s&quot; % (dt.isoformat(), txt))

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # 訂單狀態 submitted/accepted，無動作
            return
        # 訂單完成
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(&quot;買單執行, %.2f&quot; % order.executed.price)
            elif order.issell():
                self.log(&quot;賣單執行, %.2f&quot; % order.executed.price)
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&quot;訂單 Canceled/Margin/Rejected&quot;)

    # 記錄交易收益情況（可省略，默認不輸出結果）
    def notify_trade(self, trade):
        if trade.isclosed:
            print(
                &quot;毛收益 %0.2f, 扣傭後收益 % 0.2f, 佣金 %.2f&quot;
                % (trade.pnl, trade.pnlcomm, trade.commission)
            )

    def __init__(self):
        self.ma10 = bt.indicators.MovingAverageSimple(
            self.data.close, period=self.params.ma10
        )
        self.ma20 = bt.indicators.MovingAverageSimple(
            self.data.close, period=self.params.ma20
        )
        self.ma40 = bt.indicators.MovingAverageSimple(
            self.data.close, period=self.params.ma40
        )

    def __bt_to_pandas__(self, btdata, len):
        get = lambda mydata: mydata.get(ago=0, size=len)

        fields = {
            &quot;open&quot;: get(btdata.open),
            &quot;high&quot;: get(btdata.high),
            &quot;low&quot;: get(btdata.low),
            &quot;close&quot;: get(btdata.close),
            &quot;volume&quot;: get(btdata.volume),
        }
        time = [btdata.num2date(x) for x in get(btdata.datetime)]
        return pd.DataFrame(data=fields, index=time)

    def next(self):
        data = self.__bt_to_pandas__(self.datas[1], len(self.datas[1]))
        cash = self.broker.cash
        # print('剩餘現金:', cash)
        # print(data)
        # Get the current position
        pos = self.getposition()
        # Get the position size, 股數
        size = pos.size
        print(
            f&quot;size:{size}, close:{self.data.close[0]}, ma10:{self.ma10[0]}, ma20:{self.ma20[0]}, ma40:{self.ma40[0]}, cash:{cash}&quot;
        )

        # 如果當前價格低於MA10，就買入一次
        if self.data.close[0] &lt; self.ma10[0] and size &lt; 200:
            self.buy(size=10)
            print(&quot;close &lt; ma10&quot;)

        # 如果當前價格低於MA20，再買入一次
        if self.data.close[0] &lt; self.ma20[0] and size &lt; 200:
            self.buy(size=10)
            print(&quot;close &lt; ma20&quot;)

        # 如果當前有持倉，計算當前持倉的盈利百分比
        if self.position:
            # 如果當前價格低於MA40，就停止交易並止損
            if self.data.close[0] &lt; self.ma40[0]:
                self.close()

            profit = (self.data.close[0] - self.position.price) / self.position.price

            # 如果當前持倉的盈利達到設定的獲利目標，就賣出並止盈
            if profit &gt;= self.params.take_profit:
                self.close()


##########################
# 主程序開始
#########################

# 建立大腦引擎對象
cerebro = bt.Cerebro()


# 建立行情資料對象，載入資料
# data = bt.feeds.PandasData(dataname=yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))
data = bt.feeds.PandasData(dataname=yf.download(&quot;2330.TW&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;))
# print(yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;), type(yf.download(&quot;MSFT&quot;, &quot;2011-01-01&quot;, &quot;2023-01-01&quot;)))
# input()

# self.datas[0] 日K數據, self.datas[1] 月K數據
data = cerebro.resampledata(data, timeframe=bt.TimeFrame.Months, compression=1)
cerebro.adddata(data)  # 將行情資料對象注入引擎

cerebro.addstrategy(SmaCross)  # 將策略注入引擎

cerebro.broker.setcash(10000.0)  # 設定初始資金

# 加入pyfolio分析者
cerebro.addanalyzer(bt.analyzers.PyFolio, _name=&quot;pyfolio&quot;)

results = cerebro.run()  # 運行
strat = results[0]
pyfoliozer = strat.analyzers.getbyname(&quot;pyfolio&quot;)
returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()
pf.create_full_tear_sheet(returns)
</code></pre>

                        <script src="https://utteranc.es/client.js"
                            repo="imxood/imxood.github.io"
                            issue-term="pathname"
                            theme="boxy-light"
                            crossorigin="anonymous"
                            async>
                        </script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../strategy/backtrader/Pyfolio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../strategy/backtrader/performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../strategy/backtrader/Pyfolio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../strategy/backtrader/performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../theme/custom/mermaid.min.js"></script>
        <script type="text/javascript" src="../../theme/custom/mermaid-init.js"></script>
    </body>
</html>
